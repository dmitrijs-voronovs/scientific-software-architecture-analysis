id,quality_attribute,keyword,matched_word,match_idx,sentence,source,filename,author,repo,version,wiki,url
https://qutip.org/docs/4.7/guide/guide-bloch.html:7412,Modifiability,Config,Configuring,7412,"atplotlib to generate figures. As such, the data plotted on the sphere is in reality just a 2D object. In contrast the Bloch3d class uses the 3D rendering engine from VTK via mayavi to generate the sphere and the included data. In this sense the Bloch3d class is much more advanced, as objects are rendered in 3D leading to a higher quality figure.; Only the Bloch class can be embedded in a Matplotlib figure window. Thus if you want to combine a Bloch sphere with another figure generated in QuTiP, you can not use Bloch3d. Of course you can always post-process your figures using other software to get the desired result.; Due to limitations in the rendering engine, the Bloch3d class does not support LaTeX for text. Again, you can get around this by post-processing.; The user customizable attributes for the Bloch and Bloch3d classes are not identical. Therefore, if you change the properties of one of the classes, these changes will cause an exception if the class is switched. Configuring the Bloch sphere¶. Bloch Class Options¶; At the end of the last section we saw that the colors and marker shapes of the data plotted on the Bloch sphere are automatically varied according to the number of points and vectors added. But what if you want a different choice of color, or you want your sphere to be purple with different axes labels? Well then you are in luck as the Bloch class has 22 attributes which one can control. Assuming b=Bloch():. Attribute; Function; Default Setting. b.axes; Matplotlib axes instance for animations. Set by axes; keyword arg.; None. b.fig; User supplied Matplotlib Figure instance. Set by fig; keyword arg.; None. b.font_color; Color of fonts; ‘black’. b.font_size; Size of fonts; 20. b.frame_alpha; Transparency of wireframe; 0.1. b.frame_color; Color of wireframe; ‘gray’. b.frame_width; Width of wireframe; 1. b.point_color; List of colors for Bloch point markers to cycle through; ['b', 'r', 'g', '#CC6600']. b.point_marker; List of point marker shapes to cyc",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:13036,Modifiability,evolve,evolve,13036,"the save() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; import numpy as np; import qutip. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); sm = qutip.sigmam(); H = w * (np.cos(theta) * sz + np.sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0: c_op_list.append(np.sqrt(rate) * sm); rate = gamma1 * n_th; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sz); # evolve and calculate expectation values; output = qutip.mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to te",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:1856,Performance,load,load,1856,"Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:;",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:1947,Performance,load,loads,1947,"documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(p",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:10891,Security,access,accessed,10891,"ay'. b.frame_num; Number of wireframe elements to draw; 8. b.frame_radius; Radius of wireframe lines; 0.005. b.point_color; List of colors for Bloch point markers to cycle through; ['r', 'g', 'b', 'y']. b.point_mode; Type of point markers to draw; 'sphere'. b.point_size; Size of points; 0.075. b.sphere_alpha; Transparency of Bloch sphere; 0.1. b.sphere_color; Color of Bloch sphere; '#808080'. b.size; Sets size of figure window; [500, 500] (500x500 pixels). b.vector_color; List of colors for Bloch vectors to cycle through; ['r', 'g', 'b', 'y']. b.vector_width; Width of Bloch vectors; 3. b.view; Azimuthal and Elevation viewing angles; [45, 65]. b.xlabel; Labels for x-axis; ['|x>', ''] +x and -x. b.xlpos; Position of x-axis labels; [1.07, -1.07]. b.ylabel; Labels for y-axis; ['$y$', ''] +y and -y. b.ylpos; Position of y-axis labels; [1.07, -1.07]. b.zlabel; Labels for z-axis; ['|0>', '|1>'] +z and -z. b.zlpos; Position of z-axis labels; [1.07, -1.07]. These properties can also be accessed via the print command:; >>> b = qutip.Bloch(). >>> print(b) ; Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the o",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:974,Testability,Log,Log,974,". Plotting on the Bloch Sphere — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay. Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before gettin",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:138,Usability,Guid,Guide,138,". Plotting on the Bloch Sphere — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay. Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before gettin",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:145,Usability,Guid,Guide,145,". Plotting on the Bloch Sphere — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay. Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before gettin",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:1100,Usability,Guid,Guide,1100,"er; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Differences Between Bloch and Bloch3d. Configuring the Bloch sphere; Bloch Class Options; Bloch3d Class Options. Animating with the Bloch sphere; Example: Qubit Decay. Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances vi",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:2045,Usability,simpl,simply,2045,"ng. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Plotting on the Bloch Sphere. Plotting on the Bloch Sphere¶. Introduction¶; When studying the dynamics of a two-level system, it is often convenient to visualize the state of the system by plotting the state-vector or density matrix on the Bloch sphere. In QuTiP, we have created two different classes to allow for easy creation and manipulation of data sets, both vectors and data points, on the Bloch sphere. The qutip.bloch.Bloch class, uses Matplotlib to render the Bloch sphere, where as qutip.bloch3d.Bloch3d uses the Mayavi rendering engine to generate a more faithful 3D reconstruction of the Bloch sphere. The Bloch and Bloch3d Classes¶; In QuTiP, creating a Bloch sphere is accomplished by calling either:; b = qutip.Bloch(). which will load an instance of the qutip.bloch.Bloch class, or using; >>> b3d = qutip.Bloch3d(). that loads the qutip.bloch3d.Bloch3d version. Before getting into the details of these objects, we can simply plot the blank Bloch sphere associated with these instances via:; b.make_sphere(). or. In addition to the show command, see the API documentation for Bloch for a full list of other available functions.; As an example, we can add a single data point:; pnt = [1/np.sqrt(3), 1/np.sqrt(3), 1/np.sqrt(3)]; b.add_points(pnt); b.render(). and then a single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where ",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:3363,Usability,clear,clear,3363," single vector:; b.fig.clf(); vec = [0, 1, 0]; b.add_vectors(vec); b.render(). and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is be",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:3467,Usability,clear,clear,3467," and then add another vector corresponding to the \(\left|\rm up \right>\) state:; up = qutip.basis(2, 0); b.add_states(up); b.render(). Notice that when we add more than a single vector (or data point), a different color will automatically be applied to the later data set (mod 4).; In total, the code for constructing our Bloch sphere with one vector, one state, and a single data point is:; b = qutip.Bloch(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted,",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:3852,Usability,clear,clear,3852,"och(). pnt = [1./np.sqrt(3), 1./np.sqrt(3), 1./np.sqrt(3)]; b.add_points(pnt); vec = [0, 1, 0]; b.add_vectors(vec); up = qutip.basis(2, 0); b.add_states(up); b.render(). where we have removed the extra show() commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and sha",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:4119,Usability,clear,clear,4119,"commands. Replacing b=Bloch() with b=Bloch3d() in the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:4132,Usability,clear,clear,4132," the above code generates the following 3D Bloch sphere. We can also plot multiple points, vectors, and states at the same time by passing list or arrays instead of individual elements. Before giving an example, we can use the clear() command to remove the current data from our Bloch sphere instead of creating a new instance:; b.clear(); b.render(). Now on the same Bloch sphere, we can plot the three states associated with the x, y, and z directions:; x = (qutip.basis(2, 0) + (1+0j)*qutip.basis(2, 1)).unit(); y = (qutip.basis(2, 0) + (0+1j)*qutip.basis(2, 1)).unit(); z = (qutip.basis(2, 0) + (0+0j)*qutip.basis(2, 1)).unit(). b.add_states([x, y, z]); b.render(). a similar method works for adding vectors:; b.clear(); vec = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]; b.add_vectors(vec); b.render(). Adding multiple points to the Bloch sphere works slightly differently than adding multiple states or vectors. For example, lets add a set of 20 points around the equator (after calling clear()):; b.clear(). th = np.linspace(0, 2*np.pi, 20); xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20). pnts = [xp, yp, zp]; b.add_points(pnts); b.render(). Notice that, in contrast to states or vectors, each point remains the same color as the initial point. This is because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:5391,Usability,clear,clear,5391,"s because adding multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.bloch.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). Again, the same plot can be generated using the qutip.bloch3d.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing b",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:5403,Usability,clear,clear,5403,"multiple data points using the add_points function is interpreted, by default, to correspond to a single data point (single qubit state) plotted at different times. This is very useful when visualizing the dynamics of a qubit. An example of this is given in the example . If we want to plot additional qubit states we can call additional add_points functions:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th); b.add_points([xz, yz, zz]); b.render(). The color and shape of the data points is varied automatically by the Bloch class. Notice how the color and point markers change for each set of data. Again, we have had to call add_points twice because adding more than one set of multiple data points is not supported by the add_points function.; What if we want to vary the color of our points. We can tell the qutip.bloch.Bloch class to vary the color of each point according to the colors listed in the b.point_color list (see Configuring the Bloch sphere below). Again after clear():; b.clear(). xp = np.cos(th); yp = np.sin(th); zp = np.zeros(20); pnts = [xp, yp, zp]; b.add_points(pnts, 'm') # <-- add a 'm' string to signify 'multi' colored points; b.render(). Now, the data points cycle through a variety of predefined colors. Now lets add another set of points, but this time we want the set to be a single color, representing say a qubit going from the \(\left|\rm up\right>\) state to the \(\left|\rm down\right>\) state in the y-z plane:; xz = np.zeros(20); yz = np.sin(th); zz = np.cos(th). b.add_points([xz, yz, zz]) # no 'm'; b.render(). Again, the same plot can be generated using the qutip.bloch3d.Bloch3d class by replacing Bloch with Bloch3d:. A more slick way of using this ‘multi’ color feature is also given in the example, where we set the color of the markers as a function of time. Differences Between Bloch and Bloch3d¶; While in general the Bloch and Bloch3d classes are interchangeable, there are some important differences to consider when choosing between them. The",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:11816,Usability,clear,clear,11816," [1.07, -1.07]. These properties can also be accessed via the print command:; >>> b = qutip.Bloch(). >>> print(b) ; Bloch data:; -----------; Number of points: 0; Number of vectors: 0. Bloch sphere properties:; ------------------------; font_color: black; font_size: 20; frame_alpha: 0.2; frame_color: gray; frame_width: 1; point_color: ['b', 'r', 'g', '#CC6600']; point_marker: ['o', 's', 'd', '^']; point_size: [25, 32, 35, 45]; sphere_alpha: 0.2; sphere_color: #FFDDDD; figsize: [5, 5]; vector_color: ['g', '#CC6600', 'b', 'r']; vector_width: 3; vector_style: -|>; vector_mutation: 20; view: [-60, 30]; xlabel: ['$x$', '']; xlpos: [1.2, -1.2]; ylabel: ['$y$', '']; ylpos: [1.2, -1.2]; zlabel: ['$\\left|0\\right>$', '$\\left|1\\right>$']; zlpos: [1.2, -1.2]. Animating with the Bloch sphere¶; The Bloch class was designed from the outset to generate animations. To animate a set of vectors or data points the basic idea is: plot the data at time t1, save the sphere, clear the sphere, plot data at t2,… The Bloch sphere will automatically number the output file based on how many times the object has been saved (this is stored in b.savenum). The easiest way to animate data on the Bloch sphere is to use the save() method and generate a series of images to convert into an animation. However, as of Matplotlib version 1.1, creating animations is built-in. We will demonstrate both methods by looking at the decay of a qubit on the bloch sphere. Example: Qubit Decay¶; The code for calculating the expectation values for the Pauli spin operators of a qubit decay is given below. This code is common to both animation examples.; import numpy as np; import qutip. def qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist):; # operators and the hamiltonian; sx = qutip.sigmax(); sy = qutip.sigmay(); sz = qutip.sigmaz(); sm = qutip.sigmam(); H = w * (np.cos(theta) * sz + np.sin(theta) * sx); # collapse operators; c_op_list = []; n_th = 0.5 # temperature; rate = gamma1 * (n_th + 1); if rate > 0.0:",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:13908,Usability,clear,clear,13908,"e > 0.0: c_op_list.append(np.sqrt(rate) * sm.dag()); rate = gamma2; if rate > 0.0: c_op_list.append(np.sqrt(rate) * sz); # evolve and calculate expectation values; output = qutip.mesolve(H, psi0, tlist, c_op_list, [sx, sy, sz]); return output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax.",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:14158,Usability,simpl,simple,14158,"turn output.expect[0], output.expect[1], output.expect[2]. ## calculate the dynamics; w = 1.0 * 2 * np.pi # qubit angular frequency; theta = 0.2 * np.pi # qubit angle from sigma_z axis (toward sigma_x axis); gamma1 = 0.5 # qubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be view",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-bloch.html:14767,Usability,clear,clear,14767,"ubit relaxation rate; gamma2 = 0.2 # qubit dephasing rate; # initial state; a = 1.0; psi0 = (a*qutip.basis(2, 0) + (1-a)*qutip.basis(2, 1))/np.sqrt(a**2 + (1-a)**2); tlist = np.linspace(0, 4, 250); #expectation values for ploting; sx, sy, sz = qubit_integrate(w, theta, gamma1, gamma2, psi0, tlist). Generating Images for Animation¶; An example of generating images for generating an animation outside of Python is given below:; import numpy as np; b = qutip.Bloch(); b.vector_color = ['r']; b.view = [-40, 30]; for i in range(len(sx)):; b.clear(); b.add_vectors([np.sin(theta), 0, np.cos(theta)]); b.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); b.save(dirc='temp') # saving images to temp directory in current working directory. Generating an animation using FFmpeg (for example) is fairly simple:; ffmpeg -i temp/bloch_%01d.png bloch.mp4. Directly Generating an Animation¶. Important; Generating animations directly from Matplotlib requires installing either MEncoder or FFmpeg.; While either choice works on linux, it is best to choose FFmpeg when running on the Mac.; If using macports just do: sudo port install ffmpeg. The code to directly generate an mp4 movie of the Qubit decay is as follows; from matplotlib import pyplot, animation; from mpl_toolkits.mplot3d import Axes3D. fig = pyplot.figure(); ax = Axes3D(fig, azim=-40, elev=30); sphere = qutip.Bloch(axes=ax). def animate(i):; sphere.clear(); sphere.add_vectors([np.sin(theta), 0, np.cos(theta)]); sphere.add_points([sx[:i+1], sy[:i+1], sz[:i+1]]); sphere.make_sphere(); return ax. def init():; sphere.vector_color = ['r']; return ax. ani = animation.FuncAnimation(fig, animate, np.arange(len(sx)),; init_func=init, blit=False, repeat=False); ani.save('bloch_sphere.mp4', fps=20). The resulting movie may be viewed here: bloch_decay.mp4. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-bloch.html
https://qutip.org/docs/4.7/guide/guide-control.html:6019,Availability,error,error,6019,"then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:11760,Availability,down,down,11760,"11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, al",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:11832,Availability,avail,available,11832,"ter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, a",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:12901,Availability,error,errors,12901,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:113,Deployability,Install,Installation,113,". Quantum Optimal Control — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Optimal Control. Quantum Optimal Control¶. Introduction¶; In quantum control we look to prepare some specific state, effect some state-to-state transfer, or effect some transformation (or gate) on a quantum system. For a given quantum system there will always be factors that effect the dynamics that are outside of our control. As examples, the interactions between elements of the system or a magnetic field required to trap the system. However, there may be methods of affecting the dynamics in a controlled way, such as the time varying amplitude of the electric component of an interacting laser field. And so this leads to some questions; given a specific quantum system with known time-independent dynamics generator (referred to as the drift dynamics generators) and set of externally controllable fields for which the interaction can be described by control dynamics generators:. What states or transformations can we achieve (if any)?; What is the",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:11641,Deployability,integrat,integration,11641,"11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, al",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:12709,Deployability,integrat,integration,12709,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:12853,Deployability,integrat,integration,12853,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13334,Deployability,integrat,integrated,13334,"ch time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14436,Deployability,configurat,configuration,14436,"misation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic tran",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14660,Deployability,configurat,configuration,14660,"; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:17370,Deployability,configurat,configuration,17370," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:18173,Deployability,update,updated,18173," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:8045,Energy Efficiency,efficient,efficient,8045,"stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited m",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:8336,Energy Efficiency,reduce,reduces,8336,"we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exac",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:9114,Energy Efficiency,reduce,reduces,9114," the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:9313,Energy Efficiency,efficient,efficient,9313,"vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:9668,Energy Efficiency,efficient,efficient,9668," known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:11152,Energy Efficiency,efficient,efficiently,11152," this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm; [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:18011,Energy Efficiency,efficient,efficient,18011," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:4295,Integrability,depend,dependent,4295,"} \ket{\psi} = -i H(t)\ket{\psi}\]; Note we use units where \(\hbar=1\) throughout. The solutions to Schrödinger’s equation are of the form:. \[\ket{\psi(t)} = U(t)\ket{\psi_0}\]; where \(\psi_0\) is the state of the system at \(t=0\) and \(U(t)\) is a unitary operator on the Hilbert space containing the states. \(U(t)\) is a solution to the Schrödinger operator equation. \[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\ket{\psi_0}\) to \(\ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The GRadient Ascent Pulse Engineering was first proposed in [NKanej]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\c",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:8971,Integrability,wrap,wrapper,8971,"and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other opti",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:11641,Integrability,integrat,integration,11641,"11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, al",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:12709,Integrability,integrat,integration,12709,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:12853,Integrability,integrat,integration,12853,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13334,Integrability,integrat,integrated,13334,"ch time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14180,Integrability,interface,interface,14180,"; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14704,Integrability,wrap,wrapper,14704,"ded for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be ac",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:4478,Modifiability,evolve,evolve,4478,"t=0\) and \(U(t)\) is a unitary operator on the Hilbert space containing the states. \(U(t)\) is a solution to the Schrödinger operator equation. \[\tfrac{d}{dt}U = -i H(t)U ,\quad U(0) = \mathbb{1}\]; We can use optimal control algorithms to determine a set of \(u_j\) that will drive our system from \(\ket{\psi_0}\) to \(\ket{\psi_1}\), this is state-to-state transfer, or drive the system from some arbitary state to a given state \(\ket{\psi_1}\), which is state preparation, or effect some unitary transformation \(U_{target}\), called gate synthesis. The latter of these is most important in quantum computation. The GRAPE algorithm¶; The GRadient Ascent Pulse Engineering was first proposed in [NKanej]. Solutions to Schrödinger’s equation for a time-dependent Hamiltonian are not generally possible to obtain analytically. Therefore, a piecewise constant approximation to the pulse amplitudes is made. Time allowed for the system to evolve \(T\) is split into \(M\) timeslots (typically these are of equal duration), during which the control amplitude is assumed to remain constant. The combined Hamiltonian can then be approximated as:. \[H(t) \approx H(t_k) = H_0 + \sum_{j=1}^N u_{jk} H_j\quad\]; where \(k\) is a timeslot index, \(j\) is the control index, and \(N\) is the number of controls. Hence \(t_k\) is the evolution time at the start of the timeslot, and \(u_{jk}\) is the amplitude of control \(j\) throughout timeslot \(k\). The time evolution operator, or propagator, within the timeslot can then be calculated as:. \[X_k:=e^{-iH(t_k)\Delta t_k}\]; where \(\Delta t_k\) is the duration of the timeslot. The evolution up to (and including) any timeslot \(k\) (including the full evolution \(k=M\)) can the be calculated as. \[X(t_k):=X_k X_{k-1}\cdots X_1 X_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of meri",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6215,Modifiability,variab,variables,6215,"_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then loo",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6331,Modifiability,variab,variable,6331,"_0\]; If the objective is state-to-state transfer then \(X_0=\ket{\psi_0}\) and the target \(X_{targ}=\ket{\psi_1}\), for gate synthesis \(X_0 = U(0) = \mathbb{1}\) and the target \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then loo",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6587,Modifiability,variab,variables,6587,"ontrol amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6656,Modifiability,variab,variable,6656,"ontrol amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6966,Modifiability,variab,variable,6966,"d \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we mi",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:8150,Modifiability,variab,variables,8150," likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required,",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:9185,Modifiability,variab,variable,9185," the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13418,Modifiability,variab,variable,13418,"his trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to h",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13697,Modifiability,extend,extended,13697,"t integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrap",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13933,Modifiability,config,configurability,13933,",; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14095,Modifiability,flexible,flexible,14095,"ementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a conta",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14436,Modifiability,config,configuration,14436,"misation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic tran",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14660,Modifiability,config,configuration,14660,"; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:17370,Modifiability,config,configuration,17370," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:17902,Modifiability,config,configure,17902," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:10150,Performance,perform,performing,10150,"entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm; [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), thi",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:11164,Performance,optimiz,optimize,11164," this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evolution time. You can think of this as the information content of the; pulse (as being the only effective input) being very limited e.g. the pulse is; compressible to a few bytes without loosing the target.; This is where the Chopped RAndom Basis (CRAB) algorithm; [Doria11], [Caneva11] comes into play: Since the pulse complexity is usually; very low, it is sufficient to transform the optimal control problem to a few; parameter search by introducing a physically motivated function basis that; builds up the pulse. Compared to the number of time slices needed to accurately; simulate quantum dynamics (often equals basis dimension for Gradient based; algorithms), this number is lower by orders of magnitude, allowing CRAB to; efficiently optimize smooth pulses with realistic experimental constraints. It; is important to point out, that CRAB does not make any suggestion on the basis; function to be used. The basis must be chosen carefully considered, taking into; account a priori knowledge of the system (such as symmetries, magnitudes of; scales,…) and solution (e.g. sign, smoothness, bang-bang behavior,; singularities, maximum excursion or rate of change,….). By doing so, this; algorithm allows for native integration of experimental constraints such as; maximum frequencies allowed, maximum amplitude, smooth ramping up and down of; the pulse and many more. Moreover initial guesses, if they are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:12803,Performance,optimiz,optimization,12803,"are available, can; (however not have to) be included to speed up convergence.; As mentioned in the GRAPE paragraph, for CRAB local minima arising from; algorithmic design can occur, too. However, for CRAB a ‘dressed’ version has; recently been introduced [Rach15] that allows to escape local minima.; For some control objectives and/or dynamical quantum descriptions, it is either; not possible to derive the gradient for the cost functional with respect to; each time slice or it is computationally expensive to do so. The same can apply; for the necessary (reverse) propagation of the co-state. All this trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13377,Performance,optimiz,optimize,13377,"his trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to h",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:13399,Performance,perform,perform,13399,"his trouble does; not occur within CRAB as those elements are not in use here. CRAB, instead,; takes the time evolution as a black-box where the pulse goes as an input and; the cost (e.g. infidelity) value will be returned as an output. This concept,; on top, allows for direct integration in a closed loop experimental environment; where both the preliminarily open loop optimization, as well as the final; adoption, and integration to the lab (to account for modeling errors,; experimental systematic noise, …) can be done all in one, using this; algorithm. Optimal Quantum Control in QuTiP¶; There are two separate implementations of optimal control inside QuTiP. The; first is an implementation of first order GRAPE, and is not further described; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to h",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14601,Performance,load,loadparams,14601,"; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the init",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14680,Performance,Optimiz,OptimizerThis,14680,"ded for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be ac",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14725,Performance,optimiz,optimize,14725," of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some k",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14749,Performance,perform,perform,14749," of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some k",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:15823,Performance,perform,performed,15823,"orithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported.; There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised. TerminationConditionsThis is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The opti",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:17145,Performance,perform,performance,17145,"is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previo",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:901,Testability,Log,Log,901,". Quantum Optimal Control — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Optimal Control. Quantum Optimal Control¶. Introduction¶; In quantum control we look to prepare some specific state, effect some state-to-state transfer, or effect some transformation (or gate) on a quantum system. For a given quantum system there will always be factors that effect the dynamics that are outside of our control. As examples, the interactions between elements of the system or a magnetic field required to trap the system. However, there may be methods of affecting the dynamics in a controlled way, such as the time varying amplitude of the electric component of an interacting laser field. And so this leads to some questions; given a specific quantum system with known time-independent dynamics generator (referred to as the drift dynamics generators) and set of externally controllable fields for which the interaction can be described by control dynamics generators:. What states or transformations can we achieve (if any)?; What is the",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:133,Usability,Guid,Guide,133,". Quantum Optimal Control — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Optimal Control. Quantum Optimal Control¶. Introduction¶; In quantum control we look to prepare some specific state, effect some state-to-state transfer, or effect some transformation (or gate) on a quantum system. For a given quantum system there will always be factors that effect the dynamics that are outside of our control. As examples, the interactions between elements of the system or a magnetic field required to trap the system. However, there may be methods of affecting the dynamics in a controlled way, such as the time varying amplitude of the electric component of an interacting laser field. And so this leads to some questions; given a specific quantum system with known time-independent dynamics generator (referred to as the drift dynamics generators) and set of externally controllable fields for which the interaction can be described by control dynamics generators:. What states or transformations can we achieve (if any)?; What is the",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:140,Usability,Guid,Guide,140,". Quantum Optimal Control — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Optimal Control. Quantum Optimal Control¶. Introduction¶; In quantum control we look to prepare some specific state, effect some state-to-state transfer, or effect some transformation (or gate) on a quantum system. For a given quantum system there will always be factors that effect the dynamics that are outside of our control. As examples, the interactions between elements of the system or a magnetic field required to trap the system. However, there may be methods of affecting the dynamics in a controlled way, such as the time varying amplitude of the electric component of an interacting laser field. And so this leads to some questions; given a specific quantum system with known time-independent dynamics generator (referred to as the drift dynamics generators) and set of externally controllable fields for which the interaction can be described by control dynamics generators:. What states or transformations can we achieve (if any)?; What is the",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:1027,Usability,Guid,Guide,1027,"Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Optimal Control. Quantum Optimal Control¶. Introduction¶; In quantum control we look to prepare some specific state, effect some state-to-state transfer, or effect some transformation (or gate) on a quantum system. For a given quantum system there will always be factors that effect the dynamics that are outside of our control. As examples, the interactions between elements of the system or a magnetic field required to trap the system. However, there may be methods of affecting the dynamics in a controlled way, such as the time varying amplitude of the electric component of an interacting laser field. And so this leads to some questions; given a specific quantum system with known time-independent dynamics generator (referred to as the drift dynamics generators) and set of externally controllable fields for which the interaction can be described by control dynamics generators:. What states or transformations can we achieve (if any)?; What is the shape of the control pulse required t",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6459,Usability,simpl,simplest,6459,"get \(X_{targ}=U_{targ}\).; A figure of merit or fidelity is some measure of how close the evolution is to the target, based on the control amplitudes in the timeslots. The typical figure of merit for unitary systems is the normalised overlap of the evolution and the target. \[f_{PSU} = \tfrac{1}{d} \big| \tr \{X_{targ}^{\dagger} X(T)\} \big|\]; where \(d\) is the system dimension. In this figure of merit the absolute value is taken to ignore any differences in global phase, and \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidel",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:6909,Usability,clear,clearly,6909,"d \(0 \le f \le 1\). Typically the fidelity error (or infidelity) is more useful, in this case defined as \(\varepsilon = 1 - f_{PSU}\). There are many other possible objectives, and hence figures of merit.; As there are now \(N \times M\) variables (the \(u_{jk}\)) and one; parameter to minimise \(\varepsilon\), then the problem becomes a finite; multi-variable optimisation problem, for which there are many established; methods, often referred to as ‘hill-climbing’ methods. The simplest of these to; understand is that of steepest ascent (or descent). The gradient of the; fidelity with respect to all the variables is calculated (or approximated) and; a step is made in the variable space in the direction of steepest ascent (or; descent). This method is a first order gradient method. In two dimensions this; describes a method of climbing a hill by heading in the direction where the; ground rises fastest. This analogy also clearly illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we mi",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:7837,Usability,Clear,Clearly,7837,"illustrates one of the main; challenges in multi-variable optimisation, which is that all methods have a; tendency to get stuck in local maxima. It is hard to determine whether one has; found a global maximum or not - a local peak is likely not to be the highest; mountain in the region. In quantum optimal control we can typically define an; infidelity that has a lower bound of zero. We can then look to minimise the; infidelity (from here on we will only consider optimising for infidelity; minima). This means that we can terminate any pulse optimisation when the; infidelity reaches zero (to a sufficient precision). This is however only; possible for fully controllable systems; otherwise it is hard (if not; impossible) to know that the minimum possible infidelity has been achieved. In; the hill walking analogy the step size is roughly fixed to a stride, however,; in computations the step size must be chosen. Clearly there is a trade-off here; between the number of steps (or iterations) required to reach the minima and; the possibility that we might step over a minima. In practice it is difficult; to determine an efficient and effective step size.; The second order differentials of the infidelity with respect to the variables; can be used to approximate the local landscape to a parabola. This way a step; (or jump) can be made to where the minima would be if it were parabolic. This; typically vastly reduces the number of iterations, and removes the need to; guess a step size. The method where all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE impleme",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:9398,Usability,simpl,simple,9398,"ere all the second differentials are calculated; explicitly is called the Newton-Raphson method. However, calculating the; second-order differentials (the Hessian matrix) can be computationally; expensive, and so there are a class of methods known as quasi-Newton that; approximate the Hessian based on successive iterations. The most popular of; these (in quantum optimal control) is the Broyden–Fletcher–Goldfarb–Shanno; algorithm (BFGS). The default method in the QuTiP Qtrl GRAPE implementation is; the L-BFGS-B method in Scipy, which is a wrapper to the implementation; described in [Byrd95]. This limited memory and bounded method does not need to; store the entire Hessian, which reduces the computer memory required, and; allows bounds to be set for variable values, which considering these are field; amplitudes is often physical.; The pulse optimisation is typically far more efficient if the gradients can be; calculated exactly, rather than approximated. For simple fidelity measures such; as \(f_{PSU}\) this is possible. Firstly the propagator gradient for each; timeslot with respect to the control amplitudes is calculated. For closed; systems, with unitary dynamics, a method using the eigendecomposition is used,; which is efficient as it is also used in the propagator calculation (to; exponentiate the combined Hamiltonian). More generally (for example open; systems and symplectic dynamics) the Frechet derivative (or augmented matrix); method is used, which is described in [Flo12]. For other optimisation goals it; may not be possible to calculate analytic gradients. In these cases it is; necessary to approximate the gradients, but this can be very expensive, and can; lead to other algorithms out-performing GRAPE. The CRAB Algorithm¶; It has been shown [Lloyd14], the dimension of a quantum optimal control; problem is a polynomial function of the dimension of the manifold of the; time-polynomial reachable states, when allowing for a finite control precision; and evoluti",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14152,Usability,simpl,simple,14152,"; here, but there are the example notebooks. The second is referred to as Qtrl; (when a distinction needs to be made) as this was its name before it was; integrated into QuTiP. Qtrl uses the Scipy optimize functions to perform the; multi-variable optimisation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:14421,Usability,simpl,simply,14421,"misation, typically the L-BFGS-B method for GRAPE and; Nelder-Mead for CRAB. The GRAPE implementation in Qtrl was initially based on; the open-source package DYNAMO, which is a MATLAB implementation, and is; described in [DYNAMO]. It has since been restructured and extended for; flexibility and compatibility within QuTiP.; The rest of this section describes the Qtrl implementation and how to use it. Object ModelThe Qtrl code is organised in a hierarchical object model in order to try and maximise configurability whilst maintaining some clarity. It is not necessary to understand the model in order to use the pulse optimisation functions, but it is the most flexible method of using Qtrl. If you just want to use a simple single function call interface, then jump to Using the pulseoptim functions. Qtrl code object model.¶. The object’s properties and methods are described in detail in the documentation, so that will not be repeated here. OptimConfigThe OptimConfig object is used simply to hold configuration parameters used by all the objects. Typically this is the subclass types for the other objects and parameters for the users specific requirements. The loadparams module can be used read parameter values from a configuration file. OptimizerThis acts as a wrapper to the Scipy.optimize functions that perform the work of the pulse optimisation algorithms. Using the main classes the user can specify which of the optimisation methods are to be used. There are subclasses specifically for the BFGS and L-BFGS-B methods. There is another subclass for using the CRAB algorithm. DynamicsThis is mainly a container for the lists that hold the dynamics generators, propagators, and time evolution operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic tran",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:16093,Usability,simpl,simply,16093,"on operators in each timeslot. The combining of dynamics generators is also complete by this object. Different subclasses support a range of types of quantum systems, including closed systems with unitary dynamics, systems with quadratic Hamiltonians that have Gaussian states and symplectic transforms, and a general subclass that can be used for open system dynamics with Lindbladian operators. PulseGenThere are many subclasses of pulse generators that generate different types of pulses as the initial amplitudes for the optimisation. Often the goal cannot be achieved from all starting conditions, and then typically some kind of random pulse is used and repeated optimisations are performed until the desired infidelity is reached or the minimum infidelity found is reported.; There is a specific subclass that is used by the CRAB algorithm to generate the pulses based on the basis coefficients that are being optimised. TerminationConditionsThis is simply a convenient place to hold all the properties that will determine when the single optimisation run terminates. Limits can be set for number of iterations, time, and of course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termi",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:17233,Usability,simpl,simplest,17233,"f course the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-control.html:17741,Usability,simpl,simply,17741," the target infidelity. StatsPerformance data are optionally collected during the optimisation. This object is shared to a single location to store, calculate and report run statistics. FidelityComputerThe subclass of the fidelity computer determines the type of fidelity measure. These are closely linked to the type of dynamics in use. These are also the most commonly user customised subclasses. PropagatorComputerThis object computes propagators from one timeslot to the next and also the propagator gradient. The options are using the spectral decomposition or Frechet derivative, as discussed above. TimeslotComputerHere the time evolution is computed by calling the methods of the other computer objects. OptimResultThe result of a pulse optimisation run is returned as an object with properties for the outcome in terms of the infidelity, reason for termination, performance statistics, final evolution, and more. Using the pulseoptim functions¶; The simplest method for optimising a control pulse is to call one of the functions in the pulseoptim module. This automates the creation and configuration of the necessary objects, generation of initial pulses, running the optimisation and returning the result. There are functions specifically for unitary dynamics, and also specifically for the CRAB algorithm (GRAPE is the default). The optimise_pulse function can in fact be used for unitary dynamics and / or the CRAB algorithm, the more specific functions simply have parameter names that are more familiar in that application.; A semi-automated method is to use the create_optimizer_objects function to generate and configure all the objects, then manually set the initial pulse and call the optimisation. This would be more efficient when repeating runs with different starting conditions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-control.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-control.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:2728,Availability,avail,available,2728,"ite. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho_{\rm ss}\right\}\right]; = {\rm Tr}\left[A V(\tau, 0)\left\{B\rho_{\rm ss}\right\}\right] = \left<A(\tau)B(0)\right>,\]; which is independent of \(t\), so that we only have one time coordinate \(\tau\).; QuTiP provides a family of functions that assists in the process of calculating two-time correlation functions. The available functions and their usage is shown in the table below. Each of these functions can use one of the following evolution solvers: Master-equation, Exponential series and the Monte-Carlo. The choice of solver is defined by the optional argument solver. QuTiP function; Correlation function. qutip.correlation.correlation_2op_2t; \(\left<A(t+\tau)B(t)\right>\) or; \(\left<A(t)B(t+\tau)\right>\). qutip.correlation.correlation_2op_1t; \(\left<A(\tau)B(0)\right>\) or; \(\left<A(0)B(\tau)\right>\). qutip.correlation.correlation_3op_1t; \(\left<A(0)B(\tau)C(0)\right>\). qutip.correlation.correlation_3op_2t; \(\left<A(t)B(t+\tau)C(t)\right>\). The most common use-case is to calculate correlation functions of the kind \(\left<A(\tau)B(0)\right>\), in which case we use the correlation function solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function solvers return a vector or matrix (in general complex) with the correlations as a function of the delays",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:120,Deployability,Install,Installation,120,". Two-time correlation functions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\r",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:12708,Deployability,update,updated,12708,"unched photons, more likely to arrive separated in time).; To calculate this type of correlation function with QuTiP, we can use qutip.correlation.correlation_3op_1t, which computes a correlation function on the form \(\left<A(0)B(\tau)C(0)\right>\) (three operators, one delay-time vector).; We first have to combine the central two operators into one single one as they are evaluated at the same time, e.g. here we do \(a^\dagger(\tau)a(\tau) = (a^\dagger a)(\tau)\).; The following code calculates and plots \(g^{(2)}(\tau)\) as a function of \(\tau\) for a coherent, thermal and Fock state.; import numpy as np; import matplotlib.pyplot as plt; import qutip. N = 25; taus = np.linspace(0, 25.0, 200); a = qutip.destroy(N); H = 2 * np.pi * a.dag() * a. kappa = 0.25; n_th = 2.0 # bath temperature in terms of excitation number; c_ops = [np.sqrt(kappa * (1 + n_th)) * a, np.sqrt(kappa * n_th) * a.dag()]. states = [; {'state': qutip.coherent_dm(N, np.sqrt(2)), 'label': ""coherent state""},; {'state': qutip.thermal_dm(N, 2), 'label': ""thermal state""},; {'state': qutip.fock_dm(N, 2), 'label': ""Fock state""},; ]. fig, ax = plt.subplots(1, 1). for state in states:; rho0 = state['state']. # first calculate the occupation number as a function of time; n = qutip.mesolve(H, rho0, taus, c_ops, [a.dag() * a]).expect[0]. # calculate the correlation function G2 and normalize with n(0)n(t) to; # obtain g2; G2 = qutip.correlation_3op_1t(H, rho0, taus, c_ops, a.dag(), a.dag()*a, a); g2 = G2 / (n[0] * n). ax.plot(taus, np.real(g2), label=state['label'], lw=2). ax.legend(loc=0); ax.set_xlabel(r'$\tau$'); ax.set_ylabel(r'$g^{(2)}(\tau)$'); plt.show(). For convenience, the steps for calculating the second-order coherence function have been collected in the function qutip.correlation.coherence_function_g2. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:4570,Energy Efficiency,power,power,4570,"tion solvers that start from the steady state, e.g., the qutip.correlation.correlation_2op_1t function. These correlation function solvers return a vector or matrix (in general complex) with the correlations as a function of the delays times. Steadystate correlation function¶; The following code demonstrates how to calculate the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qu",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:5162,Energy Efficiency,power,power,5162,"ion_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting s",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:6312,Energy Efficiency,power,power,6312,"upling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = qutip.correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = qutip.spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 = np.linspace(0.25, 1.75, 200) * 2 * np.pi; spec2 = qutip.spectrum(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = pyplot.subplots(1, 1); ax.plot(wlist1 / (2 * np.pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * np.pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*np.pi), wlist2[-1]/(2*np.pi)); plt.show(). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function qutip.correlation.correlation_2op_2t. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (\(t",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:6777,Energy Efficiency,Power,Power,6777,"a) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = qutip.correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = qutip.spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolve; # to solve for the dynamics (by default); wlist2 = np.linspace(0.25, 1.75, 200) * 2 * np.pi; spec2 = qutip.spectrum(H, wlist2, c_ops, a.dag(), a). # plot the spectra; fig, ax = pyplot.subplots(1, 1); ax.plot(wlist1 / (2 * np.pi), spec1, 'b', lw=2, label='eseries method'); ax.plot(wlist2 / (2 * np.pi), spec2, 'r--', lw=2, label='me+fft method'); ax.legend(); ax.set_xlabel('Frequency'); ax.set_ylabel('Power spectrum'); ax.set_title('Vacuum Rabi splitting'); ax.set_xlim(wlist2[0]/(2*np.pi), wlist2[-1]/(2*np.pi)); plt.show(). Non-steadystate correlation function¶; More generally, we can also calculate correlation functions of the kind \(\left<A(t_1+t_2)B(t_1)\right>\), i.e., the correlation function of a system that is not in its steady state. In QuTiP, we can evaluate such correlation functions using the function qutip.correlation.correlation_2op_2t. The default behavior of this function is to return a matrix with the correlations as a function of the two time coordinates (\(t_1\) and \(t_2\)).; import numpy as np; import matplotlib.pyplot as plt; import qutip. times = np.linspace(0, 10.0, 200); a = qutip.destroy(10); x = a.dag() + a; H = a.dag() * a; alpha = 2.5; rho0 = qutip.coherent_dm(10, alpha); corr = qutip.correlation_2op_2t(H, rho0, times, times, [np.sqrt(0.25) * a], x, x). plt.pcolor(np.real(corr)); plt.xlabel(r'Time $t_2$'); plt.ylabel(r'Time $t_1$'); plt.title(r'Correlation $\l",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:4834,Integrability,depend,dependent,4834,"te the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:1280,Modifiability,evolve,evolved,1280,"tion; Solving for Steady-State Solutions; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then again use the same solver to calculate \(V(t+\tau, t)\left\{B\rho(t)\right\}\) using \(B\rho(t)\) as initial state.; Note that if the initial state is the steady state, then \(\rho(t)=V(t, 0)\left\{\rho_{\rm ss}\right\}=\rho_{\rm ss}\) and. \[\left<A(t+\",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:5359,Modifiability,coupling,coupling,5359,"plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve solver, and then fft to; # obtain the spectrum. Here we need to make sure to evaluate the correlation; # function for a sufficient long time and sufficiently high sampling rate so ; # that the discrete Fourier transform (FFT) captures all the features in the; # resulting spectrum.; tlist = np.linspace(0, 100, 5000); corr = qutip.correlation_2op_1t(H, None, tlist, c_ops, a.dag(), a); wlist1, spec1 = qutip.spectrum_correlation_fft(tlist, corr). # calculate the power spectrum using spectrum, which internally uses essolv",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:4861,Performance,perform,performs,4861,"te the \(\left<x(t)x(0)\right>\) correlation for a leaky cavity with three different relaxation rates.; times = np.linspace(0,10.0,200); a = destroy(10); x = a.dag() + a; H = a.dag() * a. corr1 = correlation_2op_1t(H, None, times, [np.sqrt(0.5) * a], x, x); corr2 = correlation_2op_1t(H, None, times, [np.sqrt(1.0) * a], x, x); corr3 = correlation_2op_1t(H, None, times, [np.sqrt(2.0) * a], x, x). plt.figure(); plt.plot(times, np.real(corr1), times, np.real(corr2), times, np.real(corr3)); plt.legend(['0.5','1.0','2.0']); plt.xlabel(r'Time $t$'); plt.ylabel(r'Correlation $\left<x(t)x(0)\right>$'); plt.show(). Emission spectrum¶; Given a correlation function \(\left<A(\tau)B(0)\right>\) we can define the corresponding power spectrum as. \[S(\omega) = \int_{-\infty}^{\infty} \left<A(\tau)B(0)\right> e^{-i\omega\tau} d\tau.\]; In QuTiP, we can calculate \(S(\omega)\) using either qutip.correlation.spectrum_ss, which first calculates the correlation function using one of the time-dependent solvers and then performs the Fourier transform semi-analytically, or we can use the function qutip.correlation.spectrum_correlation_fft to numerically calculate the Fourier transform of a given correlation data using FFT.; The following example demonstrates how these two functions can be used to obtain the emission power spectrum.; import numpy as np; from matplotlib import pyplot; import qutip. N = 4 # number of cavity fock states; wc = wa = 1.0 * 2 * np.pi # cavity and atom frequency; g = 0.1 * 2 * np.pi # coupling strength; kappa = 0.75 # cavity dissipation rate; gamma = 0.25 # atom dissipation rate. # Jaynes-Cummings Hamiltonian; a = qutip.tensor(qutip.destroy(N), qutip.qeye(2)); sm = qutip.tensor(qutip.qeye(N), qutip.destroy(2)); H = wc*a.dag()*a + wa*sm.dag()*sm + g*(a.dag()*sm + a*sm.dag()). # collapse operators; n_th = 0.25; c_ops = [; np.sqrt(kappa * (1 + n_th)) * a,; np.sqrt(kappa * n_th) * a.dag(),; np.sqrt(gamma) * sm,; ]. # calculate the correlation function using the mesolve",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:953,Testability,Log,Log,953,". Two-time correlation functions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\r",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:140,Usability,Guid,Guide,140,". Two-time correlation functions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\r",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:147,Usability,Guid,Guide,147,". Two-time correlation functions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\r",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-correlation.html:1079,Usability,Guid,Guide,1079,". ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function; Example: first-order optical coherence function; Example: second-order optical coherence function. Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Two-time correlation functions. Two-time correlation functions¶; With the QuTiP time-evolution functions (for example qutip.mesolve and qutip.mcsolve), a state vector or density matrix can be evolved from an initial state at \(t_0\) to an arbitrary time \(t\), \(\rho(t)=V(t, t_0)\left\{\rho(t_0)\right\}\), where \(V(t, t_0)\) is the propagator defined by the equation of motion. The resulting density matrix can then be used to evaluate the expectation values of arbitrary combinations of same-time operators.; To calculate two-time correlation functions on the form \(\left<A(t+\tau)B(t)\right>\), we can use the quantum regression theorem (see, e.g., [Gar03]) to write. \[\left<A(t+\tau)B(t)\right> = {\rm Tr}\left[A V(t+\tau, t)\left\{B\rho(t)\right\}\right]; = {\rm Tr}\left[A V(t+\tau, t)\left\{BV(t, 0)\left\{\rho(0)\right\}\right\}\right]\]; We therefore first calculate \(\rho(t)=V(t, 0)\left\{\rho(0)\right\}\) using one of the QuTiP evolution solvers with \(\rho(0)\) as initial state, and then",MatchSource.WIKI,docs/4.7/guide/guide-correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-correlation.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:132,Deployability,Install,Installation,132,. Time Evolution and Quantum System Dynamics — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experi,MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:2623,Deployability,update,updated,2623,"e Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:524,Integrability,depend,dependent,524,. Time Evolution and Quantum System Dynamics — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experi,MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:1842,Integrability,depend,dependent,1842,"e Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:1891,Integrability,Depend,Dependent,1891,"e Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:1932,Integrability,Depend,Dependence,1932,"e Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:2013,Integrability,Depend,Dependent,2013,"e Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:2110,Integrability,Depend,Dependent,2110,"e Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:2264,Integrability,depend,dependent,2264,"e Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:1435,Performance,Load,Loading,1435,olver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutation,MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:1401,Security,Access,Accessing,1401,olver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutation,MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:1109,Testability,Log,Log,1109,Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian ,MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:152,Usability,Guid,Guide,152,. Time Evolution and Quantum System Dynamics — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experi,MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:159,Usability,Guid,Guide,159,. Time Evolution and Quantum System Dynamics — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experi,MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-dynamics.html:1235,Usability,Guid,Guide,1235,sor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics. Time Evolution and Quantum System Dynamics¶. Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTi,MatchSource.WIKI,docs/4.7/guide/guide-dynamics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-dynamics.html
https://qutip.org/docs/4.7/guide/guide-heom.html:122,Deployability,Install,Installation,122,". Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion. Hierarchical Equations of Motion¶. Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Describing the system and bath; System and bath dynamics; Determining currents; Steady state currents; Padé expansion coefficients. Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-heom.html
https://qutip.org/docs/4.7/guide/guide-heom.html:1584,Deployability,update,updated,1584,". Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion. Hierarchical Equations of Motion¶. Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Describing the system and bath; System and bath dynamics; Determining currents; Steady state currents; Padé expansion coefficients. Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-heom.html
https://qutip.org/docs/4.7/guide/guide-heom.html:863,Testability,Log,Log,863,". Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion. Hierarchical Equations of Motion¶. Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Describing the system and bath; System and bath dynamics; Determining currents; Steady state currents; Padé expansion coefficients. Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-heom.html
https://qutip.org/docs/4.7/guide/guide-heom.html:142,Usability,Guid,Guide,142,". Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion. Hierarchical Equations of Motion¶. Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Describing the system and bath; System and bath dynamics; Determining currents; Steady state currents; Padé expansion coefficients. Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-heom.html
https://qutip.org/docs/4.7/guide/guide-heom.html:149,Usability,Guid,Guide,149,". Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion. Hierarchical Equations of Motion¶. Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Describing the system and bath; System and bath dynamics; Determining currents; Steady state currents; Padé expansion coefficients. Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-heom.html
https://qutip.org/docs/4.7/guide/guide-heom.html:989,Usability,Guid,Guide,989,". Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion. Hierarchical Equations of Motion¶. Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Describing the system and bath; System and bath dynamics; Determining currents; Steady state currents; Padé expansion coefficients. Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-heom.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-heom.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:1914,Availability,down,down,1914,"ics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”.",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:1945,Availability,down,down,1945,"ange Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states wit",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:2038,Availability,down,down,2038,"phy; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures th",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:2990,Availability,down,down,2990,"spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator ",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:3233,Availability,down,down,3233,"max which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvecto",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:3397,Availability,down,down,3397,"ement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:3421,Availability,down,down,3421,"self:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement wil",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:3492,Availability,down,down,3492,"ne of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - ",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:3821,Availability,down,down,3821,"ment is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:3845,Availability,down,down,3845,"ment is the eigenvalue corresponding to the; chosen eigenvector. Note; How to interpret this “random choosing” is the famous; “quantum measurement problem”. The eigenvectors of spin_z are the states with their spin pointing either up; or down, so it measures the component of the spin along the z-axis.; The eigenvectors of spin_x are the states with their spin pointing either; left or right, so it measures the component of the spin along the x-axis.; When we measure our up and down states using the operator spin_z, we; always obtain:; from qutip.measurement import measure, measurement_statistics. measure(up, spin_z) == (1.0, up). measure(down, spin_z) == (-1.0, down). because up is the eigenvector of spin_z with eigenvalue 1.0 and down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:4511,Availability,down,down,4511,"nd down; is the eigenvector with eigenvalue -1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conven",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:4539,Availability,down,down,4539,"1.0. The minus signs are just an; arbitrary global phase – up and -up represent the same quantum state.; Neither eigenvector has any component in the direction of the other (they are; orthogonal), so measure(spin_z, up) returns the state up 100% percent of the; time and measure(spin_z, down) returns the state down 100% of the time.; Note how measure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspace",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:5411,Availability,down,down,5411,"ill select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension \(1\). However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state \(\ket{0+}\); state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the ",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:5434,Availability,down,down,5434,"ill select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension \(1\). However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state \(\ket{0+}\); state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the ",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:120,Deployability,Install,Installation,120,". Measurement of Quantum Objects — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles w",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:11703,Deployability,update,updated,11703," measurement statistics for projection operators,; we can use the measurement_statistics function with the second argument being a list of projectors.; Consider again, the state \(\ket{0+}\).; Suppose, now we want to obtain the measurement outcomes for the second qubit. We; must use the projectors specified earlier by PZ2 which allow us to measure only; on the second qubit. Since the second qubit has the state \(\ket{+}\), we get; the following result.; collapsed_states, probabilities = measurement_statistics(state_0plus, PZ2). print(collapsed_states). Output:; [Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]], Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]]]. print(probabilities). Output:; [0.4999999999999999, 0.4999999999999999]. The function measurement_statistics then returns two values:. collapsed_states is an array of the possible final states after the; measurement is complete. Each element of the array is a Qobj.; probabilities is a list of the probabilities of each measurement outcome. Note that the collapsed_states are exactly \(\ket{00}\) and \(\ket{01}\); with equal probability, as expected. The two lists are in the same order. Note; When measurement_statistics; is invoked with the second argument; being a list of projectors, it acts as an alias to; measurement_statistics_povm. The measurement_statistics function can provide statistics for measurements; of density matrices too.; You can read about these and other details at; measurement_statistics_observable; and measurement_statistics_povm.; Furthermore, the measure_povm; and measurement_statistics_povm functions can; handle POVM measurements which are more general than projective measurements. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:742,Performance,Perform,Performing,742,". Measurement of Quantum Objects — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles w",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:787,Performance,Perform,Performing,787,". Measurement of Quantum Objects — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles w",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:1573,Performance,perform,perform,1573,"nerating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to p",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:1778,Performance,Perform,Performing,1778,"ctive); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to project onto is chosen probabilistically according to the; square of the amplitude of the state in the direction of the eigenvector.; The value returned by the measurement is the eigenvalue corresponding to the; chosen eigenvector. Note; H",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:4819,Performance,Perform,Performing,4819,"sure returns a pair of values. The; first is the measured value, i.e. an eigenvalue of the operator (e.g. 1.0),; and the second is the state of the quantum system after the measurement,; i.e. an eigenvector of the operator (e.g. up).; Now let us consider what happens if we measure the x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension \(1\). However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state \(\ket{0+}\); state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tens",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:6812,Performance,perform,perform,6812,"lus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:7072,Performance,perform,perform,7072," \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we woul",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:8091,Performance,perform,perform,8091," What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we would have to perform the measurement many many times,; but in QuTiP we can peak at the state itself and determine the probability; distribution of the outcomes exactly in a single line:; >>> eigenvalues, eigenstates, probabilities = measurement_statistics(up, spin_x). >>> eigenvalues ; array([-1., 1.]). >>> eigenstates ; array([Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.70710678]; [-0.70710678]],; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.70710678]; [0.70710678]]], dtype=object). >>> probabilities ; [0.5000000000000001, 0.4999999999999999]. The measurement_statistics function then returns three values; when called with a single observable:. eigenvalues is an array of eigenvalues of the measurement operator, i.e.; a list of the possible measurement results. In our example; the value is array([-1., -1.]).; eigenstates is an array of the eigenstates of the measurement operator, i.e.; a list of the possible final states after the measurement is complete.; Each element of the array is a Qobj.; probab",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:959,Testability,Log,Log,959,". Measurement of Quantum Objects — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles w",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:140,Usability,Guid,Guide,140,". Measurement of Quantum Objects — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles w",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:147,Usability,Guid,Guide,147,". Measurement of Quantum Objects — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles w",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:1085,Usability,Guid,Guide,1085,"4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this ca",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:1581,Usability,simpl,simple,1581,"nerating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Measurement of Quantum Objects. Measurement of Quantum Objects¶. Note; New in QuTiP 4.6. Introduction¶; Measurement is a fundamental part of the standard formulation of quantum; mechanics and is the process by which classical readings are obtained from; a quantum object. Although the interpretation of the procedure is at times; contentious, the procedure itself is mathematically straightforward and is; described in many good introductory texts.; Here we will show you how to perform simple measurement operations on QuTiP; objects. The same functions measure and; measurement_statistics can be used; to handle both observable-style measurements and projective style measurements. Performing a basic measurement (Observable)¶; First we need to select some states to measure. For now, let us create an up; state and a down state:; up = basis(2, 0). down = basis(2, 1). which represent spin-1/2 particles with their spin pointing either up or down; along the z-axis.; We choose what to measure (in this case) by selecting a measurement operator.; For example,; we could select sigmaz which measures the z-component of the; spin of a spin-1/2 particle, or sigmax which measures the; x-component:; spin_z = sigmaz(). spin_x = sigmax(). How do we know what these operators measure? The answer lies in the measurement; procedure itself:. A quantum measurement transforms the state being measured by projecting it into; one of the eigenvectors of the measurement operator.; Which eigenvector to p",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:5147,Usability,simpl,simply,5147,"he x-component of the spin; of up:; measure(up, spin_x). The up state is not an eigenvector of spin_x. spin_x has two eigenvectors; which we will call left and right. The up state has equal components in; the direction of these two vectors, so measurement will select each of them; 50% of the time.; These left and right states are:; left = (up - down).unit(). right = (up + down).unit(). When left is chosen, the result of the measurement will be (-1.0, -left).; When right is chosen, the result of measurement with be (1.0, right). Note; When measure is invoked with the second argument; being an observable, it acts as an alias to; measure_observable. Performing a basic measurement (Projective)¶; We can also choose what to measure by specifying a list of projection operators. For; example, we could select the projection operators \(\ket{0} \bra{0}\) and; \(\ket{1} \bra{1}\) which measure the state in the \(\ket{0}, \ket{1}\); basis. Note that these projection operators are simply the projectors determined by; the eigenstates of the sigmaz operator.; Z0, Z1 = ket2dm(basis(2, 0)), ket2dm(basis(2, 1)). The probabilities and respective output state; are calculated for each projection operator.; measure(up, [Z0, Z1]) == (0, up). measure(down, [Z0, Z1]) == (1, down). In this case, the projection operators are conveniently eigenstates corresponding; to subspaces of dimension \(1\). However, this might not be; the case, in which case it is not possible to have unique eigenvalues for each; eigenstate. Suppose we want to measure only the first; qubit in a two-qubit system. Consider the two qubit state \(\ket{0+}\); state_0 = basis(2, 0). state_plus = (basis(2, 0) + basis(2, 1)).unit(). state_0plus = tensor(state_0, state_plus). Now, suppose we want to measure only the first qubit in the computational basis.; We can do that by measuring with the projection operators; \(\ket{0}\bra{0} \otimes I\) and \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:7057,Usability,learn,learned,7057," \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we woul",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-measurement.html:7120,Usability,learn,learned,7120," \(\ket{1}\bra{1} \otimes I\).; PZ1 = [tensor(Z0, identity(2)), tensor(Z1, identity(2))]. PZ2 = [tensor(identity(2), Z0), tensor(identity(2), Z1)]. Now, as in the previous example, we can measure by supplying a list of projection operators; and the state.; measure(state_0plus, PZ1) == (0, state_0plus). The output of the measurement is the index of the measurement outcome as well; as the output state on the full Hilbert space of the input state. It is crucial to; note that we do not discard the measured qubit after measurement (as opposed to; when measuring on quantum hardware). Note; When measure is invoked with the second argument; being a list of projectors, it acts as an alias to; measure_povm. The measure function can perform measurements on; density matrices too. You can read about these and other details at; measure_povm and measure_observable.; Now you know how to measure quantum states in QuTiP!. Obtaining measurement statistics(Observable)¶; You’ve just learned how to perform measurements in QuTiP, but you’ve also; learned that measurements are probabilistic. What if instead of just making; a single measurement, we want to determine the probability distribution of; a large number of measurements?; One way would be to repeat the measurement many times – and this is what; happens in many quantum experiments. In QuTiP one could simulate this using:; results = {1.0: 0, -1.0: 0} # 1 and -1 are the possible outcomes; for _ in range(1000):; value, new_state = measure(up, spin_x); results[round(value)] += 1; print(results). Output:; {1.0: 497, -1.0: 503}. which measures the x-component of the spin of the up state 1000 times and; stores the results in a dictionary. Afterwards we expect to have seen the; result 1.0 (i.e. left) roughly 500 times and the result -1.0 (i.e. right); roughly 500 times, but, of course, the number of each will vary slightly; each time we run it.; But what if we want to know the distribution of results precisely? In a; physical system, we woul",MatchSource.WIKI,docs/4.7/guide/guide-measurement.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-measurement.html
https://qutip.org/docs/4.7/guide/guide-overview.html:1752,Availability,avail,available,1752,"ide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:105,Deployability,Install,Installation,105,"﻿. Guide Overview — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP devel",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:2033,Deployability,update,updated,2033,"ide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:1834,Security,access,accessible,1834,"ide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:762,Testability,Log,Log,762,"﻿. Guide Overview — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP devel",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:3,Usability,Guid,Guide,3,"﻿. Guide Overview — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP devel",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:125,Usability,Guid,Guide,125,"﻿. Guide Overview — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP devel",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:132,Usability,Guid,Guide,132,"﻿. Guide Overview — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP devel",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:888,Usability,Guid,Guide,888,"﻿. Guide Overview — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP devel",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:897,Usability,Guid,Guide,897,"﻿. Guide Overview — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP devel",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:913,Usability,Guid,Guide,913,"﻿. Guide Overview — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP devel",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:947,Usability,guid,guide,947,"﻿. Guide Overview — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP devel",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:1036,Usability,guid,guide,1036,"; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sph",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-overview.html:1248,Usability,guid,guide,1248,"ide Overview; Organization. Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Guide Overview. Guide Overview¶; The goal of this guide is to introduce you to the basic structures and functions that make up QuTiP. This guide is divided up into several; sections, each highlighting a specific set of functionalities. In combination with the examples that can be found on the project; web page https://qutip.org/tutorials.html, this guide should provide a more or less complete overview; of QuTip. We also provide the API documentation in API documentation. Organization¶; QuTiP is designed to be a general framework for solving quantum mechanics problems such as systems composed of few-level quantum systems and harmonic oscillators. To this end, QuTiP is built from a large (and ever growing) library of functions and classes; from qutip.states.basis to qutip.wigner. The general organization of QuTiP, highlighting the important API available to the user, is shown in the figure below. Tree-diagram of the 468 user accessible functions and classes in QuTiP 4.6. A vector image of the code tree is in qutip_tree.pdf.¶. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-overview.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-overview.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:110,Deployability,Install,Installation,110,". Parallel computation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> ",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:6111,Deployability,configurat,configurations,6111,"keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPython’s powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:6626,Deployability,update,updated,6626,"keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPython’s powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:6403,Energy Efficiency,power,powerful,6403,"keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPython’s powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:1606,Modifiability,variab,variables,1606,"uTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; >>> result = parfor(func1, range(5)). >>> print(result); [ar",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:1655,Modifiability,variab,variables,1655,"uTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; >>> result = parfor(func1, range(5)). >>> print(result); [ar",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:6111,Modifiability,config,configurations,6111,"keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:00:13; 60.0%. Run time: 15.15s. Est. time left: 00:00:00:10; 70.0%. Run time: 18.15s. Est. time left: 00:00:00:07; 80.0%. Run time: 20.15s. Est. time left: 00:00:00:05; 90.0%. Run time: 23.15s. Est. time left: 00:00:00:02; 100.0%. Run time: 25.15s. Est. time left: 00:00:00:00; Total run time: 28.91s. Parallel processing is useful for repeated tasks such as generating plots corresponding to the dynamical evolution of your system, or simultaneously simulating different parameter configurations. IPython-based parallel_map¶; When QuTiP is used with IPython interpreter, there is an alternative parallel for-loop implementation in the QuTiP module qutip.ipynbtools, see qutip.ipynbtools.parallel_map. The advantage of this parallel_map implementation is based on IPython’s powerful framework for parallelization, so the compute processes are not confined to run on the same host as the main process. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:1340,Performance,perform,performing,1340,"amics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.pa",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:1418,Performance,perform,performed,1418,"; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:4682,Performance,perform,performance,4682,"ere the qutip.parallel.parallel_map and qutip.parallel.parfor functions behaves differently:; While qutip.parallel.parallel_map only iterate over the values arguments, the qutip.parallel.parfor function simultaneously iterates over all arguments:; >>> def sum_diff(x, y, z=0): return x + y, x - y, z. >>> parfor(sum_diff, [1, 2, 3], [4, 5, 6], z=5.0); [array([5, 7, 9]), array([-3, -3, -3]), array([5., 5., 5.])]. >>> parallel_map(sum_diff, [1, 2, 3], task_args=(np.array([4, 5, 6]),), task_kwargs=dict(z=5.0)); [(array([5, 6, 7]), array([-3, -4, -5]), 5.0),; (array([6, 7, 8]), array([-2, -3, -4]), 5.0),; (array([7, 8, 9]), array([-1, -2, -3]), 5.0)]. Note that the keyword arguments can be anything you like, but the keyword values are not iterated over. The keyword argument num_cpus is reserved as it sets the number of CPU’s used by parfor. By default, this value is set to the total number of physical processors on your system. You can change this number to a lower value, however setting it higher than the number of CPU’s will cause a drop in performance. In qutip.parallel.parallel_map, keyword arguments to the task function are specified using task_kwargs argument, so there is no special reserved keyword arguments.; The qutip.parallel.parallel_map function also supports progressbar, using the keyword argument progress_bar which can be set to True or to an instance of qutip.ui.progressbar.BaseProgressBar. There is a function called qutip.parallel.serial_map that works as a non-parallel drop-in replacement for qutip.parallel.parallel_map, which allows easy switching between serial and parallel computation.; >>> import time. >>> def func(x): time.sleep(1). >>> result = parallel_map(func, range(50), progress_bar=True). 10.0%. Run time: 3.10s. Est. time left: 00:00:00:27; 20.0%. Run time: 5.11s. Est. time left: 00:00:00:20; 30.0%. Run time: 8.11s. Est. time left: 00:00:00:18; 40.0%. Run time: 10.15s. Est. time left: 00:00:00:15; 50.0%. Run time: 13.15s. Est. time left: 00:00:",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:2461,Safety,avoid,avoid,2461,"el.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> print(result_array[:, 0]) # == a; [0 1 2 3 4 5 6 7 8 9]. >>> print(result_array[:, 1]) # == b; [ 0 1 4 9 16 25 36 49 64 81]. >>> print(result_array[:, 2]) # == c; [ 0 1 8 27 64 125 216 343 512 729]. Note that the return values are arranged differently for the qutip.parallel.parallel_map and the qutip.parallel.parfor functions, as illustrated below. In particular, the return value of qutip.parallel.parallel_map is not enforced to be NumPy arrays, which can avoid unnecessary copying if all that is needed is to iterate over the resulting list:; >>> result = parfor(func1, range(5)). >>> print(result); [array([0, 1, 2, 3, 4]), array([ 0, 1, 4, 9, 16]), array([ 0, 1, 8, 27, 64])]. >>> result = parallel_map(func1, range(5)). >>> print(result); [(0, 0, 0), (1, 1, 1), (2, 4, 8), (3, 9, 27), (4, 16, 64)]. The qutip.parallel.parallel_map and qutip.parallel.parfor functions are not limited to just numbers, but also works for a variety of outputs:; >>> def func2(x): return x, Qobj(x), 'a' * x. >>> a, b, c = parfor(func2, range(5)). >>> print(a); [0 1 2 3 4]. >>> print(b); [Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[0.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[1.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[2.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[3.]]; Quantum object: dims = [[1], [1]], shape = (1, 1), type = bra; Qobj data =; [[4.",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:817,Testability,Log,Log,817,". Parallel computation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> ",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:130,Usability,Guid,Guide,130,". Parallel computation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> ",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:137,Usability,Guid,Guide,137,". Parallel computation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> ",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-parfor.html:943,Usability,Guid,Guide,943,". Parallel computation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Parallel computation. Parallel computation¶. Parallel map and parallel for-loop¶; Often one is interested in the output of a given function as a single-parameter is varied. For instance, we can calculate the steady-state response of our system as the driving frequency is varied. In cases such as this, where each iteration is independent of the others, we can speedup the calculation by performing the iterations in parallel. In QuTiP, parallel computations may be performed using the qutip.parallel.parallel_map function or the qutip.parallel.parfor (parallel-for-loop) function.; To use the these functions we need to define a function of one or more variables, and the range over which one of these variables are to be evaluated. For example:; >>> def func1(x): return x, x**2, x**3. >>> a, b, c = parfor(func1, range(10)). >>> print(a); [0 1 2 3 4 5 6 7 8 9]. >>> print(b); [ 0 1 4 9 16 25 36 49 64 81]. >>> print(c); [ 0 1 8 27 64 125 216 343 512 729]. or; >>> result = parallel_map(func1, range(10)). >>> result_array = np.array(result). >>> ",MatchSource.WIKI,docs/4.7/guide/guide-parfor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-parfor.html
https://qutip.org/docs/4.7/guide/guide-qip.html:120,Deployability,Install,Installation,120,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-qip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-qip.html
https://qutip.org/docs/4.7/guide/guide-qip.html:1626,Deployability,update,updated,1626,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-qip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-qip.html
https://qutip.org/docs/4.7/guide/guide-qip.html:1445,Energy Efficiency,schedul,scheduler,1445,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-qip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-qip.html
https://qutip.org/docs/4.7/guide/guide-qip.html:862,Testability,Log,Log,862,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-qip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-qip.html
https://qutip.org/docs/4.7/guide/guide-qip.html:140,Usability,Guid,Guide,140,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-qip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-qip.html
https://qutip.org/docs/4.7/guide/guide-qip.html:147,Usability,Guid,Guide,147,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-qip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-qip.html
https://qutip.org/docs/4.7/guide/guide-qip.html:988,Usability,Guid,Guide,988,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing. Quantum Information Processing¶. Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-qip.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-qip.html
https://qutip.org/docs/4.7/guide/guide-random.html:2753,Availability,down,down,2753,"6 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.61607187j -0.15243356-0.65392096j -0.52603038+0.07991553j; -0.34240902+0.2879303j 0. +0.j ]]. Random Variable Type; Sampling Functions; Dimensions. State vector (ket); rand_ket, rand_ket_haar; \(N \times 1\). Hermitian operator (oper); rand_herm; \(N \times 1\). Density operator (oper); rand_dm, rand_dm_hs, rand_dm_ginibre; \(N \times N\). Unitary operator (oper); rand_unitary, rand_unitary_haar; \(N \times N\). CPTP channel (super); rand_super, rand_super_bcsz; \((N \times N) \times (N \times N)\). In all cases, these functions can be called with a single parameter \(N\) that specifies the dimension of the relevant Hilbert space. The optional; dims keyword argument allows for the dimensions of a random state, unitary or channel to be broken down into subsystems.; >>> rand_super_bcsz(7).dims; [[[7], [7]], [[7], [7]]]; >>> rand_super_bcsz(6, dims=[[[2, 3], [2, 3]], [[2, 3], [2, 3]]]).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. Several of the distributions supported by QuTiP support additional parameters as well, namely density and rank. In particular,; the rand_herm and rand_dm functions return quantum objects such that a fraction of the elements are identically equal to zero.; The ratio of nonzero elements is passed as the density keyword argument. By contrast, the rand_dm_ginibre and; rand_super_bcsz take as an argument the rank of the generated object, such that passing rank=1 returns a random; pure state or unitary channel, respectively. Passing rank=None specifies that the generated object should be; full-rank for the given dimension.; For example,; >>> rand_dm(5, density=0.5); Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[ 0.",MatchSource.WIKI,docs/4.7/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-random.html
https://qutip.org/docs/4.7/guide/guide-random.html:134,Deployability,Install,Installation,134,". Generating Random Quantum States & Operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Generating Random Quantum States & Operators. Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; >>> rand_herm(5) ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.",MatchSource.WIKI,docs/4.7/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-random.html
https://qutip.org/docs/4.7/guide/guide-random.html:7617,Deployability,update,updated,7617,"ata =; [[ 2.51387054-5.55111512e-17j 0.81161447+2.02283642e-01j; 0. +0.00000000e+00j 0.875 +3.35634092e-01j; 0.81161447+2.02283642e-01j]; [ 0.81161447-2.02283642e-01j 1.375 +0.00000000e+00j; 0. +0.00000000e+00j -0.76700198+5.53011066e-01j; 0.375 +0.00000000e+00j]; [ 0. +0.00000000e+00j 0. +0.00000000e+00j; 2. +0.00000000e+00j 0. +0.00000000e+00j; 0. +0.00000000e+00j]; [ 0.875 -3.35634092e-01j -0.76700198-5.53011066e-01j; 0. +0.00000000e+00j 2.73612946+0.00000000e+00j; -0.76700198-5.53011066e-01j]; [ 0.81161447-2.02283642e-01j 0.375 +0.00000000e+00j; 0. +0.00000000e+00j -0.76700198+5.53011066e-01j; 1.375 +0.00000000e+00j]]. >>> H.eigenenergies() ; array([7.70647994e-17, 1.00000000e+00, 2.00000000e+00, 3.00000000e+00,; 4.00000000e+00]). In order to generate a random object with a given spectrum QuTiP applies a series of random complex Jacobi rotations. This technique requires many steps to build the desired quantum object, and is thus suitable only for objects with Hilbert dimensionality \(\lesssim 1000\). Composite random objects¶; In many cases, one is interested in generating random quantum objects that correspond to composite systems generated using the qutip.tensor.tensor function. Specifying the tensor structure of a quantum object is done using the dims keyword argument in the same fashion as one would do for a qutip.Qobj object:; >>> rand_dm(4, 0.5, dims=[[2,2], [2,2]]) ; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 0.13622928+0.j 0. +0.j 0.01180807-0.01739166j; 0. +0.j ]; [ 0. +0.j 0.14600238+0.j 0.10335328+0.21790786j; -0.00426027-0.02193627j]; [ 0.01180807+0.01739166j 0.10335328-0.21790786j 0.57566072+0.j; -0.0670631 +0.04124094j]; [ 0. +0.j -0.00426027+0.02193627j -0.0670631 -0.04124094j; 0.14210761+0.j ]]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-random.html
https://qutip.org/docs/4.7/guide/guide-random.html:2102,Modifiability,Variab,Variable,2102,"nitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; >>> rand_herm(5) ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.61607187j -0.15243356-0.65392096j -0.52603038+0.07991553j; -0.34240902+0.2879303j 0. +0.j ]]. Random Variable Type; Sampling Functions; Dimensions. State vector (ket); rand_ket, rand_ket_haar; \(N \times 1\). Hermitian operator (oper); rand_herm; \(N \times 1\). Density operator (oper); rand_dm, rand_dm_hs, rand_dm_ginibre; \(N \times N\). Unitary operator (oper); rand_unitary, rand_unitary_haar; \(N \times N\). CPTP channel (super); rand_super, rand_super_bcsz; \((N \times N) \times (N \times N)\). In all cases, these functions can be called with a single parameter \(N\) that specifies the dimension of the relevant Hilbert space. The optional; dims keyword argument allows for the dimensions of a random state, unitary or channel to be broken down into subsystems.; >>> rand_super_bcsz(7).dims; [[[7], [7]], [[7], [7]]]; >>> rand_super_bcsz(6, dims=[[[2, 3], [2, 3]], [[2, 3], [2, 3]]]).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. Several of the distributions supported by QuTiP support additional parameters as well, namely density and rank. In particular,; the rand_herm and rand_dm functions return quantum o",MatchSource.WIKI,docs/4.7/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-random.html
https://qutip.org/docs/4.7/guide/guide-random.html:847,Testability,Log,Log,847,". Generating Random Quantum States & Operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Generating Random Quantum States & Operators. Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; >>> rand_herm(5) ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.",MatchSource.WIKI,docs/4.7/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-random.html
https://qutip.org/docs/4.7/guide/guide-random.html:1221,Testability,test,testing,1221,"tter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Generating Random Quantum States & Operators. Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; >>> rand_herm(5) ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.61607187j -0.15243356-0.65392096j -0.52603038+0.07991553j; -0.34240902+0.2879303j 0. +0.j ]]. Random Variable Type; Sampling Fu",MatchSource.WIKI,docs/4.7/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-random.html
https://qutip.org/docs/4.7/guide/guide-random.html:154,Usability,Guid,Guide,154,". Generating Random Quantum States & Operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Generating Random Quantum States & Operators. Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; >>> rand_herm(5) ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.",MatchSource.WIKI,docs/4.7/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-random.html
https://qutip.org/docs/4.7/guide/guide-random.html:161,Usability,Guid,Guide,161,". Generating Random Quantum States & Operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Generating Random Quantum States & Operators. Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; >>> rand_herm(5) ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.",MatchSource.WIKI,docs/4.7/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-random.html
https://qutip.org/docs/4.7/guide/guide-random.html:973,Usability,Guid,Guide,973,". Generating Random Quantum States & Operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Generating Random Quantum States & Operators. Generating Random Quantum States & Operators¶; QuTiP includes a collection of random state, unitary and channel generators for simulations, Monte Carlo evaluation, theorem evaluation, and code testing.; Each of these objects can be sampled from one of several different distributions including the default distributions; used by QuTiP versions prior to 3.2.0.; For example, a random Hermitian operator can be sampled by calling rand_herm function:; >>> rand_herm(5) ; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[-0.25091976+0.j 0. +0.j 0. +0.j; -0.21793701+0.47037633j -0.23212846-0.61607187j]; [ 0. +0.j -0.88383278+0.j 0.836086 -0.23956218j; -0.09464275+0.45370863j -0.15243356+0.65392096j]; [ 0. +0.j 0.836086 +0.23956218j 0.66488528+0.j; -0.26290446+0.64984451j -0.52603038-0.07991553j]; [-0.21793701-0.47037633j -0.09464275-0.45370863j -0.26290446-0.64984451j; -0.13610996+0.j -0.34240902-0.2879303j ]; [-0.23212846+0.",MatchSource.WIKI,docs/4.7/guide/guide-random.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-random.html
https://qutip.org/docs/4.7/guide/guide-saving.html:124,Deployability,Install,Installation,124,". Saving QuTiP Objects and Data Sets — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parame",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:8451,Deployability,update,updated,8451,"505+0.0000000000j,1.5687324121+0.0000000000j,0.1351622725+0.0000000000j,0.2018398581+0.0000000000j; 6.0606060606+0.0000000000j,1.4348632045+0.0000000000j,0.2143080535+0.0000000000j,-0.0067820038+0.0000000000j; 7.0707070707+0.0000000000j,1.3321818015+0.0000000000j,0.0950352763+0.0000000000j,-0.1630920429+0.0000000000j; 8.0808080808+0.0000000000j,1.2533244850+0.0000000000j,-0.0771210981+0.0000000000j,-0.1468923919+0.0000000000j. In this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=""real"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real""); >>> with open(""expect.dat"", ""r"") as f:; ... print('\n'.join(f.readlines()[:5])); # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.2109553666,0.3689771549,0.0185002867; 1.0101010101,2.6754598872,0.1298251132,-0.3303672956; 2.0202020202,2.2743186810,-0.2106241300,-0.2623894277; 3.0303030303,1.9726633457,-0.3037311621,0.0397330921. and if we prefer scientific notation we can request that using the numformat=""exp"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; input_data = file_data_read('expect.dat'); plt.plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=""_"" if _ is the deliminator). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:599,Performance,load,loading,599,". Saving QuTiP Objects and Data Sets — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parame",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:634,Performance,load,loading,634,". Saving QuTiP Objects and Data Sets — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parame",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:1527,Performance,perform,performed,1527,"iP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steady",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:1701,Performance,load,loading,1701,"antum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:1738,Performance,load,load,1738,"antum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:2161,Performance,load,loads,2161,"ocessed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:2687,Performance,load,loaded,2687," qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:2777,Performance,Load,Loaded,2777," qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:3115,Performance,load,load,3115,"tip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:3486,Performance,load,loaded,3486,"adystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and thre",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:3596,Performance,Load,Loaded,3596,"adystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and thre",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:3932,Performance,load,loading,3932,"ect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="","") . where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:4316,Performance,load,load,4316,"10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991233]). Storing and loading datasets¶; The qutip.fileio.qsave and qutip.fileio.qload are great, but the file format used is only understood by QuTiP (python) programs. When data must be exported to other programs the preferred method is to store the data in the commonly used plain-text file formats. With the QuTiP functions qutip.fileio.file_data_store and qutip.fileio.file_data_read we can store and load numpy arrays and matrices to files on disk using a deliminator-separated value format (for example comma-separated values CSV). Almost any program can handle this file format.; The qutip.fileio.file_data_store takes two mandatory and three optional arguments:; >>> file_data_store(filename, data, numtype=""complex"", numformat=""decimal"", sep="","") . where filename is the name of the file, data is the data to be written to the file (must be a numpy array), numtype (optional) is a flag indicating numerical type that can take values complex or real, numformat (optional) specifies the numerical format that can take the values exp for the format 1.0e1 and decimal for the format 10.0, and sep (optional) is an arbitrary single-character field separator (usually a tab, space, comma, semicolon, etc.).; A common use for the qutip.fileio.file_data_store function is to store the expectation values of a set of operators for a sequence of times, e.g., as returned by the qutip.mesolve function, which is what the following example does; >>> a = dest",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:7733,Performance,Load,Loading,7733,"505+0.0000000000j,1.5687324121+0.0000000000j,0.1351622725+0.0000000000j,0.2018398581+0.0000000000j; 6.0606060606+0.0000000000j,1.4348632045+0.0000000000j,0.2143080535+0.0000000000j,-0.0067820038+0.0000000000j; 7.0707070707+0.0000000000j,1.3321818015+0.0000000000j,0.0950352763+0.0000000000j,-0.1630920429+0.0000000000j; 8.0808080808+0.0000000000j,1.2533244850+0.0000000000j,-0.0771210981+0.0000000000j,-0.1468923919+0.0000000000j. In this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=""real"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real""); >>> with open(""expect.dat"", ""r"") as f:; ... print('\n'.join(f.readlines()[:5])); # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.2109553666,0.3689771549,0.0185002867; 1.0101010101,2.6754598872,0.1298251132,-0.3303672956; 2.0202020202,2.2743186810,-0.2106241300,-0.2623894277; 3.0303030303,1.9726633457,-0.3037311621,0.0397330921. and if we prefer scientific notation we can request that using the numformat=""exp"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; input_data = file_data_read('expect.dat'); plt.plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=""_"" if _ is the deliminator). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:7988,Performance,load,loaded,7988,"505+0.0000000000j,1.5687324121+0.0000000000j,0.1351622725+0.0000000000j,0.2018398581+0.0000000000j; 6.0606060606+0.0000000000j,1.4348632045+0.0000000000j,0.2143080535+0.0000000000j,-0.0067820038+0.0000000000j; 7.0707070707+0.0000000000j,1.3321818015+0.0000000000j,0.0950352763+0.0000000000j,-0.1630920429+0.0000000000j; 8.0808080808+0.0000000000j,1.2533244850+0.0000000000j,-0.0771210981+0.0000000000j,-0.1468923919+0.0000000000j. In this case we didn’t really need to store both the real and imaginary parts, so instead we could use the numtype=""real"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real""); >>> with open(""expect.dat"", ""r"") as f:; ... print('\n'.join(f.readlines()[:5])); # Generated by QuTiP: 100x4 real matrix in decimal format [',' separated values].; 0.0000000000,3.2109553666,0.3689771549,0.0185002867; 1.0101010101,2.6754598872,0.1298251132,-0.3303672956; 2.0202020202,2.2743186810,-0.2106241300,-0.2623894277; 3.0303030303,1.9726633457,-0.3037311621,0.0397330921. and if we prefer scientific notation we can request that using the numformat=""exp"" option; >>> file_data_store('expect.dat', output_data.T, numtype=""real"", numformat=""exp""). Loading data previously stored using qutip.fileio.file_data_store (or some other software) is a even easier. Regardless of which deliminator was used, if data was stored as complex or real numbers, if it is in decimal or exponential form, the data can be loaded using the qutip.fileio.file_data_read, which only takes the filename as mandatory argument.; input_data = file_data_read('expect.dat'); plt.plot(input_data[:,0], input_data[:,1]); # plot the data. (If a particularly obscure choice of deliminator was used it might be necessary to use the optional second argument, for example sep=""_"" if _ is the deliminator). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:832,Testability,Log,Log,832,". Saving QuTiP Objects and Data Sets — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parame",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:2909,Testability,test,testing,2909,"e takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> psi0 = rand_ket(10); >>> times = np.linspace(0, 10, 10); >>> dm_list = mesolve(H, psi0, times, c_ops, []); >>> qsave(dm_list, 'density_matrix_vs_time'). And it can then be loaded and used again, for example in an other program; >>> dm_list_loaded = qload('density_matrix_vs_time'); Loaded Result object:; Result object with mesolve data.; --------------------------------; states = True; num_collapse = 0; >>> a = destroy(10); >>> expect(a.dag() * a, dm_list_loaded.states) ; array([4.63317086, 3.59150315, 2.90590183, 2.41306641, 2.05120716,; 1.78312503, 1.58357995, 1.4346382 , 1.32327398, 1.23991",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:144,Usability,Guid,Guide,144,". Saving QuTiP Objects and Data Sets — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parame",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:151,Usability,Guid,Guide,151,". Saving QuTiP Objects and Data Sets — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parame",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:958,Usability,Guid,Guide,958,". Saving QuTiP Objects and Data Sets — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Saving QuTiP Objects and Data Sets. Saving QuTiP Objects and Data Sets¶; With time-consuming calculations it is often necessary to store the results to files on disk, so it can be post-processed and archived. In QuTiP there are two facilities for storing data: Quantum objects can be stored to files and later read back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parame",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-saving.html:2263,Usability,simpl,simple,2263,"ad back as python pickles, and numerical data (vectors and matrices) can be exported as plain text files in for example CSV (comma-separated values), TSV (tab-separated values), etc. The former method is preferred when further calculations will be performed with the data, and the latter when the calculations are completed and data is to be imported into a post-processing tool (e.g. for generating figures). Storing and loading QuTiP objects¶; To store and load arbitrary QuTiP related objects (qutip.Qobj, qutip.solver.Result, etc.) there are two functions: qutip.fileio.qsave and qutip.fileio.qload. The function qutip.fileio.qsave takes an arbitrary object as first parameter and an optional filename as second parameter (default filename is qutip_data.qu). The filename extension is always .qu. The function qutip.fileio.qload takes a mandatory filename as first argument and loads and returns the objects in the file.; To illustrate how these functions can be used, consider a simple calculation of the steadystate of the harmonic oscillator; >>> a = destroy(10); H = a.dag() * a; >>> c_ops = [np.sqrt(0.5) * a, np.sqrt(0.25) * a.dag()]; >>> rho_ss = steadystate(H, c_ops). The steadystate density matrix rho_ss is an instance of qutip.Qobj. It can be stored to a file steadystate.qu using; >>> qsave(rho_ss, 'steadystate'); >>> !ls *.qu; density_matrix_vs_time.qu steadystate.qu. and it can later be loaded again, and used in further calculations; >>> rho_ss_loaded = qload('steadystate'); Loaded Qobj object:; Quantum object: dims = [[10], [10]], shape = (10, 10), type = oper, isHerm = True; >>> a = destroy(10); >>> np.testing.assert_almost_equal(expect(a.dag() * a, rho_ss_loaded), 0.9902248289345061). The nice thing about the qutip.fileio.qsave and qutip.fileio.qload functions is that almost any object can be stored and load again later on. We can for example store a list of density matrices as returned by qutip.mesolve; >>> a = destroy(10); H = a.dag() * a ; c_ops = [np.sqrt(0.5) *",MatchSource.WIKI,docs/4.7/guide/guide-saving.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-saving.html
https://qutip.org/docs/4.7/guide/guide-settings.html:1433,Availability,Toler,Tolerance,1433,"rol; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persis",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:1494,Availability,toler,tolerance,1494,"tum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a ",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:1936,Availability,toler,tolerance,1936,"umentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possi",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:123,Deployability,Install,Installation,123,". Modifying Internal QuTiP Settings — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite sim",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:3398,Deployability,update,updated,3398,"ance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:3142,Integrability,depend,dependent,3142,"ance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:2604,Performance,load,loaded,2604,"ance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:672,Security,Access,Accessible,672,". Modifying Internal QuTiP Settings — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite sim",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:1054,Security,Access,Accessible,1054,"7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session o",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:843,Testability,Log,Log,843,". Modifying Internal QuTiP Settings — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite sim",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:143,Usability,Guid,Guide,143,". Modifying Internal QuTiP Settings — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite sim",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:150,Usability,Guid,Guide,150,". Modifying Internal QuTiP Settings — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite sim",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:969,Usability,Guid,Guide,969,". Modifying Internal QuTiP Settings — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Modifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite sim",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:1998,Usability,simpl,simple,1998,"ifying Internal QuTiP Settings. Modifying Internal QuTiP Settings¶. User Accessible Parameters¶; In this section we show how to modify a few of the internal parameters used by QuTiP. The settings that can be modified are given in the following table:. Setting; Description; Options. auto_herm; Automatically calculate the hermicity of; quantum objects.; True / False. auto_tidyup; Automatically tidyup quantum objects.; True / False. auto_tidyup_atol; Tolerance used by tidyup; any float value > 0. atol; General tolerance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openm",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-settings.html:2776,Usability,simpl,simple,2776,"ance; any float value > 0. num_cpus; Number of CPU’s used for multiprocessing.; int between 1 and # cpu’s. debug; Show debug printouts.; True / False. openmp_thresh; NNZ matrix must have for OPENMP.; Int. Example: Changing Settings¶; The two most important settings are auto_tidyup and auto_tidyup_atol as they control whether the small elements of a quantum object should be removed, and what number should be considered as the cut-off tolerance. Modifying these, or any other parameters, is quite simple:; >>> qutip.settings.auto_tidyup = False. These settings will be used for the current QuTiP session only and will need to be modified again when restarting QuTiP. If running QuTiP from a script file, then place the qutip.settings.xxxx commands immediately after from qutip import * at the top of the script file. If you want to reset the parameters back to their default values then call the reset command:; >>> qutip.settings.reset(). Persistent Settings¶; When QuTiP is imported, it looks for a file named qutiprc in a folder called .qutip user’s home directory. If this file is found, it will be loaded and overwrite the QuTiP default settings, which allows for persistent changes in the QuTiP settings to be made. A sample qutiprc file is show below. The syntax is a simple key-value format, where the keys and possible values are described in the table above:; [qutip]; auto_tidyup=True; auto_herm=True; auto_tidyup_atol=1e-12; num_cpus=4; debug=False. Note that the openmp_thresh value is automatically generatd by QuTiP. It is also possible to set a specific compiler for QuTiP to use when generating runtime Cython code for time-dependent problems. For example, the following section in the qutiprc file will set the compiler to be clang-3.9:; [compiler]; cc = clang-3.9; cxx = clang-3.9. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-settings.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-settings.html
https://qutip.org/docs/4.7/guide/guide-states.html:13711,Availability,down,downarrow,13711,". Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [0.]]. Now we see the difference! The qutip.operators.sigmap operator acting on the spin state returns the zero vector. Why is this? To see what happened, let us use the qutip.operators.sigmaz operator:; print(sigmaz()). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[ 1. 0.]; [ 0. -1.]]. print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. spin2 = basis(2, 1). print(spin2). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. print(sigmaz() * spin2). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[ 0.]; [-1.]]. The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) sta",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:14404,Availability,down,downarrow,14404," The answer is now apparent. Since the QuTiP qutip.operators.sigmaz function uses the standard z-basis representation of the sigma-z spin operator, the spin state corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:14670,Availability,down,downarrow,14670,"corresponds to the \(\left|\uparrow\right>\) state of a two-level spin system while spin2 gives the \(\left|\downarrow\right>\) state. Therefore, in our previous example sigmap() * spin, we raised the qubit state out of the truncated two-level Hilbert space resulting in the zero state.; While at first glance this convention might seem somewhat odd, it is in fact quite handy. For one, the spin operators remain in the conventional form. Second, when the spin system is in the \(\left|\uparrow\right>\) state:; print(sigmaz() * spin). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:16512,Availability,down,down,16512,", 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:16637,Availability,down,down,16637,"ity matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:124,Deployability,Install,Installation,124,"﻿. Manipulating States and Operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:33206,Deployability,update,updated,33206,"ensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the dims and superrep attributes to reflect the; structure of the underlying Hilbert space and the chosen representation.; J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). Output:; False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, \(\Lambda(\rho) = (\Lambda(\rho))^\dagger\) for all \(\rho\) such that; \(\rho = \rho^\dagger\). To see this, we note that \((\rho^{\mathrm{T}})^\dagger; = \rho^*\), the complex conjugate of \(\rho\). By assumption, \(\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}\), though, such that \(\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*\).; We can confirm this by checking the ishp attribute:; print(J.ishp). Output:; True. Next, we note that the transpose map does preserve the trace of its inputs, such that; \(\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)\) for all \(\rho\).; This can be confirmed by the istp attribute:; print(J.istp). Output:; False. Finally, a map is called a quantum channel if it always maps valid states to valid; states. Formally, a map is a channel if it is both completely positive and trace preserving.; Thus, QuTiP provides a single attribute to quickly check that this is true.; >>> print(J.iscptp); False. >>> print(to_super(qeye(2)).iscptp); True. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:11538,Energy Efficiency,energy,energy,11538,"9080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a harmonic oscillator, then, as we have already seen, we can use the raising operator to get the \(\left|1\right>\) state:; print(vac). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]]. c = create(2). print(c * vac). Output:; Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.]; [1.]]. For a spin system, the operator analogous to the raising operator is the sigma-plus operator qutip.operators.sigmap. Operating on the spin state gives:; print(",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:3831,Integrability,depend,dependence,3831," =; [[0.]; [1.]; [0.]; [0.]; [0.]]. The raising operator has in indeed raised the state vec from the vacuum to the \(\left| 1\right>\) state. Instead of using the dagger Qobj.dag() method to raise the state, we could have also used the built in qutip.operators.create function to make a raising operator:; c = create(5). print(c * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. which does the same thing. We can raise the vacuum state more than once by successively apply the raising operator:; print(c * c * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. or just taking the square of the raising operator \(\left(\hat{a}^\dagger\right)^{2}\):; print(c ** 2 * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [1.41421356]; [0. ]; [0. ]]. Applying the raising operator twice gives the expected \(\sqrt{n + 1}\) dependence. We can use the product of \(c * a\) to also apply the number operator to the state vector vac:; print(c * a * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [0.]; [0.]; [0.]; [0.]]. or on the \(\left| 1\right>\) state:; print(c * a * (c * vac)). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0.]; [1.]; [0.]; [0.]; [0.]]. or the \(\left| 2\right>\) state:; print(c * a * (c**2 * vac)). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[0. ]; [0. ]; [2.82842712]; [0. ]; [0. ]]. Notice how in this last example, application of the number operator does not give the expected value \(n=2\), but rather \(2\sqrt{2}\). This is because this last state is not normalized to unity as \(c\left| n\right> = \sqrt{n+1}\left| n+1\right>\). Therefore, we should normalize our vector first:; print(c * a * (c**2 * vac).unit()). Output:; Quant",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:19737,Modifiability,extend,extended,19737,"pace can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by type='super':; print(S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; print(S.iscp, S.istp, S.iscptp). Output:; True True True. In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \rangle\!\rangle\). Because; the Pauli basis is Hermitian, \(S_{\mu,\nu}\) is a real number for all Hermitian-preserving superoperators; \(S\),; allowing us to plot the elements of \(S\) as a Hinton diagr",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:1415,Performance,perform,performing,1415,"\(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; a = destroy(5). print(a). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; print(a * vac). Output:; Quantum object: dims = [[5]",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:30545,Performance,perform,perform,30545,"+0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). Output:; (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space \(\mathcal{H}\). As with the superoperator; and Choi representations, the \(\chi\) representation is; denoted by the superrep, such that to_super,; to_choi, to_kraus,; to_stinespring and to_chi; all convert from the \(\chi\) representation appropriately. Properties of Quantum Maps¶; In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses superrep to automatically perform any needed conversions.; In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map \(\Lambda(\rho) = \rho^{\mathrm{T}}\) is a positive map. We run into; problems, however, if we tensor \(\Lambda\) with the identity to get a partial; transpose map.; rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). Output:; [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:19581,Security,expose,exposed,19581," Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by type='super':; print(S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; print(S.iscp, S.istp, S.iscptp). Output:; True True True. In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j 1. +0.j]; [ 0. +0.j -0.5+20.j 0. +0.j 0. +0.j]; [ 0. +0.j 0. +0.j -0.5-20.j 0. +0.j]; [ 0. +0.j 0. +0.j 0. +0.j -1. +0.j]]. For qubits, a particularly useful way to visualize superoperators is to plot them in the Pauli basis,; such that \(S_{\mu,\nu} = \langle\!\langle \sigma_{\mu} | S[\sigma_{\nu}] \",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:1000,Testability,Log,Log,1000,"and Operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using th",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:10383,Testability,test,testing,10383,"29292109 0.19402805 0.16684347]; [0.23509686 0.29292109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. print(thermal_dm(5, 1.25)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:;",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:10434,Testability,test,testing,10434,"2109 0.26343512 0.17449684 0.1500487 ]; [0.15572585 0.19402805 0.17449684 0.11558499 0.09939079]; [0.13390765 0.16684347 0.1500487 0.09939079 0.0854655 ]]. print(thermal_dm(5, 1.25)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0.46927974 0. 0. 0. 0. ]; [0. 0.26071096 0. 0. 0. ]; [0. 0. 0.14483942 0. 0. ]; [0. 0. 0. 0.08046635 0. ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:10823,Testability,test,testing,10823,". ]; [0. 0. 0. 0. 0.04470353]]. QuTiP also provides a set of distance metrics for determining how close two density matrix distributions are to each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.si",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:10988,Testability,assert,assert,10988,"o each other. Included are the trace distance qutip.metrics.tracedist, fidelity qutip.metrics.fidelity, Hilbert-Schmidt distance qutip.metrics.hilbert_dist, Bures distance qutip.metrics.bures_dist, Bures angle qutip.metrics.bures_angle, and quantum Hellinger distance qutip.metrics.hellinger_dist.; x = coherent_dm(5, 1.25). y = coherent_dm(5, np.complex(0, 1.25)) # <-- note the 'j'. z = thermal_dm(5, 0.125). np.testing.assert_almost_equal(fidelity(x, x), 1). np.testing.assert_almost_equal(hellinger_dist(x, y), 1.3819080728932833). We also know that for two pure states, the trace distance (T) and the fidelity (F) are related by \(T = \sqrt{1 - F^{2}}\), while the quantum Hellinger distance (QHE) between two pure states \(\left|\psi\right>\) and \(\left|\phi\right>\) is given by \(QHE = \sqrt{2 - 2\left|\left<\psi | \phi\right>\right|^2}\).; np.testing.assert_almost_equal(tracedist(y, x), np.sqrt(1 - fidelity(y, x) ** 2)). For a pure state and a mixed state, \(1 - F^{2} \le T\) which can also be verified:; assert 1 - fidelity(x, z) ** 2 < tracedist(x, z). Qubit (two-level) systems¶; Having spent a fair amount of time on basis states that represent harmonic oscillator states, we now move on to qubit, or two-level quantum systems (for example a spin-1/2). To create a state vector corresponding to a qubit system, we use the same qutip.states.basis, or qutip.states.fock, function with only two levels:; spin = basis(2, 0). Now at this point one may ask how this state is different than that of a harmonic oscillator in the vacuum state truncated to two energy levels?; vac = basis(2, 0). At this stage, there is no difference. This should not be surprising as we called the exact same function twice. The difference between the two comes from the action of the spin operators qutip.operators.sigmax, qutip.operators.sigmay, qutip.operators.sigmaz, qutip.operators.sigmap, and qutip.operators.sigmam on these two-level states. For example, if vac corresponds to the vacuum state of a ha",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:15232,Testability,test,testing,15232," the non-zero component is the zeroth-element of the underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:15283,Testability,test,testing,15283,"e underlying matrix (remember that python uses c-indexing, and matrices start with the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect functio",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:15362,Testability,test,testing,15362,"ith the zeroth element). The \(\left|\downarrow\right>\) state therefore has a non-zero entry in the first index position. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the i",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:15479,Testability,test,testing,15479,"tion. This corresponds nicely with the quantum information definitions of qubit states, where the excited \(\left|\uparrow\right>\) state is label as \(\left|0\right>\), and the \(\left|\downarrow\right>\) state by \(\left|1\right>\).; If one wants to create spin operators for higher spin systems, then the qutip.operators.jmat function comes in handy. Expectation values¶; Some of the most important information about quantum systems comes from calculating the expectation value of operators, both Hermitian and non-Hermitian, as the state or density matrix of the system varies in time. Therefore, in this section we demonstrate the use of the qutip.expect function. To begin:; vac = basis(5, 0). one = basis(5, 1). c = create(5). N = num(5). np.testing.assert_almost_equal(expect(N, vac), 0). np.testing.assert_almost_equal(expect(N, one), 1). coh = coherent_dm(5, 1.0j). np.testing.assert_almost_equal(expect(N, coh), 0.9970555745806597). cat = (basis(5, 4) + 1.0j * basis(5, 3)).unit(). np.testing.assert_almost_equal(expect(c, cat), 0.9999999999999998j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and o",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:16535,Testability,test,testing,16535,"98j). The qutip.expect function also accepts lists or arrays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuT",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:16592,Testability,test,testing,16592,"ays of state vectors or density matrices for the second input:; states = [(c**k * vac).unit() for k in range(5)] # must normalize. print(expect(N, states)). Output:; [0. 1. 2. 3. 4.]. cat_list = [(basis(5, 4) + x * basis(5, 3)).unit() for x in [0, 1.0j, -1.0, -1.0j]]. print(expect(c, cat_list)). Output:; [ 0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator fun",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:16900,Testability,test,testing,16900,"0.+0.j 0.+1.j -1.+0.j 0.-1.j]. Notice how in this last example, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). rho = ket2dm(psi). print(rho). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. vec_rho = operator_to_vector(rho). print(vec_rho). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = ope",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:16959,Testability,test,testing,16959,"ple, all of the return values are complex numbers. This is because the qutip.expect function looks to see whether the operator is Hermitian or not. If the operator is Hermitian, then the output will always be real. In the case of non-Hermitian operators, the return values may be complex. Therefore, the qutip.expect function will return an array of complex values for non-Hermitian operators when the input is a list/array of states or density matrices.; Of course, the qutip.expect function works for spin states and operators:; up = basis(2, 0). down = basis(2, 1). np.testing.assert_almost_equal(expect(sigmaz(), up), 1). np.testing.assert_almost_equal(expect(sigmaz(), down), -1). as well as the composite objects discussed in the next section Using Tensor Products and Partial Traces:; spin1 = basis(2, 0). spin2 = basis(2, 1). two_spins = tensor(spin1, spin2). sz1 = tensor(sigmaz(), qeye(2)). sz2 = tensor(qeye(2), sigmaz()). np.testing.assert_almost_equal(expect(sz1, two_spins), 1). np.testing.assert_almost_equal(expect(sz2, two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). rho = ket2dm(psi). print(rho). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. vec_rho = operator_to_vector(rho). print(vec_rho). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. rho2 = ve",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:17993,Testability,test,testing,17993,", two_spins), -1). Superoperators and Vectorized Operators¶; In addition to state vectors and density operators, QuTiP allows for; representing maps that act linearly on density operators using the Kraus,; Liouville supermatrix and Choi matrix formalisms. This support is based on the; correspondence between linear operators acting on a Hilbert space, and vectors; in two copies of that Hilbert space,; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\); [Hav03], [Wat13].; This isomorphism is implemented in QuTiP by the; operator_to_vector and; vector_to_operator functions:; psi = basis(2, 0). rho = ket2dm(psi). print(rho). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. vec_rho = operator_to_vector(rho). print(vec_rho). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. rho2 = vector_to_operator(vec_rho). np.testing.assert_almost_equal((rho - rho2).norm(), 0). The type attribute indicates whether a quantum object is; a vector corresponding to an operator (operator-ket), or its Hermitian; conjugate (operator-bra).; Note that QuTiP uses the column-stacking convention for the isomorphism; between \(\mathcal{L}(\mathcal{H})\) and \(\mathcal{H} \otimes \mathcal{H}\):; A = Qobj(np.arange(4).reshape((2, 2))). print(A). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. print(operator_to_vector(A)). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:19175,Testability,test,testing,19175,"jugate (operator-bra).; Note that QuTiP uses the column-stacking convention for the isomorphism; between \(\mathcal{L}(\mathcal{H})\) and \(\mathcal{H} \otimes \mathcal{H}\):; A = Qobj(np.arange(4).reshape((2, 2))). print(A). Output:; Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = False; Qobj data =; [[0. 1.]; [2. 3.]]. print(operator_to_vector(A)). Output:; Quantum object: dims = [[[2], [2]], [1]], shape = (4, 1), type = operator-ket; Qobj data =; [[0.]; [2.]; [1.]; [3.]]. Since \(\mathcal{H} \otimes \mathcal{H}\) is a vector space, linear maps; on this space can be represented as matrices, often called superoperators.; Using the Qobj, the spre and spost functions, supermatrices; corresponding to left- and right-multiplication respectively can be quickly; constructed.; X = sigmax(). S = spre(X) * spost(X.dag()) # Represents conjugation by X. Note that this is done automatically by the to_super function when given; type='oper' input.; S2 = to_super(X). np.testing.assert_almost_equal((S - S2).norm(), 0). Quantum objects representing superoperators are denoted by type='super':; print(S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. Information about superoperators, such as whether they represent completely; positive maps, is exposed through the iscp, istp; and iscptp attributes:; print(S.iscp, S.istp, S.iscptp). Output:; True True True. In addition, dynamical generators on this extended space, often called; Liouvillian superoperators, can be created using the liouvillian function. Each of these takes a Hamiltonian along with; a list of collapse operators, and returns a type=""super"" object that can; be exponentiated to find the superoperator for that evolution.; H = 10 * sigmaz(). c1 = destroy(2). L = liouvillian(H, [c1]). print(L). S = (12 * L).expm(). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], sh",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:29788,Testability,test,testing,29788,").eigenenergies()). Output:; [0. 0.04861218 0.1 1.85138782]. Finally, the last superoperator representation supported by QuTiP is; the \(\chi\)-matrix representation,. \[\Lambda(\rho) = \sum_{\alpha,\beta} \chi_{\alpha,\beta} B_{\alpha} \rho B_{\beta}^\dagger,\]; where \(\{B_\alpha\}\) is a basis for the space of matrices acting; on \(\mathcal{H}\). In QuTiP, this basis is taken to be the Pauli; basis \(B_\alpha = \sigma_\alpha / \sqrt{2}\). Conversion to the; \(\chi\) formalism is handled by the to_chi; function.; chi = to_chi(S); print(chi). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = chi; Qobj data =; [[3.7+0.j 0. +0.j 0. +0.j 0.1+0.j ]; [0. +0.j 0.1+0.j 0. +0.1j 0. +0.j ]; [0. +0.j 0. -0.1j 0.1+0.j 0. +0.j ]; [0.1+0.j 0. +0.j 0. +0.j 0.1+0.j ]]. One convenient property of the \(\chi\) matrix is that the average; gate fidelity with the identity map can be read off directly from; the \(\chi_{00}\) element:; np.testing.assert_almost_equal(average_gate_fidelity(S), 0.9499999999999998). print(chi[0, 0] / 4). Output:; (0.925+0j). Here, the factor of 4 comes from the dimension of the underlying; Hilbert space \(\mathcal{H}\). As with the superoperator; and Choi representations, the \(\chi\) representation is; denoted by the superrep, such that to_super,; to_choi, to_kraus,; to_stinespring and to_chi; all convert from the \(\chi\) representation appropriately. Properties of Quantum Maps¶; In addition to converting between the different representations of quantum maps,; QuTiP also provides attributes to make it easy to check if a map is completely; positive, trace preserving and/or hermicity preserving. Each of these attributes; uses superrep to automatically perform any needed conversions.; In particular, a quantum map is said to be positive (but not necessarily completely; positive) if it maps all positive operators to positive operators. For instance, the; transpose map \(\Lambda(\rho) = \rho^{\math",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:144,Usability,Guid,Guide,144,"﻿. Manipulating States and Operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:151,Usability,Guid,Guide,151,"﻿. Manipulating States and Operators — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 ",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:1126,Usability,Guid,Guide,1126,"s Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; a = destroy(5). print(a). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:1237,Usability,guid,guide,1237,"sity matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; a = destroy(5). print(a). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0.",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:1392,Usability,guid,guide,1392,"\(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Manipulating States and Operators. Manipulating States and Operators¶. Introduction¶; In the previous guide section Basic Operations on Quantum Objects, we saw how to create states and operators, using the functions built into QuTiP. In this portion of the guide, we will look at performing basic operations with states and operators. For more detailed demonstrations on how to use and manipulate these objects, see the examples on the tutorials web page. State Vectors (kets or bras)¶; Here we begin by creating a Fock qutip.states.basis vacuum state vector \(\left|0\right>\) with in a Hilbert space with 5 number states, from 0 to 4:; vac = basis(5, 0). print(vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]; [0.]]. and then create a lowering operator \(\left(\hat{a}\right)\) corresponding to 5 number states using the qutip.operators.destroy function:; a = destroy(5). print(a). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = False; Qobj data =; [[0. 1. 0. 0. 0. ]; [0. 0. 1.41421356 0. 0. ]; [0. 0. 0. 1.73205081 0. ]; [0. 0. 0. 0. 2. ]; [0. 0. 0. 0. 0. ]]. Now lets apply the destruction operator to our vacuum state vac,; print(a * vac). Output:; Quantum object: dims = [[5]",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:7565,Usability,simpl,simplest,7565,"rint(d * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.60655682+0.j ]; [ 0. +0.60628133j]; [-0.4303874 +0.j ]; [ 0. -0.24104351j]; [ 0.14552147+0.j ]]. print(d * s * vac). Output:; Quantum object: dims = [[5], [1]], shape = (5, 1), type = ket; Qobj data =; [[ 0.65893786+0.08139381j]; [ 0.10779462+0.51579735j]; [-0.37567217-0.01326853j]; [-0.02688063-0.23828775j]; [ 0.26352814+0.11512178j]]. Of course, displacing the vacuum gives a coherent state, which can also be generated using the built in qutip.states.coherent function. Density matrices¶; One of the main purpose of QuTiP is to explore the dynamics of open quantum systems, where the most general state of a system is no longer a state vector, but rather a density matrix. Since operations on density matrices operate identically to those of vectors, we will just briefly highlight creating and using these structures.; The simplest density matrix is created by forming the outer-product \(\left|\psi\right>\left<\psi\right|\) of a ket vector:; ket = basis(5, 2). print(ket * ket.dag()). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. A similar task can also be accomplished via the qutip.states.fock_dm or qutip.states.ket2dm functions:; print(fock_dm(5, 2)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. print(ket2dm(ket)). Output:; Quantum object: dims = [[5], [5]], shape = (5, 5), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 1. 0. 0.]; [0. 0. 0. 0. 0.]; [0. 0. 0. 0. 0.]]. If we want to create a density matrix with equal classical probability of being found in the \(\left|2\right>\) or \(\left|4\right>\) number states we can do the following:; prin",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:22983,Usability,simpl,simply,22983,"\otimes \Lambda) [|\mathbb{1}\rangle\!\rangle \langle\!\langle \mathbb{1}|].\]; In QuTiP, \(J(\Lambda)\) can be found by calling the to_choi; function on a type=""super"" Qobj.; X = sigmax(). S = sprepost(X, X). J = to_choi(S). print(J). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. print(to_choi(spre(qeye(2)))). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[1. 0. 0. 1.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [1. 0. 0. 1.]]. If a Qobj instance is already in the Choi superrep, then calling to_choi; does nothing:; print(to_choi(J)). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True, superrep = choi; Qobj data =; [[0. 0. 0. 0.]; [0. 1. 1. 0.]; [0. 1. 1. 0.]; [0. 0. 0. 0.]]. To get back to the superoperator representation, simply use the to_super function.; As with to_choi, to_super is idempotent:; print(to_super(J) - S). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]; [0. 0. 0. 0.]]. print(to_super(S)). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. We can quickly obtain another useful representation from the Choi matrix by taking its eigendecomposition.; In particular, let \(\{A_i\}\) be a set of operators such that; \(J(\Lambda) = \sum_i |A_i\rangle\!\rangle \langle\!\langle A_i|\).; We can write \(J(\Lambda)\) in this way; for any hermicity-preserving map; that is, for any map \(\Lambda\) such that \(J(\Lambda) = J^\dagger(\Lambda)\).; These operators then form the Kraus representation of \(\Lambda\). In particular, for any input \(\rho\),. \[\Lambda(\",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-states.html:31681,Usability,simpl,simply,31681,"spose map \(\Lambda(\rho) = \rho^{\mathrm{T}}\) is a positive map. We run into; problems, however, if we tensor \(\Lambda\) with the identity to get a partial; transpose map.; rho = ket2dm(bell_state()); rho_out = partial_transpose(rho, [0, 1]); print(rho_out.eigenenergies()). Output:; [-0.5 0.5 0.5 0.5]. Notice that even though we started with a positive map, we got an operator out; with negative eigenvalues. Complete positivity addresses this by requiring that; a map returns positive operators for all positive operators, and does so even; under tensoring with another map. The Choi matrix is very useful here, as it; can be shown that a map is completely positive if and only if its Choi matrix; is positive [Wat13]. QuTiP implements this check with the iscp; attribute. As an example, notice that the snippet above already calculates; the Choi matrix of the transpose map by acting it on half of an entangled; pair. We simply need to manually set the dims and superrep attributes to reflect the; structure of the underlying Hilbert space and the chosen representation.; J = rho_out; J.dims = [[[2], [2]], [[2], [2]]]; J.superrep = 'choi'; print(J.iscp). Output:; False. This confirms that the transpose map is not completely positive. On the other hand,; the transpose map does satisfy a weaker condition, namely that it is hermicity preserving.; That is, \(\Lambda(\rho) = (\Lambda(\rho))^\dagger\) for all \(\rho\) such that; \(\rho = \rho^\dagger\). To see this, we note that \((\rho^{\mathrm{T}})^\dagger; = \rho^*\), the complex conjugate of \(\rho\). By assumption, \(\rho = \rho^\dagger; = (\rho^*)^{\mathrm{T}}\), though, such that \(\Lambda(\rho) = \Lambda(\rho^\dagger) = \rho^*\).; We can confirm this by checking the ishp attribute:; print(J.ishp). Output:; True. Next, we note that the transpose map does preserve the trace of its inputs, such that; \(\operatorname{Tr}(\Lambda[\rho]) = \operatorname{Tr}(\rho)\) for all \(\rho\).; This can be confirmed by the istp attribute:; p",MatchSource.WIKI,docs/4.7/guide/guide-states.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-states.html
https://qutip.org/docs/4.7/guide/guide-steady.html:5572,Availability,down,downside,5572,"n be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to have a good condition number. QuTiP can make use of an incomplete LU preconditioner when using the iterative 'gmres', 'lgmres', and 'bicgstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the precond",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:6919,Availability,error,error,6919,"ate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the ability to find a good preconditioner is not guaranteed. And moreover, if a preconditioner is found, it is not guaranteed to have a good condition number. QuTiP can make use of an incomplete LU preconditioner when using the iterative 'gmres', 'lgmres', and 'bicgstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:7515,Availability,avail,available,7515,"gstab' solvers by setting use_precond=True. The preconditioner optionally makes use of a combination of symmetric and anti-symmetric matrix permutations that attempt to improve the preconditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted ",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:8730,Availability,Toler,Tolerance,8730," False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a therm",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:124,Deployability,Install,Installation,124,". Solving for Steady-State Solutions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Solving for Steady-State Solutions. Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady ",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:11773,Deployability,update,updated,11773,"nd weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = qutip.steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = qutip.expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = qutip.mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = qutip.mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); plt.axhline(y=fexpt, color='r', lw=1.5); plt.ylim([0, 10]); plt.xlabel('Time', fontsize=14); plt.ylabel('Number of excitations', fontsize=14); plt.legend(('Monte-Carlo', 'Master Equation', 'Steady State')); plt.title(; r'Decay of Fock state $\left|10\rangle\right.$'; r' in a thermal environment with $\langle n\rangle=2$'; ); plt.show(). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:2542,Energy Efficiency,Power,Power,2542,"-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:2550,Energy Efficiency,power,power,2550,"-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:2582,Energy Efficiency,power,power,2582,"-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:3423,Energy Efficiency,power,power,3423,"teratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel Python distributions. This gives a substantial increase in performance compared with the standard SuperLU method used by SciPy. To verify that QuTiP can find the necessary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory nee",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:4688,Energy Efficiency,reduce,reduced,4688,"essary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these it",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:4990,Energy Efficiency,power,power,4990,"m with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditi",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:5027,Energy Efficiency,power,power,5027,"g the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the othe",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:5074,Energy Efficiency,power,power,5074,"g the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the othe",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:5212,Energy Efficiency,power,power,5212,"e solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the other solution methods. The problem with precondioning is that it is only well defined for Hermitian matrices. Since the Liouvillian is non-Hermitian, the",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:7637,Energy Efficiency,power,power,7637,"econditioning process. These features are discussed in the Additional Solver Arguments section. Even with these state-of-the-art permutations, the generation of a successful preconditoner for non-symmetric matrices is currently a trial-and-error process due to the lack of mathematical work done in this area. It is always recommended to begin with the direct solver with no additional arguments before selecting a different method.; Finding the steady-state solution is not limited to the Lindblad form of the master equation. Any time-independent Liouvillian constructed from a Hamiltonian and collapse operators can be used as an input:; >>> rho_ss = steadystate(L). where L is the Louvillian. All of the additional arguments can also be used in this case. Additional Solver Arguments¶; The following additional solver arguments are available for the steady-state solver:. Keyword; Options (default listed first); Description. method; ‘direct’, ‘eigen’, ‘power’, ‘iterative-gmres’,’iterative-lgmres’, ‘svd’; Method used for solving for the steady-state density matrix. sparse; True, False; Use sparse version of direct solver. weight; None; Allows the user to define the weighting factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a i",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:5148,Integrability,rout,routine,5148,"g the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) generated in the LU factors. This fill-in can be reduced by using bandwidth minimization algorithms such as those discussed in Additional Solver Arguments. However, in most cases, the default fill-in reducing algorithm is nearly optimal. Additional parameters may be used by calling the steady-state solver as:; rho_ss = steadystate(H, c_ops, method='power', use_rcm=True). where method='power' indicates that we are using the inverse-power solution method, and use_rcm=True turns on a bandwidth minimization routine.; Although it is not obvious, the 'direct', eigen, and 'power' methods all use an LU decomposition internally and thus suffer from a large memory overhead. In contrast, iterative methods such as the 'iterative-gmres', 'iterative-lgmres', and 'iterative-bicgstab' methods do not factor the matrix and thus take less memory than these previous methods and allowing, in principle, for extremely large system sizes. The downside is that these methods can take much longer than the direct method as the condition number of the Liouvillian matrix is large, indicating that these iterative methods require a large number of iterations for convergence. To overcome this, one can use a preconditioner \(M\) that solves for an approximate inverse for the (modified) Liouvillian, thus better conditioning the problem, leading to faster convergence. The use of a preconditioner can actually make these iterative methods faster than the othe",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:10489,Modifiability,coupling,coupling,10489," decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = qutip.steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = qutip.expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = qutip.mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = qutip.mesolve(H, psi0, tlist, c_op_list, [a.dag() * a]). plt.plot(tlist, mcdata.expect[0], tlist, medata.expect[0], lw=2); # plot steady-state expt. value as horizontal line (should be = 2); plt.axhline(y=fexpt, color='r', lw=1.5); plt.ylim([0, 10]); plt.xlabel('Time', fontsize=14); plt.ylabel('Number of excitations', fontsize=14); plt.legend(('Monte",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:3624,Performance,perform,performance,3624,"MRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution via the dense SVD of the Liouvillian. The function qutip.steadystate.steadystate can take either a Hamiltonian and a list of collapse operators as input, generating internally the corresponding Liouvillian super operator in Lindblad form, or alternatively, a Liouvillian passed by the user. When possible, we recommend passing the Hamiltonian and collapse operators to qutip.steadystate.steadystate, and letting the function automatically build the Liouvillian (in Lindblad form) for the system.; As of QuTiP 3.2, the direct and power methods can take advantage of the Intel Pardiso LU solver in the Intel Math Kernel library that comes with the Anacoda (2.5+) and Intel Python distributions. This gives a substantial increase in performance compared with the standard SuperLU method used by SciPy. To verify that QuTiP can find the necessary libraries, one can check for INTEL MKL Ext: True in the QuTiP about box (qutip.about). Using the Steadystate Solver¶; Solving for the steady state solution to the Lindblad master equation for a general system with qutip.steadystate.steadystate can be accomplished using:; >>> rho_ss = steadystate(H, c_ops). where H is a quantum object representing the system Hamiltonian, and c_ops is a list of quantum objects for the system collapse operators. The output, labeled as rho_ss, is the steady-state solution for the systems. If no other keywords are passed to the solver, the default ‘direct’ method is used, generating a solution that is exact to machine precision at the expense of a large memory requirement. The large amount of memory need for the direct LU decomposition method stems from the large bandwidth of the system Liouvillian and the correspondingly large fill-in (extra nonzero elements) ",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:8860,Performance,perform,perform,8860,"ng factor used in the 'direct', 'GMRES', and 'LGMRES' solvers. permc_spec; ‘COLAMD’, ‘NATURAL’; Column ordering used in the sparse LU decomposition. use_rcm; False, True; Use a Reverse Cuthill-Mckee reordering to minimize the bandwidth of the modified Liouvillian used in the LU decomposition. If use_rcm=True then the column ordering is set to 'Natural' automatically unless explicitly set. use_precond; False, True; Attempt to generate a preconditioner when using the 'iterative-gmres' and 'iterative-lgmres' methods. M; None, sparse_matrix, LinearOperator; A user defined preconditioner, if any. use_wbm; False, True; Use a Weighted Bipartite Matching algorithm to attempt to make the modified Liouvillian more diagonally dominate, and thus for favorable for preconditioning. Set to True automatically when using a iterative method, unless explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) nu",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:10144,Performance,perform,perform,10144,"er number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay operators; rate = kappa * n_th_a; if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a.dag()) # excitation operators. # find steady-state solution; final_state = qutip.steadystate(H, c_op_list); # find expectation value for particle number in steady state; fexpt = qutip.expect(a.dag() * a, final_state). tlist = np.linspace(0, 50, 100); # monte-carlo; mcdata = qutip.mcsolve(H, psi0, tlist, c_op_list, [a.dag() * a], ntraj=100); # master eq.; medata = qutip.mesolve(H, psi0, tlist, c_op_list, [a.d",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:917,Testability,Log,Log,917,". Solving for Steady-State Solutions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Solving for Steady-State Solutions. Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady ",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:144,Usability,Guid,Guide,144,". Solving for Steady-State Solutions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Solving for Steady-State Solutions. Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady ",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:151,Usability,Guid,Guide,151,". Solving for Steady-State Solutions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Solving for Steady-State Solutions. Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady ",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:1043,Usability,Guid,Guide,1043,"on. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Solving for Steady-State Solutions. Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solutio",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:1838,Usability,simpl,simple,1838," documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Solving for Steady-State Solutions. Solving for Steady-State Solutions¶. Introduction¶; For time-independent open quantum systems with decay rates larger than the corresponding excitation rates, the system will tend toward a steady state as \(t\rightarrow\infty\) that satisfies the equation. \[\frac{d\hat{\rho}_{ss}}{dt}=\mathcal{L}\hat{\rho}_{ss}=0.\]; Although the requirement for time-independence seems quite resitrictive, one can often employ a transformation to the interaction picture that yields a time-independent Hamiltonian. For many these systems, solving for the asymptotic density matrix \(\hat{\rho}_{ss}\) can be achieved using direct or iterative solution methods faster than using master equation or Monte Carlo simulations. Although the steady state equation has a simple mathematical form, the properties of the Liouvillian operator are such that the solutions to this equation are anything but straightforward to find. Steady State solvers in QuTiP¶; In QuTiP, the steady-state solution for a system Hamiltonian or Liouvillian is given by qutip.steadystate.steadystate. This function implements a number of different methods for finding the steady state, each with their own pros and cons, where the method used can be chosen using the method keyword argument. Method; Keyword; Description. Direct (default); ‘direct’; Direct solution solving \(Ax=b\) via sparse LU decomposition. Eigenvalue; ‘eigen’; Iteratively find the zero eigenvalue of \(\mathcal{L}\). Inverse-Power; ‘power’; Solve using the inverse-power method. GMRES; ‘iterative-gmres’; Solve using the GMRES method and optional preconditioner. LGMRES; ‘iterative-lgmres’; Solve using the LGMRES method and optional preconditioner. BICGSTAB; ‘iterative-bicgstab’; Solve using the BICGSTAB method and optional preconditioner. SVD; ‘svd’; Steady-state solution v",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-steady.html:9667,Usability,simpl,simple,9667,"less explicitly set. tol; 1e-9; Tolerance used in finding the solution for all methods expect 'direct' and 'svd'. maxiter; 10000; Maximum number of iterations to perform for all methods expect 'direct' and 'svd'. fill_factor; 10; Upper-bound on the allowed fill-in for the approximate inverse preconditioner. This value may need to be set much higher than this in some cases. drop_tol; 1e-3; Sets the threshold for the relative magnitude of preconditioner elements that should be dropped. A lower number yields a more accurate approximate inverse at the expense of fill-in and increased runtime. diag_pivot_thresh; None; Sets the threshold between \([0,1]\) for which diagonal elements are considered acceptable pivot points when using a preconditioner. ILU_MILU; ‘smilu_2’; Selects the incomplete LU decomposition method algorithm used. Further information can be found in the qutip.steadystate.steadystate docstrings. Example: Harmonic Oscillator in Thermal Bath¶; A simple example of a system that reaches a steady state is a harmonic oscillator coupled to a thermal environment. Below we consider a harmonic oscillator, initially in the \(\left|10\right>\) number state, and weakly coupled to a thermal environment characterized by an average particle expectation value of \(\left<n\right>=2\). We calculate the evolution via master equation and Monte Carlo methods, and see that they converge to the steady-state solution. Here we choose to perform only a few Monte Carlo trajectories so we can distinguish this evolution from the master-equation solution.; import numpy as np; import matplotlib.pyplot as plt. import qutip. # Define paramters; N = 20 # number of basis states to consider; a = qutip.destroy(N); H = a.dag() * a; psi0 = qutip.basis(N, 10) # initial state; kappa = 0.1 # coupling to oscillator. # collapse operators; c_op_list = []; n_th_a = 2 # temperature with average of 2 excitations; rate = kappa * (1 + n_th_a); if rate > 0.0:; c_op_list.append(np.sqrt(rate) * a) # decay ope",MatchSource.WIKI,docs/4.7/guide/guide-steady.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-steady.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:3179,Availability,down,down,3179,"qubits in their ground states is formed by taking the tensor product of the two single-qubit ground state vectors:; print(tensor(basis(2, 0), basis(2, 0))). Output:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the list format:; print(tensor([basis(2, 0), basis(2, 0)])). Output:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). Output:; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; print(tensor(sigmax(), sigmax())). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:130,Deployability,Install,Installation,130,". Using Tensor Products and Partial Traces — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Two coupled qubits; Three coupled qubits; A two-level system coupled to a cavity: The Jaynes-Cummings model. Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Using Tensor Products and Partial Traces. Using Tensor Products and Partial Traces¶. Tensor products¶; To describe the states of multipartite quantum systems - such as two coupled qubits, a qubit coupled to an oscillator, etc. - we need to expand the Hilbert space by taking the tensor product of the state vectors for each of the system components. Similarly, the operators acting on the state vectors in the combined Hilbert space (describing the coupled system) are formed by taking the tensor product of the individual operators.; In QuTiP the function qutip.tensor.tensor is used to accomplish this task. This function takes as argument a collection:; >>> tensor(op1, op2, op3) . or a list:; >>> tensor([op1, op2, op3]) . of state vectors or operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary num",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:13118,Deployability,update,updated,13118,"[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.tensor.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.tensor.composite function automatically switches between; qutip.tensor and qutip.tensor.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; contracting one or more pairs of indices. As detailed in; the channel contraction tutorial, this can be used to find; superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from \(3 \times 3\) operators to \(2 \times 2\); operators:; >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:4659,Energy Efficiency,energy,energy,4659," [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:4813,Energy Efficiency,energy,energy,4813,"n a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:6217,Energy Efficiency,energy,energy,6217,"ntity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cummings Hamiltonian can be constructed as:; N = 10. omega_a = 1.0. omega_c = 1.25. g = 0.05. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). print(H). Output:; Quantum object: dims = [[2, 10], [2, 10]], shape = (20, 20), type = oper, isherm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 1.75 0. 0. 0. 0.; 0. 0. 0. 0. 0.05 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 3. 0. 0. 0.; 0. 0. 0. 0. 0. 0.07071068; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 4.25 0. 0.; 0. 0. 0. 0. 0. 0.; 0.08660254 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 5.5 0.; 0. 0. 0. 0. 0. 0.; 0. 0.1 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 6.75; 0. 0. 0. 0. 0. 0.; 0. 0. 0.1118034 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 8. 0. 0. 0. 0. 0.; 0. 0. 0. 0.12247449 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 9",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:8373,Energy Efficiency,reduce,reduces,8373,"0. 0. 0. 0. 0. 0.14142136; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0. 11.75 0. 0.; 0. 0. 0. 0. 0. 0.; 0.15 0. ]; [ 0. 0.05 0. 0. 0. 0.; 0. 0. 0. 0. -0.5 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0.07071068 0. 0. 0.; 0. 0. 0. 0. 0. 0.75; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0.08660254 0. 0.; 0. 0. 0. 0. 0. 0.; 2. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0.1 0.; 0. 0. 0. 0. 0. 0.; 0. 3.25 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.1118034; 0. 0. 0. 0. 0. 0.; 0. 0. 4.5 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0.12247449 0. 0. 0. 0. 0.; 0. 0. 0. 5.75 0. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0.13228757 0. 0. 0. 0.; 0. 0. 0. 0. 7. 0.; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0.14142136 0. 0. 0.; 0. 0. 0. 0. 0. 8.25; 0. 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0.15 0. 0.; 0. 0. 0. 0. 0. 0.; 9.5 0. ]; [ 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 10.75 ]]. Here N is the number of Fock states included in the cavity mode. Partial trace¶; The partial trace is an operation that reduces the dimension of a Hilbert space by eliminating some degrees of freedom by averaging (tracing). In this sense it is therefore the converse of the tensor product. It is useful when one is interested in only a part of a coupled quantum system. For open quantum systems, this typically involves tracing over the environment leaving only the system of interest. In QuTiP the class method qutip.Qobj.ptrace is used to take partial traces. qutip.Qobj.ptrace acts on the qutip.Qobj instance for which it is called, and it takes one argument sel, which is a list of integers that mark the component systems that should be kept. All other components are traced out.; For example, the density matrix describing a single qubit obtained from a coupled two-qubit system is obtained via:; >>> psi = tensor(basis(2, 0), basis(2, 1)). >>> psi.ptrace(0); Quantum object: dims = [[2], [2]], shape = (2, 2), type = oper, isherm = True; Qobj data =; [[1. 0.]; [0. 0.]]. >>> psi.ptrace(1); Quantum object: dims = [[2], [2]], shape = (2, ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:12605,Integrability,contract,contracting,12605,"[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.tensor.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.tensor.composite function automatically switches between; qutip.tensor and qutip.tensor.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; contracting one or more pairs of indices. As detailed in; the channel contraction tutorial, this can be used to find; superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from \(3 \times 3\) operators to \(2 \times 2\); operators:; >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:12675,Integrability,contract,contraction,12675,"[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.tensor.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.tensor.composite function automatically switches between; qutip.tensor and qutip.tensor.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; contracting one or more pairs of indices. As detailed in; the channel contraction tutorial, this can be used to find; superoperators that represent partial trace maps.; Using this functionality, we can construct some quite exotic maps,; such as a map from \(3 \times 3\) operators to \(2 \times 2\); operators:; >>> tensor_contract(composite(to_super(A), to_super(B)), (1, 3), (4, 6)).dims; [[[2], [2]], [[3], [3]]]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:3277,Modifiability,extend,extended,3277,"ut:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. or equivalently using the list format:; print(tensor([basis(2, 0), basis(2, 0)])). Output:; Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[1.]; [0.]; [0.]; [0.]]. This is straightforward to generalize to more qubits by adding more component state vectors in the argument list to the qutip.tensor.tensor function, as illustrated in the following example:; print(tensor((basis(2, 0) + basis(2, 1)).unit(), (basis(2, 0) + basis(2, 1)).unit(), basis(2, 0))). Output:; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]; [0.5]; [0. ]]. This state is slightly more complicated, describing two qubits in a superposition between the up and down states, while the third qubit is in its ground state.; To construct operators that act on an extended Hilbert space of a combined system, we similarly pass a list of operators for each component system to the qutip.tensor.tensor function. For example, to form the operator that represents the simultaneous action of the \(\sigma_x\) operator on two qubits:; print(tensor(sigmax(), sigmax())). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:6113,Modifiability,coupling,coupling,6113,"hape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cummings Hamiltonian can be constructed as:; N = 10. omega_a = 1.0. omega_c = 1.25. g = 0.05. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). print(H). Output:; Quantum object: dims = [[2, 10], [2, 10]], shape = (20, 20), type = oper, isherm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 1.75 0. 0. 0. 0.; 0. 0. 0. 0. 0.05 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 3. 0. 0. 0.; 0. 0. 0. 0. 0. 0.07071068; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 4.25 0. 0.; 0. 0. 0. 0. 0. 0.; 0.08660254 0. 0. 0. 0. 0.; 0. 0. ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:11577,Performance,perform,performs,11577,"eroperators can be represented; using the isomorphism; \(\mathrm{vec} : \mathcal{L}(\mathcal{H}) \to \mathcal{H} \otimes \mathcal{H}\) [Hav03], [Wat13].; To represent superoperators acting on \(\mathcal{L}(\mathcal{H}_1 \otimes \mathcal{H}_2)\) thus takes some tensor rearrangement to get the desired ordering; \(\mathcal{H}_1 \otimes \mathcal{H}_2 \otimes \mathcal{H}_1 \otimes \mathcal{H}_2\).; In particular, this means that qutip.tensor does not act as; one might expect on the results of qutip.superop_reps.to_super:; >>> A = qeye([2]). >>> B = qeye([3]). >>> to_super(tensor(A, B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. >>> tensor(to_super(A), to_super(B)).dims; [[[2], [2], [3], [3]], [[2], [2], [3], [3]]]. In the former case, the result correctly has four copies; of the compound index with dims [2, 3]. In the latter; case, however, each of the Hilbert space indices is listed; independently and in the wrong order.; The qutip.tensor.super_tensor function performs the needed; rearrangement, providing the most direct analog to qutip.tensor on; the underlying Hilbert space. In particular, for any two type=""oper""; Qobjs A and B, to_super(tensor(A, B)) == super_tensor(to_super(A), to_super(B)) and; operator_to_vector(tensor(A, B)) == super_tensor(operator_to_vector(A), operator_to_vector(B)). Returning to the previous example:; >>> super_tensor(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. The qutip.tensor.composite function automatically switches between; qutip.tensor and qutip.tensor.super_tensor based on the type; of its arguments, such that composite(A, B) returns an appropriate Qobj to; represent the composition of two systems.; >>> composite(A, B).dims; [[2, 3], [2, 3]]. >>> composite(to_super(A), to_super(B)).dims; [[[2, 3], [2, 3]], [[2, 3], [2, 3]]]. QuTiP also allows more general tensor manipulations that are; useful for converting between superoperator representations [WBC11].; In particular, the tensor_contract function allows for; ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:1001,Testability,Log,Log,1001,"and Partial Traces — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Two coupled qubits; Three coupled qubits; A two-level system coupled to a cavity: The Jaynes-Cummings model. Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Using Tensor Products and Partial Traces. Using Tensor Products and Partial Traces¶. Tensor products¶; To describe the states of multipartite quantum systems - such as two coupled qubits, a qubit coupled to an oscillator, etc. - we need to expand the Hilbert space by taking the tensor product of the state vectors for each of the system components. Similarly, the operators acting on the state vectors in the combined Hilbert space (describing the coupled system) are formed by taking the tensor product of the individual operators.; In QuTiP the function qutip.tensor.tensor is used to accomplish this task. This function takes as argument a collection:; >>> tensor(op1, op2, op3) . or a list:; >>> tensor([op1, op2, op3]) . of state vectors or operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary number of states or operat",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:150,Usability,Guid,Guide,150,". Using Tensor Products and Partial Traces — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Two coupled qubits; Three coupled qubits; A two-level system coupled to a cavity: The Jaynes-Cummings model. Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Using Tensor Products and Partial Traces. Using Tensor Products and Partial Traces¶. Tensor products¶; To describe the states of multipartite quantum systems - such as two coupled qubits, a qubit coupled to an oscillator, etc. - we need to expand the Hilbert space by taking the tensor product of the state vectors for each of the system components. Similarly, the operators acting on the state vectors in the combined Hilbert space (describing the coupled system) are formed by taking the tensor product of the individual operators.; In QuTiP the function qutip.tensor.tensor is used to accomplish this task. This function takes as argument a collection:; >>> tensor(op1, op2, op3) . or a list:; >>> tensor([op1, op2, op3]) . of state vectors or operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary num",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:157,Usability,Guid,Guide,157,". Using Tensor Products and Partial Traces — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Two coupled qubits; Three coupled qubits; A two-level system coupled to a cavity: The Jaynes-Cummings model. Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Using Tensor Products and Partial Traces. Using Tensor Products and Partial Traces¶. Tensor products¶; To describe the states of multipartite quantum systems - such as two coupled qubits, a qubit coupled to an oscillator, etc. - we need to expand the Hilbert space by taking the tensor product of the state vectors for each of the system components. Similarly, the operators acting on the state vectors in the combined Hilbert space (describing the coupled system) are formed by taking the tensor product of the individual operators.; In QuTiP the function qutip.tensor.tensor is used to accomplish this task. This function takes as argument a collection:; >>> tensor(op1, op2, op3) . or a list:; >>> tensor([op1, op2, op3]) . of state vectors or operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary num",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:1127,Usability,Guid,Guide,1127,"rs Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Two coupled qubits; Three coupled qubits; A two-level system coupled to a cavity: The Jaynes-Cummings model. Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Using Tensor Products and Partial Traces. Using Tensor Products and Partial Traces¶. Tensor products¶; To describe the states of multipartite quantum systems - such as two coupled qubits, a qubit coupled to an oscillator, etc. - we need to expand the Hilbert space by taking the tensor product of the state vectors for each of the system components. Similarly, the operators acting on the state vectors in the combined Hilbert space (describing the coupled system) are formed by taking the tensor product of the individual operators.; In QuTiP the function qutip.tensor.tensor is used to accomplish this task. This function takes as argument a collection:; >>> tensor(op1, op2, op3) . or a list:; >>> tensor([op1, op2, op3]) . of state vectors or operators and returns a composite quantum object for the combined Hilbert space. The function accepts an arbitrary number of states or operators as argument. The type returned quantum object is the same as that of the input(s).; For example, the state vector descr",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:4528,Usability,simpl,simple,4528,"or on two qubits:; print(tensor(sigmax(), sigmax())). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 1.]; [0. 0. 1. 0.]; [0. 1. 0. 0.]; [1. 0. 0. 0.]]. To create operators in a combined Hilbert space that only act on a single component, we take the tensor product of the operator acting on the subspace of interest, with the identity operators corresponding to the components that are to be unchanged. For example, the operator that represents \(\sigma_z\) on the first qubit in a two-qubit system, while leaving the second qubit unaffected:; print(tensor(sigmaz(), identity(2))). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 1. 0. 0. 0.]; [ 0. 1. 0. 0.]; [ 0. 0. -1. 0.]; [ 0. 0. 0. -1.]]. Example: Constructing composite Hamiltonians¶; The qutip.tensor.tensor function is extensively used when constructing Hamiltonians for composite systems. Here we’ll look at some simple examples. Two coupled qubits¶; First, let’s consider a system of two coupled qubits. Assume that both the qubits have equal energy splitting, and that the qubits are coupled through a \(\sigma_x\otimes\sigma_x\) interaction with strength g = 0.05 (in units where the bare qubit energy splitting is unity). The Hamiltonian describing this system is:; H = tensor(sigmaz(), identity(2)) + tensor(identity(2), sigmaz()) + 0.05 * tensor(sigmax(), sigmax()). print(H). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). O",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-tensor.html:5969,Usability,simpl,simplest,5969,"hape = (4, 4), type = oper, isherm = True; Qobj data =; [[ 2. 0. 0. 0.05]; [ 0. 0. 0.05 0. ]; [ 0. 0.05 0. 0. ]; [ 0.05 0. 0. -2. ]]. Three coupled qubits¶; The two-qubit example is easily generalized to three coupled qubits:; H = (tensor(sigmaz(), identity(2), identity(2)) + tensor(identity(2), sigmaz(), identity(2)) + tensor(identity(2), identity(2), sigmaz()) + 0.5 * tensor(sigmax(), sigmax(), identity(2)) + 0.25 * tensor(identity(2), sigmax(), sigmax())). print(H). Output:; Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[ 3. 0. 0. 0.25 0. 0. 0.5 0. ]; [ 0. 1. 0.25 0. 0. 0. 0. 0.5 ]; [ 0. 0.25 1. 0. 0.5 0. 0. 0. ]; [ 0.25 0. 0. -1. 0. 0.5 0. 0. ]; [ 0. 0. 0.5 0. 1. 0. 0. 0.25]; [ 0. 0. 0. 0.5 0. -1. 0.25 0. ]; [ 0.5 0. 0. 0. 0. 0.25 -1. 0. ]; [ 0. 0.5 0. 0. 0.25 0. 0. -3. ]]. A two-level system coupled to a cavity: The Jaynes-Cummings model¶; The simplest possible quantum mechanical description for light-matter interaction is encapsulated in the Jaynes-Cummings model, which describes the coupling between a two-level atom and a single-mode electromagnetic field (a cavity mode). Denoting the energy splitting of the atom and cavity omega_a and omega_c, respectively, and the atom-cavity interaction strength g, the Jaynes-Cummings Hamiltonian can be constructed as:; N = 10. omega_a = 1.0. omega_c = 1.25. g = 0.05. a = tensor(identity(2), destroy(N)). sm = tensor(destroy(2), identity(N)). sz = tensor(sigmaz(), identity(N)). H = 0.5 * omega_a * sz + omega_c * a.dag() * a + g * (a.dag() * sm + a * sm.dag()). print(H). Output:; Quantum object: dims = [[2, 10], [2, 10]], shape = (20, 20), type = oper, isherm = True; Qobj data =; [[ 0.5 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 1.75 0. 0. 0. 0.; 0. 0. 0. 0. 0.05 0.; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 3. 0. 0. 0.; 0. 0. 0. 0. 0. 0.07071068; 0. 0. 0. 0. 0. 0.; 0. 0. ]; [ 0. 0. 0. 4.25 0. 0.; 0. 0. 0. 0. 0. 0.; 0.08660254 0. 0. 0. 0. 0.; 0. 0. ",MatchSource.WIKI,docs/4.7/guide/guide-tensor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-tensor.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:11169,Availability,error,errors,11169,"in tomography._index_permutations([len(lbls) for lbls in lbls_list]):; xlabels.append("""".join([lbls_list[k][inds[k]] for k in range(len(lbls_list))])). fig, ax = matrix_histogram(H, xlabels, xlabels, limits=[-4,4]). ax.view_init(azim=-55, elev=45). plt.show(). Similarly, we can use the function qutip.visualization.hinton, which is; used below to visualize the corresponding steadystate density matrix:; rho_ss = steadystate(H, [np.sqrt(0.1) * a, np.sqrt(0.4) * b.dag()]). hinton(rho_ss). plt.show(). Quantum process tomography¶; Quantum process tomography (QPT) is a useful technique for characterizing experimental implementations of quantum gates involving a small number of qubits. It can also be a useful theoretical tool that can give insight in how a process transforms states, and it can be used for example to study how noise or other imperfections deteriorate a gate. Whereas a fidelity or distance measure can give a single number that indicates how far from ideal a gate is, a quantum process tomography analysis can give detailed information about exactly what kind of errors various imperfections introduce.; The idea is to construct a transformation matrix for a quantum process (for example a quantum gate) that describes how the density matrix of a system is transformed by the process. We can then decompose the transformation in some operator basis that represent well-defined and easily interpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the m",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:135,Deployability,Install,Installation,135,". Visualization of quantum states and processes — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a prob",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:15614,Deployability,update,updated,15614,"e superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.qip.operations.iswap generates the unitary transformation for the state kets:; from qutip.qip.operations import iswap. U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2; op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; chi = qpt(U_rho, op_basis). fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:8542,Energy Efficiency,efficient,efficient,8542,"s[1]). fig.tight_layout(). plt.show(). Husimi Q-function¶; The Husimi Q function is, like the Wigner function, a quasiprobability; distribution for harmonic modes. It is defined as. \[Q(\alpha) = \frac{1}{\pi}\left<\alpha|\rho|\alpha\right>\]; where \(\left|\alpha\right>\) is a coherent state and; \(\alpha = x + iy\). In QuTiP, the Husimi Q function can be computed given; a state ket or density matrix using the function qfunc, as; demonstrated below.; Q_coherent = qfunc(rho_coherent, xvec, xvec); Q_thermal = qfunc(rho_thermal, xvec, xvec); Q_fock = qfunc(rho_fock, xvec, xvec); fig, axes = plt.subplots(1, 3, figsize=(12,3)); cont0 = axes[0].contourf(xvec, xvec, Q_coherent, 100); lbl0 = axes[0].set_title(""Coherent state""); cont1 = axes[1].contourf(xvec, xvec, Q_thermal, 100); lbl1 = axes[1].set_title(""Thermal state""); cont0 = axes[2].contourf(xvec, xvec, Q_fock, 100); lbl2 = axes[2].set_title(""Fock state""); plt.show(). If you need to calculate the Q function for many states with the same; phase-space coordinates, it is more efficient to use the QFunc class.; This stores various intermediary results to achieve an order-of-magnitude; improvement compared to calling qfunc in a loop.; xs = np.linspace(-1, 1, 101); qfunc_calculator = qutip.QFunc(xs, xs); q_state1 = qfunc_calculator(qutip.rand_dm(5)); q_state2 = qfunc_calculator(qutip.rand_ket(100)). Visualizing operators¶; Sometimes, it may also be useful to directly visualizing the underlying matrix; representation of an operator. The density matrix, for example, is an operator; whose elements can give insights about the state it represents, but one might; also be interesting in plotting the matrix of an Hamiltonian to inspect the; structure and relative importance of various elements.; QuTiP offers a few functions for quickly visualizing matrix data in the; form of histograms, qutip.visualization.matrix_histogram and; qutip.visualization.matrix_histogram_complex, and as Hinton diagram of weighted; squares, qutip.visualiza",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:15417,Integrability,depend,dependent,15417,"e superoperator for the system. Obviously, this scales very badly with increasing system size, but this method can still be a very useful for small systems (such as system comprised of a small number of coupled qubits). Implementation in QuTiP¶; In QuTiP, the procedure described above is implemented in the function qutip.tomography.qpt, which returns the \(\chi\) matrix given a density matrix propagator. To illustrate how to use this function, let’s consider the \(i\)-SWAP gate for two qubits. In QuTiP the function qutip.qip.operations.iswap generates the unitary transformation for the state kets:; from qutip.qip.operations import iswap. U_psi = iswap(). To be able to use this unitary transformation matrix as input to the function qutip.tomography.qpt, we first need to convert it to a transformation matrix for the corresponding density matrix:; U_rho = spre(U_psi) * spost(U_psi.dag()). Next, we construct a list of operators that define the basis \(\{B_i\}\) in the form of a list of operators for each composite system. At the same time, we also construct a list of corresponding labels that will be used when plotting the \(\chi\) matrix.; op_basis = [[qeye(2), sigmax(), sigmay(), sigmaz()]] * 2; op_label = [[""i"", ""x"", ""y"", ""z""]] * 2. We are now ready to compute \(\chi\) using qutip.tomography.qpt, and to plot it using qutip.tomography.qpt_plot_combined.; chi = qpt(U_rho, op_basis). fig = qpt_plot_combined(chi, op_label, r'$i$SWAP'). plt.show(). For a slightly more advanced example, where the density matrix propagator is calculated from the dynamics of a system defined by its Hamiltonian and collapse operators using the function qutip.propagator.propagator, see notebook “Time-dependent master equation: Landau-Zener transitions” on the tutorials section on the QuTiP web site. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:1718,Performance,perform,perform,1718,"putation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator mode with Hamiltonian \(H = \hbar\omega a^\dagger a\), which is; in a state described by its density matrix \(\rho\), and which on average; is occupied by two photons, \(\mathrm{Tr}[\rho a^\dagger a] = 2\). Given; this information we cannot say whether the oscillator is in a Fock state,; a thermal state, a coherent state, etc. By visualizing the photon distribution; in the Fock state basis important clues about the underlying state can be; obtained.; One convenient way to visualize a probability distribution is to use histograms.; Consider the following histogram visualization of the number-basis probability; distribut",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:12512,Security,access,access,12512,"terpreted transformations of the input states.; To see how this works (see e.g. [Moh08] for more details), consider a process that is described by quantum map \(\epsilon(\rho_{\rm in}) = \rho_{\rm out}\), which can be written. (1)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{i}^{N^2} A_i \rho_{\rm in} A_i^\dagger,\]; where \(N\) is the number of states of the system (that is, \(\rho\) is represented by an \([N\times N]\) matrix). Given an orthogonal operator basis of our choice \(\{B_i\}_i^{N^2}\), which satisfies \({\rm Tr}[B_i^\dagger B_j] = N\delta_{ij}\), we can write the map as. (2)¶\[\epsilon(\rho_{\rm in}) = \rho_{\rm out} = \sum_{mn} \chi_{mn} B_m \rho_{\rm in} B_n^\dagger.\]; where \(\chi_{mn} = \sum_{ij} b_{im}b_{jn}^*\) and \(A_i = \sum_{m} b_{im}B_{m}\). Here, matrix \(\chi\) is the transformation matrix we are after, since it describes how much \(B_m \rho_{\rm in} B_n^\dagger\) contributes to \(\rho_{\rm out}\).; In a numerical simulation of a quantum process we usually do not have access to the quantum map in the form Eq. (1). Instead, what we usually can do is to calculate the propagator \(U\) for the density matrix in superoperator form, using for example the QuTiP function qutip.propagator.propagator. We can then write. \[\epsilon(\tilde{\rho}_{\rm in}) = U \tilde{\rho}_{\rm in} = \tilde{\rho}_{\rm out}\]; where \(\tilde{\rho}\) is the vector representation of the density matrix \(\rho\). If we write Eq. (2) in superoperator form as well we obtain. \[\tilde{\rho}_{\rm out} = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger \tilde{\rho}_{\rm in} = U \tilde{\rho}_{\rm in}.\]; so we can identify. \[U = \sum_{mn} \chi_{mn} \tilde{B}_m \tilde{B}_n^\dagger.\]; Now this is a linear equation systems for the \(N^2 \times N^2\) elements in \(\chi\). We can solve it by writing \(\chi\) and the superoperator propagator as \([N^4]\) vectors, and likewise write the superoperator product \(\tilde{B}_m\tilde{B}_n^\dagger\) as a \([N^4\times N^4]\) matrix \(",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:960,Testability,Log,Log,960,". Visualization of quantum states and processes — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a prob",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:155,Usability,Guid,Guide,155,". Visualization of quantum states and processes — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a prob",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:162,Usability,Guid,Guide,162,". Visualization of quantum states and processes — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a prob",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide-visualization.html:1086,Usability,Guid,Guide,1086," . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Wigner function; Husimi Q-function. Visualizing operators; Quantum process tomography; Implementation in QuTiP. Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Visualization of quantum states and processes. Visualization of quantum states and processes¶; Visualization is often an important complement to a simulation of a quantum; mechanical system. The first method of visualization that come to mind might be; to plot the expectation values of a few selected operators. But on top of that,; it can often be instructive to visualize for example the state vectors or; density matices that describe the state of the system, or how the state is; transformed as a function of time (see process tomography below). In this; section we demonstrate how QuTiP and matplotlib can be used to perform a few; types of visualizations that often can provide additional understanding of; quantum system. Fock-basis probability distribution¶; In quantum mechanics probability distributions plays an important role, and as; in statistics, the expectation values computed from a probability distribution; does not reveal the full story. For example, consider an quantum harmonic; oscillator ",MatchSource.WIKI,docs/4.7/guide/guide-visualization.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide-visualization.html
https://qutip.org/docs/4.7/guide/guide.html:101,Deployability,Install,Installation,101,". Users Guide — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-Stat",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:3633,Deployability,update,updated,3633,"edfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:1703,Integrability,depend,dependent,1703,"ormation Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis pro",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:2532,Modifiability,Config,Configuring,2532, Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(P,MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:2897,Performance,load,loading,2897,"edfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:2932,Performance,load,loading,2932,"edfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:3355,Performance,Perform,Performing,3355,"edfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:3400,Performance,Perform,Performing,3400,"edfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:3106,Security,Access,Accessible,3106,"edfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Introduction; Steady State solvers in QuTiP; Using the Steadystate Solver; Additional Solver Arguments; Example: Harmonic Oscillator in Thermal Bath. Two-time correlation functions; Steadystate correlation function; Emission spectrum; Non-steadystate correlation function. Quantum Optimal Control; Introduction; Closed Quantum Systems; The GRAPE algorithm; The CRAB Algorithm; Optimal Quantum Control in QuTiP; Using the pulseoptim functions. Plotting on the Bloch Sphere; Introduction; The Bloch and Bloch3d Classes; Configuring the Bloch sphere; Animating with the Bloch sphere. Visualization of quantum states and processes; Fock-basis probability distribution; Quasi-probability distributions; Visualizing operators; Quantum process tomography. Parallel computation; Parallel map and parallel for-loop; IPython-based parallel_map. Saving QuTiP Objects and Data Sets; Storing and loading QuTiP objects; Storing and loading datasets. Generating Random Quantum States & Operators; Random objects with a given eigen spectrum; Composite random objects. Modifying Internal QuTiP Settings; User Accessible Parameters; Example: Changing Settings; Persistent Settings. Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects; Introduction; Performing a basic measurement (Observable); Performing a basic measurement (Projective); Obtaining measurement statistics(Observable); Obtaining measurement statistics(Projective). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:744,Testability,Log,Log,744,". Users Guide — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-Stat",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:8,Usability,Guid,Guide,8,". Users Guide — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-Stat",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:121,Usability,Guid,Guide,121,". Users Guide — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-Stat",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:128,Usability,Guid,Guide,128,". Users Guide — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-Stat",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:870,Usability,Guid,Guide,870,". Users Guide — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-Stat",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:883,Usability,Guid,Guide,883,". Users Guide — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-Stat",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/guide/guide.html:891,Usability,Guid,Guide,891,". Users Guide — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide. Users Guide¶. Guide Overview; Organization. Basic Operations on Quantum Objects; First things first; The quantum object class; Functions operating on Qobj class. Manipulating States and Operators; Introduction; State Vectors (kets or bras); Density matrices; Qubit (two-level) systems; Expectation values; Superoperators and Vectorized Operators; Choi, Kraus, Stinespring and \(\chi\) Representations; Properties of Quantum Maps. Using Tensor Products and Partial Traces; Tensor products; Example: Constructing composite Hamiltonians; Partial trace; Superoperators and Tensor Manipulations. Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-Stat",MatchSource.WIKI,docs/4.7/guide/guide.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/guide.html
https://qutip.org/docs/4.7/modules/index.html:346,Availability,avail,available,346,. Overview: module code — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qut,MatchSource.WIKI,docs/4.7/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html
https://qutip.org/docs/4.7/modules/index.html:111,Deployability,Install,Installation,111,. Overview: module code — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qut,MatchSource.WIKI,docs/4.7/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html
https://qutip.org/docs/4.7/modules/index.html:2201,Deployability,update,updated,2201," module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html
https://qutip.org/docs/4.7/modules/index.html:1477,Energy Efficiency,schedul,scheduler,1477," module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qutip.tensor; qutip.three_level_atom; qutip.tomography; qutip.topology; qutip.utilities; qutip.visualization; qutip.wigner. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html
https://qutip.org/docs/4.7/modules/index.html:529,Performance,optimiz,optimizer,529,. Overview: module code — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qut,MatchSource.WIKI,docs/4.7/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html
https://qutip.org/docs/4.7/modules/index.html:173,Testability,Log,Log,173,. Overview: module code — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qut,MatchSource.WIKI,docs/4.7/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html
https://qutip.org/docs/4.7/modules/index.html:131,Usability,Guid,Guide,131,. Overview: module code — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Overview: module code. All modules for which code is available; qutip.about; qutip.bloch; qutip.bloch3d; qutip.bloch_redfield; qutip.continuous_variables; qutip.control.dump; qutip.control.dynamics; qutip.control.fidcomp; qutip.control.optimizer; qutip.control.optimresult; qutip.control.propcomp; qutip.control.pulsegen; qutip.control.pulseoptim; qutip.control.stats; qutip.control.termcond; qutip.control.tslotcomp; qutip.correlation; qutip.cy.br_tensor; qutip.dimensions; qutip.distributions; qutip.entropy; qutip.eseries; qutip.essolve; qutip.expect; qutip.fileio; qutip.floquet; qutip.graph; qutip.interpolate; qutip.ipynbtools; qutip.krylovsolve; qutip.lattice; qutip.matplotlib_utilities; qutip.mcsolve; qutip.measurement; qutip.mesolve; qutip.metrics; qutip.nonmarkov.bofin_baths; qutip.nonmarkov.bofin_solvers; qutip.nonmarkov.dlheom_solver; qutip.nonmarkov.memorycascade; qutip.nonmarkov.transfertensor; qutip.operators; qutip.orbital; qutip.parallel; qutip.partial_transpose; qutip.piqs; qutip.propagator; qutip.qip.algorithms.qft; qutip.qip.circuit; qutip.qip.compiler.cavityqedcompiler; qutip.qip.compiler.gatecompiler; qutip.qip.compiler.instruction; qutip.qip.compiler.scheduler; qutip.qip.compiler.spinchaincompiler; qutip.qip.device.cavityqed; qutip.qip.device.modelprocessor; qutip.qip.device.optpulseprocessor; qutip.qip.device.processor; qutip.qip.device.spinchain; qutip.qip.noise; qutip.qip.operations.gates; qutip.qip.pulse; qutip.qip.qasm; qutip.qip.qubits; qutip.qobj; qutip.qobjevo; qutip.random_objects; qutip.rhs_generate; qutip.scattering; qutip.sesolve; qutip.simdiag; qutip.solver; qutip.states; qutip.steadystate; qutip.stochastic; qutip.superop_reps; qutip.superoperator; qut,MatchSource.WIKI,docs/4.7/modules/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/index.html
https://qutip.org/docs/4.7/development/ideas/heom-gpu.html:425,Availability,Error,Error,425,"﻿. GPU implementation of the Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org",MatchSource.WIKI,docs/4.7/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html
https://qutip.org/docs/4.7/development/ideas/heom-gpu.html:149,Deployability,Install,Installation,149,"﻿. GPU implementation of the Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org",MatchSource.WIKI,docs/4.7/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html
https://qutip.org/docs/4.7/development/ideas/heom-gpu.html:644,Deployability,Release,Release,644,"﻿. GPU implementation of the Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org",MatchSource.WIKI,docs/4.7/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html
https://qutip.org/docs/4.7/development/ideas/heom-gpu.html:2192,Deployability,update,updated,2192,"iP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce. 2; https://arxiv.org/abs/2010.10806. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html
https://qutip.org/docs/4.7/development/ideas/heom-gpu.html:1351,Modifiability,extend,extend,1351,"iP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce. 2; https://arxiv.org/abs/2010.10806. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html
https://qutip.org/docs/4.7/development/ideas/heom-gpu.html:1506,Modifiability,extend,extended,1506,"iP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce. 2; https://arxiv.org/abs/2010.10806. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html
https://qutip.org/docs/4.7/development/ideas/heom-gpu.html:1593,Performance,Perform,Performance,1593,"iP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org/doi/abs/10.1021/ct200126d?src=recsys&journalCode=jctcce. 2; https://arxiv.org/abs/2010.10806. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html
https://qutip.org/docs/4.7/development/ideas/heom-gpu.html:211,Testability,Log,Log,211,"﻿. GPU implementation of the Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org",MatchSource.WIKI,docs/4.7/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html
https://qutip.org/docs/4.7/development/ideas/heom-gpu.html:169,Usability,Guid,Guide,169,"﻿. GPU implementation of the Hierarchical Equations of Motion — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Expected outcomes; Skills; Difficulty; Mentors; References. Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; GPU implementation of the Hierarchical Equations of Motion. GPU implementation of the Hierarchical Equations of Motion¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The Hierarchical Equations of Motion (HEOM) method is a non-perturbative; approach to simulate the evolution of the density matrix of dissipative quantum; systems. The underlying equations are a system of coupled ODEs which can be run; on a GPU. This will allow the study of larger systems as discussed in 1. The; goal of this project would be to extend QuTiP’s HEOM method 2 and implement; it on a GPU.; Since the method is related to simulating large, coupled ODEs, it can also be; quite general and extended to other solvers. Expected outcomes¶. A version of HEOM which runs on a GPU.; Performance comparison with the CPU version.; Implement dynamic scaling. Skills¶. Git, python and familiarity with the Python scientific computing stack; CUDA and OpenCL knowledge. Difficulty¶. Hard. Mentors¶. Neill Lambert (nwlambert@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Shahnawaz Ahmed (shahnawaz.ahmed95@gmail.com); Simon Cross (hodgestar@gmail.com). References¶. 1; https://pubs.acs.org",MatchSource.WIKI,docs/4.7/development/ideas/heom-gpu.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/heom-gpu.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:470,Availability,Error,Error,470,"﻿. Pulse level description of quantum circuits — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; lib",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:134,Deployability,Install,Installation,134,"﻿. Pulse level description of quantum circuits — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; lib",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:629,Deployability,Release,Release,629,"﻿. Pulse level description of quantum circuits — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; lib",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:3718,Deployability,update,updated,3718,"er which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in qutip.qip.device and; qutip.qip.compiler. Skills¶. Git, Python and familiarity with the Python scientific computing stack; quantum information processing and quantum computing (quantum circuit formalism). Difficulty¶. Medium. Mentors¶. Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; McKay D C, Alexander T, Bello L, et al. Qiskit backend specifications for openqasm and openpulse experiments[J]. arXiv preprint arXiv:1809.03452, 2018. 2; Häffner H, Roos C F, Blatt R, Quantum computing with trapped ions, Physics reports, 2008, 469(4): 155-203. 3; Krantz P, Kjaergaard M, Yan F, et al. A quantum engineer’s guide to superconducting qubits, Applied Physics Reviews, 2019, 6(2): 021318. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:2269,Integrability,depend,depend,2269,"20,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in qutip.qip.device and; qutip.qip.compiler. Skills¶. Git, Python and familiarity with the Python scientific computing stack; quantum information processing and quantum computing (quantum circuit formalism). Difficulty¶. Medium. Mentors¶. Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; McKay D C, Alexander T, Bello L, et al. Qiskit b",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:990,Modifiability,enhance,enhance,990,"ion of quantum circuits — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:1273,Modifiability,enhance,enhanced,1273,"deas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical sy",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:1528,Modifiability,enhance,enhance,1528,"ogle Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Ham",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:196,Testability,Log,Log,196,"﻿. Pulse level description of quantum circuits — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; lib",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:154,Usability,Guid,Guide,154,"﻿. Pulse level description of quantum circuits — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Expected outcomes; Skills; Difficulty; Mentors; References. Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Pulse level description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; lib",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:1764,Usability,simpl,simple,1764,"l description of quantum circuits. Pulse level description of quantum circuits¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. The aim of this proposal is to enhance QuTiP quantum-circuit compilation; features with regard to quantum information processing. While QuTiP core modules; deal with dynamics simulation, there is also a module for quantum circuits; simulation. The two subsequent Google Summer of Code projects, in 2019 and 2020,; enhanced them in capabilities and features, allowing the simulation both at the; level of gates and at the level of time evolution. To connect them, a compiler; is implemented to compile quantum gates into the Hamiltonian model. We would; like to further enhance this feature in QuTiP and the connection with other; libraries. Expected outcomes¶. APIs to import and export pulses to other libraries. Quantum compiler is a; current research topic in quantum engineering. Although QuTiP has a simple; compiler, many may want to try their own compiler which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code c",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html:3544,Usability,guid,guide,3544,"er which is more compatible; with their quantum device. Allowing importation and exportation of control; pulses will make this much easier. This will include a study of existing; libraries, such as qiskit.pulse and OpenPulse 1, comparing them with; qutip.qip.pulse module and building a more general and comprehensive; description of the pulse.; More examples of quantum system in the qutip.qip.device module. The circuit; simulation and compilation depend strongly on the physical system. At the; moment, we have two models: spin chain and cavity QED. We would like to; include some other commonly used planform such as Superconducting system 2,; Ion trap system 3 or silicon system. Each model will need a new set of; control Hamiltonian and a compiler that finds the control pulse of a quantum; gate. More involved noise models can also be added based on the physical; system. This part is going to involve some physics and study of commonly used; hardware platforms. The related code can be found in qutip.qip.device and; qutip.qip.compiler. Skills¶. Git, Python and familiarity with the Python scientific computing stack; quantum information processing and quantum computing (quantum circuit formalism). Difficulty¶. Medium. Mentors¶. Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]; Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; McKay D C, Alexander T, Bello L, et al. Qiskit backend specifications for openqasm and openpulse experiments[J]. arXiv preprint arXiv:1809.03452, 2018. 2; Häffner H, Roos C F, Blatt R, Quantum computing with trapped ions, Physics reports, 2008, 469(4): 155-203. 3; Krantz P, Kjaergaard M, Yan F, et al. A quantum engineer’s guide to superconducting qubits, Applied Physics Reviews, 2019, 6(2): 021318. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/pulse-level-quantum-circuits.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/pulse-level-quantum-circuits.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:11,Availability,Error,Error,11,"﻿. Quantum Error Mitigation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:391,Availability,Error,Error,391,"﻿. Quantum Error Mitigation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:787,Availability,Error,Error,787,"﻿. Quantum Error Mitigation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:813,Availability,Error,Error,813,"﻿. Quantum Error Mitigation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:1708,Availability,error,error,1708,"thon. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python sc",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2132,Availability,error,error,2132,"lasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Krista",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2402,Availability,error,error,2402," a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future appli",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2533,Availability,error,error,2533,"dels, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level contr",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:3050,Availability,Error,Error,3050,"; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:3399,Availability,error,error,3399,"; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:115,Deployability,Install,Installation,115,"﻿. Quantum Error Mitigation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:610,Deployability,Release,Release,610,"﻿. Quantum Error Mitigation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:921,Deployability,release,release,921,"﻿. Quantum Error Mitigation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:1571,Deployability,integrat,integration,1571,"Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation pr",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2291,Deployability,integrat,integrate,2291,"simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2570,Deployability,integrat,integration,2570,"dels, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level contr",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:3801,Deployability,update,updated,3801,"; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:1929,Energy Efficiency,schedul,schedule,1929,"qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (eta",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:3664,Energy Efficiency,schedul,schedule,3664,"; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:1571,Integrability,integrat,integration,1571,"Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation pr",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2291,Integrability,integrat,integrate,2291,"simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2550,Integrability,protocol,protocols,2550,"dels, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level contr",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2570,Integrability,integrat,integration,2570,"dels, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level contr",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:1038,Modifiability,enhance,enhanced,1038,"TiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues an",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:3246,Modifiability,Extend,Extending,3246,"; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future applications, Physical Review X 8, 031027 (2018). 4; Boxi Li’s blog on the GSoC 2019 project on pulse-level control, https://gsoc2019-boxili.blogspot.com/. 5; Video of a recent talk on the GSoC 2019 project, https://fosdem.org/2020/schedule/event/quantum_qutip/. 6; Mitiq. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2394,Performance,perform,perform,2394," a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum processor, Nature 567, 491 (2019). 3. Endo, S.C. Benjamin, Y. Li, Practical quantum error mitigation for near-future appli",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:2351,Safety,avoid,avoid,2351,"simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a collection of related issues and ongoing Pull Requests. Expected outcomes¶. Make an overview of existing libraries and features in error mitigation,; similarly to a literature survey for a research article, but for a code; project (starting from Refs. 4, 5). This is done in order to best; integrate the features in QuTiP with existing libraries and avoid; reinventing the wheel.; Features to perform error mitigation techniques in QuTiP, such as zero-noise; extrapolation by pulse stretching.; Tutorials implementing basic quantum error mitigation protocols; Possible integration with Mitiq 6. Skills¶. Background in quantum physics and quantum circuits.; Git, python and familiarity with the Python scientific computing stack. Difficulty¶. Medium. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Eric Giguère (eric.giguere@usherbrooke.ca); Neill Lambert (nwlambert@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. References¶. 1; Kristan Temme, Sergey Bravyi, Jay M. Gambetta, Error mitigation for short-depth quantum circuits, Phys. Rev. Lett. 119, 180509 (2017). 2; Abhinav Kandala, Kristan Temme, Antonio D. Corcoles, Antonio Mezzacapo, Jerry M. Chow, Jay M. Gambetta,; Extending the computational reach of a noisy superconducting quantum proce",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:177,Testability,Log,Log,177,"﻿. Quantum Error Mitigation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html:135,Usability,Guid,Guide,135,"﻿. Quantum Error Mitigation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; Expected outcomes; Skills; Difficulty; Mentors; References. GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; Quantum Error Mitigation. Quantum Error Mitigation¶. Contents. Expected outcomes; Skills; Difficulty; Mentors; References. From the QuTiP 4.5 release, the qutip.qip module now contains the noisy quantum; circuit simulator (which was a GSoC project) providing enhanced features for a; pulse-level description of quantum circuits and noise models. A new class; Processor and several subclasses are added to represent different platforms; for quantum computing. They can transfer a quantum circuit into the; corresponding control sequence and simulate the dynamics with QuTiP solvers.; Different noise models can be added to qutip.qip.noise to simulate noise in a; quantum device.; This module is still young and many features can be improved, including new; device models, new noise models and integration with the existing general; framework for quantum circuits (qutip.qip.circuit). There are also possible; applications such as error mitigation techniques (1, 2, 3).; The tutorial notebooks can be found at https://qutip.org/tutorials.html#nisq. A; recent presentation on the FOSDEM conference may help you get an overview; (https://fosdem.org/2020/schedule/event/quantum_qutip/). See also the Github; Project page for a ",MatchSource.WIKI,docs/4.7/development/ideas/quantum-error-mitigation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/quantum-error-mitigation.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:450,Availability,Error,Error,450,"﻿. QuTiP Interactive — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Ha",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:108,Deployability,Install,Installation,108,"﻿. QuTiP Interactive — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Ha",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:609,Deployability,Release,Release,609,"﻿. QuTiP Interactive — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Ha",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1703,Deployability,toggle,toggle,1703,"on. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills¶. Git, Python and familiarity with the Python scientific computing stack; elementary understanding of quantum dynamics. Difficulty¶. Variable. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Simon Cross (hodgestar@gm",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:2870,Deployability,update,updated,2870,"at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills¶. Git, Python and familiarity with the Python scientific computing stack; elementary understanding of quantum dynamics. Difficulty¶. Variable. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Simon Cross (hodgestar@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1087,Integrability,interface,interface,1087,"ion; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP cir",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1393,Modifiability,flexible,flexible,1393,"imated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks int",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1954,Modifiability,config,configure,1954,"at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills¶. Git, Python and familiarity with the Python scientific computing stack; elementary understanding of quantum dynamics. Difficulty¶. Variable. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Simon Cross (hodgestar@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:2574,Modifiability,Variab,Variable,2574,"at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processing. Animated Bloch spheres for qubits. Expected outcomes¶. Interactive graphical components for demonstrating quantum dynamics; Web pages for qutip.org or Jupyter notebooks introducing quantum dynamics; using the new components. Skills¶. Git, Python and familiarity with the Python scientific computing stack; elementary understanding of quantum dynamics. Difficulty¶. Variable. Mentors¶. Nathan Shammah (nathan.shammah@gmail.com); Alex Pitchford (alex.pitchford@gmail.com); Simon Cross (hodgestar@gmail.com); Boxi Li (etamin1201@gmail.com) [QuTiP GSoC 2019 graduate]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1155,Security,access,accessible,1155,"ion; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP cir",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:170,Testability,Log,Log,170,"﻿. QuTiP Interactive — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Ha",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:128,Usability,Guid,Guide,128,"﻿. QuTiP Interactive — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Ha",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:957,Usability,simpl,simple,957,"﻿. QuTiP Interactive — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Ha",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html:1234,Usability,learn,learners,1234,"entation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Interactive Bloch sphere; Interactive solvers; Animated circuits. Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; QuTiP Interactive. QuTiP Interactive¶. Contents. Interactive Bloch sphere; Interactive solvers; Animated circuits. Expected outcomes; Skills; Difficulty; Mentors. QuTiP is pretty simple to use at an entry level for anyone with basic Python; skills. However, some Python skills are necessary. A graphical user interface; (GUI) for some parts of qutip could help make qutip more accessible. This could; be particularly helpful in education, for teachers and learners.; Ideally, interactive components could be embedded in web pages. Including, but; not limited to, Jupyter notebooks.; The scope for this is broad and flexible. Ideas including, but not limited to:. Interactive Bloch sphere¶; QuTiP has a Bloch sphere virtualisation for qubit states. This could be made; interactive through sliders, radio buttons, cmd buttons etc. An interactive; Bloch sphere could have sliders for qubit state angles. Buttons to add states,; toggle state evolution path. Potential for recording animations. Matplotlib has; some interactive features (sliders, radio buttons, cmd buttons) that can be used; to control parameters. that could potentially be used. Interactive solvers¶; Options to configure dynamics generators (Lindbladian / Hamiltonian args etc); and expectation operators. Then run solver and view state evolution. Animated circuits¶; QIP circuits could be animated. Status lights showing evolution of states during; the processi",MatchSource.WIKI,docs/4.7/development/ideas/qutip-interactive.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/qutip-interactive.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:390,Availability,Error,Error,390,"﻿. TensorFlow Data Backend — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; TensorFlow Data Backend. TensorFlow Data Backend¶. Contents. Why a TensorFlow backend?; Challenges. Expected outcomes; Skills; Difficulty; Mentors; References. Note; This project was completed as part of GSoC 2021 3. QuTiP’s data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; de",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:114,Deployability,Install,Installation,114,"﻿. TensorFlow Data Backend — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; TensorFlow Data Backend. TensorFlow Data Backend¶. Contents. Why a TensorFlow backend?; Challenges. Expected outcomes; Skills; Difficulty; Mentors; References. Note; This project was completed as part of GSoC 2021 3. QuTiP’s data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; de",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:574,Deployability,Release,Release,574,"﻿. TensorFlow Data Backend — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; TensorFlow Data Backend. TensorFlow Data Backend¶. Contents. Why a TensorFlow backend?; Challenges. Expected outcomes; Skills; Difficulty; Mentors; References. Note; This project was completed as part of GSoC 2021 3. QuTiP’s data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; de",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:3440,Deployability,update,updated,3440,"tiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. 3; https://github.com/qutip/qutip-tensorflow/. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:1614,Energy Efficiency,efficient,efficiently,1614,"ckend. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; TensorFlow Data Backend. TensorFlow Data Backend¶. Contents. Why a TensorFlow backend?; Challenges. Expected outcomes; Skills; Difficulty; Mentors; References. Note; This project was completed as part of GSoC 2021 3. QuTiP’s data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some i",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:2090,Energy Efficiency,efficient,efficiently,2090,"i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not requi",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:2180,Energy Efficiency,efficient,efficiently,2180,"itten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (ja",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:2415,Performance,perform,performance,2415,"es already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. 3; https://github.com",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:176,Testability,Log,Log,176,"﻿. TensorFlow Data Backend — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; TensorFlow Data Backend. TensorFlow Data Backend¶. Contents. Why a TensorFlow backend?; Challenges. Expected outcomes; Skills; Difficulty; Mentors; References. Note; This project was completed as part of GSoC 2021 3. QuTiP’s data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; de",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:2602,Testability,benchmark,benchmark,2602,"tiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. 3; https://github.com/qutip/qutip-tensorflow/. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:2714,Testability,benchmark,benchmark,2714,"tiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. 3; https://github.com/qutip/qutip-tensorflow/. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:2845,Testability,benchmark,benchmark,2845,"tiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; dense and sparse matrix backends. It uses flow graphs to describe operations,; and to work efficiently. Ideally large graphs of operations need to be; executed together in order to efficiently compute results.; The QuTiP data layer might need to be adjusted to accommodate these; differences, and it is possible that this will prove challenging or even; that we will not find a reasonable way to achieve the desired performance. Expected outcomes¶. Add a qutip.core.data.tensorflow data type.; Implement specialisations for some important operations (e.g. add,; mul, matmul, eigen, etc).; Write a small benchmark to show how Qobj operations scale on the new; backend in comparison to the existing backends. Run the benchmark both; with and without using a GPU.; Implement enough for a solver to run on top of the new TensorFlow data; backend and benchmark that (stretch goal). Skills¶. Git, Python and familiarity with the Python scientific computing stack; Familiarity with TensorFlow (beneficial, but not required); Familiarity with Cython (beneficial, but not required). Difficulty¶. Medium. Mentors¶. Simon Cross (hodgestar@gmail.com); Jake Lishman (jake@binhbar.com); Alex Pitchford (alex.pitchford@gmail.com). References¶. 1; https://www.tensorflow.org/. 2; https://github.com/tehruhn/bofin. 3; https://github.com/qutip/qutip-tensorflow/. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html:134,Usability,Guid,Guide,134,"﻿. TensorFlow Data Backend — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Contributing to QuTiP Development; QuTiP Development Roadmap; Ideas for future QuTiP development; QuTiP Interactive; Pulse level description of quantum circuits; Quantum Error Mitigation; GPU implementation of the Hierarchical Equations of Motion; Google Summer of Code; Completed Projects; TensorFlow Data Backend. Working with the QuTiP Documentation; Release and Distribution. Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Development Documentation »; Ideas for future QuTiP development »; TensorFlow Data Backend. TensorFlow Data Backend¶. Contents. Why a TensorFlow backend?; Challenges. Expected outcomes; Skills; Difficulty; Mentors; References. Note; This project was completed as part of GSoC 2021 3. QuTiP’s data layer provides the mathematical operations needed to work with; quantum states and operators, i.e. Qobj, inside QuTiP. As part of Google; Summer of Code 2020, the data layer was rewritten to allow new backends to; be added more easily and for different backends to interoperate with each; other. Backends using in-memory spares and dense matrices already exist,; and we would like to add a backend that implements the necessary operations; using TensorFlow 1. Why a TensorFlow backend?¶; TensorFlow supports distributing matrix operations across multiple GPUs and; multiple machines, and abstracts away some of the complexities of doing so; efficiently. We hope that by using TensorFlow we might enable QuTiP to scale; to bigger quantum systems (e.g. more qubits) and decrease the time taken to; simulate them.; There is particular interest in trying the new backend with the; BoFiN HEOM (Hierarchical Equations of Motion) solver 2. Challenges¶; TensorFlow is a very different kind of computational framework to the existing; de",MatchSource.WIKI,docs/4.7/development/ideas/tensorflow-data-backend.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/development/ideas/tensorflow-data-backend.html
https://qutip.org/docs/4.7/gallery/build/index.html:585,Availability,Down,Download,585,". Gallery — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery. Gallery¶; This is the gallery for QuTiP examples, you can click on the image to see the source code. Quantum Information Processing¶. Basic use of Processor¶. T2 Relaxation¶. Control Amplitude Noise¶. Download all examples in Python source code: build_python.zip. Download all examples in Jupyter notebooks: build_jupyter.zip. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/index.html
https://qutip.org/docs/4.7/gallery/build/index.html:648,Availability,Down,Download,648,". Gallery — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery. Gallery¶; This is the gallery for QuTiP examples, you can click on the image to see the source code. Quantum Information Processing¶. Basic use of Processor¶. T2 Relaxation¶. Control Amplitude Noise¶. Download all examples in Python source code: build_python.zip. Download all examples in Jupyter notebooks: build_jupyter.zip. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/index.html
https://qutip.org/docs/4.7/gallery/build/index.html:97,Deployability,Install,Installation,97,". Gallery — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery. Gallery¶; This is the gallery for QuTiP examples, you can click on the image to see the source code. Quantum Information Processing¶. Basic use of Processor¶. T2 Relaxation¶. Control Amplitude Noise¶. Download all examples in Python source code: build_python.zip. Download all examples in Jupyter notebooks: build_jupyter.zip. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/index.html
https://qutip.org/docs/4.7/gallery/build/index.html:844,Deployability,update,updated,844,". Gallery — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery. Gallery¶; This is the gallery for QuTiP examples, you can click on the image to see the source code. Quantum Information Processing¶. Basic use of Processor¶. T2 Relaxation¶. Control Amplitude Noise¶. Download all examples in Python source code: build_python.zip. Download all examples in Jupyter notebooks: build_jupyter.zip. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/index.html
https://qutip.org/docs/4.7/gallery/build/index.html:255,Testability,Log,Log,255,". Gallery — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery. Gallery¶; This is the gallery for QuTiP examples, you can click on the image to see the source code. Quantum Information Processing¶. Basic use of Processor¶. T2 Relaxation¶. Control Amplitude Noise¶. Download all examples in Python source code: build_python.zip. Download all examples in Jupyter notebooks: build_jupyter.zip. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/index.html
https://qutip.org/docs/4.7/gallery/build/index.html:117,Usability,Guid,Guide,117,". Gallery — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery. Gallery¶; This is the gallery for QuTiP examples, you can click on the image to see the source code. Quantum Information Processing¶. Basic use of Processor¶. T2 Relaxation¶. Control Amplitude Noise¶. Download all examples in Python source code: build_python.zip. Download all examples in Jupyter notebooks: build_jupyter.zip. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/index.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/index.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html:448,Availability,down,download,448,". Control Amplitude Noise — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f0268569e80>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.081 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Bui",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html:1714,Availability,Down,Download,1714,"um Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f0268569e80>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.081 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html:1772,Availability,Down,Download,1772,"um Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f0268569e80>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.081 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html:113,Deployability,Install,Installation,113,". Control Amplitude Noise — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f0268569e80>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.081 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Bui",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html:1964,Deployability,update,updated,1964,"um Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f0268569e80>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.081 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html:271,Testability,Log,Log,271,". Control Amplitude Noise — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f0268569e80>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.081 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Bui",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html:133,Usability,Guid,Guide,133,". Control Amplitude Noise — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Control Amplitude Noise. Note; Click here; to download the full example code. Control Amplitude Noise¶; This example demonstrates how to add Gaussian noise to the control pulse. Out:; [<matplotlib.lines.Line2D object at 0x7f0268569e80>]. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.qip.noise import RandomNoise; from qutip.operators import sigmaz, sigmay. # add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, ax2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); ax2[0].step(qobjevo.tlist, noisy_coeff). Total running time of the script: ( 0 minutes 0.081 seconds). Download Python source code: plot_qip_amplitude_noise.py. Download Jupyter notebook: plot_qip_amplitude_noise.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Bui",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_amplitude_noise.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:446,Availability,down,download,446,". Basic use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Doc",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:1655,Availability,Down,Download,1655,"c use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:1713,Availability,Down,Download,1713,"c use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:112,Deployability,Install,Installation,112,". Basic use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Doc",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:756,Deployability,continuous,continuous,756,". Basic use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Doc",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:1905,Deployability,update,updated,1905,"c use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:270,Testability,Log,Log,270,". Basic use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Doc",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html:132,Usability,Guid,Guide,132,". Basic use of Processor — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; Basic use of Processor. Note; Click here; to download the full example code. Basic use of Processor¶; This example contains the basic functions of qutip.qip.device.Processor. We define a simulator with control Hamiltonian, pulse amplitude and time slice for each pulse. The two figures illustrate the pulse shape for two different setup: step function or continuous pulse. Out:; (<Figure size 1200x600 with 1 Axes>, [<AxesSubplot:>]). import copy; import numpy as np; import matplotlib.pyplot as plt; pi = np.pi; from qutip.qip.device import Processor; from qutip.operators import sigmaz; from qutip.states import basis. processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""step_func""); processor.add_control(sigmaz(), 0); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). tlist = np.linspace(0., 2*np.pi, 20); processor = Processor(N=1, spline_kind=""cubic""); processor.add_control(sigmaz()); processor.pulses[0].tlist = tlist; processor.pulses[0].coeff = np.array([np.sin(t) for t in tlist]); processor.plot_pulses(). Total running time of the script: ( 0 minutes 0.814 seconds). Download Python source code: plot_qip_intro_processor.py. Download Jupyter notebook: plot_qip_intro_processor.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Doc",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_intro_processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_intro_processor.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html:428,Availability,down,download,428,". T2 Relaxation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.136 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_relaxation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html:1703,Availability,Down,Download,1703,"uTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.136 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_relaxation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html:1756,Availability,Down,Download,1756,"uTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.136 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_relaxation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html:103,Deployability,Install,Installation,103,". T2 Relaxation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.136 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_relaxation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html:1943,Deployability,update,updated,1943,"uTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.136 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_relaxation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html:261,Testability,Log,Log,261,". T2 Relaxation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.136 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_relaxation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html
https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html:123,Usability,Guid,Guide,123,". T2 Relaxation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; Quantum Information Processing; Basic use of Processor; T2 Relaxation; Control Amplitude Noise. API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Gallery »; T2 Relaxation. Note; Click here; to download the full example code. T2 Relaxation¶; Simulating the T2 relaxation of a single qubit with qutip.qip.device.Processor. The single qubit is driven by a rotation around z axis. We measure the population of the plus state as a function of time to see the Ramsey signal. import numpy as np; import matplotlib.pyplot as plt; from qutip.qip.device import Processor; from qutip.operators import sigmaz, destroy; from qutip.qip.operations import snot; from qutip.states import basis. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length of tlist needs to be fixed; ax.plot(tlist[:-1], result.expect[1][:-1], '.', label=""simulation""); ax.plot(tlist[:-1], np.exp(-1./T2*tlist[:-1])*0.5 + 0.5, label=""theory""); ax.set_xlabel(""t""); ax.set_ylabel(""Ramsey signal""); ax.legend(); ax.set_title(""Relaxation T2=5""); ax.grid(); fig.tight_layout(); fig.show(). Total running time of the script: ( 0 minutes 0.136 seconds). Download Python source code: plot_qip_relaxation.py. Download Jupyter notebook: plot_qip_relaxation.ipynb. Gallery generated by Sphinx-Gallery. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using ",MatchSource.WIKI,docs/4.7/gallery/build/qip/plot_qip_relaxation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/gallery/build/qip/plot_qip_relaxation.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:2991,Availability,down,downside,2991,"es, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:3361,Availability,robust,robust,3361,"ten desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Definitions¶; The starting point of the Bloch-Redfield formalism is the total Hamiltonian for the system and the environment (bath): \(H = H_{\rm S} + H_{\rm B} + H_{\rm I}\), where \(H\) is the total system+bath Hamiltonian, \(H_{\rm S}\) and \(H_{\rm B}\) are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)¶\[ \frac{d}{dt}\rho_S(t) = - \hb",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:120,Deployability,Install,Installation,120,". Bloch-Redfield master equation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their correspondi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:5578,Deployability,integrat,integration,5578," This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:18717,Deployability,update,updated,18717,"kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:2225,Energy Efficiency,energy,energy,2225,"ime Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:2525,Energy Efficiency,power,power,2525,"ime Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more ro",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:8291,Energy Efficiency,power,power,8291,"esponding the eigenstate \(\left|m\right>\), we obtain in matrix form in the Schrödinger picture. \[\begin{split}\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); -\hbar^{-2}; \sum_{\alpha,\beta}; \sum_{c,d}^{\rm sec}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)¶\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:8573,Energy Efficiency,energy,energy,8573," g_{\alpha\beta}(\tau); \left[\delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}e^{i\omega_{cn}\tau}; -; A^\alpha_{ac} A^\beta_{db} e^{i\omega_{ca}\tau}; \right]; \right. \nonumber\\; +; \left.; g_{\alpha\beta}(-\tau); \left[\delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} e^{i\omega_{nd}\tau}; -; A^\alpha_{ac}A^\beta_{db}e^{i\omega_{bd}\tau}; \right]; \right\} \rho_{cd}(t),; \nonumber\\\end{split}\]; where the “sec” above the summation symbol indicate summation of the secular terms which satisfy \(|\omega_{ab}-\omega_{cd}| \ll \tau_ {\rm decay}\). This is an almost-useful form of the master equation. The final step before arriving at the form of the Bloch-Redfield master equation that is implemented in QuTiP, involves rewriting the bath correlation function \(g(\tau)\) in terms of the noise-power spectrum of the environment \(S(\omega) = \int_{-\infty}^\infty d\tau e^{i\omega\tau} g(\tau)\):. (4)¶\[ \int_0^\infty d\tau\; g_{\alpha\beta}(\tau) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\bet",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:9472,Energy Efficiency,power,power,9472,"u) e^{i\omega\tau} = \frac{1}{2}S_{\alpha\beta}(\omega) + i\lambda_{\alpha\beta}(\omega),\]; where \(\lambda_{ab}(\omega)\) is an energy shift that is neglected here. The final form of the Bloch-Redfield master equation is. (5)¶\[\frac{d}{dt}\rho_{ab}(t); =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes two mandatory arguments: The system Hamiltonian \(H\), a nest",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14716,Energy Efficiency,efficient,efficient,14716,"-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations preven",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14863,Energy Efficiency,efficient,efficient,14863,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Ha",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15021,Energy Efficiency,power,power,15021,"section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, s",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15405,Energy Efficiency,power,power,15405,"the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17829,Energy Efficiency,power,power,17829,"kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:512,Integrability,depend,dependent,512,". Bloch-Redfield master equation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their correspondi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:662,Integrability,depend,dependent,662,". Bloch-Redfield master equation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their correspondi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:4980,Integrability,depend,depends,4980," are the system and bath Hamiltonians, respectively, and \(H_{\rm I}\) is the interaction Hamiltonian.; The most general form of a master equation for the system dynamics is obtained by tracing out the bath from the von-Neumann equation of motion for the combined system (\(\dot\rho = -i\hbar^{-1}[H, \rho]\)). In the interaction picture the result is. (1)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the ba",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:5528,Integrability,depend,dependence,5528,"Tr}_B [H_I(t), [H_I(\tau), \rho_S(\tau)\otimes\rho_B]],\]; where the additional assumption that the total system-bath density matrix can be factorized as \(\rho(t) \approx \rho_S(t) \otimes \rho_B\). This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:5578,Integrability,integrat,integration,5578," This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:13678,Integrability,depend,dependent,13678,"_x\), \(\sigma_y\), and \(\sigma_z\) operators for the example above, we can use the following code:; tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, H_ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:13792,Integrability,depend,dependent,13792,"use the following code:; tlist = np.linspace(0, 15.0, 1000). psi0 = rand_ket(2). e_ops = [sigmax(), sigmay(), sigmaz()]. expt_list = bloch_redfield_solve(R, H_ekets, psi0, tlist, e_ops). sphere = Bloch(). sphere.add_points([expt_list[0], expt_list[1], expt_list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems th",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14058,Integrability,depend,dependent,14058,"list[2]]). sphere.vector_color = ['r']. sphere.add_vectors(np.array([delta, 0, eps0]) / np.sqrt(delta ** 2 + eps0 ** 2)). sphere.make_sphere(). The two steps of calculating the Bloch-Redfield tensor and evolving according to the corresponding master equation can be combined into one by using the function qutip.bloch_redfield.brmesolve, which takes same arguments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14309,Integrability,depend,dependent,14309,"uments as qutip.mesolve and qutip.mcsolve, save for the additional nested list of operator-spectrum pairs that is called a_ops.; output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14808,Integrability,depend,dependent,14808,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Ha",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14930,Integrability,depend,dependent,14930,"ng parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Ha",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14994,Integrability,depend,dependent,14994,"section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, s",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15152,Integrability,depend,dependent,15152,"aster equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponen",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15453,Integrability,depend,dependent,15453,"the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15727,Integrability,depend,dependent,15727,"l, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15777,Integrability,depend,dependent,15777,"elies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kap",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15978,Integrability,depend,dependent,15978,"such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:16262,Integrability,depend,dependent,16262,"rmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17349,Integrability,depend,dependence,17349,"pa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17854,Integrability,depend,dependence,17854,"kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:18546,Integrability,depend,dependent,18546,"kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:2837,Modifiability,coupling,coupling,2837,"rators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the resulting master equation unconditionally preserves the physical properties of the density matrix (because it is a perturbative method). The Bloch-Redfield master equation must therefore be used with care, and the assumptions made in the derivation must be honored. (The Lindblad master equation is in a sense more robust – it always results in a physical density matrix – although some collapse operators might not be physically justified). For a full derivation of the Bloch Redfield master equation, see e.g. [Coh92] or [Bre02]. Here we present only a brief version of the derivation, with the intention of introducing the notation and how it relates to the implementation in QuTiP. Brief Derivation and Def",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:5564,Modifiability,extend,extending,5564," This assumption is known as the Born approximation, and it implies that there never is any entanglement between the system and the bath, neither in the initial state nor at any time during the evolution. It is justified for weak system-bath interaction.; The master equation (1) is non-Markovian, i.e., the change in the density matrix at a time \(t\) depends on states at all times \(\tau < t\), making it intractable to solve both theoretically and numerically. To make progress towards a manageable master equation, we now introduce the Markovian approximation, in which \(\rho_S(\tau)\) is replaced by \(\rho_S(t)\) in Eq. (1). The result is the Redfield equation. (2)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^t d\tau\; {\rm Tr}_B [H_I(t), [H_I(\tau), \rho_S(t)\otimes\rho_B]],\]; which is local in time with respect the density matrix, but still not Markovian since it contains an implicit dependence on the initial state. By extending the integration to infinity and substituting \(\tau \rightarrow t-\tau\), a fully Markovian master equation is obtained:. (3)¶\[ \frac{d}{dt}\rho_S(t) = - \hbar^{-2}\int_0^\infty d\tau\; {\rm Tr}_B [H_I(t), [H_I(t-\tau), \rho_S(t)\otimes\rho_B]].\]; The two Markovian approximations introduced above are valid if the time-scale with which the system dynamics changes is large compared to the time-scale with which correlations in the bath decays (corresponding to a “short-memory” bath, which results in Markovian system dynamics).; The master equation (3) is still on a too general form to be suitable for numerical implementation. We therefore assume that the system-bath interaction takes the form \(H_I = \sum_\alpha A_\alpha \otimes B_\alpha\) and where \(A_\alpha\) are system operators and \(B_\alpha\) are bath operators. This allows us to write master equation in terms of system operators and bath correlation functions:. \[\begin{split}\frac{d}{dt}\rho_S(t) =; -\hbar^{-2}; \sum_{\alpha\beta}; \int_0^\infty d\tau\;; \left\{; g_{\alpha\beta}(\",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:10554,Modifiability,coupling,coupling,10554,"ectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes two mandatory arguments: The system Hamiltonian \(H\), a nested list of operator \(A_\alpha\), spectral density functions \(S_\alpha(\omega)\) pairs that characterize the coupling between system and bath. The spectral density functions are Python callback functions that takes the (angular) frequency as a single argument.; To illustrate how to calculate the Bloch-Redfield tensor, let’s consider a two-level atom. (8)¶\[ H = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z\]; delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; gamma1 = 0.5. H = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(). def ohmic_spectrum(w):; if w == 0.0: # dephasing inducing noise; return gamma1; else: # relaxation inducing noise; return gamma1 / 2 * (w / (2 * np.pi)) * (w > 0.0). R, H_ekets = bloch_redfield_tensor(H, [[sigmax(), ohmic_spectrum]]). print(R). Output:; Quantum object: dims = [[[2], [2]], [[2], [2]]], shape = (4, 4), type = super, isherm = False; Qobj data =; [[ 0. +0.j 0. +0.j 0. +0.j; 0.24514517+0.j ]; [ 0. +0.j -0.16103412-6.4076169j 0. +0.j; 0. +0.j ]; [ 0. +0.j 0. +0.j -0.16103412+6.4076169",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15993,Modifiability,coupling,coupling,15993,"such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:16372,Modifiability,coupling,coupling,16372,"nt, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For exam",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:16436,Modifiability,coupling,coupling,16436,"nto time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:16771,Modifiability,coupling,coupling,16771,"endent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kapp",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17135,Modifiability,coupling,coupling,17135,"appa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number of basis states to consider. a = destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) +",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:17716,Modifiability,coupling,coupling,17716," destroy(N). H = a.dag() * a. psi0 = basis(N, 9) # initial state. kappa = 0.2 # coupling to oscillator. a_ops = [[a+a.dag(), '{kappa}*exp(-t)*(w>=0)'.format(kappa=kappa)]]. tlist = np.linspace(0, 10, 100). out = brmesolve(H, psi0, tlist, a_ops, e_ops=[a.dag() * a]). actual_answer = 9.0 * np.exp(-kappa * (1.0 - np.exp(-tlist))). plt.figure(). plt.plot(tlist, out.expect[0]). plt.plot(tlist, actual_answer). plt.show(). In many cases, the bath-coupling operators can take the form \(A = f(t)a + f(t)^* a^{+}\). In this case, the above format for inputting the a_ops is not sufficient. Instead, one must construct a nested-list of tuples to specify this time-dependence. For example consider a white-noise bath that is coupled to an operator of the form exp(1j*t)*a + exp(-1j*t)* a.dag(). In this example, the a_ops list would be:; a_ops = [ [ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ] ]. where the first tuple element (a, a.dag()) tells the solver which operators make up the full Hermitian coupling operator. The second tuple ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)'), gives the noise power spectrum, and time-dependence of each operator. Note that the noise spectrum must always come first in this second tuple. A full example is:; N = 10. w0 = 1.0 * 2 * np.pi. g = 0.05 * w0. kappa = 0.15. times = np.linspace(0, 25, 1000). a = destroy(N). H = w0 * a.dag() * a + g * (a + a.dag()). psi0 = ket2dm((basis(N, 4) + basis(N, 2) + basis(N, 0)).unit()). a_ops = [[ (a, a.dag()), ('{0} * (w >= 0)'.format(kappa), 'exp(1j*t)', 'exp(-1j*t)') ]]. e_ops = [a.dag() * a, a + a.dag()]. res_brme = brmesolve(H, psi0, times, a_ops, e_ops). plt.figure(). plt.plot(times,res_brme.expect[0], label=r'$a^{+}a$'). plt.plot(times,res_brme.expect[1], label=r'$a+a^{+}$'). plt.legend(). plt.show(). Further examples on time-dependent Bloch-Redfield simulations can be found in the online tutorials. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:14563,Performance,scalab,scalability,14563," psi0, tlist, a_ops=[[sigmax(),ohmic_spectrum]], e_ops=e_ops). where the resulting output is an instance of the class qutip.solver.Result. Time-dependent Bloch-Redfield Dynamics¶. Warning; It takes ~3-5 seconds (~30 if using Visual Studio) to compile a time-dependent Bloch-Redfield problem. Therefore,; if you are doing repeated simulations by varying parameters, then it is best to pass; options = Options(rhs_reuse=True) to the solver. If you have not done so already, please read the section: Solving Problems with Time-dependent Hamiltonians.; As we have already discussed, the Bloch-Redfield master equation requires transforming into the eigenbasis of the system Hamiltonian. For time-independent systems, this transformation need only be done once. However, for time-dependent systems, one must move to the instantaneous eigenbasis at each time-step in the evolution, thus greatly increasing the computational complexity of the dynamics. In addition, the requirement for computing all the eigenvalues severely limits the scalability of the method. Fortunately, this eigen decomposition occurs at the Hamiltonian level, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, exc",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:15572,Safety,avoid,avoid,15572,"l, as opposed to the super-operator level, and thus, with efficient programming, one can tackle many systems that are commonly encountered.; The time-dependent Bloch-Redfield solver in QuTiP relies on the efficient numerical computations afforded by the string-based time-dependent format, and Cython compilation. As such, all the time-dependent terms, and noise power spectra must be expressed in the string format. To begin, lets consider the previous example, but formatted to call the time-dependent solver:; ohmic = ""{gamma1} / 2.0 * (w / (2 * pi)) * (w > 0.0)"".format(gamma1=gamma1). output = brmesolve(H, psi0, tlist, a_ops=[[sigmax(),ohmic]], e_ops=e_ops). Although the problem itself is time-independent, the use of a string as the noise power spectrum tells the solver to go into time-dependent mode. The string is nearly identical to the Python function format, except that we replaced np.pi with pi to avoid calling Python in our Cython code, and we have hard coded the gamma1 argument into the string as limitations prevent passing arguments into the time-dependent Bloch-Redfield solver.; For actual time-dependent Hamiltonians, the Hamiltonian itself can be passed into the solver like any other string-based Hamiltonian, as thus we will not discuss this topic further. Instead, here the focus is on time-dependent bath coupling terms. To this end, suppose that we have a dissipative harmonic oscillator, where the white-noise dissipation rate decreases exponentially with time \(\kappa(t) = \kappa(0)\exp(-t)\). In the Lindblad or monte-carlo solvers, this could be implemented as a time-dependent collapse operator list c_ops = [[a, 'sqrt(kappa*exp(-t))']]. In the Bloch-Redfield solver, the bath coupling terms must be Hermitian. As such, in this example, our coupling operator is the position operator a+a.dag(). In addition, we do not need the sqrt operation that occurs in the c_ops definition. The complete example, and comparison to the analytic expression is:; N = 10 # number ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:1226,Testability,Log,Log,1226,"roducts and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigens",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:140,Usability,Guid,Guide,140,". Bloch-Redfield master equation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their correspondi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:147,Usability,Guid,Guide,147,". Bloch-Redfield master equation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their correspondi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:1352,Usability,Guid,Guide,1352,"olver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Introduction; Brief Derivation and Definitions; Bloch-Redfield master equation in QuTiP; Time-dependent Bloch-Redfield Dynamics. Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator),",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:2015,Usability,clear,clear,2015,"ating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Bloch-Redfield master equation. Bloch-Redfield master equation¶. Introduction¶; The Lindblad master equation introduced earlier is constructed so that it describes a physical evolution of the density matrix (i.e., trace and positivity preserving), but it does not provide a connection to any underlaying microscopic physical model. The Lindblad operators (collapse operators) describe phenomenological processes, such as for example dephasing and spin flips, and the rates of these processes are arbitrary parameters in the model. In many situations the collapse operators and their corresponding rates have clear physical interpretation, such as dephasing and relaxation rates, and in those cases the Lindblad master equation is usually the method of choice.; However, in some cases, for example systems with varying energy biases and eigenstates and that couple to an environment in some well-defined manner (through a physically motivated system-environment interaction operator), it is often desirable to derive the master equation from more fundamental physical principles, and relate it to for example the noise-power spectrum of the environment.; The Bloch-Redfield formalism is one such approach to derive a master equation from a microscopic system. It starts from a combined system-environment perspective, and derives a perturbative master equation for the system alone, under the assumption of weak system-environment coupling. One advantage of this approach is that the dissipation processes and rates are obtained directly from the properties of the environment. On the downside, it does not intrinsically guarantee that the result",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html:9577,Usability,simpl,simplify,9577," =; -i\omega_{ab}\rho_{ab}(t); +; \sum_{c,d}^{\rm sec}R_{abcd}\rho_{cd}(t),\]; where. (6)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha,\beta}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\beta_{nc}S_{\alpha\beta}(\omega_{cn}); -; A^\alpha_{ac} A^\beta_{db} S_{\alpha\beta}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\beta_{nb} S_{\alpha\beta}(\omega_{dn}); -; A^\alpha_{ac}A^\beta_{db} S_{\alpha\beta}(\omega_{db}); \right\},\end{split}\]; is the Bloch-Redfield tensor.; The Bloch-Redfield master equation in the form Eq. (5) is suitable for numerical implementation. The input parameters are the system Hamiltonian \(H\), the system operators through which the environment couples to the system \(A_\alpha\), and the noise-power spectrum \(S_{\alpha\beta}(\omega)\) associated with each system-environment interaction term.; To simplify the numerical implementation we assume that \(A_\alpha\) are Hermitian and that cross-correlations between different environment operators vanish, so that the final expression for the Bloch-Redfield tensor that is implemented in QuTiP is. (7)¶\[\begin{split} R_{abcd} = -\frac{\hbar^{-2}}{2} \sum_{\alpha}; \left\{; \delta_{bd}\sum_nA^\alpha_{an}A^\alpha_{nc}S_{\alpha}(\omega_{cn}); -; A^\alpha_{ac} A^\alpha_{db} S_{\alpha}(\omega_{ca}); \right. \nonumber\\; +; \left.; \delta_{ac}\sum_n A^\alpha_{dn}A^\alpha_{nb} S_{\alpha}(\omega_{dn}); -; A^\alpha_{ac}A^\alpha_{db} S_{\alpha}(\omega_{db}); \right\}.\end{split}\]. Bloch-Redfield master equation in QuTiP¶; In QuTiP, the Bloch-Redfield tensor Eq. (7) can be calculated using the function qutip.bloch_redfield.bloch_redfield_tensor. It takes two mandatory arguments: The system Hamiltonian \(H\), a nested list of operator \(A_\alpha\), spectral density functions \(S_\alpha(\omega)\) pairs that characterize the coupling between system and bath. The spectral density functions are Python callback functions that takes the (angular) frequency as a single ar",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-bloch-redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-bloch-redfield.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:117,Deployability,Install,Installation,117,". Dynamics Simulation Results — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result con",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:6161,Deployability,update,updated,6161,"n values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_result.times; plot(times, expt0, times, expt1); show(). Also see Saving QuTiP Objects and Data Sets for more information on saving quantum objects, as well as arrays for use in other programs. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:592,Integrability,depend,dependent,592,". Dynamics Simulation Results — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result con",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:420,Performance,Load,Loading,420,". Dynamics Simulation Results — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result con",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:4793,Performance,Load,Loading,4793,"using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_resul",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:5417,Performance,Load,Loading,5417,"n values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_result.times; plot(times, expt0, times, expt1); show(). Also see Saving QuTiP Objects and Data Sets for more information on saving quantum objects, as well as arrays for use in other programs. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:5510,Performance,Load,Loaded,5510,"n values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_result.times; plot(times, expt0, times, expt1); show(). Also see Saving QuTiP Objects and Data Sets for more information on saving quantum objects, as well as arrays for use in other programs. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:386,Security,Access,Accessing,386,". Dynamics Simulation Results — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result con",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:2894,Security,Access,Accessing,2894,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:2939,Security,access,access,2939,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:3986,Security,access,access,3986,"do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload f",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:4475,Security,access,accessed,4475,"om the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_res",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:1177,Testability,Log,Log,1177,"ipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at w",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:137,Usability,Guid,Guide,137,". Dynamics Simulation Results — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result con",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:144,Usability,Guid,Guide,144,". Dynamics Simulation Results — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result con",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:1303,Usability,Guid,Guide,1303,"s Simulation Results; The solver.Result Class; Accessing Result Data; Saving and Loading Result Objects. Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Dynamics Simulation Results. Dynamics Simulation Results¶. The solver.Result Class¶; Before embarking on simulating the dynamics of quantum systems, we will first look at the data structure used for returning the simulation results to the user. This object is a qutip.solver.Result class that stores all the crucial data needed for analyzing and plotting the results of a simulation. Like the qutip.Qobj class, the Result class has a collection of properties for storing information. However, in contrast to the Qobj class, this structure contains no methods, and is therefore nothing but a container object. A generic Result object result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vector",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:3002,Usability,guid,guide,3002,"bject result contains the following properties for storing simulation data:. Property; Description. result.solver; String indicating which solver was used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:3178,Usability,simpl,simply,3178," used to generate the data. result.times; List/array of times at which simulation data is calculated. result.expect; List/array of expectation values, if requested. result.states; List/array of state vectors/density matrices calculated at times,; if requested. result.num_expect; The number of expectation value operators in the simulation. result.num_collapse; The number of collapse operators in the simulation. result.ntraj; Number of Monte Carlo trajectories run. result.col_times; Times at which state collapse occurred. Only for Monte Carlo solver. result.col_which; Which collapse operator was responsible for each collapse in; in col_times. Only used by Monte Carlo solver. result.seeds; Seeds used in generating random numbers for Monte Carlo solver. Accessing Result Data¶; To understand how to access the data in a Result object we will use an example as a guide, although we do not worry about the simulation details at this stage. Like all solvers, the Monte Carlo solver used in this example returns an Result object, here called simply result. To see what is contained inside result we can use the print function:; >>> print(result); Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. The first line tells us that this data object was generated from the Monte Carlo solver mcsolve (discussed in Monte Carlo Solver). The next line (not the --- line of course) indicates that this object contains expectation value data. Finally, the last line gives the number of expectation value and collapse operators used in the simulation, along with the number of Monte Carlo trajectories run. Note that the number of trajectories ntraj is only displayed when using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style index",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html:4903,Usability,simpl,simplicity,4903,"using the Monte Carlo solver.; Now we have all the information needed to analyze the simulation results.; To access the data for the two expectation values one can do:; expt0 = result.expect[0]; expt1 = result.expect[1]. Recall that Python uses C-style indexing that begins with zero (i.e., [0] => 1st collapse operator data). Together with the array of times at which these expectation values are calculated:; times = result.times. we can plot the resulting expectation values:; plot(times, expt0, times, expt1); show(). State vectors, or density matrices, as well as col_times and col_which, are accessed in a similar manner, although typically one does not need an index (i.e [0]) since there is only one list for each of these components. The one exception to this rule is if you choose to output state vectors from the Monte Carlo solver, in which case there are ntraj number of state vector arrays. Saving and Loading Result Objects¶; The main advantage in using the Result class as a data storage object comes from the simplicity in which simulation data can be stored and later retrieved. The qutip.fileio.qsave and qutip.fileio.qload functions are designed for this task. To begin, let us save the data object from the previous section into a file called “cavity+qubit-data” in the current working directory by calling:; qsave(result, 'cavity+qubit-data'). All of the data results are then stored in a single file of the same name with a “.qu” extension. Therefore, everything needed to later this data is stored in a single file. Loading the file is just as easy as saving:; >>> stored_result = qload('cavity+qubit-data'); Loaded Result object:; Result object with mcsolve data.; ---------------------------------; expect = True; num_expect = 2, num_collapse = 2, ntraj = 500. where stored_result is the new name of the Result object. We can then extract the data and plot in the same manner as before:; expt0 = stored_result.expect[0]; expt1 = stored_result.expect[1]; times = stored_resul",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-data.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-data.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:107,Deployability,Install,Installation,107,". Floquet Formalism — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independe",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:1537,Deployability,integrat,integration,1537,"quation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:20471,Deployability,update,updated,20471," * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = np.zeros(tlist.shape, dtype=np.complex128); for idx, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = qutip.floquet_states(f_modes_t, f_energies, t); p_ex[idx] = qutip.expect(qutip.num(2), output.states[idx].transform(f_states_t, True)). # For reference: calculate the same thing with mesolve; output = qutip.mesolve(H, psi0, tlist,; [np.sqrt(gamma1) * qutip.sigmax()], [qutip.num(2)],; args); p_ex_ref = output.expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'r--', tlist, 1-np.real(p_ex), 'b--'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). Alternatively, we can let the qutip.floquet.fmmesolve function transform the density matrix at each time step back to the computational basis, and calculating the expectation values for us, by using:. output = fmmesolve(H, psi0, tlist, [sigmax()], [num(2)], [noise_spectrum], T, args, floquet_basis=False); p_ex = output.expect[0]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:1768,Energy Efficiency,efficient,efficiently,1768,"ing for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and nam",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:12443,Energy Efficiency,efficient,efficiently,12443,"t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = qutip.expect(qutip.num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t, args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian ; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = qutip.floquet_modes_table(f_modes_0, f_energies, tlist, H, T",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:12596,Energy Efficiency,efficient,efficiently,12596," same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet states or the wavefunction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t, args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian ; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = qutip.floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = np.zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:18674,Energy Efficiency,power,power,18674,"ccept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = np.zeros(tlist.shape, dtype=np.complex128); for idx, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = qutip.floquet_states(f_modes_t, f_energies, t); p_ex[idx] = qutip.expect(qutip.num(2), output.states[idx].transform(f_states_t, True)). # For reference: calculate the same thing with mesolve; output = qutip.mesolve(H, psi0, tlist,; [np.sqrt(gamma1) * qutip.sigmax()], [qutip.num(2)],; args); p_ex_",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:499,Integrability,depend,dependent,499,". Floquet Formalism — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independe",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:1423,Integrability,depend,dependent,1423,"lver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamil",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:1537,Integrability,integrat,integration,1537,"quation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:1603,Integrability,depend,dependent,1603,"quation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important app",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:2135,Integrability,depend,dependent,2135,"antum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solu",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:2297,Integrability,depend,dependent,2297,"opyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. Accordi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:2403,Integrability,depend,dependent,2403,"lism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) of the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:2709,Integrability,depend,dependent,2709,"ndependent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) of the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but o",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:2937,Integrability,depend,dependent,2937," Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) of the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wav",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:3141,Integrability,depend,dependence,3141,"stem with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous approach would be to rederive the master equation taking the time-dependent nature of the Hamiltonian into account from the start. The Floquet-Markov Master equation is one such a formalism, with important applications for strongly driven systems (see e.g., [Gri98]).; Here we give an overview of how the Floquet and Floquet-Markov formalisms can be used for solving time-dependent problems in QuTiP. To introduce the terminology and naming conventions used in QuTiP we first give a brief summary of quantum Floquet theory. Floquet theory for unitary evolution¶; The Schrödinger equation with a time-dependent Hamiltonian \(H(t)\) is. (1)¶\[ H(t)\Psi(t) = i\hbar\frac{\partial}{\partial t}\Psi(t),\]; where \(\Psi(t)\) is the wave function solution. Here we are interested in problems with periodic time-dependence, i.e., the Hamiltonian satisfies \(H(t) = H(t+T)\) where \(T\) is the period. According to the Floquet theorem, there exist solutions to (1) of the form. (2)¶\[ \Psi_\alpha(t) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where \(\Psi_\alpha(t)\) are the Floquet states (i.e., the set of wave function solutions to the Schrödinger equation), \(\Phi_\alpha(t)=\Phi_\alpha(t+T)\) are the periodic Floquet modes, and \(\epsilon_\alpha\) are the quasienergy levels. The quasienergy levels are constants in time, but only uniquely defined up to multiples of \(2\pi/T\) (i.e., unique value in the interval \([0, 2\pi/T]\)).; If we know the Floquet modes (for \(t \in [0,T]\)) and the quasienergies for a particular \(H(t)\), we can easily decompose any initial wavefunction \(\Psi(t=0)\) in the Floquet states and immediately obtain the solution for arbitrary \(t\). (3)¶\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:5001,Integrability,depend,dependent,5001,"\). (3)¶\[ \Psi(t) = \sum_\alpha c_\alpha \Psi_\alpha(t) = \sum_\alpha c_\alpha \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; where the coefficients \(c_\alpha\) are determined by the initial wavefunction \(\Psi(0) = \sum_\alpha c_\alpha \Psi_\alpha(0)\).; This formalism is useful for finding \(\Psi(t)\) for a given \(H(t)\) only if we can obtain the Floquet modes \(\Phi_a(t)\) and quasienergies \(\epsilon_\alpha\) more easily than directly solving (1). By substituting (2) into the Schrödinger equation (1) we obtain an eigenvalue equation for the Floquet modes and quasienergies. (4)¶\[ \mathcal{H}(t)\Phi_\alpha(t) = \epsilon_\alpha\Phi_\alpha(t),\]; where \(\mathcal{H}(t) = H(t) - i\hbar\partial_t\). This eigenvalue problem could be solved analytically or numerically, but in QuTiP we use an alternative approach for numerically finding the Floquet states and quasienergies [see e.g. Creffield et al., Phys. Rev. B 67, 165301 (2003)]. Consider the propagator for the time-dependent Schrödinger equation (1), which by definition satisfies. \[U(T+t,t)\Psi(t) = \Psi(T+t).\]; Inserting the Floquet states from (2) into this expression results in. \[U(T+t,t)\exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha(T+t)/\hbar)\Phi_\alpha(T+t),\]; or, since \(\Phi_\alpha(T+t)=\Phi_\alpha(t)\),. \[U(T+t,t)\Phi_\alpha(t) = \exp(-i\epsilon_\alpha T/\hbar)\Phi_\alpha(t) = \eta_\alpha \Phi_\alpha(t),\]; which shows that the Floquet modes are eigenstates of the one-period propagator. We can therefore find the Floquet modes and quasienergies \(\epsilon_\alpha = -\hbar\arg(\eta_\alpha)/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet mod",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:6580,Integrability,depend,dependent,6580,")/T\) by numerically calculating \(U(T+t,t)\) and diagonalizing it. In particular this method is useful to find \(\Phi_\alpha(0)\) by calculating and diagonalize \(U(T,0)\).; The Floquet modes at arbitrary time \(t\) can then be found by propagating \(\Phi_\alpha(0)\) to \(\Phi_\alpha(t)\) using the wave function propagator \(U(t,0)\Psi_\alpha(0) = \Psi_\alpha(t)\), which for the Floquet modes yields. \[U(t,0)\Phi_\alpha(0) = \exp(-i\epsilon_\alpha t/\hbar)\Phi_\alpha(t),\]; so that \(\Phi_\alpha(t) = \exp(i\epsilon_\alpha t/\hbar) U(t,0)\Phi_\alpha(0)\). Since \(\Phi_\alpha(t)\) is periodic we only need to evaluate it for \(t \in [0, T]\), and from \(\Phi_\alpha(t \in [0,T])\) we can directly evaluate \(\Phi_\alpha(t)\), \(\Psi_\alpha(t)\) and \(\Psi(t)\) for arbitrary large \(t\). Floquet formalism in QuTiP¶; QuTiP provides a family of functions to calculate the Floquet modes and quasi energies, Floquet state decomposition, etc., given a time-dependent Hamiltonian on the callback format, list-string format and list-callback format (see, e.g., qutip.mesolve for details).; Consider for example the case of a strongly driven two-level atom, described by the Hamiltonian. (5)¶\[ H(t) = -\frac{1}{2}\Delta\sigma_x - \frac{1}{2}\epsilon_0\sigma_z + \frac{1}{2}A\sin(\omega t)\sigma_z.\]; In QuTiP we can define this Hamiltonian as follows:; >>> delta = 0.2 * 2*np.pi; >>> eps0 = 1.0 * 2*np.pi; >>> A = 2.5 * 2*np.pi; >>> omega = 1.0 * 2*np.pi; >>> H0 = - delta/2.0 * sigmax() - eps0/2.0 * sigmaz(); >>> H1 = A/2.0 * sigmaz(); >>> args = {'w': omega}; >>> H = [H0, [H1, 'sin(w * t)']]. The \(t=0\) Floquet modes corresponding to the Hamiltonian (5) can then be calculated using the qutip.floquet.floquet_modes function, which returns lists containing the Floquet modes and the quasienergies; >>> T = 2*np.pi / omega; >>> f_modes_0, f_energies = floquet_modes(H, T, args); >>> f_energies ; array([-2.83131212, 2.83131212]); >>> f_modes_0 ; [Quantum object: dims = [[2], [1]], shape = (2, 1)",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:11095,Integrability,depend,dependent,11095,"(-0.645265993068382+0.7304552549315746j),; (0.15517002114250228-0.1612116102238258j)]. and given this decomposition of the initial state in the Floquet states we can easily evaluate the wavefunction that is the solution to (5) at an arbitrary time \(t\) using the function qutip.floquet.floquet_wavefunction_t; >>> t = 10 * np.random.rand(); >>> psi_t = floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args). The following example illustrates how to use the functions introduced above to calculate and plot the time-evolution of (5).; import numpy as np; from matplotlib import pyplot. import qutip. delta = 0.2 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.5 * 2*np.pi; omega = 1.0 * 2*np.pi; T = (2*np.pi)/omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2, 0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmaz(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; p_ex = np.zeros(len(tlist)); for n, t in enumerate(tlist):; psi_t = qutip.floquet_wavefunction_t(f_modes_0, f_energies, f_coeff, t, H, T, args); p_ex[n] = qutip.expect(qutip.num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). Pre-computing the Floquet modes for one period¶; When evaluating the Floquet stat",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:13112,Integrability,depend,dependent,13112,"ction at many points in time it is useful to pre-compute the Floquet modes for the first period of the driving with the required resolution. In QuTiP the function qutip.floquet.floquet_modes_table calculates a table of Floquet modes which later can be used together with the function qutip.floquet.floquet_modes_t_lookup to efficiently lookup the Floquet mode at an arbitrary time. The following example illustrates how the example from the previous section can be solved more efficiently using these functions for pre-computing the Floquet modes.; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 10 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t, args: np.sin(args['w'] * t)]]. # find the floquet modes for the time-dependent hamiltonian ; f_modes_0,f_energies = qutip.floquet_modes(H, T, args). # decompose the inital state in the floquet modes; f_coeff = qutip.floquet_state_decomposition(f_modes_0, f_energies, psi0). # calculate the wavefunctions using the from the floquet modes; f_modes_table_t = qutip.floquet_modes_table(f_modes_0, f_energies, tlist, H, T, args); p_ex = np.zeros(len(tlist)); for n, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); psi_t = qutip.floquet_wavefunction(f_modes_t, f_energies, f_coeff, t); p_ex[n] = qutip.expect(qutip.num(2), psi_t). # For reference: calculate the same thing with mesolve; p_ex_ref = qutip.mesolve(H, psi0, tlist, [], [qutip.num(2)], args).expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:14948,Integrability,depend,dependent,14948,"e results; pyplot.plot(tlist, np.real(p_ex), 'ro', tlist, 1-np.real(p_ex), 'bo'); pyplot.plot(tlist, np.real(p_ex_ref), 'r', tlist, 1-np.real(p_ex_ref), 'b'); pyplot.xlabel('Time'); pyplot.ylabel('Occupation probability'); pyplot.legend((""Floquet $P_1$"", ""Floquet $P_0$"", ""Lindblad $P_1$"", ""Lindblad $P_0$"")); pyplot.show(). Note that the parameters and the Hamiltonian used in this example is not the same as in the previous section, and hence the different appearance of the resulting figure.; For convenience, all the steps described above for calculating the evolution of a quantum system using the Floquet formalisms are encapsulated in the function qutip.floquet.fsesolve. Using this function, we could have achieved the same results as in the examples above using; output = fsesolve(H, psi0=psi0, tlist=tlist, e_ops=[qutip.num(2)], args=args); p_ex = output.expect[0]. Floquet theory for dissipative evolution¶; A driven system that is interacting with its environment is not necessarily well described by the standard Lindblad master equation, since its dissipation process could be time-dependent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details.; For a brief summary of the derivation, the important contents for the implementation in QuTiP are listed below.; The floquet mode \(\ket{\phi_\alpha(t)}\) refers to a full class of quasienergies defined by \(\epsilon_\alpha + k \Omega\) for arbitrary \(k\). Hence, the quasienenergy difference between two floquet modes is given by. \[\Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega\]; For any coupling operator \(q\) (given by the user) the matrix elements in the ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:17071,Integrability,depend,dependent,17071,"a_{\alpha \beta k} = 2 \pi \Theta(\Delta_{\alpha \beta k}) J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2\]; where \(\Theta\) is the Heaviside function. The master equation is further simplified by the RWA, which makes the following matrix useful:. \[A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k})\]; The density matrix of the system then evolves according to:. \[\dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta\]. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent Hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. Th",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:18809,Integrability,depend,dependent,18809," implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, args). # calculate expectation values in the computational basis; p_ex = np.zeros(tlist.shape, dtype=np.complex128); for idx, t in enumerate(tlist):; f_modes_t = qutip.floquet_modes_t_lookup(f_modes_table_t, t, T); f_states_t = qutip.floquet_states(f_modes_t, f_energies, t); p_ex[idx] = qutip.expect(qutip.num(2), output.states[idx].transform(f_states_t, True)). # For reference: calculate the same thing with mesolve; output = qutip.mesolve(H, psi0, tlist,; [np.sqrt(gamma1) * qutip.sigmax()], [qutip.num(2)],; args); p_ex_ref = output.expect[0]. # plot the results; pyplot.plot(tlist, np.real(p_ex), 'r--', tlist, 1-np.real(p_ex), 'b--'); pyplot.plot(tlist",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:15781,Modifiability,coupling,coupling,15781,"em that is interacting with its environment is not necessarily well described by the standard Lindblad master equation, since its dissipation process could be time-dependent due to the driving. In such cases a rigorious approach would be to take the driving into account when deriving the master equation. This can be done in many different ways, but one way common approach is to derive the master equation in the Floquet basis. That approach results in the so-called Floquet-Markov master equation, see Grifoni et al., Physics Reports 304, 299 (1998) for details.; For a brief summary of the derivation, the important contents for the implementation in QuTiP are listed below.; The floquet mode \(\ket{\phi_\alpha(t)}\) refers to a full class of quasienergies defined by \(\epsilon_\alpha + k \Omega\) for arbitrary \(k\). Hence, the quasienenergy difference between two floquet modes is given by. \[\Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega\]; For any coupling operator \(q\) (given by the user) the matrix elements in the floquet basis are calculated as:. \[X_{\alpha \beta k} = \frac{1}{T} \int_0^T dt \; e^{-ik \Omega t} \bra{\phi_\alpha(t)}q\ket{\phi_\beta(t)}\]; From the matrix elements and the spectral density \(J(\omega)\), the decay rate \(\gamma_{\alpha \beta k}\) is defined:. \[\gamma_{\alpha \beta k} = 2 \pi \Theta(\Delta_{\alpha \beta k}) J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2\]; where \(\Theta\) is the Heaviside function. The master equation is further simplified by the RWA, which makes the following matrix useful:. \[A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k})\]; The density matrix of the system then evolves according to:. \[\dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:16579,Modifiability,evolve,evolves,16579,"phi_\alpha(t)}\) refers to a full class of quasienergies defined by \(\epsilon_\alpha + k \Omega\) for arbitrary \(k\). Hence, the quasienenergy difference between two floquet modes is given by. \[\Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega\]; For any coupling operator \(q\) (given by the user) the matrix elements in the floquet basis are calculated as:. \[X_{\alpha \beta k} = \frac{1}{T} \int_0^T dt \; e^{-ik \Omega t} \bra{\phi_\alpha(t)}q\ket{\phi_\beta(t)}\]; From the matrix elements and the spectral density \(J(\omega)\), the decay rate \(\gamma_{\alpha \beta k}\) is defined:. \[\gamma_{\alpha \beta k} = 2 \pi \Theta(\Delta_{\alpha \beta k}) J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2\]; where \(\Theta\) is the Heaviside function. The master equation is further simplified by the RWA, which makes the following matrix useful:. \[A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k})\]; The density matrix of the system then evolves according to:. \[\dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta\]. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent Hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density fu",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:17427,Modifiability,coupling,coupling,17427,"ta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k})\]; The density matrix of the system then evolves according to:. \[\dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta\]. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent Hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:17710,Modifiability,coupling,coupling,17710,"alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta\]. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent Hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:18146,Modifiability,extend,extends,18146,"onment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fmmesolve does characterize the environment with dissipation rates, but extract the strength of the coupling to the environment from the noise spectral-density functions and the instantaneous Hamiltonian parameters (similar to the Bloch-Redfield master equation solver qutip.bloch_redfield.brmesolve). Note; Currently the qutip.floquet.fmmesolve can only accept a single environment coupling operator and spectral-density function. The noise spectral-density function of the environment is implemented as a Python callback function that is passed to the solver. For example:; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*pi). The other parameters are similar to the qutip.mesolve and qutip.mcsolve, and the same format for the return value is used qutip.solver.Result. The following example extends the example studied above, and uses qutip.floquet.fmmesolve to introduce dissipation into the calculation; import numpy as np; from matplotlib import pyplot; import qutip. delta = 0.0 * 2*np.pi; eps0 = 1.0 * 2*np.pi; A = 0.25 * 2*np.pi; omega = 1.0 * 2*np.pi; T = 2*np.pi / omega; tlist = np.linspace(0.0, 20 * T, 101); psi0 = qutip.basis(2,0). H0 = - delta/2.0 * qutip.sigmax() - eps0/2.0 * qutip.sigmaz(); H1 = A/2.0 * qutip.sigmax(); args = {'w': omega}; H = [H0, [H1, lambda t,args: np.sin(args['w'] * t)]]. # noise power spectrum; gamma1 = 0.1; def noise_spectrum(omega):; return 0.5 * gamma1 * omega/(2*np.pi). # find the floquet modes for the time-dependent hamiltonian ; f_modes_0, f_energies = qutip.floquet_modes(H, T, args). # precalculate mode table; f_modes_table_t = qutip.floquet_modes_table(; f_modes_0, f_energies, np.linspace(0, T, 500 + 1), H, T, args,; ). # solve the floquet-markov master equation; output = qutip.fmmesolve(H, psi0, tlist, [qutip.sigmax()], [], [noise_spectrum], T, ar",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:1178,Testability,Log,Log,1178,"tates and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in partic",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:127,Usability,Guid,Guide,127,". Floquet Formalism — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independe",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:134,Usability,Guid,Guide,134,". Floquet Formalism — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independe",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:1304,Usability,Guid,Guide,1304,"lation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Introduction; Floquet theory for unitary evolution; Floquet theory for dissipative evolution. Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Floquet Formalism. Floquet Formalism¶. Introduction¶; Many time-dependent problems of interest are periodic. The dynamics of such systems can be solved for directly by numerical integration of the Schrödinger or Master equation, using the time-dependent Hamiltonian. But they can also be transformed into time-independent problems using the Floquet formalism. Time-independent problems can be solve much more efficiently, so such a transformation is often very desirable.; In the standard derivations of the Lindblad and Bloch-Redfield master equations the Hamiltonian describing the system under consideration is assumed to be time independent. Thus, strictly speaking, the standard forms of these master equation formalisms should not blindly be applied to system with time-dependent Hamiltonians. However, in many relevant cases, in particular for weak driving, the standard master equations still turns out to be useful for many time-dependent problems. But a more rigorous",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html:16313,Usability,simpl,simplified,16313," (1998) for details.; For a brief summary of the derivation, the important contents for the implementation in QuTiP are listed below.; The floquet mode \(\ket{\phi_\alpha(t)}\) refers to a full class of quasienergies defined by \(\epsilon_\alpha + k \Omega\) for arbitrary \(k\). Hence, the quasienenergy difference between two floquet modes is given by. \[\Delta_{\alpha \beta k} = \frac{\epsilon_\alpha - \epsilon_\beta}{\hbar} + k \Omega\]; For any coupling operator \(q\) (given by the user) the matrix elements in the floquet basis are calculated as:. \[X_{\alpha \beta k} = \frac{1}{T} \int_0^T dt \; e^{-ik \Omega t} \bra{\phi_\alpha(t)}q\ket{\phi_\beta(t)}\]; From the matrix elements and the spectral density \(J(\omega)\), the decay rate \(\gamma_{\alpha \beta k}\) is defined:. \[\gamma_{\alpha \beta k} = 2 \pi \Theta(\Delta_{\alpha \beta k}) J(\Delta_{\alpha \beta k}) | X_{\alpha \beta k}|^2\]; where \(\Theta\) is the Heaviside function. The master equation is further simplified by the RWA, which makes the following matrix useful:. \[A_{\alpha \beta} = \sum_{k = -\infty}^\infty [\gamma_{\alpha \beta k} + n_{th}(|\Delta_{\alpha \beta k}|)(\gamma_{\alpha \beta k} + \gamma_{\alpha \beta -k})\]; The density matrix of the system then evolves according to:. \[\dot{\rho}_{\alpha \alpha}(t) = \sum_\nu (A_{\alpha \nu} \rho_{\nu \nu}(t) - A_{\nu \alpha} \rho_{\alpha \alpha} (t))\]. \[\dot{\rho}_{\alpha \beta}(t) = -\frac{1}{2} \sum_\nu (A_{\nu \alpha} + A_{\nu \beta}) \rho_{\alpha \beta}(t) \qquad \alpha \neq \beta\]. The Floquet-Markov master equation in QuTiP¶; The QuTiP function qutip.floquet.fmmesolve implements the Floquet-Markov master equation. It calculates the dynamics of a system given its initial state, a time-dependent Hamiltonian, a list of operators through which the system couples to its environment and a list of corresponding spectral-density functions that describes the environment. In contrast to the qutip.mesolve and qutip.mcsolve, and the qutip.floquet.fm",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-floquet.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-floquet.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:102,Deployability,Install,Installation,102,". Introduction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; n",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:3141,Deployability,update,updated,3141,"ystem Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; needed instead. When we are modeling an open system, or an ensemble; of systems, the use of the density matrix is mandatory.; Collapse operators are used to model the collapse of the state vector; that can occur when a measurement is performed.; The following tables lists some of the solvers QuTiP provides for dynamic quantum systems and indicates the type of object; returned by the solver:. QuTiP Solvers¶. Solver; Returns; Remarks. sesolve(); qutip.solver.Result; Unitary evolution, single system. mesolve(); qutip.solver.Result; Lindblad master eqn. or Von Neuman eqn. Density matrix. mcsolve(); qutip.solver.Result; Monte Carlo with collapse operators. essolve(); Array of expectation values; Exponential series with collapse operators. bloch_redfield_solve(); qutip.solver. floquet_markov_solve(); qutip.solver.Result; Floquet-Markov master equation. fmmesolve(); qutip.solver; Floquet-Markov master equation. smesolve(); qutip.solver.Result; Stochastic master equation. ssesolve(); qutip.solver.Result; Stochastic Schrödinger equation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:494,Integrability,depend,dependent,494,". Introduction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; n",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:1467,Modifiability,evolve,evolves,1467,"Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; needed instead. When we are modeling an open system, or an ensemble; of systems, the use of the density matrix is mandatory.; Collapse operators are used to model the collapse of the state vector; that can occur when a measurement is performed.; The following tables lists some of the solvers QuTiP provides for dynamic quantum systems and indicates the type of object; returned ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:2234,Performance,perform,performed,2234," in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; needed instead. When we are modeling an open system, or an ensemble; of systems, the use of the density matrix is mandatory.; Collapse operators are used to model the collapse of the state vector; that can occur when a measurement is performed.; The following tables lists some of the solvers QuTiP provides for dynamic quantum systems and indicates the type of object; returned by the solver:. QuTiP Solvers¶. Solver; Returns; Remarks. sesolve(); qutip.solver.Result; Unitary evolution, single system. mesolve(); qutip.solver.Result; Lindblad master eqn. or Von Neuman eqn. Density matrix. mcsolve(); qutip.solver.Result; Monte Carlo with collapse operators. essolve(); Array of expectation values; Exponential series with collapse operators. bloch_redfield_solve(); qutip.solver. floquet_markov_solve(); qutip.solver.Result; Floquet-Markov master equation. fmmesolve(); qutip.solver; Floquet-Markov master equation. smesolve(); qutip.solver.Result; Stochastic master equation. ssesolve(); qutip.solver.Result; Stochastic Schrödinger equation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built wit",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:1079,Testability,Log,Log,1079,"Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; needed instead. When we are modeling an open system, or an ensemble; of systems, the use of the densit",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:122,Usability,Guid,Guide,122,". Introduction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; n",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:129,Usability,Guid,Guide,129,". Introduction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; n",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html:1205,Usability,Guid,Guide,1205,"ucts and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Introduction. Introduction¶; Although in some cases, we want to find the stationary states of; a quantum system, often we are interested in the dynamics:; how the state of a system or an ensemble of systems evolves with time. QuTiP provides; many ways to model dynamics.; Broadly speaking, there are two categories; of dynamical models: unitary and non-unitary. In unitary evolution,; the state of the system remains normalized. In non-unitary, or; dissipative, systems, it does not.; There are two kinds of quantum systems: open systems that interact; with a larger environment and closed systems that do not.; In a closed system, the state can be described by a state vector,; although when there is entanglement a density matrix may be; needed instead. When we are modeling an open system, or an ensemble; of systems, the use of the density matrix is mandatory.; Collapse operators are used to model the collapse of the state vector; that can occur when a measurement is ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-intro.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:3080,Availability,error,error,3080,"t orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this can be easily corrected by restarting the subspace when the error reaches a certain threshold. Therefore, a series of \(M\) Krylov-subspace time evolutions provides accurate solutions for the complete time evolution. Within this scheme, the magic of Krylov resides not only in its ability to capture complex time evolutions from very large Hilbert spaces with very small dimenions \(M\), but also in the computing speed-up it presents.; For exceptional cases, the Lanczos algorithm might arrive at the exact evolution of the initial state at a dimension \(M_{hb}<M\). This is called a happy breakdown. For example, if a Hamiltonian has a symmetry subspace \(D_{\text{sim}}<M\), then the algorithm will optimize using the value math:M_{hb}<M:, at which the evolution is not only exact but also cheap. Krylov Solver in QuTiP¶; In QuTiP, Krylov-subspace evolution is implemented as the f",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:3111,Availability,error,error,3111,"n the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this can be easily corrected by restarting the subspace when the error reaches a certain threshold. Therefore, a series of \(M\) Krylov-subspace time evolutions provides accurate solutions for the complete time evolution. Within this scheme, the magic of Krylov resides not only in its ability to capture complex time evolutions from very large Hilbert spaces with very small dimenions \(M\), but also in the computing speed-up it presents.; For exceptional cases, the Lanczos algorithm might arrive at the exact evolution of the initial state at a dimension \(M_{hb}<M\). This is called a happy breakdown. For example, if a Hamiltonian has a symmetry subspace \(D_{\text{sim}}<M\), then the algorithm will optimize using the value math:M_{hb}<M:, at which the evolution is not only exact but also cheap. Krylov Solver in QuTiP¶; In QuTiP, Krylov-subspace evolution is implemented as the function qutip.krylovsolve. Arguments are nearly the same as qutip.mesol",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:3221,Availability,error,error,3221,")¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this can be easily corrected by restarting the subspace when the error reaches a certain threshold. Therefore, a series of \(M\) Krylov-subspace time evolutions provides accurate solutions for the complete time evolution. Within this scheme, the magic of Krylov resides not only in its ability to capture complex time evolutions from very large Hilbert spaces with very small dimenions \(M\), but also in the computing speed-up it presents.; For exceptional cases, the Lanczos algorithm might arrive at the exact evolution of the initial state at a dimension \(M_{hb}<M\). This is called a happy breakdown. For example, if a Hamiltonian has a symmetry subspace \(D_{\text{sim}}<M\), then the algorithm will optimize using the value math:M_{hb}<M:, at which the evolution is not only exact but also cheap. Krylov Solver in QuTiP¶; In QuTiP, Krylov-subspace evolution is implemented as the function qutip.krylovsolve. Arguments are nearly the same as qutip.mesolve; function for master-equation evolution, except that the initial state must be a k",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:103,Deployability,Install,Installation,103,". Krylov Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Sc",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:6859,Deployability,update,updated,6859,"= krylovsolve(H, psi0, tlist, krylov_dim=20, e_ops=e_ops); >>> plt.figure(); >>> for expect in results.expect:; >>> plt.plot(tlist, expect); >>> plt.legend(('jmat x', 'jmat y', 'jmat z')); >>> plt.xlabel('Time'); >>> plt.ylabel('Expectation values'); >>> plt.show(). Sparse and Dense Hamiltonians¶; If the Hamiltonian of interest is known to be sparse, qutip.krylovsolve also comes equipped with the possibility to store its internal data in a sparse optimized format using scipy. This allows for significant speed-ups, let’s showcase it:; >>> from qutip import krylovsolve, rand_herm, rand_ket; >>> import numpy as np; >>> from time import time; >>> def time_krylov(psi0, H, tlist, sparse):; >>> start = time(); >>> krylovsolve(H, psi0, tlist, krylov_dim=30, sparse=sparse); >>> end = time(); >>> return end - start; >>> dim = 2000; >>> tlist = np.linspace(0, 1, 10); >>> psi0 = rand_ket(dim, seed=0); >>> H_sparse = rand_herm(dim, density=0.1, seed=0); >>> H_dense = rand_herm(dim, density=0.9, seed=0); >>> # first index for type of H and second index for sparse = True or False (dense); >>> t_ss = time_krylov(psi0, H_sparse, tlist, sparse=True); >>> t_sd = time_krylov(psi0, H_sparse, tlist, sparse=False); >>> t_ds = time_krylov(psi0, H_dense, tlist, sparse=True); >>> t_dd = time_krylov(psi0, H_dense, tlist, sparse=False); >>> print(f""Average time of solution for a sparse H is {round((t_sd)/t_ss, 2)} faster for sparse=True in comparison to sparse=False""); >>> print(f""Average time of solution for a dense H is {round((t_dd)/t_ds, 2)} slower for sparse=True in comparison to sparse=False""); Average time of solution for a sparse H is 2.46 faster for sparse=True in comparison to sparse=False; Average time of solution for a dense H is 0.45 slower for sparse=True in comparison to sparse=False. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:2476,Energy Efficiency,reduce,reduced,2476,"s. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this can be easily corrected by restarting the subspace when the error reaches a certain threshold. Therefore, a series of \(M\) Krylov-subspace time evolutions provides accurate solutions for the complete time evolution. Within this scheme, the magic of Krylov resid",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:533,Integrability,depend,dependent,533,". Krylov Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Sc",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:1519,Modifiability,evolve,evolves,1519," Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:2160,Modifiability,evolve,evolved,2160,"Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this ca",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:3863,Performance,optimiz,optimize,3863," when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are practically impossible.; One of the biggest problems with this type of method is the control of the error. After a short time, the error starts to grow exponentially. However, this can be easily corrected by restarting the subspace when the error reaches a certain threshold. Therefore, a series of \(M\) Krylov-subspace time evolutions provides accurate solutions for the complete time evolution. Within this scheme, the magic of Krylov resides not only in its ability to capture complex time evolutions from very large Hilbert spaces with very small dimenions \(M\), but also in the computing speed-up it presents.; For exceptional cases, the Lanczos algorithm might arrive at the exact evolution of the initial state at a dimension \(M_{hb}<M\). This is called a happy breakdown. For example, if a Hamiltonian has a symmetry subspace \(D_{\text{sim}}<M\), then the algorithm will optimize using the value math:M_{hb}<M:, at which the evolution is not only exact but also cheap. Krylov Solver in QuTiP¶; In QuTiP, Krylov-subspace evolution is implemented as the function qutip.krylovsolve. Arguments are nearly the same as qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as opposed to a density matrix, and the additional parameter krylov_dim that defines the maximum allowed Krylov-subspace dimension. The maximum number of allowed Lanczos partitions can also be determined using the qutip.solver.options.nsteps parameter, which defaults to ‘10000’.; Let’s solve a simple example using the algorithm in QuTiP to get familiar with the method.; >>> from qutip import jmat, rand_ket, krylovsolve; >>> import numpy as np; >>> import matplotlib.pyplot as plt; >>> dim = 100; >>> e_ops = [jmat((dim - 1) / 2.0, ""x""), jmat((dim - 1) / 2.0, ""y""), jmat((dim - 1) / 2.0, ""z"")]; >>> H = .5*jmat((dim - 1) / 2.0, ""z"") + .5*jmat((di",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:5411,Performance,optimiz,optimized,5411,"os partitions can also be determined using the qutip.solver.options.nsteps parameter, which defaults to ‘10000’.; Let’s solve a simple example using the algorithm in QuTiP to get familiar with the method.; >>> from qutip import jmat, rand_ket, krylovsolve; >>> import numpy as np; >>> import matplotlib.pyplot as plt; >>> dim = 100; >>> e_ops = [jmat((dim - 1) / 2.0, ""x""), jmat((dim - 1) / 2.0, ""y""), jmat((dim - 1) / 2.0, ""z"")]; >>> H = .5*jmat((dim - 1) / 2.0, ""z"") + .5*jmat((dim - 1) / 2.0, ""x""); >>> psi0 = rand_ket(dim); >>> tlist = np.linspace(0.0, 10.0, 200); >>> results = krylovsolve(H, psi0, tlist, krylov_dim=20, e_ops=e_ops); >>> plt.figure(); >>> for expect in results.expect:; >>> plt.plot(tlist, expect); >>> plt.legend(('jmat x', 'jmat y', 'jmat z')); >>> plt.xlabel('Time'); >>> plt.ylabel('Expectation values'); >>> plt.show(). Sparse and Dense Hamiltonians¶; If the Hamiltonian of interest is known to be sparse, qutip.krylovsolve also comes equipped with the possibility to store its internal data in a sparse optimized format using scipy. This allows for significant speed-ups, let’s showcase it:; >>> from qutip import krylovsolve, rand_herm, rand_ket; >>> import numpy as np; >>> from time import time; >>> def time_krylov(psi0, H, tlist, sparse):; >>> start = time(); >>> krylovsolve(H, psi0, tlist, krylov_dim=30, sparse=sparse); >>> end = time(); >>> return end - start; >>> dim = 2000; >>> tlist = np.linspace(0, 1, 10); >>> psi0 = rand_ket(dim, seed=0); >>> H_sparse = rand_herm(dim, density=0.1, seed=0); >>> H_dense = rand_herm(dim, density=0.9, seed=0); >>> # first index for type of H and second index for sparse = True or False (dense); >>> t_ss = time_krylov(psi0, H_sparse, tlist, sparse=True); >>> t_sd = time_krylov(psi0, H_sparse, tlist, sparse=False); >>> t_ds = time_krylov(psi0, H_dense, tlist, sparse=True); >>> t_dd = time_krylov(psi0, H_dense, tlist, sparse=False); >>> print(f""Average time of solution for a sparse H is {round((t_sd)/t_ss, 2)} faster for",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:1118,Testability,Log,Log,1118,"iew; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in t",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:123,Usability,Guid,Guide,123,". Krylov Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Sc",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:130,Usability,Guid,Guide,130,". Krylov Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Sc",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:1244,Usability,Guid,Guide,1244,"n and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Introduction; Krylov Solver in QuTiP. Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\math",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:1913,Usability,simpl,simplest,1913,"Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Krylov Solver. Krylov Solver¶. Introduction¶; The Krylov-subspace method is a standard method to approximate quantum dynamics. Let \(\left|\psi\right\rangle\) be a state in a \(D\)-dimensional complex Hilbert space that evolves under a time-independent Hamiltonian \(H\). Then, the \(N\)-dimensional Krylov subspace associated with that state and Hamiltonian is given by. (1)¶\[\mathcal{K}_{N}=\operatorname{span}\left\{|\psi\rangle, H|\psi\rangle, \ldots, H^{N-1}|\psi\rangle\right\},\]; where the dimension \(N<D\) is a parameter of choice. To construct an orthonormal basis \(B_N\) for \(\mathcal{K}_{N}\), the simplest algorithm is the well-known Lanczos algorithm, which provides a sort of Gram-Schmidt procedure that harnesses the fact that orthonormalization needs to be imposed only for the last two vectors in the basis. Written in this basis the time-evolved state can be approximated as. (2)¶\[|\psi(t)\rangle=e^{-iHt}|\psi\rangle\approx\mathbb{P}_{N}e^{-iHt}\mathbb{P}_{N}|\psi\rangle=\mathbb{V}_{N}^{\dagger}e^{-iT_{N}t}\mathbb{V}_{N}|\psi\rangle\equiv\left|\psi_{N}(t)\right\rangle,\]; where \(T_{N}=\mathbb{V}_{N} H \mathbb{V}_{N}^{\dagger}\) is the Hamiltonian reduced to the Krylov subspace (which takes a tridiagonal matrix form), and \(\mathbb{V}_{N}^{\dagger}\) is the matrix containing the vectors of the Krylov basis as columns.; With the above approximation, the time-evolution is calculated only with a smaller square matrix of the desired size. Therefore, the Krylov method provides huge speed-ups in computation of short-time evolutions when the dimension of the Hamiltonian is very large, a point at which exact calculations on the complete subspace are pract",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html:4507,Usability,simpl,simple,4507,"ions \(M\), but also in the computing speed-up it presents.; For exceptional cases, the Lanczos algorithm might arrive at the exact evolution of the initial state at a dimension \(M_{hb}<M\). This is called a happy breakdown. For example, if a Hamiltonian has a symmetry subspace \(D_{\text{sim}}<M\), then the algorithm will optimize using the value math:M_{hb}<M:, at which the evolution is not only exact but also cheap. Krylov Solver in QuTiP¶; In QuTiP, Krylov-subspace evolution is implemented as the function qutip.krylovsolve. Arguments are nearly the same as qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as opposed to a density matrix, and the additional parameter krylov_dim that defines the maximum allowed Krylov-subspace dimension. The maximum number of allowed Lanczos partitions can also be determined using the qutip.solver.options.nsteps parameter, which defaults to ‘10000’.; Let’s solve a simple example using the algorithm in QuTiP to get familiar with the method.; >>> from qutip import jmat, rand_ket, krylovsolve; >>> import numpy as np; >>> import matplotlib.pyplot as plt; >>> dim = 100; >>> e_ops = [jmat((dim - 1) / 2.0, ""x""), jmat((dim - 1) / 2.0, ""y""), jmat((dim - 1) / 2.0, ""z"")]; >>> H = .5*jmat((dim - 1) / 2.0, ""z"") + .5*jmat((dim - 1) / 2.0, ""x""); >>> psi0 = rand_ket(dim); >>> tlist = np.linspace(0.0, 10.0, 200); >>> results = krylovsolve(H, psi0, tlist, krylov_dim=20, e_ops=e_ops); >>> plt.figure(); >>> for expect in results.expect:; >>> plt.plot(tlist, expect); >>> plt.legend(('jmat x', 'jmat y', 'jmat z')); >>> plt.xlabel('Time'); >>> plt.ylabel('Expectation values'); >>> plt.show(). Sparse and Dense Hamiltonians¶; If the Hamiltonian of interest is known to be sparse, qutip.krylovsolve also comes equipped with the possibility to store its internal data in a sparse optimized format using scipy. This allows for significant speed-ups, let’s showcase it:; >>> from qutip import krylovsolve, ra",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-krylov.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-krylov.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:121,Deployability,Install,Installation,121,". Lindblad Master Equation Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in ma",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:14626,Deployability,update,updated,14626,"equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding np.sqrt(0.05) * sigmax() in the fourth; parameter to the qutip.mesolve function and moving the expectation; operators [sigmaz(), sigmay()] to the fifth argument.; >>> times = np.linspace(0.0, 10.0, 100); >>> result = mesolve(H, psi0, times, [np.sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]); >>> fig, ax = plt.subplots(); >>> ax.plot(times, result.expect[0]) ; >>> ax.plot(times, result.expect[1]) ; >>> ax.set_xlabel('Time') ; >>> ax.set_ylabel('Expectation values') ; >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")) ; >>> plt.show() . Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process.; Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavity in a 5-photon Fock state, the dynamics is calculated with the lines following code; >>> times = np.linspace(0.0, 10.0, 200); >>> psi0 = tensor(fock(2,0), fock(10, 5)); >>> a = tensor(qeye(2), destroy(10)); >>> sm = tensor(destroy(2), qeye(10)); >>> H = 2 * np.pi * a.dag() * a + 2 * np.pi * sm.dag() * sm + 2 * np.pi * 0.25 * (sm * a.dag() + sm.dag() * a); >>> result = mesolve(H, psi0, times, [np.sqrt(0.1)*a], [a.dag()*a, sm.dag()*sm]); >>> plt.figure() ; >>> plt.plot(times, result.expect[0]) ; >>> plt.plot(times, result.expect[1]) ; >>> plt.xlabel('Time') ; >>> plt.ylabel('Expectation values') ; >>> plt.legend((""cavity photon number"", ""atom excitation probability"")) ; >>> plt.show() . Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:2901,Energy Efficiency,efficient,efficient,2901,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.sesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 =",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:6481,Energy Efficiency,energy,energy,6481,")]); >>> fig, ax = plt.subplots(); >>> ax.plot(result.times, result.expect[0]) ; >>> ax.plot(result.times, result.expect[1]) ; >>> ax.set_xlabel('Time') ; >>> ax.set_ylabel('Expectation values') ; >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")) ; >>> plt.show() . If an empty list of operators is passed as fourth parameter, the qutip.sesolve function returns a qutip.solver.Result instance that contains a list of state vectors for the times specified in times; >>> times = [0.0, 1.0]; >>> result = sesolve(H, psi0, times, []); >>> result.states ; [Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[1.]; [0.]], Quantum object: dims = [[2], [1]], shape = (2, 1), type = ket; Qobj data =; [[0.80901699+0.j ]; [0. -0.58778526j]]]. Non-unitary evolution¶; While the evolution of the state vector in a closed quantum system is deterministic, open quantum systems are stochastic in nature. The effect of an environment on the system of interest is to induce stochastic transitions between energy levels, and to introduce uncertainty in the phase difference between states of the system. The state of an open quantum system is therefore described in terms of ensemble averaged states using the density matrix formalism. A density matrix \(\rho\) describes a probability distribution of quantum states \(\left|\psi_n\right>\), in a matrix representation \(\rho = \sum_n p_n \left|\psi_n\right>\left<\psi_n\right|\), where \(p_n\) is the classical probability that the system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:8253,Energy Efficiency,reduce,reduced,8253,"acting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires:",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:10300,Energy Efficiency,energy,energy,10300," not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; mast",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:10882,Energy Efficiency,energy,energy,10882,"med a “short-memory environment” as it requires that environmental correlation functions decay on a time-scale fast compared to those of the system.; Secular approximation Stipulates that elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the function qutip.mesolve is used for both:; the evolution according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems) t",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:11095,Energy Efficiency,energy,energy,11095,"at elements in the master equation corresponding to transition frequencies satisfy \(|\omega_{ab}-\omega_{cd}| \ll 1/\tau_{\rm sys}\), i.e., all fast rotating terms in the interaction picture can be neglected. It also ignores terms that lead to a small renormalization of the system energy levels. This approximation is not strictly necessary for all master-equation formalisms (e.g., the Block-Redfield master equation), but it is required for arriving at the Lindblad form (3) which is used in qutip.mesolve. For systems with environments satisfying the conditions outlined above, the Lindblad master equation (3) governs the time-evolution of the system density matrix, giving an ensemble average of the system dynamics. In order to ensure that these approximations are not violated, it is important that the decay rates \(\gamma_n\) be smaller than the minimum energy splitting in the system Hamiltonian. Situations that demand special attention therefore include, for example, systems strongly coupled to their environment, and systems with degenerate or nearly degenerate energy levels.; For non-unitary evolution of a quantum systems, i.e., evolution that includes; incoherent processes such as relaxation and dephasing, it is common to use; master equations. In QuTiP, the function qutip.mesolve is used for both:; the evolution according to the Schrödinger equation and to the master equation,; even though these two equations of motion are very different. The qutip.mesolve; function automatically determines if it is sufficient to use the Schrödinger; equation (if no collapse operators were given) or if it has to use the; master equation (if collapse operators were given). Note that to calculate; the time evolution according to the Schrödinger equation is easier and much; faster (for large systems) than using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:12877,Energy Efficiency,energy,energy,12877,"an using the master equation, so if possible the; solver will fall back on using the Schrödinger equation.; What is new in the master equation compared to the Schrödinger equation are; processes that describe dissipation in the quantum system due to its interaction; with an environment. These environmental interactions are defined by the; operators through which the system couples to the environment, and rates that; describe the strength of the processes.; In QuTiP, the product of the square root of the rate and the operator that; describe the dissipation process is called a collapse operator. A list of; collapse operators (c_ops) is passed as the fourth argument to the; qutip.mesolve function in order to define the dissipation processes in the master; equation. When the c_ops isn’t empty, the qutip.mesolve function will use; the master equation instead of the unitary Schrödinger equation.; Using the example with the spin dynamics from the previous section, we can; easily add a relaxation process (describing the dissipation of energy from the; spin to its environment), by adding np.sqrt(0.05) * sigmax() in the fourth; parameter to the qutip.mesolve function and moving the expectation; operators [sigmaz(), sigmay()] to the fifth argument.; >>> times = np.linspace(0.0, 10.0, 100); >>> result = mesolve(H, psi0, times, [np.sqrt(0.05) * sigmax()], [sigmaz(), sigmay()]); >>> fig, ax = plt.subplots(); >>> ax.plot(times, result.expect[0]) ; >>> ax.plot(times, result.expect[1]) ; >>> ax.set_xlabel('Time') ; >>> ax.set_ylabel('Expectation values') ; >>> ax.legend((""Sigma-Z"", ""Sigma-Y"")) ; >>> plt.show() . Here, 0.05 is the rate and the operator \(\sigma_x\) (qutip.operators.sigmax) describes the dissipation; process.; Now a slightly more complex example: Consider a two-level atom coupled to a leaky single-mode cavity through a dipole-type interaction, which supports a coherent exchange of quanta between the two systems. If the atom initially is in its groundstate and the cavit",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:585,Integrability,depend,dependent,585,". Lindblad Master Equation Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in ma",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:3406,Modifiability,evolve,evolves,3406,"ynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.sesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 = basis(2, 0); >>> times = np.linspace(0.0, 10.0, 20); >>> result = sesolve(H, psi0, times, [sigmaz()]). See the next section for examples on how dissipation is included by defining a list of collapse operators and using qutip.mesolve instead.; The function qutip.sesolve returns an instance of qutip.solver.Result, as described in the previous section Dynamics Simulation Results. The attribute expect in result is a list of expectation values for the operators that are included in the list in the fourth argument. Adding operators to this list results in a larger output list returned by the function (one array of numbers, correspon",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:2331,Performance,perform,perform,2331,"ter Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) u",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:7963,Performance,perform,perform,7963,"system is in the quantum state \(\left|\psi_n\right>\). The time evolution of a density matrix \(\rho\) is the topic of the remaining portions of this section. The Lindblad Master equation¶; The standard approach for deriving the equations of motion for a system interacting with its environment is to expand the scope of the system to include the environment. The combined quantum system is then closed, and its evolution is governed by the von Neumann equation. (2)¶\[\dot \rho_{\rm tot}(t) = -\frac{i}{\hbar}[H_{\rm tot}, \rho_{\rm tot}(t)],\]; the equivalent of the Schrödinger equation (1) in the density matrix formalism. Here, the total Hamiltonian. \[H_{\rm tot} = H_{\rm sys} + H_{\rm env} + H_{\rm int},\]; includes the original system Hamiltonian \(H_{\rm sys}\), the Hamiltonian for the environment \(H_{\rm env}\), and a term representing the interaction between the system and its environment \(H_{\rm int}\). Since we are only interested in the dynamics of the system, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculati",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:8939,Performance,perform,perform,8939,"ystem, we can at this point perform a partial trace over the environmental degrees of freedom in Eq. (2), and thereby obtain a master equation for the motion of the original system density matrix. The most general trace-preserving and completely positive form of this evolution is the Lindblad master equation for the reduced density matrix \(\rho = {\rm Tr}_{\rm env}[\rho_{\rm tot}]\). (3)¶\[\dot\rho(t)=-\frac{i}{\hbar}[H(t),\rho(t)]+\sum_n \frac{1}{2} \left[2 C_n \rho(t) C_n^\dagger - \rho(t) C_n^\dagger C_n - C_n^\dagger C_n \rho(t)\right]\]; where the \(C_n = \sqrt{\gamma_n} A_n\) are collapse operators, and \(A_n\) are the operators through which the environment couples to the system in \(H_{\rm int}\), and \(\gamma_n\) are the corresponding rates. The derivation of Eq. (3) may be found in several sources, and will not be reproduced here. Instead, we emphasize the approximations that are required to arrive at the master equation in the form of Eq. (3) from physical arguments, and hence perform a calculation in QuTiP:. Separability: At \(t=0\) there are no correlations between the system and its environment such that the total density matrix can be written as a tensor product \(\rho^I_{\rm tot}(0) = \rho^I(0) \otimes \rho^I_{\rm env}(0)\).; Born approximation: Requires: (1) that the state of the environment does not significantly change as a result of the interaction with the system; (2) The system and the environment remain separable throughout the evolution. These assumptions are justified if the interaction is weak, and if the environment is much larger than the system. In summary, \(\rho_{\rm tot}(t) \approx \rho(t)\otimes\rho_{\rm env}\).; Markov approximation The time-scale of decay for the environment \(\tau_{\rm env}\) is much shorter than the smallest time-scale of the system dynamics \(\tau_{\rm sys} \gg \tau_{\rm env}\). This approximation is often deemed a “short-memory environment” as it requires that environmental correlation functions decay on a tim",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:2915,Security,access,accessible,2915,"ses it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perform this diagonalization unless the size of the Hilbert space (dimension of the matrix \(H\)) is small. Analytically, it is a formidable task to calculate the dynamics for systems with more than two states. If, in addition, we consider dissipation due to the inevitable interaction with a surrounding environment, the computational complexity grows even larger, and we have to resort to numerical calculations in all realistic situations. This illustrates the importance of numerical calculations in describing the dynamics of open quantum systems, and the need for efficient and accessible tools for this task.; The Schrödinger equation, which governs the time-evolution of closed quantum systems, is defined by its Hamiltonian and state vector. In the previous section, Using Tensor Products and Partial Traces, we showed how Hamiltonians and state vectors are constructed in QuTiP. Given a Hamiltonian, we can calculate the unitary (non-dissipative) time-evolution of an arbitrary state vector \(\left|\psi_0\right>\) (psi0) using the QuTiP function qutip.sesolve. It evolves the state vector and evaluates the expectation values for a set of operators expt_ops at the points in time in the list times, using an ordinary differential equation solver.; For example, the time evolution of a quantum spin-1/2 system with tunneling rate 0.1 that initially is in the up state is calculated, and the expectation values of the \(\sigma_z\) operator evaluated, with the following code; >>> H = 2*np.pi * 0.1 * sigmax(); >>> psi0 =",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:1170,Testability,Log,Log,1170,"bjects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:141,Usability,Guid,Guide,141,". Lindblad Master Equation Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in ma",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:148,Usability,Guid,Guide,148,". Lindblad Master Equation Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in ma",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html:1296,Usability,Guid,Guide,1296,"; Dynamics Simulation Results; Lindblad Master Equation Solver; Unitary evolution; Non-unitary evolution; The Lindblad Master equation. Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Lindblad Master Equation Solver. Lindblad Master Equation Solver¶. Unitary evolution¶; The dynamics of a closed (pure) quantum system is governed by the Schrödinger equation. (1)¶\[ i\hbar\frac{\partial}{\partial t}\Psi = \hat H \Psi,\]; where \(\Psi\) is the wave function, \(\hat H\) the Hamiltonian, and \(\hbar\) is Planck’s constant. In general, the Schrödinger equation is a partial differential equation (PDE) where both \(\Psi\) and \(\hat H\) are functions of space and time. For computational purposes it is useful to expand the PDE in a set of basis functions that span the Hilbert space of the Hamiltonian, and to write the equation in matrix and vector form. \[i\hbar\frac{d}{dt}\left|\psi\right> = H \left|\psi\right>\]; where \(\left|\psi\right>\) is the state vector and \(H\) is the matrix representation of the Hamiltonian. This matrix equation can, in principle, be solved by diagonalizing the Hamiltonian matrix \(H\). In practice, however, it is difficult to perf",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-master.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-master.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:7997,Availability,error,errors,7997," are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; ntraj = [1, 10, 100, 1000]. Keep in mind that the input ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:9637,Availability,avail,available,9637,"er 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; ntraj = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reu",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:10008,Availability,down,down,10008," = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qey",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:108,Deployability,Install,Installation,108,". Monte Carlo Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:1653,Deployability,continuous,continuously,1653,"ions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)¶\[\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2). If the environmental ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:3852,Deployability,Integrat,Integrate,3852,"d by projecting \(\left|\psi(t)\right>\) using the collapse operator \(C_{n}\) corresponding to the measurement. (3)¶\[\left|\psi(t+\delta t)\right>=C_{n}\left|\psi(t)\right>/\left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right>^{1/2}.\]; If more than a single collapse operator is present in Eq. (1), the probability of collapse due to the \(i\mathrm{th}\)-operator \(C_{i}\) is given by. (4)¶\[P_{i}(t)=\left<\psi(t)|C_{i}^{+}C_{i}|\psi(t)\right>/\delta p.\]; Evaluating the MC evolution to first-order in time is quite tedious. Instead, QuTiP uses the following algorithm to simulate a single realization of a quantum system. Starting from a pure state \(\left|\psi(0)\right>\):. Ia: Choose a random number \(r_1\) between zero and one, representing the probability that a quantum jump occurs.; Ib: Choose a random number \(r_2\) between zero and one, used to select which collapse operator was responsible for the jump.; II: Integrate the Schrödinger equation, using the effective Hamiltonian (1) until a time \(\tau\) such that the norm of the wave function satisfies \(\left<\psi(\tau)\right.\left|\psi(\tau)\right> = r_1\), at which point a jump occurs.; III: The resultant jump projects the system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r_2\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:10359,Deployability,configurat,configuration,10359,"data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:12169,Deployability,update,updated,12169," cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H, psi1, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], options=opts). plt.figure(); plt.plot(times, data1.expect[0], times, data1.expect[1], lw=2); plt.plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); plt.title('Monte Carlo time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:1666,Energy Efficiency,monitor,monitored,1666,"ions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of the wave function, that to first-order in a small time \(\delta t\), is given by \(\left<\psi(t+\delta t)|\psi(t+\delta t)\right>=1-\delta p\) where. (2)¶\[\delta p =\delta t \sum_{n}\left<\psi(t)|C^{+}_{n}C_{n}|\psi(t)\right>,\]; and \(\delta t\) is such that \(\delta p \ll 1\). With a probability of remaining in the state \(\left|\psi(t+\delta t)\right>\) given by \(1-\delta p\), the corresponding quantum jump probability is thus Eq. (2). If the environmental ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:6997,Energy Efficiency,efficient,efficient,6997,"how(). The advantage of the Monte Carlo method over the master equation approach is that only the state vector is required to be kept in the computers memory, as opposed to the entire density matrix. For large quantum system this becomes a significant advantage, and the Monte Carlo solver is therefore generally recommended for such systems. For example, simulating a Heisenberg spin-chain consisting of 10 spins with random parameters and initial states takes almost 7 times longer using the master equation rather than Monte Carlo approach with the default number of trajectories running on a quad-CPU machine. Furthermore, it takes about 7 times the memory as well. However, for small systems, the added overhead of averaging a large number of stochastic trajectories to obtain the open system dynamics, as well as starting the multiprocessing functionality, outweighs the benefit of the minor (in this case) memory saving. Master equation methods are therefore generally more efficient when Hilbert space sizes are on the order of a couple of hundred states or smaller.; Like the master equation solver qutip.mesolve, the Monte Carlo solver returns a qutip.solver.Result object consisting of expectation values, if the user has defined expectation value operators in the 5th argument to mcsolve, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:536,Integrability,depend,dependent,536,". Monte Carlo Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:3852,Integrability,Integrat,Integrate,3852,"d by projecting \(\left|\psi(t)\right>\) using the collapse operator \(C_{n}\) corresponding to the measurement. (3)¶\[\left|\psi(t+\delta t)\right>=C_{n}\left|\psi(t)\right>/\left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right>^{1/2}.\]; If more than a single collapse operator is present in Eq. (1), the probability of collapse due to the \(i\mathrm{th}\)-operator \(C_{i}\) is given by. (4)¶\[P_{i}(t)=\left<\psi(t)|C_{i}^{+}C_{i}|\psi(t)\right>/\delta p.\]; Evaluating the MC evolution to first-order in time is quite tedious. Instead, QuTiP uses the following algorithm to simulate a single realization of a quantum system. Starting from a pure state \(\left|\psi(0)\right>\):. Ia: Choose a random number \(r_1\) between zero and one, representing the probability that a quantum jump occurs.; Ib: Choose a random number \(r_2\) between zero and one, used to select which collapse operator was responsible for the jump.; II: Integrate the Schrödinger equation, using the effective Hamiltonian (1) until a time \(\tau\) such that the norm of the wave function satisfies \(\left<\psi(\tau)\right.\left|\psi(\tau)\right> = r_1\), at which point a jump occurs.; III: The resultant jump projects the system at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r_2\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:11974,Integrability,depend,dependent,11974," cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H, psi1, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], options=opts). plt.figure(); plt.plot(times, data1.expect[0], times, data1.expect[1], lw=2); plt.plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); plt.title('Monte Carlo time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:12029,Integrability,depend,dependent,12029," cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H, psi1, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], options=opts). plt.figure(); plt.plot(times, data1.expect[0], times, data1.expect[1], lw=2); plt.plot(times, data2.expect[0], '--', times, data2.expect[1], '--', lw=2); plt.title('Monte Carlo time evolution'); plt.xlabel('Time', fontsize=14); plt.ylabel('Expectation values', fontsize=14); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). In addition to the initial state, one may reuse the Hamiltonian data when changing the number of trajectories ntraj or simulation times times. The reusing of Hamiltonian data is also supported for time-dependent Hamiltonians. See Solving Problems with Time-dependent Hamiltonians for further details. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:10359,Modifiability,config,configuration,10359,"data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)). H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data1 = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]); psi1 = tensor(fock(2, 0), coherent(10, 2 - 1j)); opts = Options(rhs_reuse=True) # Run a second time, reusing RHS; data2 = mcsolve(H",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:5156,Performance,perform,performed,5156,"ystem at time \(\tau\) into one of the renormalized states given by Eq. (3). The corresponding collapse operator \(C_{n}\) is chosen such that \(n\) is the smallest integer satisfying:. (5)¶\[\sum_{i=1}^{n} P_{n}(\tau) \ge r_2\]; where the individual \(P_{n}\) are given by Eq. (4). Note that the left hand side of Eq. (5) is, by definition, normalized to unity. IV: Using the renormalized state from step III as the new initial condition at time \(\tau\), draw a new random number, and repeat the above procedure until the final simulation time is reached. Monte Carlo in QuTiP¶; In QuTiP, Monte Carlo evolution is implemented with the qutip.mcsolve function. It takes nearly the same arguments as the qutip.mesolve; function for master-equation evolution, except that the initial state must be a ket vector, as oppose to a density matrix, and there is an optional keyword parameter ntraj that defines the number of stochastic trajectories to be simulated. By default, ntraj=500 indicating that 500 Monte Carlo trajectories will be performed.; To illustrate the use of the Monte Carlo evolution of quantum systems in QuTiP, let’s again consider the case of a two-level atom coupled to a leaky cavity. The only differences to the master-equation treatment is that in this case we invoke the qutip.mcsolve function instead of qutip.mesolve; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qeye(2), destroy(10)); sm = tensor(destroy(2), qeye(10)); H = 2*np.pi*a.dag()*a + 2*np.pi*sm.dag()*sm + 2*np.pi*0.25*(sm*a.dag() + sm.dag()*a); data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm]). plt.figure(); plt.plot(times, data.expect[0], times, data.expect[1]); plt.title('Monte Carlo time evolution'); plt.xlabel('Time'); plt.ylabel('Expectation values'); plt.legend((""cavity photon number"", ""atom excitation probability"")); plt.show(). The advantage of the Monte Carlo method over the master equation approach is that only the state vec",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:1121,Testability,Log,Log,1121,"rview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible pr",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:128,Usability,Guid,Guide,128,". Monte Carlo Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:135,Usability,Guid,Guide,135,". Monte Carlo Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:1247,Usability,Guid,Guide,1247," and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Introduction; Monte Carlo in QuTiP. Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Monte Carlo Solver. Monte Carlo Solver¶. Introduction¶; Where as the density matrix formalism describes the ensemble average over many identical realizations of a quantum system, the Monte Carlo (MC), or quantum-jump approach to wave function evolution, allows for simulating an individual realization of the system dynamics. Here, the environment is continuously monitored, resulting in a series of quantum jumps in the system wave function, conditioned on the increase in information gained about the state of the system via the environmental measurements. In general, this evolution is governed by the Schrödinger equation with a non-Hermitian effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}-\frac{i\hbar}{2}\sum_{i}C^{+}_{n}C_{n},\]; where again, the \(C_{n}\) are collapse operators, each corresponding to a separate irreversible process with rate \(\gamma_{n}\). Here, the strictly negative non-Hermitian portion of Eq. (1) gives rise to a reduction in the norm of t",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:8309,Usability,simpl,simply,8309,"e, or state vectors if no expectation value operators are given. If state vectors are returned, then the qutip.solver.Result returned by qutip.mcsolve will be an array of length ntraj, with each element containing an array of ket-type qobjs with the same number of elements as times. Furthermore, the output qutip.solver.Result object will also contain a list of times at which collapse occurred, and which collapse operators did the collapse, in the col_times and col_which properties, respectively. Changing the Number of Trajectories¶; As mentioned earlier, by default, the mcsolve function runs 500 trajectories. This value was chosen because it gives good accuracy, Monte Carlo errors scale as \(1/n\) where \(n\) is the number of trajectories, and simultaneously does not take an excessive amount of time to run. However, like many other options in QuTiP you are free to change the number of trajectories to fit your needs. If we want to run 1000 trajectories in the above example, we can simply modify the call to mcsolve like:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=1000). where we have added the keyword argument ntraj=1000 at the end of the inputs. Now, the Monte Carlo solver will calculate expectation values for both operators, a.dag() * a, sm.dag() * sm averaging over 1000 trajectories. Sometimes one is also interested in seeing how the Monte Carlo trajectories converge to the master equation solution by calculating expectation values over a range of trajectory numbers. If, for example, we want to average over 1, 10, 100, and 1000 trajectories, then we can input this into the solver using:; ntraj = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html:10018,Usability,simpl,simpler,10018," = [1, 10, 100, 1000]. Keep in mind that the input list must be in ascending order since the total number of trajectories run by mcsolve will be calculated using the last element of ntraj. In this case, we need to use an extra index when getting the expectation values from the qutip.solver.Result object returned by mcsolve. In the above example using:; data = mcsolve(H, psi0, times, [np.sqrt(0.1) * a], [a.dag() * a, sm.dag() * sm], ntraj=[1, 10, 100, 1000]). we can extract the relevant expectation values using:; expt1 = data.expect[0]; expt10 = data.expect[1]; expt100 = data.expect[2]; expt1000 = data.expect[3]. The Monte Carlo solver also has many available options that can be set using the qutip.solver.Options class as discussed in Setting Options for the Dynamics Solvers. Reusing Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. In order to solve a given simulation as fast as possible, the solvers in QuTiP take the given input operators and break them down into simpler components before passing them on to the ODE solvers. Although these operations are reasonably fast, the time spent organizing data can become appreciable when repeatedly solving a system over, for example, many different initial conditions. In cases such as this, the Hamiltonian and other operators may be reused after the initial configuration, thus speeding up calculations. Note that, unless you are planning to reuse the data many times, this functionality will not be very useful.; To turn on the “reuse” functionality we must set the rhs_reuse=True flag in the qutip.solver.Options:; options = Options(rhs_reuse=True). A full account of this feature is given in Setting Options for the Dynamics Solvers. Using the previous example, we will calculate the dynamics for two different initial states, with the Hamiltonian data being reused on the second call; times = np.linspace(0.0, 10.0, 200); psi0 = tensor(fock(2, 0), fock(10, 5)); a = tensor(qey",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-monte.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-monte.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:2276,Availability,toler,tolerance,2276,ystem Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state,MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:2316,Availability,toler,tolerance,2316,e Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the s,MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:3549,Availability,Toler,Tolerance,3549,".first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you inp",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:4303,Availability,toler,tolerance,4303,"options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; print(options). Output:; Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_li",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:130,Deployability,Install,Installation,130,. Setting Options for the Dynamics Solvers — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_wi,MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:3383,Deployability,install,installed,3383,"options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:4045,Deployability,install,installed,4045,"rices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; print(options). Output:; Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new s",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:5645,Deployability,update,updated,5645,"False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; print(options). Output:; Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:522,Integrability,depend,dependent,522,. Setting Options for the Dynamics Solvers — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_wi,MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:3141,Integrability,depend,dependent,3141,hese properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute tolerance. options.rtol; 1e-6; Relative tolerance. options.method; ‘adams’; Solver method. Can be ‘adams’ (non-stiff) or ‘bdf’ (stiff). options.order; 12; Order of solver. Must be <=12 for ‘adams’ and <=5 for ‘bdf’. options.nsteps; 1000; Max. number of steps to take for each interval. options.first_step; 0; Size of initial step. 0 = determined automatically by solver. options.min_step; 0; Minimum step size. 0 = determined automatically by solver. options.max_step; 0; Maximum step size. 0 = determined automatically by solver. options.tidy; True; Whether to run tidyup function on time-independent Hamiltonian. options.store_final_state; False; Whether or not to store the final state of the evolution. options.store_states; False; Whether or not to store the state vectors or density matrices. options.rhs_filename; None; RHS filename when using compiled time-dependent Hamiltonians. options.rhs_reuse; False; Reuse compiled RHS function. Useful for repetitive tasks. options.rhs_with_state; False; Whether or not to include the state in the Hamiltonian; function callback signature. options.num_cpus; installed num; of processors; Integer number of cpus used by mcsolve. options.seeds; None; Array containing random number seeds for mcsolver. options.norm_tol; 1e-6; Tolerance used when finding wavefunction norm in mcsolve. options.norm_steps; 5; Max. number of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_open,MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:4645,Modifiability,variab,variable,4645,"er of steps used to find wavefunction’s norm to within; norm_tol in mcsolve. options.steady_state_average; False; Include an estimation of the steady state in mcsolve. options.ntraj; 500; Number of trajectories in stochastic solvers. options.average_expect; True; Average expectation values over trajectories. options.average_states; False; Average of the states over trajectories. options.openmp_threads; installed num; of processors; Number of OPENMP threads to use. options.use_openmp; None; Use OPENMP for sparse matrix vector multiplication. As an example, let us consider changing the number of processors used, turn the GUI off, and strengthen the absolute tolerance. There are two equivalent ways to do this using the Options class. First way,; options = Options(); options.num_cpus = 3; options.atol = 1e-10. or one can use an inline method,; options = Options(num_cpus=4, atol=1e-10). Note that the order in which you input the options does not matter. Using either method, the resulting options variable is now:; print(options). Output:; Options:; -----------; atol: 1e-10; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 4; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. To use these new settings we can use the keyword argument options in either the func:qutip.mesolve and qutip.mcsolve function. We can modify the last example as:; >>> mesolve(H0, psi0, tlist, c_op_list, [sigmaz()], options=options); >>> mesolve(hamiltonian_t, psi0, tlist, c_op_list, [sigmaz()], H_args, options=options). or:; >>> mcsolve(H0, psi0, tlist, ntraj,c_op_list, [sigmaz()], options=options); >>> mcsolve(hamiltonian_t, psi0, tlist, ntraj, c_op_list, [sigmaz()], H_args, options=options). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:1107,Testability,Log,Log,1107,Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These pr,MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:150,Usability,Guid,Guide,150,. Setting Options for the Dynamics Solvers — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_wi,MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:157,Usability,Guid,Guide,157,. Setting Options for the Dynamics Solvers — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_wi,MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html:1233,Usability,Guid,Guide,1233,al Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Setting Options for the Dynamics Solvers. Setting Options for the Dynamics Solvers¶; Occasionally it is necessary to change the built in parameters of the dynamics solvers used by for example the qutip.mesolve and qutip.mcsolve functions. The options for all dynamics solvers may be changed by using the Options class qutip.solver.Options.; options = Options(). the properties and default values of this class can be view via the print function:; print(options). Output:; Options:; -----------; atol: 1e-08; rtol: 1e-06; method: adams; order: 12; nsteps: 1000; first_step: 0; min_step: 0; max_step: 0; tidy: True; num_cpus: 2; norm_tol: 0.001; norm_steps: 5; rhs_filename: None; rhs_reuse: False; seeds: 0; rhs_with_state: False; average_expect: True; average_states: False; ntraj: 500; store_states: False; store_final_state: False. These properties are detailed in the following table. Assuming options = Options():. Property; Default setting; Description. options.atol; 1e-8; Absolute ,MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-options.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-options.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:122,Deployability,Install,Installation,122,". Stochastic Solver - Photocurrent — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:1502,Deployability,continuous,continuous,1502," Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of t",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:2573,Deployability,integrat,integrates,2573," system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:4310,Deployability,update,updated,4310,"a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (6)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (7)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:3276,Energy Efficiency,efficient,efficient,3276,"ability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (6)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (7)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP develo",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:542,Integrability,depend,dependent,542,". Stochastic Solver - Photocurrent — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:2573,Integrability,integrat,integrates,2573," system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:1580,Modifiability,evolve,evolve,1580,"ield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly int",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:1671,Modifiability,evolve,evolve,1671,"al Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state accor",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:2672,Modifiability,evolve,evolves,2672,"he system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small \(\delta p << 1\). If multiple jumps happen at the; same time step, the state become unphysical.; Each jump result in a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:3485,Modifiability,evolve,evolves,3485,"a sharp variation of the state by,. (3)¶\[\delta \psi = \left( \frac{C_n \psi} {\left| C_n \psi \right|} - \psi \right)\]; The basic photocurrent method directly integrates these equations to the first-order.; Starting from a state \(\left|\psi(0)\right>\), it evolves the state according to. (4)¶\[\delta \psi(t) = - i H_{\rm sys} \psi(t) \delta t + \sum_n \left(; -\frac{C_n^{+} C_n}{2} \psi(t) \delta t; + \frac{ \left| C_n \psi \right| ^2}{2} \delta t; + \delta N_n \left( \frac{C_n \psi}; {\left| C_n \psi \right|} - \psi \right)\right),\]; for each time-step.; Here \(\delta N = 1\) with a probability of \(\delta \omega\) and; \(\delta N_n = 0\) with a probability of \(1-\delta \omega\).; Trajectories obtained with this algorithm are equivalent to those obtained with; monte-carlo evolution (up to \(O(\delta t^2)\)).; In most cases, qutip.mcsolve is more efficient than; qutip.stochastic.photocurrent_sesolve. Open system¶; Photocurrent approach allows to obtain trajectories for a system with; both measured and dissipative interaction with the bath.; The system evolves according to the master equation between jumps with a modified; liouvillian. (5)¶\[L_{\rm eff}(\rho(t)) = L_{\rm sys}(\rho(t)) +; \sum_{n}\left(; \rm{tr} \left(C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right); - C_{n}^{+}C_{n} \rho C_{n}^{+}C_{n} \right),\]; with the probability of jumps in a time step \(\delta t\) given by. (6)¶\[\delta p = \rm{tr} \left( C \rho C^{+} \right) \delta t.\]; After a jump, the density matrix become. \[\rho' = \frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)}.\]; The evolution of the system at each time step if thus given by. (7)¶\[\rho(t + \delta t) = \rho(t) + L_{\rm eff}(\rho) \delta t + \delta N; \left(\frac{C \rho C^{+}}{\rm{tr} \left( C \rho C^{+} \right)} - \rho \right).\]. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:1127,Testability,Log,Log,1127,"uide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:142,Usability,Guid,Guide,142,". Stochastic Solver - Photocurrent — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:149,Usability,Guid,Guide,149,". Stochastic Solver - Photocurrent — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html:1253,Usability,Guid,Guide,1253,"n and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Closed system; Open system. Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver - Photocurrent. Stochastic Solver - Photocurrent¶; Photocurrent method, like monte-carlo method, allows for simulating an; individual realization of the system evolution under continuous measurement. Closed system¶; Photocurrent evolution have the state evolve deterministically between quantum jumps.; During the deterministic part, the system evolve by schrodinger equation with a; non-hermitian, norm conserving effective Hamiltonian. (1)¶\[H_{\rm eff}=H_{\rm sys}+; \frac{i\hbar}{2}\left( -\sum_{n}C^{+}_{n}C_{n}+ |C_{n} \psi |^2\right).\]; With \(C_{n}\), the collapse operators.; This effective Hamiltonian is equivalent to the monte-carlo effective; Hamiltonian with an extra term to keep the state normalized.; At each time step of \(\delta t\), the wave function has a probability. (2)¶\[\delta p_{n} = \left<\psi(t)|C_{n}^{+}C_{n}|\psi(t)\right> \delta t\]; of making a quantum jump. \(\delta t\) must be chosen small enough to keep; that probability small",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-photocurrent.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-photocurrent.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:115,Deployability,Install,Installation,115,"﻿. Permutational Invariance — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:7712,Deployability,update,updated,7712,"ke basis; ground(N); The ground state in the Dicke basis. GHZ-state density matrix in the Dicke basis; ghz(N); The GHZ-state density matrix in the Dicke (default) basis for N number of TLS. Collapse operators of the ensemble; Dicke.c_ops(); The collapse operators for the ensemble can be called by the c_ops method of the Dicke class. Note that the mathematical object representing the density matrix of the full system that is manipulated (or obtained from steadystate) in the Dicke-basis formalism used here is a representative of the density matrix. This representative object is of linear size N^2, whereas the full density matrix is defined over a 2^N Hilbert space. In order to calculate nonlinear functions of such density matrix, such as the Von Neumann entropy or the purity, it is necessary to take into account the degeneracy of each block of such block-diagonal density matrix. Note that as long as one calculates expected values of operators, being Tr[A*rho] a linear function of rho, the representative density matrix give straightforwardly the correct result. When a nonlinear function of the density matrix needs to be calculated, one needs to weigh each degenerate block correctly; this is taken care by the dicke_function_trace in qutip.piqs, and the user can use it to define general nonlinear functions that can be described as the trace of a Taylor expandable function. Two nonlinear functions that use dicke_function_trace and are already implemented are purity_dicke, to calculate the purity of a density matrix in the Dicke basis, and entropy_vn_dicke, which can be used to calculate the Von Neumann entropy.; More functions relative to the qutip.piqs module can be found at API documentation. Attributes to the qutip.piqs.Dicke and qutip.piqs.Pim class can also be found there. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:507,Integrability,depend,dependent,507,"﻿. Permutational Invariance — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:1139,Testability,Log,Log,1139,"c Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; Consider a system evolving according to the equation. \[ \begin{align}\begin{aligned}\dot{\rho} = \mathcal{D}_\text{TLS}(\rho)=-\frac{i}{\hbar}\lbrack H,\rho \rb",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:135,Usability,Guid,Guide,135,"﻿. Permutational Invariance — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:142,Usability,Guid,Guide,142,"﻿. Permutational Invariance — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:1265,Usability,Guid,Guide,1265,"ystem Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Permutational Invariant Quantum Solver (PIQS). Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Permutational Invariance. Permutational Invariance¶. Permutational Invariant Quantum Solver (PIQS)¶; The Permutational Invariant Quantum Solver (PIQS) is a QuTiP module that allows to study the dynamics of an open quantum system consisting of an ensemble of identical qubits that can dissipate through local and collective baths according to a Lindblad master equation.; The Liouvillian of an ensemble of \(N\) qubits, or two-level systems (TLSs), \(\mathcal{D}_{TLS}(\rho)\), can be built using only polynomial – instead of exponential – resources.; This has many applications for the study of realistic quantum optics models of many TLSs and in general as a tool in cavity QED.; Consider a system evolving according to the equation. \[ \begin{align}\begin{aligned}\dot{\rho} = \mathcal{D}_\text{TLS}(\rho)=-\frac{i}{\hbar}\lbrack H,\rho \rbrack; +\frac{\gamma_\text{CE}}{2}\mathcal{L}_{J_{-}}[\rho]; +\frac{\gamma_\text{CD}}{2}\mathcal{L}_{J_{z}}[\rho]; +\frac{\gamma_\text{CP}}",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:3277,Usability,simpl,simply,3277,"{2}\mathcal{L}_{J_{+}}[\rho]\\+\sum_{n=1}^{N}\left(; \frac{\gamma_\text{E}}{2}\mathcal{L}_{J_{-,n}}[\rho]; +\frac{\gamma_\text{D}}{2}\mathcal{L}_{J_{z,n}}[\rho]; +\frac{\gamma_\text{P}}{2}\mathcal{L}_{J_{+,n}}[\rho]\right)\end{aligned}\end{align} \]; where \(J_{\alpha,n}=\frac{1}{2}\sigma_{\alpha,n}\) are SU(2) Pauli spin operators, with \({\alpha=x,y,z}\) and \(J_{\pm,n}=\sigma_{\pm,n}\). The collective spin operators are \(J_{\alpha} = \sum_{n}J_{\alpha,n}\) . The Lindblad super-operators are \(\mathcal{L}_{A} = 2A\rho A^\dagger - A^\dagger A \rho - \rho A^\dagger A\).; The inclusion of local processes in the dynamics lead to using a Liouvillian space of dimension \(4^N\). By exploiting the permutational invariance of identical particles [2-8], the Liouvillian \(\mathcal{D}_\text{TLS}(\rho)\) can be built as a block-diagonal matrix in the basis of Dicke states \(|j, m \rangle\).; The system under study is defined by creating an object of the; Dicke class, e.g. simply named; system, whose first attribute is. system.N, the number of TLSs of the system \(N\). The rates for collective and local processes are simply defined as. collective_emission defines \(\gamma_\text{CE}\), collective (superradiant) emission; collective_dephasing defines \(\gamma_\text{CD}\), collective dephasing; collective_pumping defines \(\gamma_\text{CP}\), collective pumping.; emission defines \(\gamma_\text{E}\), incoherent emission (losses); dephasing defines \(\gamma_\text{D}\), local dephasing; pumping defines \(\gamma_\text{P}\), incoherent pumping. Then the system.lindbladian() creates the total TLS Lindbladian superoperator matrix. Similarly, system.hamiltonian defines the TLS hamiltonian of the system \(H_\text{TLS}\).; The system’s Liouvillian can be built using system.liouvillian(). The properties of a Piqs object can be visualized by simply calling; system. We give two basic examples on the use of PIQS. In the first example the incoherent emission of N driven TLSs is considered.; fr",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:3424,Usability,simpl,simply,3424,"\frac{\gamma_\text{D}}{2}\mathcal{L}_{J_{z,n}}[\rho]; +\frac{\gamma_\text{P}}{2}\mathcal{L}_{J_{+,n}}[\rho]\right)\end{aligned}\end{align} \]; where \(J_{\alpha,n}=\frac{1}{2}\sigma_{\alpha,n}\) are SU(2) Pauli spin operators, with \({\alpha=x,y,z}\) and \(J_{\pm,n}=\sigma_{\pm,n}\). The collective spin operators are \(J_{\alpha} = \sum_{n}J_{\alpha,n}\) . The Lindblad super-operators are \(\mathcal{L}_{A} = 2A\rho A^\dagger - A^\dagger A \rho - \rho A^\dagger A\).; The inclusion of local processes in the dynamics lead to using a Liouvillian space of dimension \(4^N\). By exploiting the permutational invariance of identical particles [2-8], the Liouvillian \(\mathcal{D}_\text{TLS}(\rho)\) can be built as a block-diagonal matrix in the basis of Dicke states \(|j, m \rangle\).; The system under study is defined by creating an object of the; Dicke class, e.g. simply named; system, whose first attribute is. system.N, the number of TLSs of the system \(N\). The rates for collective and local processes are simply defined as. collective_emission defines \(\gamma_\text{CE}\), collective (superradiant) emission; collective_dephasing defines \(\gamma_\text{CD}\), collective dephasing; collective_pumping defines \(\gamma_\text{CP}\), collective pumping.; emission defines \(\gamma_\text{E}\), incoherent emission (losses); dephasing defines \(\gamma_\text{D}\), local dephasing; pumping defines \(\gamma_\text{P}\), incoherent pumping. Then the system.lindbladian() creates the total TLS Lindbladian superoperator matrix. Similarly, system.hamiltonian defines the TLS hamiltonian of the system \(H_\text{TLS}\).; The system’s Liouvillian can be built using system.liouvillian(). The properties of a Piqs object can be visualized by simply calling; system. We give two basic examples on the use of PIQS. In the first example the incoherent emission of N driven TLSs is considered.; from piqs import Dicke; from qutip import steadystate; N = 10; system = Dicke(N, emission = 1, pumping = 2); L",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html:4149,Usability,simpl,simply,4149,"gonal matrix in the basis of Dicke states \(|j, m \rangle\).; The system under study is defined by creating an object of the; Dicke class, e.g. simply named; system, whose first attribute is. system.N, the number of TLSs of the system \(N\). The rates for collective and local processes are simply defined as. collective_emission defines \(\gamma_\text{CE}\), collective (superradiant) emission; collective_dephasing defines \(\gamma_\text{CD}\), collective dephasing; collective_pumping defines \(\gamma_\text{CP}\), collective pumping.; emission defines \(\gamma_\text{E}\), incoherent emission (losses); dephasing defines \(\gamma_\text{D}\), local dephasing; pumping defines \(\gamma_\text{P}\), incoherent pumping. Then the system.lindbladian() creates the total TLS Lindbladian superoperator matrix. Similarly, system.hamiltonian defines the TLS hamiltonian of the system \(H_\text{TLS}\).; The system’s Liouvillian can be built using system.liouvillian(). The properties of a Piqs object can be visualized by simply calling; system. We give two basic examples on the use of PIQS. In the first example the incoherent emission of N driven TLSs is considered.; from piqs import Dicke; from qutip import steadystate; N = 10; system = Dicke(N, emission = 1, pumping = 2); L = system.liouvillian(); steady = steadystate(L). For more example of use, see the “Permutational Invariant Lindblad Dynamics” section in the tutorials section of the website, https://qutip.org/tutorials.html. Useful PIQS functions.¶. Operators; Command; Description. Collective spin algebra \(J_x,\ J_y,\ J_z\); jspin(N); The collective spin algebra \(J_x,\ J_y,\ J_z\) for \(N\) TLSs. Collective spin \(J_x\); jspin(N, ""x""); The collective spin operator \(Jx\). Requires \(N\) number of TLSs. Collective spin \(J_y\); jspin(N, ""y""); The collective spin operator \(J_y\). Requires \(N\) number of TLSs. Collective spin \(J_z\); jspin(N, ""z""); The collective spin operator \(J_z\). Requires \(N\) number of TLSs. Collective sp",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-piqs.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-piqs.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:5419,Availability,avail,available,5419,"re monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stoc",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:6493,Availability,avail,available,6493,"left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:108,Deployability,Install,Installation,108,"﻿. Stochastic Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) an",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:1404,Deployability,continuous,continuous,1404,"stic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]). (2)¶\[d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:6691,Deployability,update,updated,6691,"left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:4423,Energy Efficiency,monitor,monitored,4423,"mulated by passing the arguments method='homodyne' or method='heterodyne' to qutip.stochastic.ssesolve.; Examples of how to solve the stochastic Schrodinger equation using QuTiP can be found in this development notebook. Stochastic Master Equation¶; When the initial state of the system is a density matrix \(\rho\), the stochastic master equation solver qutip.stochastic.smesolve must be used. The stochastic master equation is given by (see section 4.4, [Wis09]). (6)¶\[ d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passe",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:5043,Energy Efficiency,monitor,monitored,5043," A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; stor",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:561,Integrability,depend,dependent,561,"﻿. Stochastic Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) an",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:1445,Safety,detect,detection,1445,"stic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]). (2)¶\[d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\frac{e_n}{2} S_n; + \frac{e_n^2}{8} \right) \psi(t) dt; + \sum_n \left( S_n - \frac{e_n}{2} \right) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) a",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:3361,Safety,detect,detections,3361,"ight) \psi(t) dW_n,\]; where \(H\) is the Hamiltonian, \(S_n\) are the stochastic collapse operators, and \(e_n\) is. (3)¶\[e_n = \left<\psi(t)|S_n + S_n^\dagger|\psi(t)\right>\]; In QuTiP, this equation can be solved using the function qutip.stochastic.ssesolve, which is implemented by defining \(d_1\) and \(d_{2,n}\) from Equation (1) as. (4)¶\[d_1 = -iH - \frac{1}{2} \sum_n \left(S_n^\dagger S_n - e_n S_n + \frac{e_i^2}{4} \right),\]; and. (5)¶\[d_{2, n} = S_n - \frac{e_n}{2}.\]; The solver qutip.stochastic.ssesolve will construct the operators \(d_1\) and \(d_{2,n}\) once the user passes the Hamiltonian (H) and the stochastic operator list (sc_ops). As with the qutip.mcsolve, the number of trajectories and the seed for the noise realisation can be fixed using the arguments: ntraj and noise, respectively. If the user also requires the measurement output, the argument store_measurement=True should be included.; Additionally, homodyne and heterodyne detections can be easily simulated by passing the arguments method='homodyne' or method='heterodyne' to qutip.stochastic.ssesolve.; Examples of how to solve the stochastic Schrodinger equation using QuTiP can be found in this development notebook. Stochastic Master Equation¶; When the initial state of the system is a density matrix \(\rho\), the stochastic master equation solver qutip.stochastic.smesolve must be used. The stochastic master equation is given by (see section 4.4, [Wis09]). (6)¶\[ d \rho (t) = -i[H, \rho(t)] dt + D[A]\rho(t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:4899,Safety,detect,detection,4899,"t) dt + \mathcal{H}[A]\rho dW(t)\]; where. (7)¶\[D[A] \rho = \frac{1}{2} \left[2 A \rho A^\dagger; - \rho A^\dagger A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rh",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:5068,Safety,detect,detection,5068," A - A^\dagger A \rho \right],\]; and. (8)¶\[\mathcal{H}[A]\rho = A\rho(t) + \rho(t) A^\dagger - \tr[A\rho(t) + \rho(t) A^\dagger].\]; In QuTiP, solutions for the stochastic master equation are obtained using the solver qutip.stochastic.smesolve. The implementation takes into account 2 types of collapse operators. \(C_i\) (c_ops) represent the dissipation in the environment, while \(S_n\) (sc_ops) are monitored operators. The deterministic part of the evolution, described by the \(d_1\) in Equation (1), takes into account all operators \(C_i\) and \(S_n\):. (9)¶\[d_1 = - i[H(t),\rho(t)]; + \sum_i D[C_i]\rho; + \sum_n D[S_n]\rho,\]; The stochastic part, \(d_{2,n}\), is given solely by the operators \(S_n\). (10)¶\[d_{2,n} = S_n \rho(t) + \rho(t) S_n^\dagger - \tr \left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; stor",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:6155,Safety,Detect,Detection,6155,"left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:6539,Safety,detect,detection,6539,"left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:6562,Safety,detect,detection,6562,"left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:1146,Testability,Log,Log,1146,"n Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodin",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:128,Usability,Guid,Guide,128,"﻿. Stochastic Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) an",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:135,Usability,Guid,Guide,135,"﻿. Stochastic Solver — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) an",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:1272,Usability,Guid,Guide,1272,"mics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Stochastic Schrodinger Equation; Stochastic Master Equation. Solving Problems with Time-dependent Hamiltonians; Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Stochastic Solver. Stochastic Solver¶; When a quantum system is subjected to continuous measurement, through homodyne detection for example, it is possible to simulate the conditional quantum state using stochastic Schrodinger and master equations. The solution of these stochastic equations are quantum trajectories, which represent the conditioned evolution of the system given a specific measurement record.; In general, the stochastic evolution of a quantum state is calculated in; QuTiP by solving the general equation. (1)¶\[d \rho (t) = d_1 \rho dt + \sum_n d_{2,n} \rho dW_n,\]; where \(dW_n\) is a Wiener increment, which has the expectation values \(E[dW] = 0\) and \(E[dW^2] = dt\). Stochastic evolution is implemented with the qutip.stochastic.general_stochastic function. Stochastic Schrodinger Equation¶; The stochastic Schrodinger equation is given by (see section 4.4, [Wis09]). (2)¶\[d \psi(t) = - i H \psi(t) dt; - \sum_n \left( \frac{S_n^\dagger S_n}{2} -\fr",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html:6577,Usability,feedback,feedback,6577,"left(S_n \rho (t); + \rho(t) S_n^\dagger \right)\rho(t).\]; As in the stochastic Schrodinger equation, the detection method can be specified using the method argument. Example¶; Below, we solve the dynamics for an optical cavity at 0K whose output is monitored using homodyne detection. The cavity decay rate is given by \(\kappa\) and the \(\Delta\) is the cavity detuning with respect to the driving field. The measurement operators can be passed using the option m_ops. The homodyne current \(J_x\) is calculated using. (11)¶\[J_x = \langle x \rangle + dW,\]; where \(x\) is the operator passed using m_ops. The results are available in result.measurements.; import numpy as np; import matplotlib.pyplot as plt; import qutip as qt. # parameters; DIM = 20 # Hilbert space dimension; DELTA = 5*2*np.pi # cavity detuning; KAPPA = 2 # cavity decay rate; INTENSITY = 4 # intensity of initial state; NUMBER_OF_TRAJECTORIES = 500. # operators; a = qt.destroy(DIM); x = a + a.dag(); H = DELTA*a.dag()* a. rho_0 = qt.coherent(DIM, np.sqrt(INTENSITY)); times = np.arange(0, 1, 0.0025). stoc_solution = qt.smesolve(H, rho_0, times,; c_ops=[],; sc_ops=[np.sqrt(KAPPA) * a],; e_ops=[x],; ntraj=NUMBER_OF_TRAJECTORIES,; nsubsteps=2,; store_measurement=True,; dW_factors=[1],; method='homodyne'). fig, ax = plt.subplots(); ax.set_title('Stochastic Master Equation - Homodyne Detection'); ax.plot(times, np.array(stoc_solution.measurement).mean(axis=0)[:].real,; 'r', lw=2, label=r'$J_x$'); ax.plot(times, stoc_solution.expect[0], 'k', lw=2,; label=r'$\langle x \rangle$'); ax.set_xlabel('Time'); ax.legend(). For other examples on qutip.stochastic.smesolve, see the following notebook, as well as these notebooks available at QuTiP Tutorials page: heterodyne detection, inneficient detection, and feedback control. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-stochastic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-stochastic.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:14044,Availability,error,errors,14044,"efine initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn these data points into a function we call the QuTiP qutip.",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:16443,Availability,avail,available,16443,"d. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which bei",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:140,Deployability,Install,Installation,140,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:11376,Deployability,install,installed,11376,"se of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:11427,Deployability,Install,Installation,11427," * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3,",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:11460,Deployability,install,installing,11460," * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3,",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:16602,Deployability,update,updated,16602,"me-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; quti",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:18968,Deployability,update,updated,18968,"_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:3795,Energy Efficiency,efficient,efficient,3795,"ing] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.bloch_redfield.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5234,Energy Efficiency,efficient,efficient,5234,"ons,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. Wi",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:30,Integrability,depend,dependent,30,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:532,Integrability,depend,dependent,532,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:581,Integrability,Depend,Dependent,581,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:622,Integrability,Depend,Dependence,622,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:703,Integrability,Depend,Dependent,703,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:800,Integrability,Depend,Dependent,800,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1597,Integrability,depend,dependent,1597,"s for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, wh",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1648,Integrability,depend,dependent,1648,"t Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1698,Integrability,Depend,Dependent,1698,"state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a lis",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1907,Integrability,depend,dependence,1907,"ations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Ham",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:2048,Integrability,depend,depend,2048,"ations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Ham",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:2340,Integrability,depend,dependent,2340," of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:2446,Integrability,depend,dependent,2446,"ion; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given th",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:2576,Integrability,depend,dependent,2576," Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is th",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:2810,Integrability,depend,dependent,2810,"e assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:3340,Integrability,depend,dependence,3340,"olve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, np.array] pairs. The arrays are 1 dimensional and dtype are complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.bloch_redfield.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be c",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:4055,Integrability,depend,dependent,4055," complex or float. They must contain one value for each time in the tlist given to the solver. Cubic spline interpolation will be used between the given times.; Hamiltonian function (outdated): The Hamiltonian is itself a Python function with time-dependence. Collapse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.bloch_redfield.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:4185,Integrability,depend,dependent,4185,"pse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.bloch_redfield.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implem",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:4656,Integrability,Depend,Dependent,4656,"itrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.bloch_redfield.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Bas",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5179,Integrability,depend,dependence,5179,"lems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5369,Integrability,depend,dependent,5369,"atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 i",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5464,Integrability,depend,dependent,5464,"atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 i",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5551,Integrability,depend,dependent,5551,", QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5630,Integrability,Depend,Dependence,5630,"Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5678,Integrability,depend,dependent,5678,"Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5762,Integrability,depend,dependent,5762,"Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:5863,Integrability,depend,dependent,5863,"y library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implementing time-dependent Hamiltonians that cannot be; expressed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any or",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:6442,Integrability,depend,dependent,6442,"essed as a function of constant operators with time-dependent coefficients.; A collection of examples demonstrating the simulation of time-dependent problems can be found on the tutorials web page. Function Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:6616,Integrability,depend,dependent,6616,"on Based Time Dependence¶; A very general way to write a time-dependent Hamiltonian or collapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay ra",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:6732,Integrability,depend,dependent,6732,"llapse operator is by using Python functions as the time-dependent coefficients. To accomplish this, we need to write a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_op",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:6789,Integrability,depend,dependent,6789," a Python function that returns the time-dependent coefficient. Additionally, we need to tell QuTiP that a given Hamiltonian or collapse operator should be associated with a given Python function. To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tenso",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:6961,Integrability,depend,dependent,6961,"To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ust",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:7044,Integrability,depend,dependent,7044,"To do this, one needs to specify operator-function pairs in list format: [Op, py_coeff], where Op is a given Hamiltonian or collapse operator and py_coeff is the name of the Python function representing the coefficient. With this format, the form of the Hamiltonian for both mesolve and mcsolve is:; >>> H = [H0, [H1, py_coeff1], [H2, py_coeff2], ...] . where H0 is a time-independent Hamiltonian, while H1 and H2 are time-dependent. The same format can be used for collapse operators:; >>> c_ops = [[C0, py_coeff0], C1, [C2, py_coeff2], ...] . Here we have demonstrated that the ordering of time-dependent and time-independent terms does not matter. In addition, any or all of the collapse operators may be time-dependent. Note; While, in general, you can arrange time-dependent and time-independent terms in any order you like, it is best to place all time-independent terms first. As an example, we will look at an example that has a time-dependent Hamiltonian of the form \(H=H_{0}-f(t)H_{1}\) where \(f(t)\) is the time-dependent driving strength given as \(f(t)=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ust",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8207,Integrability,depend,dependent,8207,"ited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we sh",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8256,Integrability,depend,dependent,8256,"e = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8510,Integrability,depend,depends,8510,"llapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = dest",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:9610,Integrability,depend,dependent,9610,"ficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:11501,Integrability,depend,dependent,11501,"A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), gr",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:11733,Integrability,depend,dependent,11733,"ways hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:12048,Integrability,depend,dependent,12048,"output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:12241,Integrability,depend,dependent,12241,"t = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a code generator class and then compiled into C code. The details of this meta-programming will be published in due course. However, in short, this can lead to a substantial reduction in time for complex time-dependent problems, or when simulating over long intervals.; Like the previous method, the string-based format uses a list pair format [Op, str] where str is now a string representing the time-dependent coefficient. For our first example, this string would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:13418,Integrability,depend,dependent,13418,"ited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:14188,Integrability,Depend,Dependent,14188,"U.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure()",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:14300,Integrability,depend,dependent,14300,"U.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure()",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:14536,Integrability,depend,dependent,14536," this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be paste",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:15581,Integrability,depend,dependent,15581,"-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn these data points into a function we call the QuTiP qutip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the ar",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:16013,Integrability,depend,dependent,16013,"utip.interpolate.Cubic_Spline class using the first and last domain time points, t[0] and t[-1], respectively, as well as the entire array of data points:; S = Cubic_Spline(t[0], t[-1], noisy_data). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:16296,Integrability,depend,dependent,16296,"; plt.plot(t, noisy_data, 'o'); plt.plot(t, S(t), lw=2); plt.show(). Note that, at present, only equally spaced real or complex data sets can be accommodated. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{t",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:16461,Integrability,depend,dependent,16461,"d. This cubic spline class S can now be pasted to any of the mesolve, mcsolve, or sesolve functions where one would normally input a time-dependent function or string-representation. Taking the problem from the previous section as an example. We would make the replacement:; H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. to; H = [H0, [H1, S]]. When combining interpolating functions with other Python functions or strings, the interpolating class will automatically pick the appropriate method for calling the class. That is to say that, if for example, you have other time-dependent terms that are given in the string-format, then the cubic spline representation will also be passed in a string-compatible format. In the string-format, the interpolation function is compiled into c-code, and thus is quite fast. This is the default method if no other time-dependent terms are present. Accesing the state from solver¶; New in QuTiP 4.4; The state of the system, the ket vector or the density matrix,; is available to time-dependent Hamiltonian and collapse operators in args.; Some keys of the argument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which bei",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:17653,Integrability,Depend,Dependent,17653,"e obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:17828,Integrability,depend,dependent,17828,"th psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Next ; Previous. © Copyright 2011",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1983,Modifiability,coupling,coupling,1983,"ations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, where the time-dependent coefficients of the Hamiltonian (or collapse operators) are expressed using Python functions.; String (Cython) based: The Hamiltonian and/or collapse operators are expressed as a list of [qobj, string] pairs, where the time-dependent coefficients are represented as strings. The resulting Hamiltonian is then compiled into C code using Cython and executed.; Array Based: The Ham",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8071,Modifiability,coupling,coupling,8071,"=A\exp\left[-\left( t/\sigma \right)^{2}\right]\). The following code sets up the problem; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity; sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8637,Modifiability,variab,variables,8637," 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_co",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:9739,Modifiability,variab,variable,9739,"); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the value",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:9798,Modifiability,variab,variables,9798,"); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the value",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:10400,Modifiability,variab,variable,10400,"ecay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; Yo",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:10904,Modifiability,variab,variables,10904,"th \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t / sig) ** 2). where args is a Python dictionary of key: value pairs args = {'A': a, 'sigma': b} where a and b are the two parameters for the amplitude and width, respectively. Of course, we can always hardcode the values in the dictionary as well args = {'A': 9, 'sigma': 5}, but there is much more flexibility by using variables in args. To let the solvers know that we have a set of args to pass we append the args to the end of the solver input:; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args={'A': 9, 'sigma': 5}). or to keep things looking pretty; args = {'A': 9, 'sigma': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag() * a], args=args). Once again, the Monte Carlo solver qutip.mcsolve works in an identical manner. String Format Method¶. Note; You must have Cython installed on your computer to use this format. See Installation for instructions on installing Cython. The string-based time-dependent format works in a similar manner as the previously discussed Python function method. That being said, the underlying code does something completely different. When using this format, the strings used to represent the time-dependent coefficients, as well as Hamiltonian and collapse operators, are rewritten as Cython code using a ",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:13282,Modifiability,coupling,coupling,13282,"g would be '9 * exp(-(t / 5.) ** 2)'. The Hamiltonian in this format would take the form:; ustate = basis(3, 0); excited = basis(3, 1); ground = basis(3, 2). N = 2 # Set where to truncate Fock state for cavity. sigma_ge = tensor(qeye(N), ground * excited.dag()) # |g><e|; sigma_ue = tensor(qeye(N), ustate * excited.dag()) # |u><e|; a = tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the ti",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:13725,Modifiability,variab,variable,13725,"te; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = la",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:13780,Modifiability,rewrite,rewrite,13780,"te; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = la",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:14005,Modifiability,variab,variables,14005,"ine time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state; state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. H = [H0, [H1, '9 * exp(-(t / 5) ** 2)']]. Notice that this is a valid Hamiltonian for the string-based format as exp is included in the above list of suitable functions. Calling the solvers is the same as before:; output = mesolve(H, psi0, t, c_ops, [a.dag() * a]). We can also use the args variable in the same manner as before, however we must rewrite our string term to read: 'A * exp(-(t / sig) ** 2)'; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mesolve(H, psi0, times, c_ops, [a.dag()*a], args=args). Important; Naming your args variables exp, sin, pi etc. will cause errors when using the string-based format. Collapse operators are handled in the exact same way. Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions¶; Sometimes it is necessary to model a system where the time-dependent parameters are non-analytic functions, or are derived from experimental data (i.e. a collection of data points). In these situations, one can use interpolating functions as an approximate functional form for input into a time-dependent solver. QuTiP includes its own custom cubic spline interpolation class qutip.interpolate.Cubic_Spline to provide this functionality. To see how this works, lets first generate some noisy data:; t = np.linspace(-15, 15, 100); func = lambda t: 9*np.exp(-(t / 5)** 2); noisy_func = lambda t: func(t)+(0.05*func(t))*np.random.randn(t.shape[0]); noisy_data = noisy_func(t). plt.figure(); plt.plot(t, func(t)); plt.plot(t, noisy_data, 'o'); plt.show(). To turn the",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:17838,Modifiability,variab,variables,17838,"th psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Next ; Previous. © Copyright 2011",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:17948,Safety,avoid,avoid,17948,"th psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts). The second call to qutip.mcsolve does not reorganize the data, and in the case of the string format, does not recompile the Cython code. For the small system here, the savings in computation time is quite small, however, if you need to call the solvers many times for different parameters, this savings will obviously start to add up. Next ; Previous. © Copyright 2011",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1389,Testability,Log,Log,1389,"ver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:4453,Testability,log,log,4453,"pse operators must be time independent using this input format. Given the multiple choices of input style, the first question that arrises is which option to choose?; In short, the function based method (option #1) is the most general,; allowing for essentially arbitrary coefficients expressed via user-defined functions.; However, by automatically compiling your system into C++ code,; the second option (string based) tends to be more efficient and will run faster; [This is also the only format that is supported in the qutip.bloch_redfield.brmesolve solver].; Of course, for small system sizes and evolution times, the difference will be minor.; Although this method does not support all time-dependent coefficients that one can think of,; it does support essentially all problems that one would typically encounter.; Time-dependent coefficients using any of the following functions,; or combinations thereof (including constants) can be compiled directly into C++-code:; 'abs', 'acos', 'acosh', 'arg', 'asin', 'asinh', 'atan', 'atanh', 'conj',; 'cos', 'cosh','exp', 'erf', 'zerf', 'imag', 'log', 'log10', 'norm', 'pi',; 'proj', 'real', 'sin', 'sinh', 'sqrt', 'tan', 'tanh'. In addition, QuTiP supports cubic spline based interpolation functions [Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions].; If you require mathematical functions other than those listed above,; it is possible to call any of the functions in the NumPy library using the prefix np.; before the function name in the string, i.e. 'np.sin(t)' and scipy.special imported as spe.; This includes a wide range of functionality, but comes with a small overhead created by going from C++->Python->C++.; Finally option #4, expressing the Hamiltonian as a Python function,; is the original method for time dependence in QuTiP 1.x.; This method is somewhat less efficient then the previously mentioned ones.; However, in contrast to the other options; this method can be used in implem",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:17539,Testability,test,tests,17539,"gument dictionary are understood by the solver to be values; to be updated with the evolution of the system.; The state can be obtained in 3 forms: Qobj, vector (1d np.array), matrix (2d np.array),; expectation values and collapse can also be obtained. Preparation; usage; Notes. state as Qobj; name+""=Qobj"":psi0; psi_t=args[name]; The ket or density matrix as a Qobj with psi0’s dimensions. state as matrix; name+""=mat"":psi0; mat_t=args[name]; The state as a matrix, equivalent to state.full(). state as vector; name+""=vec"":psi0; vec_t=args[name]; The state as a vector, equivalent to state.full().ravel('F'). expectation value; name+""=expect"":O; e=args[name]; Expectation value of the operator O, either; \(\left<\psi(t)|O|\psi(t)\right>\); or \(\rm{tr}\left(O \rho(t)\right)\). collpases; name+""=collapse"":[]; col=args[name]; List of collapse,; each collapse is a tuple of the pair (time, which); which being the indice of the collapse operator.; mcsolve only. Here psi0 is the initial value used for tests before the evolution begins.; qutip.bloch_redfield.brmesolve does not support these arguments. Reusing Time-Dependent Hamiltonian Data¶. Note; This section covers a specialized topic and may be skipped if you are new to QuTiP. When repeatedly simulating a system where only the time-dependent variables, or initial state change, it is possible to reuse the Hamiltonian data stored in QuTiP and there by avoid spending time needlessly preparing the Hamiltonian and collapse terms for simulation. To turn on the the reuse features, we must pass a qutip.solver.Options object with the rhs_reuse flag turned on. Instructions on setting flags are found in Setting Options for the Dynamics Solvers. For example, we can do; H = [H0, [H1, 'A * exp(-(t / sig) ** 2)']]; args = {'A': 9, 'sig': 5}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args); opts = Options(rhs_reuse=True); args = {'A': 10, 'sig': 3}; output = mcsolve(H, psi0, times, c_ops, [a.dag()*a], args=args, options=opts).",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:160,Usability,Guid,Guide,160,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:167,Usability,Guid,Guide,167,"﻿. Solving Problems with Time-dependent Hamiltonians — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Introduction; Dynamics Simulation Results; Lindblad Master Equation Solver; Monte Carlo Solver; Krylov Solver; Stochastic Solver - Photocurrent; Stochastic Solver; Solving Problems with Time-dependent Hamiltonians; Methods for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the en",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:1515,Usability,Guid,Guide,1515,"s for Writing Time-Dependent Operators; Function Based Time Dependence; String Format Method; Modeling Non-Analytic and/or Experimental Time-Dependent Parameters using Interpolating Functions; Accesing the state from solver; Reusing Time-Dependent Hamiltonian Data. Bloch-Redfield master equation; Floquet Formalism; Permutational Invariance; Setting Options for the Dynamics Solvers. Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Time Evolution and Quantum System Dynamics »; Solving Problems with Time-dependent Hamiltonians. Solving Problems with Time-dependent Hamiltonians¶. Methods for Writing Time-Dependent Operators¶; In the previous examples of quantum evolution,; we assumed that the systems under consideration were described by time-independent Hamiltonians.; However, many systems have explicit time dependence in either the Hamiltonian,; or the collapse operators describing coupling to the environment, and sometimes both components might depend on time.; The time-evolutions solvers; qutip.mesolve, qutip.mcsolve, qutip.sesolve, qutip.bloch_redfield.brmesolve; qutip.stochastic.ssesolve, qutip.stochastic.photocurrent_sesolve, qutip.stochastic.smesolve, and qutip.stochastic.photocurrent_mesolve; are all capable of handling time-dependent Hamiltonians and collapse terms.; There are, in general, three different ways to implement time-dependent problems in QuTiP:. Function based: Hamiltonian / collapse operators expressed using [qobj, func] pairs, wh",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:8409,Usability,simpl,simply,8409," tensor(destroy(N), qeye(3)); ada = tensor(num(N), qeye(3)). c_ops = [] # Build collapse operators; kappa = 1.5 # Cavity decay rate; c_ops.append(np.sqrt(kappa) * a); gamma = 6 # Atomic decay rate; c_ops.append(np.sqrt(5*gamma/9) * sigma_ue) # Use Rb branching ratio of 5/9 e->u; c_ops.append(np.sqrt(4*gamma/9) * sigma_ge) # 4/9 e->g. t = np.linspace(-15, 15, 100) # Define time vector; psi0 = tensor(basis(N, 0), ustate) # Define initial state. state_GG = tensor(basis(N, 1), ground) # Define states onto which to project; sigma_GG = state_GG * state_GG.dag(); state_UU = tensor(basis(N, 0), ustate); sigma_UU = state_UU * state_UU.dag(). g = 5 # coupling strength; H0 = -g * (sigma_ge.dag() * a + a.dag() * sigma_ge) # time-independent term; H1 = (sigma_ue.dag() + sigma_ue) # time-dependent term. Given that we have a single time-dependent Hamiltonian term, and constant collapse terms, we need to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient func",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:9310,Usability,simpl,simple,9310,"ed to specify a single Python function for the coefficient \(f(t)\). In this case, one can simply do; def H1_coeff(t, args):; return 9 * np.exp(-(t / 5.) ** 2). In this case, the return value depends only on time. However, when specifying Python functions for coefficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitu",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html:9531,Usability,simpl,simple,9531,"ficients, the function must have (t,args) as the input variables, in that order. Having specified our coefficient function, we can now specify the Hamiltonian in list format and call the solver (in this case qutip.mesolve); H = [H0,[H1, H1_coeff]]; output = mesolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). We can call the Monte Carlo solver in the exact same way (if using the default ntraj=500):; output = mcsolve(H, psi0, t, c_ops, [ada, sigma_UU, sigma_GG]). The output from the master equation solver is identical to that shown in the examples, the Monte Carlo however will be noticeably off, suggesting we should increase the number of trajectories for this example. In addition, we can also consider the decay of a simple Harmonic oscillator with time-varying decay rate; kappa = 0.5. def col_coeff(t, args): # coefficient function; return np.sqrt(kappa * np.exp(-t)). N = 10 # number of basis states; a = destroy(N); H = a.dag() * a # simple HO; psi0 = basis(N, 9) # initial state; c_ops = [[a, col_coeff]] # time-dependent collapse term; times = np.linspace(0, 10, 100); output = mesolve(H, psi0, times, c_ops, [a.dag() * a]). Using the args variable¶; In the previous example we hardcoded all of the variables, driving amplitude \(A\) and width \(\sigma\), with their numerical values. This is fine for problems that are specialized, or that we only want to run once. However, in many cases, we would like to change the parameters of the problem in only one location (usually at the top of the script), and not have to worry about manually changing the values on each run. QuTiP allows you to accomplish this using the keyword args as an input to the solvers. For instance, instead of explicitly writing 9 for the amplitude and 5 for the width of the gaussian driving term, we can make use of the args variable; def H1_coeff(t, args):; return args['A'] * np.exp(-(t/args['sigma'])**2). or equivalently,; def H1_coeff(t, args):; A = args['A']; sig = args['sigma']; return A * np.exp(-(t",MatchSource.WIKI,docs/4.7/guide/dynamics/dynamics-time.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/dynamics/dynamics-time.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:5481,Availability,avail,available,5481," of Feynman Diagrams (both classify terms by increasing number; of interactions).; The result is a standard QuTiP results object with the attributes:. times: the times at which the state was evaluated (i.e. tlist); states: the system states at each time; expect: the values of each e_ops at each time; ado_states: see below (an instance of; HierarchyADOsState). If ado_return=True is passed to .run(...) the full set of auxilliary; density operators (ADOs) that make up the hierarchy at each time will be; returned as .ado_states. We will describe how to use these to determine; other properties, such as system-bath currents, later in the fermionic guide; (see Determining currents).; If one has a full set of ADOs from a previous call of .run(...) you may; supply it as the initial state of the solver by calling; .run(result.ado_states[-1], tlist, ado_init=True).; As with other QuTiP solvers, if expectation operators or functions are supplied; using .run(..., e_ops=[...]) the expectation values are available in; result.expect.; Below we run the solver again, but use e_ops to store the expectation; values of the population of the system states and the coherence:; # Define the operators that measure the populations of the two; # system states:; P11p = basis(2,0) * basis(2,0).dag(); P22p = basis(2,1) * basis(2,1).dag(). # Define the operator that measures the 0, 1 element of density matrix; # (corresonding to coherence):; P12p = basis(2,0) * basis(2,1).dag(). # Run the solver:; tlist = np.linspace(0, 20, 101); result = solver.run(rho0, tlist, e_ops={""11"": P11p, ""22"": P22p, ""12"": P12p}). # Plot the results:; fig, axes = plt.subplots(1, 1, sharex=True, figsize=(8,8)); axes.plot(result.times, result.expect[""11""], 'b', linewidth=2, label=""P11""); axes.plot(result.times, result.expect[""12""], 'r', linewidth=2, label=""P12""); axes.set_xlabel(r't', fontsize=28); axes.legend(loc=0, fontsize=12). Steady-state¶; Using the same solver, we can also determine the steady state of the; combined s",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:110,Deployability,Install,Installation,110,". Bosonic Environments — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Bosonic Environments. Bosonic Environments¶; In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, \(H_{sys}\), and the bath; spectral density, \(J_D\), are. \[ \begin{align}\begin{aligned}H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}\\J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a;",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:12732,Deployability,update,updated,12732," separate bath. Such; an arrangement can model, for example, the Fenna–Matthews–Olson (FMO); pigment-protein complex which plays an important role in photosynthesis (; for a full FMO example see the notebook; https://github.com/tehruhn/bofin/blob/main/examples/example-2-FMO-example.ipynb; ).; For each bath expansion, we also include the terminator in the system; Liouvillian.; At the end, we plot the populations of the system states as a function of; time, and show the long-time beating of quantum state coherence that; occurs:; # The size of the system:; N_sys = 3. def proj(i, j):; """""" A helper function for creating an interaction operator. """"""; return basis(N_sys, i) * basis(N_sys, j).dag(). # Construct one bath for each system state:; baths = []; for i in range(N_sys):; Q = proj(i, i); baths.append(DrudeLorentzBath(Q, lam, gamma, T, Nk)). # Construct the system Liouvillian from the system Hamiltonian and; # bath expansion terminators:; H_sys = sum((i + 0.5) * eps * proj(i, i) for i in range(N_sys)); H_sys += sum(; (i + j + 0.5) * Del * proj(i, j); for i in range(N_sys) for j in range(N_sys); if i != j; ); HL = liouvillian(H_sys) + sum(bath.terminator()[1] for bath in baths). # Construct the solver (pass a list of baths):; solver = HEOMSolver(HL, baths, max_depth=max_depth, options=options). # Run the solver:; rho0 = basis(N_sys, 0) * basis(N_sys, 0).dag(); tlist = np.linspace(0, 5, 200); e_ops = {; f""P{i}"": proj(i, i); for i in range(N_sys); }; result = solver.run(rho0, tlist, e_ops=e_ops). # Plot populations:; fig, axes = plt.subplots(1, 1, sharex=True, figsize=(8,8)); for label, values in result.expect.items():; axes.plot(result.times, values, label=label); axes.set_xlabel(r't', fontsize=28); axes.set_ylabel(r""Population"", fontsize=28); axes.legend(loc=0, fontsize=12). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:2803,Energy Efficiency,energy,energy,2803,"; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where \(\gamma\) (gamma), \(\lambda\) (lam) and \(T\) are; the parameters of a Drude-Lorentz bath, and Q is the coupling operator; between the system and the bath.; We may the pass these parameters to either; DrudeLorentzBath or; DrudeLorentzPadeBath to construct an expansion of; the bath correlations:; from qutip.nonmarkov.heom import DrudeLorentzBath; from qutip.nonmarkov.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where Nk is the number of terms to ret",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:1754,Modifiability,evolve,evolve,1754,"y-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Bosonic Environments. Bosonic Environments¶; In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, \(H_{sys}\), and the bath; spectral density, \(J_D\), are. \[ \begin{align}\begin{aligned}H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}\\J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:3092,Modifiability,coupling,coupling,3092,"ath expansion.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where \(\gamma\) (gamma), \(\lambda\) (lam) and \(T\) are; the parameters of a Drude-Lorentz bath, and Q is the coupling operator; between the system and the bath.; We may the pass these parameters to either; DrudeLorentzBath or; DrudeLorentzPadeBath to construct an expansion of; the bath correlations:; from qutip.nonmarkov.heom import DrudeLorentzBath; from qutip.nonmarkov.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where Nk is the number of terms to retain within the expansion of the; bath. System and bath dynamics¶; Now we are ready to construct a solver:; from qutip.nonmarkov.heom import HEOMSolver; from qutip import Options. max_depth = 5 # maximum hierarchy depth to retain; options = Options(nsteps=15_000). solver = HEOMSolver",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:3148,Modifiability,coupling,coupling,3148,"te the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where \(\gamma\) (gamma), \(\lambda\) (lam) and \(T\) are; the parameters of a Drude-Lorentz bath, and Q is the coupling operator; between the system and the bath.; We may the pass these parameters to either; DrudeLorentzBath or; DrudeLorentzPadeBath to construct an expansion of; the bath correlations:; from qutip.nonmarkov.heom import DrudeLorentzBath; from qutip.nonmarkov.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where Nk is the number of terms to retain within the expansion of the; bath. System and bath dynamics¶; Now we are ready to construct a solver:; from qutip.nonmarkov.heom import HEOMSolver; from qutip import Options. max_depth = 5 # maximum hierarchy depth to retain; options = Options(nsteps=15_000). solver = HEOMSolver(H_sys, bath, max_depth=max_depth, options=options). a",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:3294,Modifiability,coupling,coupling,3294,"o that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5 * Del * sigmax(). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Bath properties:; gamma = 0.5 # cut off frequency; lam = 0.1 # coupling strength; T = 0.5 # temperature. # System-bath coupling operator:; Q = sigmaz(). where \(\gamma\) (gamma), \(\lambda\) (lam) and \(T\) are; the parameters of a Drude-Lorentz bath, and Q is the coupling operator; between the system and the bath.; We may the pass these parameters to either; DrudeLorentzBath or; DrudeLorentzPadeBath to construct an expansion of; the bath correlations:; from qutip.nonmarkov.heom import DrudeLorentzBath; from qutip.nonmarkov.heom import DrudeLorentzPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). Where Nk is the number of terms to retain within the expansion of the; bath. System and bath dynamics¶; Now we are ready to construct a solver:; from qutip.nonmarkov.heom import HEOMSolver; from qutip import Options. max_depth = 5 # maximum hierarchy depth to retain; options = Options(nsteps=15_000). solver = HEOMSolver(H_sys, bath, max_depth=max_depth, options=options). and to calculate the system evolution as a function of time:; tlist = [0, 10, 20] # times to evaluate the s",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:6919,Modifiability,coupling,coupling,6919,"s={""11"": P11p, ""22"": P22p, ""12"": P12p}). # Plot the results:; fig, axes = plt.subplots(1, 1, sharex=True, figsize=(8,8)); axes.plot(result.times, result.expect[""11""], 'b', linewidth=2, label=""P11""); axes.plot(result.times, result.expect[""12""], 'r', linewidth=2, label=""P12""); axes.set_xlabel(r't', fontsize=28); axes.legend(loc=0, fontsize=12). Steady-state¶; Using the same solver, we can also determine the steady state of the; combined system and bath using:; steady_state, steady_ados = solver.steady_state(). where steady_state is the steady state of the system and steady_ados; if the steady state of the full hierarchy. The ADO states are; described more fully in Determining currents and; HierarchyADOsState. Matsubara Terminator¶; When constructing the Drude-Lorentz bath we have truncated the expansion at; Nk = 2 terms and ignore the remaining terms.; However, since the coupling to these higher order terms is comparatively weak,; we may consider the interaction with them to be Markovian, and construct an; additional Lindbladian term that captures their interaction with the system and; the lower order terms in the expansion.; This additional term is called the terminator because it terminates the; expansion.; The DrudeLorentzBath and; DrudeLorentzPadeBath both provide a means of; calculating the terminator for a given expansion:; # Matsubara expansion:; bath = DrudeLorentzBath(Q, lam, gamma, T, Nk). # Padé expansion:; bath = DrudeLorentzPadeBath(Q, lam, gamma, T, Nk). # Add terminator to the system Liouvillian:; delta, terminator = bath.terminator(); HL = liouvillian(H_sys) + terminator. # Construct solver:; solver = HEOMSolver(HL, bath, max_depth=max_depth, options=options). This captures the Markovian effect of the remaining terms in the expansion; without having to fully model many more terms.; The value delta is an approximation to the strength of the effect of; the remaining terms in the expansion (i.e. how strongly the terminator is; coupled to the rest of the sy",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:9882,Modifiability,extend,extend,9882,", \(C_{real}(t)\):. \[ \begin{align}\begin{aligned}\begin{split}\nu_{k,real} &= \begin{cases}; \gamma & k = 0\\; {2 \pi k} / {\beta } & k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,real} &= \begin{cases}; \lambda \gamma [\cot(\beta \gamma / 2) - i] & k = 0\\; \frac{4 \lambda \gamma \nu_k }{ (\nu_k^2 - \gamma^2)\beta} & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; and the imaginary part, \(C_{imag}(t)\):. \[ \begin{align}\begin{aligned}\begin{split}\nu_{k,imag} &= \begin{cases}; \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,imag} &= \begin{cases}; - \lambda \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; And now the same numbers calculated in Python:; # Convenience functions and parameters:. def cot(x):; return 1. / np.tan(x). beta = 1. / T. # Number of expansion terms to calculate:; Nk = 2. # C_real expansion terms:; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). # C_imag expansion terms (this is the full expansion):; ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. After all that, constructing the bath is very straight forward:; from qutip.nonmarkov.heom import BosonicBath. bath = BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag). And we’re done!; The BosonicBath can be used with the; HEOMSolver in exactly the same way as the baths; we constructed previously using the built-in Drude-Lorentz bath expansions. Multiple baths¶; The HEOMSolver supports having a system interact; with multiple environments. All that is needed is to supply a list of baths; instead of a single bath.; In the example below we calculate the evolution of a small system where; each basis state of the system interacts with a separate bath. Such; an arrangement can model, for example, the Fe",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:10028,Modifiability,extend,extend,10028," k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,real} &= \begin{cases}; \lambda \gamma [\cot(\beta \gamma / 2) - i] & k = 0\\; \frac{4 \lambda \gamma \nu_k }{ (\nu_k^2 - \gamma^2)\beta} & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; and the imaginary part, \(C_{imag}(t)\):. \[ \begin{align}\begin{aligned}\begin{split}\nu_{k,imag} &= \begin{cases}; \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\\\begin{split}c_{k,imag} &= \begin{cases}; - \lambda \gamma & k = 0\\; 0 & k \geq 1\\; \end{cases}\end{split}\end{aligned}\end{align} \]; And now the same numbers calculated in Python:; # Convenience functions and parameters:. def cot(x):; return 1. / np.tan(x). beta = 1. / T. # Number of expansion terms to calculate:; Nk = 2. # C_real expansion terms:; ck_real = [lam * gamma / np.tan(gamma / (2 * T))]; ck_real.extend([; (8 * lam * gamma * T * np.pi * k * T /; ((2 * np.pi * k * T)**2 - gamma**2)); for k in range(1, Nk + 1); ]); vk_real = [gamma]; vk_real.extend([2 * np.pi * k * T for k in range(1, Nk + 1)]). # C_imag expansion terms (this is the full expansion):; ck_imag = [lam * gamma * (-1.0)]; vk_imag = [gamma]. After all that, constructing the bath is very straight forward:; from qutip.nonmarkov.heom import BosonicBath. bath = BosonicBath(Q, ck_real, vk_real, ck_imag, vk_imag). And we’re done!; The BosonicBath can be used with the; HEOMSolver in exactly the same way as the baths; we constructed previously using the built-in Drude-Lorentz bath expansions. Multiple baths¶; The HEOMSolver supports having a system interact; with multiple environments. All that is needed is to supply a list of baths; instead of a single bath.; In the example below we calculate the evolution of a small system where; each basis state of the system interacts with a separate bath. Such; an arrangement can model, for example, the Fenna–Matthews–Olson (FMO); pigment-protein complex which plays an important role in photosynthesis (; for a full FMO example see the note",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:995,Testability,Log,Log,995,"ents — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Bosonic Environments. Bosonic Environments¶; In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, \(H_{sys}\), and the bath; spectral density, \(J_D\), are. \[ \begin{align}\begin{aligned}H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}\\J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a; truncated expans",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:130,Usability,Guid,Guide,130,". Bosonic Environments — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Bosonic Environments. Bosonic Environments¶; In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, \(H_{sys}\), and the bath; spectral density, \(J_D\), are. \[ \begin{align}\begin{aligned}H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}\\J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a;",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:137,Usability,Guid,Guide,137,". Bosonic Environments — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Bosonic Environments. Bosonic Environments¶; In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, \(H_{sys}\), and the bath; spectral density, \(J_D\), are. \[ \begin{align}\begin{aligned}H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}\\J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a;",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:1121,Usability,Guid,Guide,1121,"ew; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Bosonic Environments. Bosonic Environments¶; In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, \(H_{sys}\), and the bath; spectral density, \(J_D\), are. \[ \begin{align}\begin{aligned}H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}\\J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion.; Afterwards, we will show how to",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:1241,Usability,simpl,simple,1241," and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Describing the system and bath; System and bath dynamics; Steady-state; Matsubara Terminator; Matsubara expansion coefficients; Multiple baths. Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Bosonic Environments. Bosonic Environments¶; In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, \(H_{sys}\), and the bath; spectral density, \(J_D\), are. \[ \begin{align}\begin{aligned}H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}\\J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own ba",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:1851,Usability,simpl,simplest,1851,"Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Bosonic Environments. Bosonic Environments¶; In this section we consider a simple two-level system coupled to a; Drude-Lorentz bosonic bath. The system Hamiltonian, \(H_{sys}\), and the bath; spectral density, \(J_D\), are. \[ \begin{align}\begin{aligned}H_{sys} &= \frac{\epsilon \sigma_z}{2} + \frac{\Delta \sigma_x}{2}\\J_D &= \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; First we will do this in the simplest way, using the built-in implementations of; the two bath expansions, DrudeLorentzBath and; DrudeLorentzPadeBath. We will do this both with a; truncated expansion and show how to include an approximation to all of the; remaining terms in the bath expansion.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own bosonic baths.; Finally, we will demonstrate how to simulate a system coupled to multiple; independent baths, as occurs, for example, in certain photosynthesis processes.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in; example notebook 1a. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, sigmax, sigmaz. # The system Hamiltonian:; eps = 0.5 # energy of the 2-level system; Del = 1.0 # tunnelling term; H_sys = 0.5 * eps * sigmaz() + 0.5",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/bosonic.html:5126,Usability,guid,guide,5126," solver = HEOMSolver(H_sys, bath, max_depth=max_depth, options=options). and to calculate the system evolution as a function of time:; tlist = [0, 10, 20] # times to evaluate the system state at; result = solver.run(rho0, tlist). The max_depth parameter determines how many levels of the hierarchy to; retain. As a first approximation hierarchy depth may be thought of as similar; to the order of Feynman Diagrams (both classify terms by increasing number; of interactions).; The result is a standard QuTiP results object with the attributes:. times: the times at which the state was evaluated (i.e. tlist); states: the system states at each time; expect: the values of each e_ops at each time; ado_states: see below (an instance of; HierarchyADOsState). If ado_return=True is passed to .run(...) the full set of auxilliary; density operators (ADOs) that make up the hierarchy at each time will be; returned as .ado_states. We will describe how to use these to determine; other properties, such as system-bath currents, later in the fermionic guide; (see Determining currents).; If one has a full set of ADOs from a previous call of .run(...) you may; supply it as the initial state of the solver by calling; .run(result.ado_states[-1], tlist, ado_init=True).; As with other QuTiP solvers, if expectation operators or functions are supplied; using .run(..., e_ops=[...]) the expectation values are available in; result.expect.; Below we run the solver again, but use e_ops to store the expectation; values of the population of the system states and the coherence:; # Define the operators that measure the populations of the two; # system states:; P11p = basis(2,0) * basis(2,0).dag(); P22p = basis(2,1) * basis(2,1).dag(). # Define the operator that measures the 0, 1 element of density matrix; # (corresonding to coherence):; P12p = basis(2,0) * basis(2,1).dag(). # Run the solver:; tlist = np.linspace(0, 20, 101); result = solver.run(rho0, tlist, e_ops={""11"": P11p, ""22"": P22p, ""12"": P12p}). # Plo",MatchSource.WIKI,docs/4.7/guide/heom/bosonic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/bosonic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:12804,Availability,down,down,12804,"nsion.; Evaluating the integral for the correlation functions gives:. \[C^{\sigma}(t) \approx \sum_{l=0}^{Nk} \eta^{\sigma,l} e^{-\gamma_{\sigma,l}t}\]; where:. \[ \begin{align}\begin{aligned}\begin{split}\eta_{\sigma, l} &= \begin{cases}; \frac{\Gamma W}{2} f_F^{approx}(i\beta W) & l = 0\\; -i\cdot \frac{k_l}{\beta} \cdot \frac{\Gamma W^2}{-\frac{\epsilon^2_l}{\beta^2} + W^2} & l \neq 0\\; \end{cases}\end{split}\\\begin{split}\gamma_{\sigma,l} &= \begin{cases}; W - \sigma i\mu & l = 0\\; \frac{\epsilon_l}{\beta} - \sigma i \mu & l \neq 0\\; \end{cases}\end{split}\end{aligned}\end{align} \]; and \(\beta = \frac{1}{T}\).; And now we calculate the same numbers in Python:; # Imports; from numpy.linalg import eigvalsh. # Convenience functions and parameters:; def deltafun(j, k):; """""" Kronecker delta function. """"""; return 1.0 if j == k else 0. def f_approx(x, Nk):; """""" Padé approxmation to Fermi distribution. """"""; f = 0.5; for ll in range(1, Nk + 1):; # kappa and epsilon are calculated further down; f = f - 2 * kappa[ll] * x / (x**2 + epsilon[ll]**2); return f. def kappa_epsilon(Nk):; """""" Calculate kappa and epsilon coefficients. """""". alpha = np.zeros((2 * Nk, 2 * Nk)); for j in range(2 * Nk):; for k in range(2 * Nk):; alpha[j][k] = (; (deltafun(j, k + 1) + deltafun(j, k - 1)); / np.sqrt((2 * (j + 1) - 1) * (2 * (k + 1) - 1)); ). eps = [-2. / val for val in eigvalsh(alpha)[:Nk]]. alpha_p = np.zeros((2 * Nk - 1, 2 * Nk - 1)); for j in range(2 * Nk - 1):; for k in range(2 * Nk - 1):; alpha_p[j][k] = (; (deltafun(j, k + 1) + deltafun(j, k - 1)); / np.sqrt((2 * (j + 1) + 1) * (2 * (k + 1) + 1)); ). chi = [-2. / val for val in eigvalsh(alpha_p)[:Nk - 1]]. eta_list = [; 0.5 * Nk * (2 * (Nk + 1) - 1) * (; np.prod([chi[k]**2 - eps[j]**2 for k in range(Nk - 1)]) /; np.prod([; eps[k]**2 - eps[j]**2 + deltafun(j, k) for k in range(Nk); ]); ); for j in range(Nk); ]. kappa = [0] + eta_list; epsilon = [0] + eps. return kappa, epsilon. kappa, epsilon = kappa_epsilon(Nk). # Phew, we made",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:112,Deployability,Install,Installation,112,". Fermionic Environments — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Describing the system and bath; System and bath dynamics; Determining currents; Steady state currents; Padé expansion coefficients. Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Fermionic Environments. Fermionic Environments¶; Here we model a single fermion coupled to two electronic leads or reservoirs; (e.g., this can describe a single quantum dot, a molecular transistor, etc).; The system hamiltonian, \(H_{sys}\), and bath spectral density, \(J_D\),; are. \[ \begin{align}\begin{aligned}H_{sys} &= c^{\dagger} c\\J_D &= \frac{\Gamma W^2}{(w - \mu)^2 + W^2},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; Since our fermion is coupled to two reservoirs, we will construct two baths –; one for each reservoir or lead – and call them the left (\(L\)) and right; (\(R\)) baths for convenience. Ea",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:15055,Deployability,update,updated,15055,". / val for val in eigvalsh(alpha)[:Nk]]. alpha_p = np.zeros((2 * Nk - 1, 2 * Nk - 1)); for j in range(2 * Nk - 1):; for k in range(2 * Nk - 1):; alpha_p[j][k] = (; (deltafun(j, k + 1) + deltafun(j, k - 1)); / np.sqrt((2 * (j + 1) + 1) * (2 * (k + 1) + 1)); ). chi = [-2. / val for val in eigvalsh(alpha_p)[:Nk - 1]]. eta_list = [; 0.5 * Nk * (2 * (Nk + 1) - 1) * (; np.prod([chi[k]**2 - eps[j]**2 for k in range(Nk - 1)]) /; np.prod([; eps[k]**2 - eps[j]**2 + deltafun(j, k) for k in range(Nk); ]); ); for j in range(Nk); ]. kappa = [0] + eta_list; epsilon = [0] + eps. return kappa, epsilon. kappa, epsilon = kappa_epsilon(Nk). # Phew, we made it to function that calculates the coefficients for the; # correlation function expansions:. def C(sigma, mu, Nk):; """""" Calculate the expansion coefficients for C_\sigma. """"""; beta = 1. / T; ck = [0.5 * gamma * W * f_approx(1.0j * beta * W, Nk)]; vk = [W - sigma * 1.0j * mu]; for ll in range(1, Nk + 1):; ck.append(; -1.0j * (kappa[ll] / beta) * gamma * W**2; / (-(epsilon[ll]**2 / beta**2) + W**2); ); vk.append(epsilon[ll] / beta - sigma * 1.0j * mu); return ck, vk. ck_plus_L, vk_plus_L = C(1.0, mu_L, Nk) # C_+, left bath; ck_minus_L, vk_minus_L = C(-1.0, mu_L, Nk) # C_-, left bath. ck_plus_R, vk_plus_R = C(1.0, mu_R, Nk) # C_+, right bath; ck_minus_R, vk_minus_R = C(-1.0, mu_R, Nk) # C_-, right bath. Finally we are ready to construct the; FermionicBath:; from qutip.nonmarkov.heom import FermionicBath. # Padé expansion:; bath_L = FermionicBath(Q, ck_plus_L, vk_plus_L, ck_minus_L, vk_minus_L); bath_R = FermionicBath(Q, ck_plus_R, vk_plus_R, ck_minus_R, vk_minus_R). And we’re done!; The FermionicBath can be used with the; HEOMSolver in exactly the same way as the baths; we constructed previously using the built-in Lorentzian bath expansions. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:2989,Energy Efficiency,energy,energy,2989,"ch bath will have a different chemical; potential \(\mu\) which we will label \(\mu_L\) and \(\mu_R\).; First we will do this using the built-in implementations of the bath expansions,; LorentzianBath and; LorentzianPadeBath.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths.; Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in example notebook 4b. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where \(\Gamma\) (gamma), \(W\) and \(T\) are the parameters of; an Lorentzian bath, \(\mu_L\) (mu_L) and \(\mu_R\) (mu_R) are; the chemical potentials of the left and right baths, and Q is the coupling; operator between the system and the baths.; We may the pass these parameters to either LorentzianBath or; LorentzianPadeBath to construct an expansion of the bath correlations:; from qutip.nonmarkov.heom import LorentzianBath; from qutip.nonmarkov.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, ta",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:11666,Energy Efficiency,Efficient,Efficient,11666," bath, so we define two different correlation; functions, \(C_{+}(t)\), and \(C_{-}(t)\):. \[C^{\sigma}(t) = \frac{1}{2\pi} \int_{-\infty}^{\infty} d\omega e^{\sigma i \omega t} J(\omega) f_F[\sigma\beta(\omega - \mu)]\]; where \(\sigma\) is either + or - and, \(f_F\) is the Fermi; distribution function, and \(J(\omega)\) is the Lorentzian spectral density; we defined at the start.; The Fermi distribution function is:. \[f_F (x) = (\exp(x) + 1)^{-1}\]; As in the bosonic case we can approximate this integral with a Matsubara or; Padé expansion. For the Lorentzian bath the Padé expansion converges much; more quickly, so we will calculate the Padé expansion coefficients here.; The Padé decomposition approximates the Fermi distribution as:. \[f_F(x) \approx f_F^{\mathrm{approx}}(x) = \frac{1}{2} - \sum_{l=0}^{Nk} \frac{2k_l x}{x^2 + \epsilon_l^2}\]; where \(k_l\) and \(\epsilon_l\) are coefficients defined in; J. Chem Phys 133, “Efficient on the fly calculation of time correlation functions in computer simulations”,; and \(Nk\) specifies the cut-off in the expansion.; Evaluating the integral for the correlation functions gives:. \[C^{\sigma}(t) \approx \sum_{l=0}^{Nk} \eta^{\sigma,l} e^{-\gamma_{\sigma,l}t}\]; where:. \[ \begin{align}\begin{aligned}\begin{split}\eta_{\sigma, l} &= \begin{cases}; \frac{\Gamma W}{2} f_F^{approx}(i\beta W) & l = 0\\; -i\cdot \frac{k_l}{\beta} \cdot \frac{\Gamma W^2}{-\frac{\epsilon^2_l}{\beta^2} + W^2} & l \neq 0\\; \end{cases}\end{split}\\\begin{split}\gamma_{\sigma,l} &= \begin{cases}; W - \sigma i\mu & l = 0\\; \frac{\epsilon_l}{\beta} - \sigma i \mu & l \neq 0\\; \end{cases}\end{split}\end{aligned}\end{align} \]; and \(\beta = \frac{1}{T}\).; And now we calculate the same numbers in Python:; # Imports; from numpy.linalg import eigvalsh. # Convenience functions and parameters:; def deltafun(j, k):; """""" Kronecker delta function. """"""; return 1.0 if j == k else 0. def f_approx(x, Nk):; """""" Padé approxmation to Fermi distribution. """"""; f = 0",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:1746,Modifiability,evolve,evolve,1746,"relation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Fermionic Environments. Fermionic Environments¶; Here we model a single fermion coupled to two electronic leads or reservoirs; (e.g., this can describe a single quantum dot, a molecular transistor, etc).; The system hamiltonian, \(H_{sys}\), and bath spectral density, \(J_D\),; are. \[ \begin{align}\begin{aligned}H_{sys} &= c^{\dagger} c\\J_D &= \frac{\Gamma W^2}{(w - \mu)^2 + W^2},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; Since our fermion is coupled to two reservoirs, we will construct two baths –; one for each reservoir or lead – and call them the left (\(L\)) and right; (\(R\)) baths for convenience. Each bath will have a different chemical; potential \(\mu\) which we will label \(\mu_L\) and \(\mu_R\).; First we will do this using the built-in implementations of the bath expansions,; LorentzianBath and; LorentzianPadeBath.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths.; Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:3195,Modifiability,coupling,coupling,3195,"; LorentzianPadeBath.; Afterwards, we will show how to calculate the bath expansion coefficients and to; use those coefficients to construct your own bath description so that you can; implement your own fermionic baths.; Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in example notebook 4b. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where \(\Gamma\) (gamma), \(W\) and \(T\) are the parameters of; an Lorentzian bath, \(\mu_L\) (mu_L) and \(\mu_R\) (mu_R) are; the chemical potentials of the left and right baths, and Q is the coupling; operator between the system and the baths.; We may the pass these parameters to either LorentzianBath or; LorentzianPadeBath to construct an expansion of the bath correlations:; from qutip.nonmarkov.heom import LorentzianBath; from qutip.nonmarkov.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Padé expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianPadeBath(Q, gamma, W, mu_R, T, Nk,",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:3357,Modifiability,coupling,coupling,3357,"tion so that you can; implement your own fermionic baths.; Our implementation of fermionic baths primarily follows the definitions used by; Christian Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in example notebook 4b. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where \(\Gamma\) (gamma), \(W\) and \(T\) are the parameters of; an Lorentzian bath, \(\mu_L\) (mu_L) and \(\mu_R\) (mu_R) are; the chemical potentials of the left and right baths, and Q is the coupling; operator between the system and the baths.; We may the pass these parameters to either LorentzianBath or; LorentzianPadeBath to construct an expansion of the bath correlations:; from qutip.nonmarkov.heom import LorentzianBath; from qutip.nonmarkov.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Padé expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianPadeBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). Where Nk is the number of terms to retain within the expansion of the; bath.; Note that we haved labelled each bath with a tag (either “L” or “R”) so t",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:3587,Modifiability,coupling,coupling,3587,"n Schinabeck in his dissertation (; https://opus4.kobv.de/opus4-fau/files/10984/DissertationChristianSchinabeck.pdf; ) and related publications.; A notebook containing a complete example similar to this one implemented in; BoFiN can be found in example notebook 4b. Describing the system and bath¶; First, let us construct the system Hamiltonian, \(H_{sys}\), and the initial; system state, rho0:; from qutip import basis, destroy. # The system Hamiltonian:; e1 = 1. # site energy; H_sys = e1 * destroy(2).dag() * destroy(2). # Initial state of the system:; rho0 = basis(2,0) * basis(2,0).dag(). Now let us describe the bath properties:; # Shared bath properties:; gamma = 0.01 # coupling strength; W = 1.0 # cut-off; T = 0.025851991 # temperature; beta = 1. / T. # Chemical potentials for the two baths:; mu_L = 1.; mu_R = -1. # System-bath coupling operator:; Q = destroy(2). where \(\Gamma\) (gamma), \(W\) and \(T\) are the parameters of; an Lorentzian bath, \(\mu_L\) (mu_L) and \(\mu_R\) (mu_R) are; the chemical potentials of the left and right baths, and Q is the coupling; operator between the system and the baths.; We may the pass these parameters to either LorentzianBath or; LorentzianPadeBath to construct an expansion of the bath correlations:; from qutip.nonmarkov.heom import LorentzianBath; from qutip.nonmarkov.heom import LorentzianPadeBath. # Number of expansion terms to retain:; Nk = 2. # Matsubara expansion:; bath_L = LorentzianBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). # Padé expansion:; bath_L = LorentzianPadeBath(Q, gamma, W, mu_L, T, Nk, tag=""L""); bath_R = LorentzianPadeBath(Q, gamma, W, mu_R, T, Nk, tag=""R""). Where Nk is the number of terms to retain within the expansion of the; bath.; Note that we haved labelled each bath with a tag (either “L” or “R”) so that; we can identify the exponents from individual baths later when calculating; the currents between the system and the bath. System and bath dynami",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:6956,Security,access,access,6956,"legend(loc=0, fontsize=12). The plot above is not very exciting. What we would really like to see in; this case are the currents between the system and the two baths. We will plot; these in the next section using the auxiliary density operators (ADOs); returned by the solver. Determining currents¶; The currents between the system and a fermionic bath may be calculated from the; first level auxiliary density operators (ADOs) associated with the exponents; of that bath.; The contribution to the current into a given bath from each exponent in that; bath is:. \[\mathrm{Contribution from Exponent} = \pm i \mathrm{Tr}(Q^\pm \cdot A)\]; where the \(\pm\) sign is the sign of the exponent (see the; description later in Padé expansion coefficients) and; \(Q^\pm\) is \(Q\) for + exponents and \(Q^{\dagger}\) for; - exponents.; The first-level exponents for the left bath are retrieved by calling; .filter(tags=[""L""]) on ado_state which is an instance of; HierarchyADOsState and also provides access to; the methods of HierarchyADOs which describes the; structure of the hierarchy for a given problem.; Here the tag “L” matches the tag passed when constructing bath_L earlier; in this example.; Similarly, we may calculate the current to the right bath from the exponents; tagged with “R”.; def exp_current(aux, exp):; """""" Calculate the current for a single exponent. """"""; sign = 1 if exp.type == exp.types[""+""] else -1; op = exp.Q if exp.type == exp.types[""+""] else exp.Q.dag(); return 1j * sign * (op * aux).tr(). def heom_current(tag, ado_state):; """""" Calculate the current between the system and the given bath. """"""; level_1_ados = [; (ado_state.extract(label), ado_state.exps(label)[0]); for label in ado_state.filter(tags=[tag]); ]; return np.real(sum(exp_current(aux, exp) for aux, exp in level_1_ados)). heom_left_current = lambda t, ado_state: heom_current(""L"", ado_state); heom_right_current = lambda t, ado_state: heom_current(""R"", ado_state). Once we have defined functions for retrieving",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:985,Testability,Log,Log,985,"nic Environments — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Describing the system and bath; System and bath dynamics; Determining currents; Steady state currents; Padé expansion coefficients. Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Fermionic Environments. Fermionic Environments¶; Here we model a single fermion coupled to two electronic leads or reservoirs; (e.g., this can describe a single quantum dot, a molecular transistor, etc).; The system hamiltonian, \(H_{sys}\), and bath spectral density, \(J_D\),; are. \[ \begin{align}\begin{aligned}H_{sys} &= c^{\dagger} c\\J_D &= \frac{\Gamma W^2}{(w - \mu)^2 + W^2},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; Since our fermion is coupled to two reservoirs, we will construct two baths –; one for each reservoir or lead – and call them the left (\(L\)) and right; (\(R\)) baths for convenience. Each bath",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:132,Usability,Guid,Guide,132,". Fermionic Environments — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Describing the system and bath; System and bath dynamics; Determining currents; Steady state currents; Padé expansion coefficients. Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Fermionic Environments. Fermionic Environments¶; Here we model a single fermion coupled to two electronic leads or reservoirs; (e.g., this can describe a single quantum dot, a molecular transistor, etc).; The system hamiltonian, \(H_{sys}\), and bath spectral density, \(J_D\),; are. \[ \begin{align}\begin{aligned}H_{sys} &= c^{\dagger} c\\J_D &= \frac{\Gamma W^2}{(w - \mu)^2 + W^2},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; Since our fermion is coupled to two reservoirs, we will construct two baths –; one for each reservoir or lead – and call them the left (\(L\)) and right; (\(R\)) baths for convenience. Ea",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:139,Usability,Guid,Guide,139,". Fermionic Environments — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Describing the system and bath; System and bath dynamics; Determining currents; Steady state currents; Padé expansion coefficients. Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Fermionic Environments. Fermionic Environments¶; Here we model a single fermion coupled to two electronic leads or reservoirs; (e.g., this can describe a single quantum dot, a molecular transistor, etc).; The system hamiltonian, \(H_{sys}\), and bath spectral density, \(J_D\),; are. \[ \begin{align}\begin{aligned}H_{sys} &= c^{\dagger} c\\J_D &= \frac{\Gamma W^2}{(w - \mu)^2 + W^2},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; Since our fermion is coupled to two reservoirs, we will construct two baths –; one for each reservoir or lead – and call them the left (\(L\)) and right; (\(R\)) baths for convenience. Ea",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/fermionic.html:1111,Usability,Guid,Guide,1111,"uide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Describing the system and bath; System and bath dynamics; Determining currents; Steady state currents; Padé expansion coefficients. Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Fermionic Environments. Fermionic Environments¶; Here we model a single fermion coupled to two electronic leads or reservoirs; (e.g., this can describe a single quantum dot, a molecular transistor, etc).; The system hamiltonian, \(H_{sys}\), and bath spectral density, \(J_D\),; are. \[ \begin{align}\begin{aligned}H_{sys} &= c^{\dagger} c\\J_D &= \frac{\Gamma W^2}{(w - \mu)^2 + W^2},\end{aligned}\end{align} \]; We will demonstrate how to describe the bath using two different expansions; of the spectral density correlation function (Matsubara’s expansion and; a Padé expansion), how to evolve the system in time, and how to calculate; the steady state.; Since our fermion is coupled to two reservoirs, we will construct two baths –; one for each reservoir or lead – and call them the left (\(L\)) and right; (\(R\)) baths for convenience. Each bath will have a different chemical; potential \(\mu\) which we will label \(\mu_L\) and \(\mu_R\).; First we will do this using the bui",MatchSource.WIKI,docs/4.7/guide/heom/fermionic.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/fermionic.html
https://qutip.org/docs/4.7/guide/heom/history.html:1374,Availability,avail,available,1374,"rchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implemen",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:1640,Availability,avail,available,1640,"n of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:2590,Availability,avail,available,2590," for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. Built-in implementations of a variety of different baths; are provided, and a single solver is used for both fermionic and bosonic baths.; Multiple baths of the same kind (either fermionic or bosonic) may be; specified in a single problem, and there is good support for working with; the auxiliary density operator (ADO) state and extracting information from it.; The code was written by Neill Lambert and Simon Cross. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:114,Deployability,Install,Installation,114,". Previous implementations — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors ",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:3362,Deployability,update,updated,3362," for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. Built-in implementations of a variety of different baths; are provided, and a single solver is used for both fermionic and bosonic baths.; Multiple baths of the same kind (either fermionic or bosonic) may be; specified in a single problem, and there is good support for working with; the auxiliary density operator (ADO) state and extracting information from it.; The code was written by Neill Lambert and Simon Cross. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:1594,Integrability,interface,interface,1594,"n of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:1787,Modifiability,flexible,flexible,1787," of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. ",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:2714,Modifiability,rewrite,rewrite,2714," for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. Built-in implementations of a variety of different baths; are provided, and a single solver is used for both fermionic and bosonic baths.; Multiple baths of the same kind (either fermionic or bosonic) may be; specified in a single problem, and there is good support for working with; the auxiliary density operator (ADO) state and extracting information from it.; The code was written by Neill Lambert and Simon Cross. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:2346,Performance,perform,performed,2346," by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and Alexander Pitchford.; BoFiN was written outside of QuTiP and is can still be found in its original; repository at https://github.com/tehruhn/bofin.; The construction of the right-hand side matrix for BoFiN was slow, so; BoFiN-fast, a hybrid C++ and Python implementation, was written that performed; the right-hand side construction in C++. It was otherwise identical to the; pure Python version. BoFiN-fast can be found at; https://github.com/tehruhn/bofin_fast.; BoFiN also came with an extensive set of example notebooks that are available; at https://github.com/tehruhn/bofin/tree/main/examples. Current implementation¶; The current implementation is a rewrite of BoFiN in pure Python. It’s; right-hand side construction has similar speed to BoFiN-fast, but is written; in pure Python. Built-in implementations of a variety of different baths; are provided, and a single solver is used for both fermionic and bosonic baths.; Multiple baths of the same kind (either fermionic or bosonic) may be; specified in a single problem, and there is good support for working with; the auxiliary density operator (ADO) state and extracting information from it.; The code was written by Neill Lambert and Simon Cross. Next ; Previous. © Copyright 2011 t",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:902,Testability,Log,Log,902,". Previous implementations — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors ",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:134,Usability,Guid,Guide,134,". Previous implementations — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors ",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:141,Usability,Guid,Guide,141,". Previous implementations — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors ",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/history.html:1028,Usability,Guid,Guide,1028,"P: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; HSolverDL; BoFiN-HEOM; Current implementation. References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Previous implementations. Previous implementations¶; The current HEOM implementation in QuTiP is the latest in a succession of HEOM; implementations by various contributors:. HSolverDL¶; The original HEOM solver was implemented by Neill Lambert, Anubhav Vardhan,; and Alexander Pitchford and is still available as; qutip.nonmarkov.dlheom_solver.HSolverDL and only directly provided; support for the Drude-Lorentz bath although there was the possibility of; sub-classing the solver to implement other baths.; A compatible interface using the current implementation is available under the; same name in qutip.nonmarkov.heom.HSolverDL. BoFiN-HEOM¶; BoFiN-HEOM (the bosonic and fermionic HEOM solver) was a much more; flexible re-write of the original QuTiP HSolverDL that added support for; both bosonic and fermionic baths and for baths to be specified directly via; their correlation function expansion coefficients. Its authors were; Neill Lambert, Tarun Raheja, Shahnawaz Ahmed, and A",MatchSource.WIKI,docs/4.7/guide/heom/history.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/history.html
https://qutip.org/docs/4.7/guide/heom/intro.html:102,Deployability,Install,Installation,102,". Introduction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Introduction. Introduction¶; The Hierarchical Equations of Motion (HEOM) method was originally developed by; Tanimura and Kubo [TK89] in the context of physical chemistry to; ‘’exactly’’ solve a quantum system in contact with a bosonic environment,; encapsulated in the Hamiltonian:. \[H = H_s + \sum_k \omega_k a_k^{\dagger}a_k + \hat{Q} \sum_k g_k \left(a_k + a_k^{\dagger}\right).\]; As in other solutions to this problem, the properties of the bath are; encapsulated by its temperature and its spectral density,. \[J(\omega) = \pi \sum_k g_k^2 \delta(\omega-\omega_k).\]; In the HEOM, for bosonic baths, one typically chooses a Drude-Lorentz spectral; density:. \[J_D = \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\]; or an under-damped Brownian motion spectral density:. \[J_U = \frac{\alpha^2 \Gamma \omega}{[(\omega_c^2 - \omega^2)^2 + \Gamma^2 \omega^2]}.\]; Given the spectral density, the HEOM requires a decomposition of the bath; correlation functions in terms of ex",MatchSource.WIKI,docs/4.7/guide/heom/intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/intro.html
https://qutip.org/docs/4.7/guide/heom/intro.html:2534,Deployability,update,updated,2534,"uTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Introduction. Introduction¶; The Hierarchical Equations of Motion (HEOM) method was originally developed by; Tanimura and Kubo [TK89] in the context of physical chemistry to; ‘’exactly’’ solve a quantum system in contact with a bosonic environment,; encapsulated in the Hamiltonian:. \[H = H_s + \sum_k \omega_k a_k^{\dagger}a_k + \hat{Q} \sum_k g_k \left(a_k + a_k^{\dagger}\right).\]; As in other solutions to this problem, the properties of the bath are; encapsulated by its temperature and its spectral density,. \[J(\omega) = \pi \sum_k g_k^2 \delta(\omega-\omega_k).\]; In the HEOM, for bosonic baths, one typically chooses a Drude-Lorentz spectral; density:. \[J_D = \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\]; or an under-damped Brownian motion spectral density:. \[J_U = \frac{\alpha^2 \Gamma \omega}{[(\omega_c^2 - \omega^2)^2 + \Gamma^2 \omega^2]}.\]; Given the spectral density, the HEOM requires a decomposition of the bath; correlation functions in terms of exponentials. In Bosonic Environments we describe; how this is done with code examples, and how these expansions are passed to the; solver.; In addition to support for bosonic environments, QuTiP also provides support for; feriomic environments which is described in Fermionic Environments.; Both bosonic and fermionic environments are supported via a single solver,; HEOMSolver, that supports solving for both dynamics and steady-states. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/intro.html
https://qutip.org/docs/4.7/guide/heom/intro.html:843,Testability,Log,Log,843,". Introduction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Introduction. Introduction¶; The Hierarchical Equations of Motion (HEOM) method was originally developed by; Tanimura and Kubo [TK89] in the context of physical chemistry to; ‘’exactly’’ solve a quantum system in contact with a bosonic environment,; encapsulated in the Hamiltonian:. \[H = H_s + \sum_k \omega_k a_k^{\dagger}a_k + \hat{Q} \sum_k g_k \left(a_k + a_k^{\dagger}\right).\]; As in other solutions to this problem, the properties of the bath are; encapsulated by its temperature and its spectral density,. \[J(\omega) = \pi \sum_k g_k^2 \delta(\omega-\omega_k).\]; In the HEOM, for bosonic baths, one typically chooses a Drude-Lorentz spectral; density:. \[J_D = \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\]; or an under-damped Brownian motion spectral density:. \[J_U = \frac{\alpha^2 \Gamma \omega}{[(\omega_c^2 - \omega^2)^2 + \Gamma^2 \omega^2]}.\]; Given the spectral density, the HEOM requires a decomposition of the bath; correlation functions in terms of ex",MatchSource.WIKI,docs/4.7/guide/heom/intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/intro.html
https://qutip.org/docs/4.7/guide/heom/intro.html:122,Usability,Guid,Guide,122,". Introduction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Introduction. Introduction¶; The Hierarchical Equations of Motion (HEOM) method was originally developed by; Tanimura and Kubo [TK89] in the context of physical chemistry to; ‘’exactly’’ solve a quantum system in contact with a bosonic environment,; encapsulated in the Hamiltonian:. \[H = H_s + \sum_k \omega_k a_k^{\dagger}a_k + \hat{Q} \sum_k g_k \left(a_k + a_k^{\dagger}\right).\]; As in other solutions to this problem, the properties of the bath are; encapsulated by its temperature and its spectral density,. \[J(\omega) = \pi \sum_k g_k^2 \delta(\omega-\omega_k).\]; In the HEOM, for bosonic baths, one typically chooses a Drude-Lorentz spectral; density:. \[J_D = \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\]; or an under-damped Brownian motion spectral density:. \[J_U = \frac{\alpha^2 \Gamma \omega}{[(\omega_c^2 - \omega^2)^2 + \Gamma^2 \omega^2]}.\]; Given the spectral density, the HEOM requires a decomposition of the bath; correlation functions in terms of ex",MatchSource.WIKI,docs/4.7/guide/heom/intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/intro.html
https://qutip.org/docs/4.7/guide/heom/intro.html:129,Usability,Guid,Guide,129,". Introduction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Introduction. Introduction¶; The Hierarchical Equations of Motion (HEOM) method was originally developed by; Tanimura and Kubo [TK89] in the context of physical chemistry to; ‘’exactly’’ solve a quantum system in contact with a bosonic environment,; encapsulated in the Hamiltonian:. \[H = H_s + \sum_k \omega_k a_k^{\dagger}a_k + \hat{Q} \sum_k g_k \left(a_k + a_k^{\dagger}\right).\]; As in other solutions to this problem, the properties of the bath are; encapsulated by its temperature and its spectral density,. \[J(\omega) = \pi \sum_k g_k^2 \delta(\omega-\omega_k).\]; In the HEOM, for bosonic baths, one typically chooses a Drude-Lorentz spectral; density:. \[J_D = \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\]; or an under-damped Brownian motion spectral density:. \[J_U = \frac{\alpha^2 \Gamma \omega}{[(\omega_c^2 - \omega^2)^2 + \Gamma^2 \omega^2]}.\]; Given the spectral density, the HEOM requires a decomposition of the bath; correlation functions in terms of ex",MatchSource.WIKI,docs/4.7/guide/heom/intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/intro.html
https://qutip.org/docs/4.7/guide/heom/intro.html:969,Usability,Guid,Guide,969,". Introduction — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; Introduction. Introduction¶; The Hierarchical Equations of Motion (HEOM) method was originally developed by; Tanimura and Kubo [TK89] in the context of physical chemistry to; ‘’exactly’’ solve a quantum system in contact with a bosonic environment,; encapsulated in the Hamiltonian:. \[H = H_s + \sum_k \omega_k a_k^{\dagger}a_k + \hat{Q} \sum_k g_k \left(a_k + a_k^{\dagger}\right).\]; As in other solutions to this problem, the properties of the bath are; encapsulated by its temperature and its spectral density,. \[J(\omega) = \pi \sum_k g_k^2 \delta(\omega-\omega_k).\]; In the HEOM, for bosonic baths, one typically chooses a Drude-Lorentz spectral; density:. \[J_D = \frac{2\lambda \gamma \omega}{(\gamma^2 + \omega^2)},\]; or an under-damped Brownian motion spectral density:. \[J_U = \frac{\alpha^2 \Gamma \omega}{[(\omega_c^2 - \omega^2)^2 + \Gamma^2 \omega^2]}.\]; Given the spectral density, the HEOM requires a decomposition of the bath; correlation functions in terms of ex",MatchSource.WIKI,docs/4.7/guide/heom/intro.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/intro.html
https://qutip.org/docs/4.7/guide/heom/references.html:100,Deployability,Install,Installation,100,". References — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; References. References¶. LACN19; Neill Lambert, Shahnawaz Ahmed, Mauro Cirio, and Franco Nori. Virtual excitations in the ultra-strongly-coupled spin-boson model: physical results from unphysical modes. arXiv preprint arXiv:1903.05892, 2019. Tan20; Yoshitaka Tanimura. Numerically “exact” approach to open quantum dynamics: the hierarchical equations of motion (heom). The Journal of Chemical Physics, 153(2):020901, 2020. URL: https://doi.org/10.1063/5.0011599, doi:10.1063/5.0011599. TK89; Yoshitaka Tanimura and Ryogo Kubo. Time evolution of a quantum system in contact with a nearly gaussian-markoffian noise bath. J. Phys. Soc. Jpn., 58(1):101–114, 1989. doi:10.1143/jpsj.58.101. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/references.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/references.html
https://qutip.org/docs/4.7/guide/heom/references.html:1793,Deployability,update,updated,1793,". References — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; References. References¶. LACN19; Neill Lambert, Shahnawaz Ahmed, Mauro Cirio, and Franco Nori. Virtual excitations in the ultra-strongly-coupled spin-boson model: physical results from unphysical modes. arXiv preprint arXiv:1903.05892, 2019. Tan20; Yoshitaka Tanimura. Numerically “exact” approach to open quantum dynamics: the hierarchical equations of motion (heom). The Journal of Chemical Physics, 153(2):020901, 2020. URL: https://doi.org/10.1063/5.0011599, doi:10.1063/5.0011599. TK89; Yoshitaka Tanimura and Ryogo Kubo. Time evolution of a quantum system in contact with a nearly gaussian-markoffian noise bath. J. Phys. Soc. Jpn., 58(1):101–114, 1989. doi:10.1143/jpsj.58.101. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/references.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/references.html
https://qutip.org/docs/4.7/guide/heom/references.html:841,Testability,Log,Log,841,". References — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; References. References¶. LACN19; Neill Lambert, Shahnawaz Ahmed, Mauro Cirio, and Franco Nori. Virtual excitations in the ultra-strongly-coupled spin-boson model: physical results from unphysical modes. arXiv preprint arXiv:1903.05892, 2019. Tan20; Yoshitaka Tanimura. Numerically “exact” approach to open quantum dynamics: the hierarchical equations of motion (heom). The Journal of Chemical Physics, 153(2):020901, 2020. URL: https://doi.org/10.1063/5.0011599, doi:10.1063/5.0011599. TK89; Yoshitaka Tanimura and Ryogo Kubo. Time evolution of a quantum system in contact with a nearly gaussian-markoffian noise bath. J. Phys. Soc. Jpn., 58(1):101–114, 1989. doi:10.1143/jpsj.58.101. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/references.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/references.html
https://qutip.org/docs/4.7/guide/heom/references.html:120,Usability,Guid,Guide,120,". References — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; References. References¶. LACN19; Neill Lambert, Shahnawaz Ahmed, Mauro Cirio, and Franco Nori. Virtual excitations in the ultra-strongly-coupled spin-boson model: physical results from unphysical modes. arXiv preprint arXiv:1903.05892, 2019. Tan20; Yoshitaka Tanimura. Numerically “exact” approach to open quantum dynamics: the hierarchical equations of motion (heom). The Journal of Chemical Physics, 153(2):020901, 2020. URL: https://doi.org/10.1063/5.0011599, doi:10.1063/5.0011599. TK89; Yoshitaka Tanimura and Ryogo Kubo. Time evolution of a quantum system in contact with a nearly gaussian-markoffian noise bath. J. Phys. Soc. Jpn., 58(1):101–114, 1989. doi:10.1143/jpsj.58.101. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/references.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/references.html
https://qutip.org/docs/4.7/guide/heom/references.html:127,Usability,Guid,Guide,127,". References — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; References. References¶. LACN19; Neill Lambert, Shahnawaz Ahmed, Mauro Cirio, and Franco Nori. Virtual excitations in the ultra-strongly-coupled spin-boson model: physical results from unphysical modes. arXiv preprint arXiv:1903.05892, 2019. Tan20; Yoshitaka Tanimura. Numerically “exact” approach to open quantum dynamics: the hierarchical equations of motion (heom). The Journal of Chemical Physics, 153(2):020901, 2020. URL: https://doi.org/10.1063/5.0011599, doi:10.1063/5.0011599. TK89; Yoshitaka Tanimura and Ryogo Kubo. Time evolution of a quantum system in contact with a nearly gaussian-markoffian noise bath. J. Phys. Soc. Jpn., 58(1):101–114, 1989. doi:10.1143/jpsj.58.101. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/references.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/references.html
https://qutip.org/docs/4.7/guide/heom/references.html:967,Usability,Guid,Guide,967,". References — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Introduction; Bosonic Environments; Fermionic Environments; Previous implementations; References. Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Hierarchical Equations of Motion »; References. References¶. LACN19; Neill Lambert, Shahnawaz Ahmed, Mauro Cirio, and Franco Nori. Virtual excitations in the ultra-strongly-coupled spin-boson model: physical results from unphysical modes. arXiv preprint arXiv:1903.05892, 2019. Tan20; Yoshitaka Tanimura. Numerically “exact” approach to open quantum dynamics: the hierarchical equations of motion (heom). The Journal of Chemical Physics, 153(2):020901, 2020. URL: https://doi.org/10.1063/5.0011599, doi:10.1063/5.0011599. TK89; Yoshitaka Tanimura and Ryogo Kubo. Time evolution of a quantum system in contact with a nearly gaussian-markoffian noise bath. J. Phys. Soc. Jpn., 58(1):101–114, 1989. doi:10.1143/jpsj.58.101. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/heom/references.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/heom/references.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:1984,Availability,avail,available,1984," Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved as a class object Gate; with information such as gate name, target qubits and arguments.; Gates can also be controlled on a classical bit by specifying the register number; with the argument classical_controls.; Measurements: We can also carry out measurements on individual qubit (both in the middle and at the end of the circuit).; Each measurement is saved as a class object Measurement with parameters such as targets,; the target qubit on which the measurement will be carried out, and classical_store,; the index of the classical register which stores the result of the measurement. A circuit with the various gates and registers available is demonstrated below:; from qutip.qip.circuit import QubitCircuit, Gate; from qutip import tensor, basis. qc = QubitCircuit(N=2, num_cbits=1); swap_gate = Gate(name=""SWAP"", targets=[0, 1]). qc.add_gate(swap_gate); qc.a",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:2695,Availability,avail,available,2695,"ircuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved as a class object Gate; with information such as gate name, target qubits and arguments.; Gates can also be controlled on a classical bit by specifying the register number; with the argument classical_controls.; Measurements: We can also carry out measurements on individual qubit (both in the middle and at the end of the circuit).; Each measurement is saved as a class object Measurement with parameters such as targets,; the target qubit on which the measurement will be carried out, and classical_store,; the index of the classical register which stores the result of the measurement. A circuit with the various gates and registers available is demonstrated below:; from qutip.qip.circuit import QubitCircuit, Gate; from qutip import tensor, basis. qc = QubitCircuit(N=2, num_cbits=1); swap_gate = Gate(name=""SWAP"", targets=[0, 1]). qc.add_gate(swap_gate); qc.add_measurement(""M0"", targets=[1], classical_store=0) # measurement gate; qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""X"", targets=0, classical_controls=[0]) # classically controlled gate; qc.add_gate(swap_gate). print(qc.gates). Output:; [Gate(SWAP, targets=[0, 1], controls=None, classical controls=None, control_value=None),; Measurement(M0, target=[1], classical_store=0),; Gate(CNOT, targets=[1], controls=[0], classical controls=None, control_value=None),; Gate(X, targets=[0], controls=None, classical controls=[0], control_value=None),; Gate(SWAP, targets=[0, 1], controls=None, classical controls=None, control_value=None)]. Unitaries¶; There are a few useful functions associated with the circuit object. For example,; the propagators method returns",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9543,Availability,down,download,9543,"+0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exa",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:120,Deployability,Install,Installation,120,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for mea",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9346,Deployability,install,installed,9346,"shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1. +0.j 0. +0.j 0. +0.j; 0. +0.j ]; [0. +0.j 0.70710678+0.j 0. +0.j; 0. -0.70710678j]; [0. +0.j 0. +0.j 1. +0.j; 0. +0.j ]; [0. +0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9379,Deployability,install,install,9379,"shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1. +0.j 0. +0.j 0. +0.j; 0. +0.j ]; [0. +0.j 0.70710678+0.j 0. +0.j; 0. -0.70710678j]; [0. +0.j 0. +0.j 1. +0.j; 0. +0.j ]; [0. +0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9417,Deployability,install,installed,9417,"shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1. +0.j 0. +0.j 0. +0.j; 0. +0.j ]; [0. +0.j 0.70710678+0.j 0. +0.j; 0. -0.70710678j]; [0. +0.j 0. +0.j 1. +0.j; 0. +0.j ]; [0. +0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9458,Deployability,install,installation,9458,"710678+0.j 0. +0.j; 0. -0.70710678j]; [0. +0.j 0. +0.j 1. +0.j; 0. +0.j ]; [0. +0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9556,Deployability,install,install,9556,"+0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exa",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9576,Deployability,install,installer,9576,"+0.j 0. -0.70710678j 0. +0.j; 0.70710678+0.j ]]. print(props[2]). Output:; Quantum object: dims = [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exa",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9761,Deployability,install,installed,9761,"]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different me",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:11169,Deployability,update,updated,11169,"converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different method of circuit simulation employs driving Hamiltonians with the ability to; simulate circuits in the presence of noise. This can be achieved through the various classes; in qutip.qip.device. A short guide to processors for QIP simulation can be found at Pulse-level circuit simulation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:6825,Energy Efficiency,reduce,reduced,6825,"tation around x axis. “CRY”; Controlled rotation around y axis. “CRZ”; Controlled rotation around z axis. “CX”; Controlled X gate. “CY”; Controlled Y gate. “CZ”; Controlled Z gate. “CS”; Controlled S gate. “CT”; Controlled T gate. “CPHASE”; Controlled phase gate. “CNOT”; Controlled NOT gate. “CSIGN”; Same as CPHASE. “QASMU”; U rotation gate used as a primitive in the QASM standard. “BERKELEY”; Berkeley gate. “SWAPalpha”; SWAPalpha gate. “SWAP”; Swap the states of two qubits. “ISWAP”; Swap gate with additional phase for 01 and 10 states. “SQRTSWAP”; Square root of the SWAP gate. “SQRTISWAP”; Square root of the ISWAP gate. “FREDKIN”; Fredkin gate. “TOFFOLI”; Toffoli gate. “GLOBALPHASE”; Global phase. For some of the gates listed above, QubitCircuit also has a primitive resolve_gates method that decomposes them into elementary gate sets such as CNOT or SWAP with single-qubit gates (RX, RY and RZ). However, this method is not fully optimized. It is very likely that the depth of the circuit can be further reduced by merging quantum gates. It is required that the gate resolution be carried out before the measurements to the circuit are added.; Custom Gates; In addition to these pre-defined gates, QuTiP also allows the user to define their own gate.; The following example shows how to define a customized gate.; The key step is to define a; gate function returning a qutip.Qobj and save it in the attribute user_gates.; from qutip.qip.circuit import Gate; from qutip.qip.operations import rx. def user_gate1(arg_value):; # controlled rotation X; mat = np.zeros((4, 4), dtype=np.complex); mat[0, 0] = mat[1, 1] = 1.; mat[2:4, 2:4] = rx(arg_value); return Qobj(mat, dims=[[2, 2], [2, 2]]). def user_gate2():; # S gate; mat = np.array([[1., 0],; [0., 1.j]]); return Qobj(mat, dims=[[2], [2]]). qc = QubitCircuit(2); qc.user_gates = {""CTRLRX"": user_gate1,; ""S"" : user_gate2}. # qubit 0 controls qubit 1; qc.add_gate(""CTRLRX"", targets=[0,1], arg_value=np.pi/2). # qubit 1 controls qubit 0; qc",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9663,Integrability,depend,dependency,9663,"= [[2, 2], [2, 2]], shape = (4, 4), type = oper, isherm = False; Qobj data =; [[1.+0.j 0.+0.j 0.+0.j 0.+0.j]; [0.+0.j 0.+1.j 0.+0.j 0.+0.j]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exa",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:9744,Integrability,depend,dependencies,9744,"]; [0.+0.j 0.+0.j 1.+0.j 0.+0.j]; [0.+0.j 0.+0.j 0.+0.j 0.+1.j]]. Plotting a Quantum Circuit¶; A quantum circuit (described above) can directly be plotted using the QCircuit library (https://github.com/CQuIC/qcircuit).; QCiruit is a quantum circuit drawing application and is implemented directly into QuTiP.; The circuit image visualization requires LaTeX and ImageMagick for display.; The module automatically generates the LaTeX code for plotting the circuit,; produces the pdf and converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different me",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:6751,Performance,optimiz,optimized,6751,"rd gate. “PHASEGATE”; Add a phase one the state 1. “CRX”; Controlled rotation around x axis. “CRY”; Controlled rotation around y axis. “CRZ”; Controlled rotation around z axis. “CX”; Controlled X gate. “CY”; Controlled Y gate. “CZ”; Controlled Z gate. “CS”; Controlled S gate. “CT”; Controlled T gate. “CPHASE”; Controlled phase gate. “CNOT”; Controlled NOT gate. “CSIGN”; Same as CPHASE. “QASMU”; U rotation gate used as a primitive in the QASM standard. “BERKELEY”; Berkeley gate. “SWAPalpha”; SWAPalpha gate. “SWAP”; Swap the states of two qubits. “ISWAP”; Swap gate with additional phase for 01 and 10 states. “SQRTSWAP”; Square root of the SWAP gate. “SQRTISWAP”; Square root of the ISWAP gate. “FREDKIN”; Fredkin gate. “TOFFOLI”; Toffoli gate. “GLOBALPHASE”; Global phase. For some of the gates listed above, QubitCircuit also has a primitive resolve_gates method that decomposes them into elementary gate sets such as CNOT or SWAP with single-qubit gates (RX, RY and RZ). However, this method is not fully optimized. It is very likely that the depth of the circuit can be further reduced by merging quantum gates. It is required that the gate resolution be carried out before the measurements to the circuit are added.; Custom Gates; In addition to these pre-defined gates, QuTiP also allows the user to define their own gate.; The following example shows how to define a customized gate.; The key step is to define a; gate function returning a qutip.Qobj and save it in the attribute user_gates.; from qutip.qip.circuit import Gate; from qutip.qip.operations import rx. def user_gate1(arg_value):; # controlled rotation X; mat = np.zeros((4, 4), dtype=np.complex); mat[0, 0] = mat[1, 1] = 1.; mat[2:4, 2:4] = rx(arg_value); return Qobj(mat, dims=[[2, 2], [2, 2]]). def user_gate2():; # S gate; mat = np.array([[1., 0],; [0., 1.j]]); return Qobj(mat, dims=[[2], [2]]). qc = QubitCircuit(2); qc.user_gates = {""CTRLRX"": user_gate1,; ""S"" : user_gate2}. # qubit 0 controls qubit 1; qc.add_gate(""CTR",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:959,Testability,Log,Log,959,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for mea",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:140,Usability,Guid,Guide,140,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for mea",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:147,Usability,Guid,Guide,147,". Quantum Information Processing — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for mea",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:1085,Usability,Guid,Guide,1085,"r; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved as a class object Gate; with information such as gate name",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:1328,Usability,simpl,simple,1328,"and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Introduction; Quantum Circuit; Unitaries; Gates; Plotting a Quantum Circuit; Circuit simulation. Operator-level circuit simulation; Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Quantum Information Processing. Quantum Information Processing¶. Introduction¶; The Quantum Information Processing (QIP) module aims at providing basic tools for quantum computing simulation both for simple quantum algorithm design and for experimental realization. It offers two different approaches, one with QubitCircuit calculating unitary evolution under quantum gates by matrix product, another called Processor using open system solvers in QuTiP to simulate noisy quantum device. Quantum Circuit¶; The most common model for quantum computing is the quantum circuit model.; In QuTiP, we use QubitCircuit to represent a quantum circuit.; The circuit is characterized by registers and gates:. Registers: The argument N specifies the number of qubit registers in the circuit; and the argument num_cbits (optional) specifies the number of classical bits available for measurement; and control.; Gates: Each quantum gate is saved as a class object Gate; with information such as gate name, target qubits and arguments.; Gates can also be controlled on a classical bit by specifying the register number; with the argument classical_controls.; Measurements: We can a",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:10636,Usability,guid,guide,10636,"converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different method of circuit simulation employs driving Hamiltonians with the ability to; simulate circuits in the presence of noise. This can be achieved through the various classes; in qutip.qip.device. A short guide to processors for QIP simulation can be found at Pulse-level circuit simulation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-basics.html:10986,Usability,guid,guide,10986,"converts it to the png format. On Mac and Linux,; ImageMagick can be easily installed with the command conda install imagemagick if you have conda installed.; Otherwise, please follow the installation instructions on the ImageMagick documentation.; On windows, you need to download and install ImageMagick installer.; In addition, you also need perl (for pdfcrop) and; Ghostscript (additional dependency of ImageMagick for png conversion).; If you want to check whether all dependencies are installed,; see if the following three commands work correctly:; pdflatex, pdfcrop and magick anypdf.pdf anypdf.png,; where anypdf.pdf is any pdf file you have.; An example code for plotting the example quantum circuit from above is given:; from qutip.qip.circuit import QubitCircuit, Gate; # create the quantum circuit; qc = QubitCircuit(2, num_cbits=1); qc.add_gate(""CNOT"", controls=0, targets=1); qc.add_gate(""H"", targets=1); qc.add_gate(""ISWAP"", targets=[0,1]); qc.add_measurement(""M0"", targets=1, classical_store=0); # plot the quantum circuit; qc.png. Circuit simulation¶; There are two different ways to simulate the action of quantum circuits using QuTiP:. The first method utilizes unitary application through matrix products on the input states.; This method simulates circuits exactly in a deterministic manner. This is achieved through; CircuitSimulator. A short guide to exact simulation can be; found at Operator-level circuit simulation. The teleportation notebook is also useful as an example.; A different method of circuit simulation employs driving Hamiltonians with the ability to; simulate circuits in the presence of noise. This can be achieved through the various classes; in qutip.qip.device. A short guide to processors for QIP simulation can be found at Pulse-level circuit simulation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-basics.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-basics.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:4627,Availability,avail,available,4627,"ferent physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrice",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:4890,Availability,avail,available,4890," find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will become very inefficient.; In the following we describe the predefined subclasses for Processor:",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:8593,Availability,avail,available,8593,"e device parameters including the cavity frequency, qubits frequency, detuning and interaction strength etc. Note; The run_state method of DispersiveCavityQED; returns the full simulation result of the solver,; hence including the cavity.; To obtain the circuit result, one needs to first trace out the cavity state. OptPulseProcessor; The OptPulseProcessor uses the function in optimize_pulse_unitary in the optimal control module to find the control pulses. The Hamiltonian includes a drift part and a control part and only the control part will be optimized. The unitary evolution follows. \[U(\Delta t)=\exp(\rm{i} \cdot \Delta t [H_d + \sum_j u_j H_j] )\]; To let it find the optimal pulses, we need to give the parameters for optimize_pulse_unitary as keyword arguments to load_circuit. Usually, the minimal requirements are the evolution time evo_time and the number of time slices num_tslots for each gate. Other parameters can also be given in the keyword arguments. For available choices, see optimize_pulse_unitary. It is also possible to specify different parameters for different gates, as shown in the following example:; from qutip.qip.device import OptPulseProcessor; from qutip.operators import sigmaz, sigmax, sigmay; from qutip.tensor import tensor. # Same parameter for all the gates; qc = QubitCircuit(N=1); qc.add_gate(""SNOT"", 0). num_tslots = 10; evo_time = 10; processor = OptPulseProcessor(N=1, drift=sigmaz()); processor.add_control(sigmax()); # num_tslots and evo_time are two keyword arguments; tlist, coeffs = processor.load_circuit(; qc, num_tslots=num_tslots, evo_time=evo_time). # Different parameters for different gates; qc = QubitCircuit(N=2); qc.add_gate(""SNOT"", 0); qc.add_gate(""SWAP"", targets=[0, 1]); qc.add_gate('CNOT', controls=1, targets=[0]). processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); processor.add_control(sigmax(), cyclic_permutation=True); processor.add_control(sigmay(), cyclic_permutation=True); processor.add_control(tensor([sigma",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13922,Availability,error,errors,13922,"and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude dam",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14294,Availability,error,error,14294,"uit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compar",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14460,Availability,error,error,14460," result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14522,Availability,error,error,14522,"o wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and the relaxation time is much longer than the gate duration, there is no need to go through all the calculations. However, this simulator is closer to the r",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14569,Availability,error,error,14569,"o wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and the relaxation time is much longer than the gate duration, there is no need to go through all the calculations. However, this simulator is closer to the r",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14612,Availability,error,error,14612,"o wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and the relaxation time is much longer than the gate duration, there is no need to go through all the calculations. However, this simulator is closer to the r",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14699,Availability,error,error,14699,"n be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and the relaxation time is much longer than the gate duration, there is no need to go through all the calculations. However, this simulator is closer to the real experiment and, therefore, more convenient in some cases, such as when coherent noise or correlated noise exist. For ins",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:121,Deployability,Install,Installation,121,"﻿. Pulse-level circuit simulation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Pulse-level circuit simulation. Pulse-level circuit simulation¶. Modelling quantum hardware with Processor¶; Based on the open system solver, Processor in the qutip.qip module simulates quantum circuits at the level of time evolution. One can consider the processor as a simulator of a quantum device, on which the quantum circuit is to be implemented.; The procedure is illustrated in the figure below.; It first compiles circuit into a Hamiltonian model, adds noisy dynamics and then uses the QuTiP open time evolution solvers to simulation the evolution. Like a real quantum device, the processor is determined by a list of Hamiltonians, i.e. the control pulses driving the evolution. Given the intensity of the control pulses and the corresponding time slices for each pulse, the evolution is then computed. A control pulse ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:3217,Deployability,continuous,continuous,3217,"nction or with cubic spline. For step function, tlist specifies the start and the end of each pulse and thus is one element longer the coeffs. One example of defining the control pulse coefficients and the time array is as follows:; import numpy as np; from qutip import sigmaz; from qutip.qip.device import Processor. processor = Processor(2); processor.add_control(sigmaz(), cyclic_permutation=True) # sigmaz for all qubits; processor.pulses[0].coeffs = np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); processor.pulses[0].tlist = np.array([0.1, 0.2, 0.4, 0.5]). It defines a \(\sigma_z\) operator on both qubits and a pulse that acts on the first qubit.; An equivalent approach is using the add_pulse method.; from qutip.qip.pulse import Pulse. processor = Processor(2); coeff=np.array([0.1, 0.2, 0.4, 0.5]); tlist=np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); pulse = Pulse(sigmaz(), targets=0, coeff=coeff, tlist=tlist); processor.add_pulse(pulse). One can also use choose the pulse_mode attribute of Processor; between ""discrete"" and ""continuous"". Note; If the coefficients represent dicrete pulse, the length of each array is 1 element shorter than tlist. If it is supposed to be a continuous function, the length should be the same as tlist. The above example shows the framework and the most essential part of the simulator’s API. So far, it looks like just a wrapper for the open system solvers. However, based on this, we can implement different physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case wher",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:3365,Deployability,continuous,continuous,3365,"the time array is as follows:; import numpy as np; from qutip import sigmaz; from qutip.qip.device import Processor. processor = Processor(2); processor.add_control(sigmaz(), cyclic_permutation=True) # sigmaz for all qubits; processor.pulses[0].coeffs = np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); processor.pulses[0].tlist = np.array([0.1, 0.2, 0.4, 0.5]). It defines a \(\sigma_z\) operator on both qubits and a pulse that acts on the first qubit.; An equivalent approach is using the add_pulse method.; from qutip.qip.pulse import Pulse. processor = Processor(2); coeff=np.array([0.1, 0.2, 0.4, 0.5]); tlist=np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); pulse = Pulse(sigmaz(), targets=0, coeff=coeff, tlist=tlist); processor.add_pulse(pulse). One can also use choose the pulse_mode attribute of Processor; between ""discrete"" and ""continuous"". Note; If the coefficients represent dicrete pulse, the length of each array is 1 element shorter than tlist. If it is supposed to be a continuous function, the length should be the same as tlist. The above example shows the framework and the most essential part of the simulator’s API. So far, it looks like just a wrapper for the open system solvers. However, based on this, we can implement different physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED mode",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:14482,Deployability,continuous,continuous-time,14482," result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the pulses (coherent control error) or the collapse operators (Lindblad error) contributing to the evolution. Mathematically, this is no different from adding error channel probabilistically (it is actually how qutip.mcsolve works internally). The collapse operator for single-qubit amplitude damping and dephasing are exactly the destroying operator and the sign-flipping operator. One just needs to choose the correct coefficients for them to simulate the noise, e.g. the relaxation time T1 and dephasing time T2. Because it is based on the open system evolution instead of abstract operators, this simulation is closer to the physical implementation and requires less pre-analysis of the system.; Compared to the approach of Kraus operators, this way of simulating noise is more computationally expensive. If you only want to simulate the decoherence of single-qubit relaxation and",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:20724,Deployability,update,updated,20724,".pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:852,Energy Efficiency,schedul,scheduler,852,"﻿. Pulse-level circuit simulation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Pulse-level circuit simulation. Pulse-level circuit simulation¶. Modelling quantum hardware with Processor¶; Based on the open system solver, Processor in the qutip.qip module simulates quantum circuits at the level of time evolution. One can consider the processor as a simulator of a quantum device, on which the quantum circuit is to be implemented.; The procedure is illustrated in the figure below.; It first compiles circuit into a Hamiltonian model, adds noisy dynamics and then uses the QuTiP open time evolution solvers to simulation the evolution. Like a real quantum device, the processor is determined by a list of Hamiltonians, i.e. the control pulses driving the evolution. Given the intensity of the control pulses and the corresponding time slices for each pulse, the evolution is then computed. A control pulse ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:9885,Energy Efficiency,schedul,scheduler,9885," Same parameter for all the gates; qc = QubitCircuit(N=1); qc.add_gate(""SNOT"", 0). num_tslots = 10; evo_time = 10; processor = OptPulseProcessor(N=1, drift=sigmaz()); processor.add_control(sigmax()); # num_tslots and evo_time are two keyword arguments; tlist, coeffs = processor.load_circuit(; qc, num_tslots=num_tslots, evo_time=evo_time). # Different parameters for different gates; qc = QubitCircuit(N=2); qc.add_gate(""SNOT"", 0); qc.add_gate(""SWAP"", targets=[0, 1]); qc.add_gate('CNOT', controls=1, targets=[0]). processor = OptPulseProcessor(N=2, drift=tensor([sigmaz()]*2)); processor.add_control(sigmax(), cyclic_permutation=True); processor.add_control(sigmay(), cyclic_permutation=True); processor.add_control(tensor([sigmay(), sigmay()])). setting_args = {""SNOT"": {""num_tslots"": 10, ""evo_time"": 1},; ""SWAP"": {""num_tslots"": 30, ""evo_time"": 3},; ""CNOT"": {""num_tslots"": 30, ""evo_time"": 3}}. tlist, coeffs = processor.load_circuit(; qc, setting_args=setting_args, merge_gates=False). Compiler and scheduler¶. Note; New in QuTiP 4.6. In order to simulate quantum circuits at the level of time evolution.; We need to first compile the circuit into the Hamiltonian model, i.e.; the control pulses.; Hence each Processor has a corresponding; GateCompiler class.; The compiler takes a QubitCircuit; and returns the compiled tlist and coeffs.; It is called implicitly when calling the method; run_state.; from qutip.qip.compiler import SpinChainCompiler; qc = QubitCircuit(2); qc.add_gate(""X"", targets=0); qc.add_gate(""X"", targets=1). processor = LinearSpinChain(2); compiler = SpinChainCompiler(; 2, params=processor.params, pulse_dict=processor.pulse_dict); resolved_qc = qc.resolve_gates([""RX"", ""RZ"", ""ISWAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11508,Energy Efficiency,schedul,scheduler,11508,"ompiler(; 2, params=processor.params, pulse_dict=processor.pulse_dict); resolved_qc = qc.resolve_gates([""RX"", ""RZ"", ""ISWAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end no",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11549,Energy Efficiency,schedul,scheduler,11549,"ISWAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11587,Energy Efficiency,Schedul,Scheduler,11587,"ISWAP""]); tlists, coeffs = compiler.compile(resolved_qc); print(tlists); print(coeffs). Output; [array([0., 1.]), array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11659,Energy Efficiency,schedul,schedules,11659," array([0., 1., 2.]), None, None, None]; [array([1.57079633]), array([0. , 1.57079633]), None, None, None]. Here we first use resolve_gates; to decompose the X gate to its natural gate on Spin Chain model,; the rotation over X-axis.; We pass the hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorith",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11876,Energy Efficiency,schedul,scheduler,11876,"hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; f",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:12570,Energy Efficiency,schedul,schedule,12570," the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate obje",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:12853,Energy Efficiency,schedul,scheduling,12853,"truction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out b",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:12976,Energy Efficiency,Schedul,Scheduler,12976,"ecuted before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13284,Energy Efficiency,schedul,scheduler,13284," by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flippin",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13296,Energy Efficiency,Schedul,Scheduler,13296," by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flippin",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13324,Energy Efficiency,schedul,scheduler,13324," by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flippin",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13334,Energy Efficiency,schedul,schedule,13334,"l gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13441,Energy Efficiency,schedul,scheduling,13441," to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13507,Energy Efficiency,schedul,schedule,13507,"ast step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the p",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13520,Energy Efficiency,schedul,scheduling,13520,"ast step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the p",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:20403,Energy Efficiency,schedul,schedule,20403,".pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:3545,Integrability,wrap,wrapper,3545,"gmaz(), cyclic_permutation=True) # sigmaz for all qubits; processor.pulses[0].coeffs = np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); processor.pulses[0].tlist = np.array([0.1, 0.2, 0.4, 0.5]). It defines a \(\sigma_z\) operator on both qubits and a pulse that acts on the first qubit.; An equivalent approach is using the add_pulse method.; from qutip.qip.pulse import Pulse. processor = Processor(2); coeff=np.array([0.1, 0.2, 0.4, 0.5]); tlist=np.array([[1.0, 1.5, 2.0], [1.8, 1.3, 0.8]]); pulse = Pulse(sigmaz(), targets=0, coeff=coeff, tlist=tlist); processor.add_pulse(pulse). One can also use choose the pulse_mode attribute of Processor; between ""discrete"" and ""continuous"". Note; If the coefficients represent dicrete pulse, the length of each array is 1 element shorter than tlist. If it is supposed to be a continuous function, the length should be the same as tlist. The above example shows the framework and the most essential part of the simulator’s API. So far, it looks like just a wrapper for the open system solvers. However, based on this, we can implement different physical realizations. They differ mainly in how to find the control pulse for a quantum circuit, which gives birth to different sub-classes:. Processor; ├── ModelProcessor; │ ├── DispersiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:4947,Integrability,depend,dependent,4947," find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will become very inefficient.; In the following we describe the predefined subclasses for Processor:",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:11918,Integrability,depend,dependency,11918,"hardware parameters of the SpinChain model, processor.params, as well as a map between the pulse name and pulse index pulse_dict to the compiler.; The later one allows one to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; f",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:12101,Integrability,depend,dependent,12101," to address the pulse more conveniently in the compiler.; The compiler returns a list of tlist and coeff, corresponding to each pulse.; The first pulse starts from t=0 and ends at t=1, with the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:12264,Integrability,depend,dependency,12264,"h the strengh \(\pi/2\).; The second one is turned on from t=1 to t=2 with the same strength.; The compiled pulse here is different from what is shown in the plot; in the previous subsection because the scheduler is turned off by default.; The scheduler is implemented in the class Scheduler,; based on the idea of https://doi.org/10.1117/12.666419.; It schedules the order of quantum gates and instructions for the; shortest execution time.; It works not only for quantum gates but also for pulse implementation of gates; (Instruction) with varying pulse duration.; The scheduler first generates a quantum gates dependency graph,; containing information about which gates have to be executed before some other gates.; The graph preserves the mobility of the gates,; i.e. commuting gates are not dependent on each other, even if they use the same qubits.; Next, it computes the longest distance of each node to the start and end nodes.; The distance for each dependency arrow is defined by the execution time of the instruction; (By default, it is 1 for all gates).; This is used as a priority measure in the next step.; The gate with a longer distance to the end node and a shorter distance to the start node has higher priority.; In the last step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:13580,Integrability,wrap,wrap,13580,"ast step, it uses a list-schedule algorithm with hardware constraint and; priority and returns a list of cycles for gates/instructions.; Since the algorithm is heuristics, sometimes it does not find the optimal solution.; Hence, we offer an option that randomly shuffles the commuting gates and; repeats the scheduling a few times to get a better result.; from qutip.qip.circuit import QubitCircuit; from qutip.qip.compiler import Scheduler; circuit = QubitCircuit(7); circuit.add_gate(""SNOT"", 3) # gate0; circuit.add_gate(""CZ"", 5, 3) # gate1; circuit.add_gate(""CZ"", 4, 3) # gate2; circuit.add_gate(""CZ"", 2, 3) # gate3; circuit.add_gate(""CZ"", 6, 5) # gate4; circuit.add_gate(""CZ"", 2, 6) # gate5; circuit.add_gate(""ISWAP"", [0, 2]) # gate6; scheduler = Scheduler(""ASAP""); result = scheduler.schedule(circuit, gates_schedule=True); print(result). Output; [0, 1, 3, 2, 2, 3, 4]. The result shows the scheduling order of each gate in the original circuit.; For pulse schedule, or scheduling gates with different duration,; one will need to wrap the qutip.qip.Gate object with qutip.qip.compiler.Instruction object,; with a parameter duration.; The result will then be the start time of each instruction. Noise Simulation¶; In the common way of QIP simulation, where evolution is carried out by gate matrix product, the noise is usually simulated with bit flipping and sign flipping errors.; The typical approaches are either applying bit/sign flipping gate probabilistically; or applying Kraus operators representing different noisy channels (e.g. amplitude damping, dephasing) after each unitary gate evolution. In the case of a single qubit, they have the same effect and the parameters in the Kraus operators are exactly the probability of a flipping error happens during the gate operation time.; Since the processor simulates the state evolution at the level of the driving Hamiltonian, there is no way to apply an error operator to the continuous-time evolution. Instead, the error is added to the p",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:19626,Integrability,rout,routines,19626,"add control Hamiltonians; processor = Processor(N=1); processor.add_control(sigmaz(), targets=0). # define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:20117,Integrability,depend,dependent,20117,".pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:20136,Integrability,depend,dependent,20136,".pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:8164,Performance,optimiz,optimized,8164,"= LinearSpinChain(2); processor.load_circuit(qc); fig, axis = processor.plot_pulses(); fig.show(). DispersiveCavityQED; Same as above, DispersiveCavityQED is a simulator based on Cavity Quantum Electrodynamics. The workflow is similar to the one for the spin chain, except that the component systems are a multi-level cavity and a qubits system. The control Hamiltonians are the single-qubit rotation together with the qubits-cavity interaction \(a^{\dagger} \sigma^{-} + a \sigma^{+}\). The device parameters including the cavity frequency, qubits frequency, detuning and interaction strength etc. Note; The run_state method of DispersiveCavityQED; returns the full simulation result of the solver,; hence including the cavity.; To obtain the circuit result, one needs to first trace out the cavity state. OptPulseProcessor; The OptPulseProcessor uses the function in optimize_pulse_unitary in the optimal control module to find the control pulses. The Hamiltonian includes a drift part and a control part and only the control part will be optimized. The unitary evolution follows. \[U(\Delta t)=\exp(\rm{i} \cdot \Delta t [H_d + \sum_j u_j H_j] )\]; To let it find the optimal pulses, we need to give the parameters for optimize_pulse_unitary as keyword arguments to load_circuit. Usually, the minimal requirements are the evolution time evo_time and the number of time slices num_tslots for each gate. Other parameters can also be given in the keyword arguments. For available choices, see optimize_pulse_unitary. It is also possible to specify different parameters for different gates, as shown in the following example:; from qutip.qip.device import OptPulseProcessor; from qutip.operators import sigmaz, sigmax, sigmay; from qutip.tensor import tensor. # Same parameter for all the gates; qc = QubitCircuit(N=1); qc.add_gate(""SNOT"", 0). num_tslots = 10; evo_time = 10; processor = OptPulseProcessor(N=1, drift=sigmaz()); processor.add_control(sigmax()); # num_tslots and evo_time are two keywor",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:20295,Performance,load,loading,20295,".pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:1004,Testability,Log,Log,1004,"lation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Pulse-level circuit simulation. Pulse-level circuit simulation¶. Modelling quantum hardware with Processor¶; Based on the open system solver, Processor in the qutip.qip module simulates quantum circuits at the level of time evolution. One can consider the processor as a simulator of a quantum device, on which the quantum circuit is to be implemented.; The procedure is illustrated in the figure below.; It first compiles circuit into a Hamiltonian model, adds noisy dynamics and then uses the QuTiP open time evolution solvers to simulation the evolution. Like a real quantum device, the processor is determined by a list of Hamiltonians, i.e. the control pulses driving the evolution. Given the intensity of the control pulses and the corresponding time slices for each pulse, the evolution is then computed. A control pulse is characterized by Pulse,",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:4811,Testability,log,logic,4811,"persiveCavityQED; │ └── SpinChain; └── OptPulseProcessor. In general, there are two ways to find the control pulses. The first one, ModelProcessor, is more experiment-oriented and based on physical models. A universal set of; gates is defined in the processor as well as the pulse implementing them in this particular physical model. This is usually the case where control pulses realizing those gates are well known and can be concatenated to realize the whole quantum circuits. Two realizations have already been implemented: the spin chain and the Cavity QED model for quantum computing. In those models, the driving Hamiltonians are predefined. Another approach, based on the optimal control module in QuTiP (see Quantum Optimal Control), is called OptPulseProcessor. In this subclass, one only defines the available Hamiltonians in their system. The processor then uses algorithms to find the optimal control pulses that realize the desired unitary evolution.; Despite this difference, the logic behind all processors is the same:. One defines a processor by a list of available Hamiltonians and, as explained later, hardware-dependent noise. In model based processors, the Hamiltonians are predefined and one only needs to give the device parameters like frequency and interaction strength.; The control pulse coefficients and time slices are either specified by the user or calculated by the method load_circuit, which takes a QubitCircuit and find the control pulse for this evolution.; The processor calculates the evolution using the QuTiP solvers. Collapse operators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will bec",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:141,Usability,Guid,Guide,141,"﻿. Pulse-level circuit simulation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Pulse-level circuit simulation. Pulse-level circuit simulation¶. Modelling quantum hardware with Processor¶; Based on the open system solver, Processor in the qutip.qip module simulates quantum circuits at the level of time evolution. One can consider the processor as a simulator of a quantum device, on which the quantum circuit is to be implemented.; The procedure is illustrated in the figure below.; It first compiles circuit into a Hamiltonian model, adds noisy dynamics and then uses the QuTiP open time evolution solvers to simulation the evolution. Like a real quantum device, the processor is determined by a list of Hamiltonians, i.e. the control pulses driving the evolution. Given the intensity of the control pulses and the corresponding time slices for each pulse, the evolution is then computed. A control pulse ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:148,Usability,Guid,Guide,148,"﻿. Pulse-level circuit simulation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Pulse-level circuit simulation. Pulse-level circuit simulation¶. Modelling quantum hardware with Processor¶; Based on the open system solver, Processor in the qutip.qip module simulates quantum circuits at the level of time evolution. One can consider the processor as a simulator of a quantum device, on which the quantum circuit is to be implemented.; The procedure is illustrated in the figure below.; It first compiles circuit into a Hamiltonian model, adds noisy dynamics and then uses the QuTiP open time evolution solvers to simulation the evolution. Like a real quantum device, the processor is determined by a list of Hamiltonians, i.e. the control pulses driving the evolution. Given the intensity of the control pulses and the corresponding time slices for each pulse, the evolution is then computed. A control pulse ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:1130,Usability,Guid,Guide,1130,"; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Pulse-level circuit simulation; Modelling quantum hardware with Processor; Compiler and scheduler; Noise Simulation; Customize the simulator; The workflow of the simulator. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Pulse-level circuit simulation. Pulse-level circuit simulation¶. Modelling quantum hardware with Processor¶; Based on the open system solver, Processor in the qutip.qip module simulates quantum circuits at the level of time evolution. One can consider the processor as a simulator of a quantum device, on which the quantum circuit is to be implemented.; The procedure is illustrated in the figure below.; It first compiles circuit into a Hamiltonian model, adds noisy dynamics and then uses the QuTiP open time evolution solvers to simulation the evolution. Like a real quantum device, the processor is determined by a list of Hamiltonians, i.e. the control pulses driving the evolution. Given the intensity of the control pulses and the corresponding time slices for each pulse, the evolution is then computed. A control pulse is characterized by Pulse, consisting of the control Hamiltonian, the targets qubit, the pulse coefficients and the time sequence. We can either use the coeffici",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:6366,Usability,simpl,simple,6366,"perators can be added to simulate decoherence. The method run_state returns a object qutip.solver.Result. It is also possible to calculate the evolution analytically with matrix exponentiation by setting analytical=True. A list of the matrices representing the gates is returned just like for propagators. However, this does not consider the collapse operators or other noise. As the system size gets larger, this approach will become very inefficient.; In the following we describe the predefined subclasses for Processor:; SpinChain; LinearSpinChain and CircularSpinChain are quantum computing models base on the spin chain realization. The control Hamiltonians are \(\sigma_x\), \(\sigma_z\) and \(\sigma_x \sigma_x + \sigma_y \sigma_y\). This processor will first decompose the gate into the universal gate set with ISWAP or SQRTISWAP as two-qubit gates, resolve them into quantum gates of adjacent qubits and then calculate the pulse coefficients.; An example of simulating a simple circuit is shown below:; from qutip import basis; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device import LinearSpinChain. qc = QubitCircuit(2); qc.add_gate(""X"", targets=0); qc.add_gate(""X"", targets=1); processor = LinearSpinChain(2); processor.load_circuit(qc); result = processor.run_state(basis([2,2], [0,0])); print(result.states[-1].tidyup(1.0e-6)). Quantum object: dims = [[2, 2], [1, 1]], shape = (4, 1), type = ket; Qobj data =; [[ 0.]; [ 0.]; [ 0.]; [-1.]]. We can also visualize the pulses implementing this circuit:; from qutip import basis; from qutip.qip.circuit import QubitCircuit; from qutip.qip.device import LinearSpinChain. qc = QubitCircuit(2); qc.add_gate(""X"", targets=0); qc.add_gate(""X"", targets=1); processor = LinearSpinChain(2); processor.load_circuit(qc); fig, axis = processor.plot_pulses(); fig.show(). DispersiveCavityQED; Same as above, DispersiveCavityQED is a simulator based on Cavity Quantum Electrodynamics. The workflow is similar to the one for the spin chai",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:16787,Usability,simpl,simplest,16787,"ecrease. It is not always easy or even possible to define a noisy gate matrix. In our simulator, it can be done by defining a ControlAmpNoise (Control Amplitude Noise).; In the simulation, noise can be added to the processor at different levels:. The decoherence time T1 and T2 can be defined for the processor or for each qubit. When calculating the evolution, the corresponding collapse operators will be added automatically to the solver.; The noise of the physical parameters (e.g. detuned frequency) can be simulated by changing the parameters in the model, e.g. laser frequency in cavity QED. (This can only be time-independent since QuTiP open system solver only allows varying coefficients, not varying Hamiltonian operators.); The noise of the pulse intensity can be simulated by modifying the coefficients of the Hamiltonian operators or even adding new Hamiltonians. To add noise to a processor, one needs to first define a noise object Noise. The simplest relaxation noise can be defined directly in the processor with relaxation time. Other pre-defined noise can be found as subclasses of Noise. We can add noise to the simulator with the method add_noise.; Below, we show two examples.; The first example is a processor with one qubit under rotation around the z-axis and relaxation time \(T_2=5\). We measure the population of the \(\left| + \right\rangle\) state and observe the Ramsey signal:; import numpy as np; import matplotlib.pyplot as plt; from qutip import sigmaz, destroy, basis; from qutip.qip.device import Processor; from qutip.qip.operations import snot. a = destroy(2); Hadamard = snot(); plus_state = (basis(2,1) + basis(2,0)).unit(); tlist = np.arange(0.00, 20.2, 0.2). T2 = 5; processor = Processor(1, t2=T2); processor.add_control(sigmaz()); processor.pulses[0].coeff = np.ones(len(tlist)); processor.pulses[0].tlist = tlist; result = processor.run_state(; plus_state, e_ops=[a.dag()*a, Hadamard*a.dag()*a*Hadamard]). fig, ax = plt.subplots(); # detail about length ",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-processor.html:19641,Usability,guid,guide,19641,"# define pulse coefficients and tlist for all pulses; processor.pulses[0].coeff = np.array([0.3, 0.5, 0. ]); processor.set_all_tlist(np.array([0., np.pi/2., 2*np.pi/2, 3*np.pi/2])). # define noise, loc and scale are keyword arguments for np.random.normal; gaussnoise = RandomNoise(; dt=0.01, rand_gen=np.random.normal, loc=0.00, scale=0.02); processor.add_noise(gaussnoise). # Plot the ideal pulse; fig1, axis1 = processor.plot_pulses(title=""Original control amplitude"", figsize=(5,3)). # Plot the noisy pulse; qobjevo, _ = processor.get_qobjevo(noisy=True); noisy_coeff = qobjevo.to_list()[1][1] + qobjevo.to_list()[2][1]; fig2, axis2 = processor.plot_pulses(title=""Noisy control amplitude"", figsize=(5,3)); axis2[0].step(qobjevo.tlist, noisy_coeff). Customize the simulator¶; The number of predefined physical models and compilers are limited.; However, it is designed for easy customization and one can easily build customized model and compiling routines.; For guide and examples, please refer to the tutorial notebooks; at https://qutip.org/tutorials.html. The workflow of the simulator¶; The following plot demonstrates the workflow of the simulator. The core of the simulator is Processor,; which characterizes the quantum hardware of interest,; containing the information such as the non-controllable drift Hamiltonian and; the control Hamiltonian.; Apart from the ideal system representing the qubits, one can also define; hardware-dependent or pulse-dependent noise in Noise.; It describes how noisy terms such as imperfect control; and decoherence can be added once the ideal control pulse is defined.; When loading a quantum circuit, a GateCompiler compiles the circuit into a sequence of control pulse signals and schedule the pulse for parallel execution.; For each control Hamiltonian, a Pulse instance is created that including the ideal evolution and associated noise.; They will then be sent to the QuTiP solvers for the computation. Next ; Previous. © Copyright 2011 to 2021 inclusi",MatchSource.WIKI,docs/4.7/guide/qip/qip-processor.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-processor.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:123,Deployability,Install,Installation,123,". Operator-level circuit simulation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Operator-level circuit simulation. Operator-level circuit simulation¶. Note; New in QuTiP 4.6. Run a quantum circuit¶; Let’s start off by defining a simple circuit which we use to demonstrate a few; examples of circuit evolution.; We take a circuit from OpenQASM 2; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.operations import controlled_gate, hadamard_transform; def controlled_hadamard():; # Controlled Hadamard; return controlled_gate(; hadamard_transform(1), 2, control=0, target=1, control_value=1); qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CN",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:10223,Deployability,update,updated,10223,"bit:; qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0); qc.add_measurement(""M0"", targets=[0], classical_store=0); qc.add_measurement(""M0"", targets=[1], classical_store=0); qc.add_measurement(""M0"", targets=[2], classical_store=0); sim = CircuitSimulator(qc, mode=""density_matrix_simulator""); print(sim.run(zero_state).get_final_states()[0]). Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0.33333257 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0.33333257 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0.33333486 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]]. We are left with a mixed state. Import and export quantum circuits¶; QuTiP supports importation and exportation of quantum circuit in the OpenQASM 2 format; through the functions read_qasm and save_qasm.; We demonstrate this using the w-state generation circuit.; The following code is in OpenQASM format:; // Name of Experiment: W-state v1. OPENQASM 2.0;; include ""qelib1.inc"";. qreg q[4];; creg c[3];; gate cH a,b {; h b;; sdg b;; cx a,b;; h b;; t b;; cx a,b;; t b;; h b;; s b;; x b;; s a;; }. u3(1.91063,0,0) q[0];; cH q[0],q[1];; ccx q[0],q[1],q[2];; x q[0];; x q[1];; cx q[0],q[1];. measure q[0] -> c[0];; measure q[1] -> c[1];; measure q[2] -> c[2];. One can save it in a .qasm file and import it using the following code:; from qutip.qip.qasm import read_qasm; qc = read_qasm(""guide/qip/w-state.qasm""). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:7368,Energy Efficiency,efficient,efficient,7368,"y=True). print(sim.ops). [Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = False; Qobj data =; [[ 0. 0.57734961 0. -0.57734961 0. 0.40824922; 0. -0.40824922]; [ 0.57734961 0. -0.57734961 0. 0.40824922 0.; -0.40824922 0. ]; [ 0.57734961 0. 0.57734961 0. 0.40824922 0.; 0.40824922 0. ]; [ 0. 0.57734961 0. 0.57734961 0. 0.40824922; 0. 0.40824922]; [ 0.57735159 0. 0. 0. -0.81649565 0.; 0. 0. ]; [ 0. 0.57735159 0. 0. 0. -0.81649565; 0. 0. ]; [ 0. 0. 0.57735159 0. 0. 0.; -0.81649565 0. ]; [ 0. 0. 0. 0.57735159 0. 0.; 0. -0.81649565]],; Measurement(M0, target=[0], classical_store=0),; Measurement(M1, target=[1], classical_store=1),; Measurement(M2, target=[2], classical_store=2)]. Here, sim.ops stores all the circuit operations that are going to be applied during; state evolution. As observed above, all the unitaries of the circuit are compressed into; a single unitary product with the precompute optimization enabled.; This is more efficient if one runs the same circuit one multiple initial states.; However, as the number of qubits increases, this will consume more and more memory; and become unfeasible. Density Matrix Simulation¶; By default, the state evolution is carried out in the “state_vector_simulator” mode; (specified by the mode argument) as described before.; In the “density_matrix_simulator” mode, the input state can be either a ket or a density; matrix. If it is a ket, it is converted into a density matrix before the evolution is; carried out. Unlike the “state_vector_simulator” mode, upon measurement, the state; does not collapse to one of the post-measurement states. Rather, the new state is now; the density matrix representing the ensemble of post-measurement states.; In this sense, we measure the qubits and forget all the results.; To demonstrate this consider the original W-state preparation circuit which is followed; just by measurement on the first qubit:; qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": cont",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:7332,Performance,optimiz,optimization,7332,"putes the product of the unitaries (in between the measurements):; sim = CircuitSimulator(qc, precompute_unitary=True). print(sim.ops). [Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = False; Qobj data =; [[ 0. 0.57734961 0. -0.57734961 0. 0.40824922; 0. -0.40824922]; [ 0.57734961 0. -0.57734961 0. 0.40824922 0.; -0.40824922 0. ]; [ 0.57734961 0. 0.57734961 0. 0.40824922 0.; 0.40824922 0. ]; [ 0. 0.57734961 0. 0.57734961 0. 0.40824922; 0. 0.40824922]; [ 0.57735159 0. 0. 0. -0.81649565 0.; 0. 0. ]; [ 0. 0.57735159 0. 0. 0. -0.81649565; 0. 0. ]; [ 0. 0. 0.57735159 0. 0. 0.; -0.81649565 0. ]; [ 0. 0. 0. 0.57735159 0. 0.; 0. -0.81649565]],; Measurement(M0, target=[0], classical_store=0),; Measurement(M1, target=[1], classical_store=1),; Measurement(M2, target=[2], classical_store=2)]. Here, sim.ops stores all the circuit operations that are going to be applied during; state evolution. As observed above, all the unitaries of the circuit are compressed into; a single unitary product with the precompute optimization enabled.; This is more efficient if one runs the same circuit one multiple initial states.; However, as the number of qubits increases, this will consume more and more memory; and become unfeasible. Density Matrix Simulation¶; By default, the state evolution is carried out in the “state_vector_simulator” mode; (specified by the mode argument) as described before.; In the “density_matrix_simulator” mode, the input state can be either a ket or a density; matrix. If it is a ket, it is converted into a density matrix before the evolution is; carried out. Unlike the “state_vector_simulator” mode, upon measurement, the state; does not collapse to one of the post-measurement states. Rather, the new state is now; the density matrix representing the ensemble of post-measurement states.; In this sense, we measure the qubits and forget all the results.; To demonstrate this consider the original W-state preparation circuit which is foll",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:996,Testability,Log,Log,996,"rcuit simulation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Operator-level circuit simulation. Operator-level circuit simulation¶. Note; New in QuTiP 4.6. Run a quantum circuit¶; Let’s start off by defining a simple circuit which we use to demonstrate a few; examples of circuit evolution.; We take a circuit from OpenQASM 2; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.operations import controlled_gate, hadamard_transform; def controlled_hadamard():; # Controlled Hadamard; return controlled_gate(; hadamard_transform(1), 2, control=0, target=1, control_value=1); qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], ",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:143,Usability,Guid,Guide,143,". Operator-level circuit simulation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Operator-level circuit simulation. Operator-level circuit simulation¶. Note; New in QuTiP 4.6. Run a quantum circuit¶; Let’s start off by defining a simple circuit which we use to demonstrate a few; examples of circuit evolution.; We take a circuit from OpenQASM 2; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.operations import controlled_gate, hadamard_transform; def controlled_hadamard():; # Controlled Hadamard; return controlled_gate(; hadamard_transform(1), 2, control=0, target=1, control_value=1); qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CN",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:150,Usability,Guid,Guide,150,". Operator-level circuit simulation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Guide Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Operator-level circuit simulation. Operator-level circuit simulation¶. Note; New in QuTiP 4.6. Run a quantum circuit¶; Let’s start off by defining a simple circuit which we use to demonstrate a few; examples of circuit evolution.; We take a circuit from OpenQASM 2; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.operations import controlled_gate, hadamard_transform; def controlled_hadamard():; # Controlled Hadamard; return controlled_gate(; hadamard_transform(1), 2, control=0, target=1, control_value=1); qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CN",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:1122,Usability,Guid,Guide,1122," Overview; Basic Operations on Quantum Objects; Manipulating States and Operators; Using Tensor Products and Partial Traces; Time Evolution and Quantum System Dynamics; Hierarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Operator-level circuit simulation. Operator-level circuit simulation¶. Note; New in QuTiP 4.6. Run a quantum circuit¶; Let’s start off by defining a simple circuit which we use to demonstrate a few; examples of circuit evolution.; We take a circuit from OpenQASM 2; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.operations import controlled_gate, hadamard_transform; def controlled_hadamard():; # Controlled Hadamard; return controlled_gate(; hadamard_transform(1), 2, control=0, target=1, control_value=1); qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0). It corresponds to the following circuit:. We will add the measurement gates later. This circuit prepares the W-state \((\ket",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:1314,Usability,simpl,simple,1314,"erarchical Equations of Motion; Solving for Steady-State Solutions; Two-time correlation functions; Quantum Optimal Control; Plotting on the Bloch Sphere; Visualization of quantum states and processes; Parallel computation; Saving QuTiP Objects and Data Sets; Generating Random Quantum States & Operators; Modifying Internal QuTiP Settings; Quantum Information Processing; Quantum Information Processing; Operator-level circuit simulation; Run a quantum circuit; Circuit simulator; Precomputing the unitary; Density Matrix Simulation; Import and export quantum circuits. Pulse-level circuit simulation. Measurement of Quantum Objects. Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Users Guide »; Quantum Information Processing »; Operator-level circuit simulation. Operator-level circuit simulation¶. Note; New in QuTiP 4.6. Run a quantum circuit¶; Let’s start off by defining a simple circuit which we use to demonstrate a few; examples of circuit evolution.; We take a circuit from OpenQASM 2; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.operations import controlled_gate, hadamard_transform; def controlled_hadamard():; # Controlled Hadamard; return controlled_gate(; hadamard_transform(1), 2, control=0, target=1, control_value=1); qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0). It corresponds to the following circuit:. We will add the measurement gates later. This circuit prepares the W-state \((\ket{001} + \ket{010} + \ket{100})/\sqrt{3}\).; The simplest way to carry out state evolution through a quantum circuit is; providing a input state to the run; method.; from q",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:2204,Usability,simpl,simplest,2204,". Run a quantum circuit¶; Let’s start off by defining a simple circuit which we use to demonstrate a few; examples of circuit evolution.; We take a circuit from OpenQASM 2; from qutip.qip.circuit import QubitCircuit, Gate; from qutip.qip.operations import controlled_gate, hadamard_transform; def controlled_hadamard():; # Controlled Hadamard; return controlled_gate(; hadamard_transform(1), 2, control=0, target=1, control_value=1); qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0). It corresponds to the following circuit:. We will add the measurement gates later. This circuit prepares the W-state \((\ket{001} + \ket{010} + \ket{100})/\sqrt{3}\).; The simplest way to carry out state evolution through a quantum circuit is; providing a input state to the run; method.; from qutip import tensor; zero_state = tensor(basis(2, 0), basis(2, 0), basis(2, 0)); result = qc.run(state=zero_state); wstate = result. print(wstate). Output:; Quantum object: dims = [[2, 2, 2], [1, 1, 1]], shape = (8, 1), type = ket; Qobj data =; [[0. ]; [0.57734961]; [0.57734961]; [0. ]; [0.57735159]; [0. ]; [0. ]; [0. ]]. As expected, the state returned is indeed the required W-state.; As soon as we introduce measurements into the circuit, it can lead to multiple outcomes; with associated probabilities. We can also carry out circuit evolution in a manner such that it returns all the possible state; outputs along with their corresponding probabilities. Suppose, in the previous circuit,; we measure each of the three qubits at the end.; qc.add_measurement(""M0"", targets=[0], classical_store=0); qc.add_measurement(""M1"", targets=[1], classical_store=1); qc.add_measurement(""M2"", targets=[2], classical_store=2). To get all the ",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/guide/qip/qip-simulator.html:10101,Usability,guid,guide,10101,"bit:; qc = QubitCircuit(N=3, num_cbits=3); qc.user_gates = {""cH"": controlled_hadamard}; qc.add_gate(""QASMU"", targets=[0], arg_value=[1.91063, 0, 0]); qc.add_gate(""cH"", targets=[0,1]); qc.add_gate(""TOFFOLI"", targets=[2], controls=[0, 1]); qc.add_gate(""X"", targets=[0]); qc.add_gate(""X"", targets=[1]); qc.add_gate(""CNOT"", targets=[1], controls=0); qc.add_measurement(""M0"", targets=[0], classical_store=0); qc.add_measurement(""M0"", targets=[1], classical_store=0); qc.add_measurement(""M0"", targets=[2], classical_store=0); sim = CircuitSimulator(qc, mode=""density_matrix_simulator""); print(sim.run(zero_state).get_final_states()[0]). Quantum object: dims = [[2, 2, 2], [2, 2, 2]], shape = (8, 8), type = oper, isherm = True; Qobj data =; [[0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0.33333257 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0.33333257 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0.33333486 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]; [0. 0. 0. 0. 0. 0.; 0. 0. ]]. We are left with a mixed state. Import and export quantum circuits¶; QuTiP supports importation and exportation of quantum circuit in the OpenQASM 2 format; through the functions read_qasm and save_qasm.; We demonstrate this using the w-state generation circuit.; The following code is in OpenQASM format:; // Name of Experiment: W-state v1. OPENQASM 2.0;; include ""qelib1.inc"";. qreg q[4];; creg c[3];; gate cH a,b {; h b;; sdg b;; cx a,b;; h b;; t b;; cx a,b;; t b;; h b;; s b;; x b;; s a;; }. u3(1.91063,0,0) q[0];; cH q[0],q[1];; ccx q[0],q[1],q[2];; x q[0];; x q[1];; cx q[0],q[1];. measure q[0] -> c[0];; measure q[1] -> c[1];; measure q[2] -> c[2];. One can save it in a .qasm file and import it using the following code:; from qutip.qip.qasm import read_qasm; qc = read_qasm(""guide/qip/w-state.qasm""). Next ; Previous. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/guide/qip/qip-simulator.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/guide/qip/qip-simulator.html
https://qutip.org/docs/4.7/modules/qutip/about.html:101,Deployability,Install,Installation,101,". qutip.about — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.about. Source code for qutip.about; """"""; Command line output of information on QuTiP and dependencies.; """"""; __all__ = ['about']. import sys; import os; import platform; import numpy; import scipy; import inspect; from qutip.utilities import _blas_info, available_cpu_count; import qutip.settings. [docs]def about():; """"""; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib.; """"""; print(""""); print(""QuTiP: Quantum Toolbox in Python""); print(""================================""); print(""Copyright (c) QuTiP team 2011 and later.""); print(; ""Current admin team: Alexander Pitchford, ""; ""Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, ""; ""Boxi Li, Jake Lishman, Simon Cross and Asier Galicia.""; ); print(; ""Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, ""; ""Franco Nori and Will Zeng.""; ); print(""Original developers: R. J. Johansson & P. D. Nation.""); print(""Previous lead developers: Chris Granade & A. Grimsmo.""); print(""Currently developed through wide collaboration. ""; ""See https://github.com/qutip for details.""); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except ImportError:; matplotlib_ver = 'None'; print(""Matplotlib Version: %s"" % matplotlib_ver); print(""Python Version: %d.%d.%d"" % sys.version_info[0:3]); print(""Number of CPUs: %s"" % available_cpu_count()); print(""BLAS Info: %s"" % _blas_info());",MatchSource.WIKI,docs/4.7/modules/qutip/about.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/about.html
https://qutip.org/docs/4.7/modules/qutip/about.html:2016,Deployability,Install,Installed,2016,"nt(""================================""); print(""Copyright (c) QuTiP team 2011 and later.""); print(; ""Current admin team: Alexander Pitchford, ""; ""Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, ""; ""Boxi Li, Jake Lishman, Simon Cross and Asier Galicia.""; ); print(; ""Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, ""; ""Franco Nori and Will Zeng.""; ); print(""Original developers: R. J. Johansson & P. D. Nation.""); print(""Previous lead developers: Chris Granade & A. Grimsmo.""); print(""Currently developed through wide collaboration. ""; ""See https://github.com/qutip for details.""); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except ImportError:; matplotlib_ver = 'None'; print(""Matplotlib Version: %s"" % matplotlib_ver); print(""Python Version: %d.%d.%d"" % sys.version_info[0:3]); print(""Number of CPUs: %s"" % available_cpu_count()); print(""BLAS Info: %s"" % _blas_info()); print(""OPENMP Installed: %s"" % str(qutip.settings.has_openmp)); print(""INTEL MKL Ext: %s"" % str(qutip.settings.has_mkl)); print(""Platform Info: %s (%s)"" % (platform.system(),; platform.machine())); qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); print(""Installation path: %s"" % qutip_install_path). # citation; longbar = ""="" * 80; cite_msg = ""For your convenience a bibtex reference can be easily""; cite_msg += "" generated using `qutip.cite()`""; print(longbar); print(""Please cite QuTiP in your publication.""); print(longbar); print(cite_msg). if __name__ == ""__main__"":; about(). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/about.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/about.html
https://qutip.org/docs/4.7/modules/qutip/about.html:2275,Deployability,Install,Installation,2275,"nt(""================================""); print(""Copyright (c) QuTiP team 2011 and later.""); print(; ""Current admin team: Alexander Pitchford, ""; ""Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, ""; ""Boxi Li, Jake Lishman, Simon Cross and Asier Galicia.""; ); print(; ""Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, ""; ""Franco Nori and Will Zeng.""; ); print(""Original developers: R. J. Johansson & P. D. Nation.""); print(""Previous lead developers: Chris Granade & A. Grimsmo.""); print(""Currently developed through wide collaboration. ""; ""See https://github.com/qutip for details.""); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except ImportError:; matplotlib_ver = 'None'; print(""Matplotlib Version: %s"" % matplotlib_ver); print(""Python Version: %d.%d.%d"" % sys.version_info[0:3]); print(""Number of CPUs: %s"" % available_cpu_count()); print(""BLAS Info: %s"" % _blas_info()); print(""OPENMP Installed: %s"" % str(qutip.settings.has_openmp)); print(""INTEL MKL Ext: %s"" % str(qutip.settings.has_mkl)); print(""Platform Info: %s (%s)"" % (platform.system(),; platform.machine())); qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); print(""Installation path: %s"" % qutip_install_path). # citation; longbar = ""="" * 80; cite_msg = ""For your convenience a bibtex reference can be easily""; cite_msg += "" generated using `qutip.cite()`""; print(longbar); print(""Please cite QuTiP in your publication.""); print(longbar); print(cite_msg). if __name__ == ""__main__"":; about(). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/about.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/about.html
https://qutip.org/docs/4.7/modules/qutip/about.html:2682,Deployability,update,updated,2682,"nt(""================================""); print(""Copyright (c) QuTiP team 2011 and later.""); print(; ""Current admin team: Alexander Pitchford, ""; ""Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, ""; ""Boxi Li, Jake Lishman, Simon Cross and Asier Galicia.""; ); print(; ""Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, ""; ""Franco Nori and Will Zeng.""; ); print(""Original developers: R. J. Johansson & P. D. Nation.""); print(""Previous lead developers: Chris Granade & A. Grimsmo.""); print(""Currently developed through wide collaboration. ""; ""See https://github.com/qutip for details.""); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except ImportError:; matplotlib_ver = 'None'; print(""Matplotlib Version: %s"" % matplotlib_ver); print(""Python Version: %d.%d.%d"" % sys.version_info[0:3]); print(""Number of CPUs: %s"" % available_cpu_count()); print(""BLAS Info: %s"" % _blas_info()); print(""OPENMP Installed: %s"" % str(qutip.settings.has_openmp)); print(""INTEL MKL Ext: %s"" % str(qutip.settings.has_mkl)); print(""Platform Info: %s (%s)"" % (platform.system(),; platform.machine())); qutip_install_path = os.path.dirname(inspect.getsourcefile(qutip)); print(""Installation path: %s"" % qutip_install_path). # citation; longbar = ""="" * 80; cite_msg = ""For your convenience a bibtex reference can be easily""; cite_msg += "" generated using `qutip.cite()`""; print(longbar); print(""Please cite QuTiP in your publication.""); print(longbar); print(cite_msg). if __name__ == ""__main__"":; about(). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/about.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/about.html
https://qutip.org/docs/4.7/modules/qutip/about.html:393,Integrability,depend,dependencies,393,". qutip.about — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.about. Source code for qutip.about; """"""; Command line output of information on QuTiP and dependencies.; """"""; __all__ = ['about']. import sys; import os; import platform; import numpy; import scipy; import inspect; from qutip.utilities import _blas_info, available_cpu_count; import qutip.settings. [docs]def about():; """"""; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib.; """"""; print(""""); print(""QuTiP: Quantum Toolbox in Python""); print(""================================""); print(""Copyright (c) QuTiP team 2011 and later.""); print(; ""Current admin team: Alexander Pitchford, ""; ""Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, ""; ""Boxi Li, Jake Lishman, Simon Cross and Asier Galicia.""; ); print(; ""Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, ""; ""Franco Nori and Will Zeng.""; ); print(""Original developers: R. J. Johansson & P. D. Nation.""); print(""Previous lead developers: Chris Granade & A. Grimsmo.""); print(""Currently developed through wide collaboration. ""; ""See https://github.com/qutip for details.""); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except ImportError:; matplotlib_ver = 'None'; print(""Matplotlib Version: %s"" % matplotlib_ver); print(""Python Version: %d.%d.%d"" % sys.version_info[0:3]); print(""Number of CPUs: %s"" % available_cpu_count()); print(""BLAS Info: %s"" % _blas_info());",MatchSource.WIKI,docs/4.7/modules/qutip/about.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/about.html
https://qutip.org/docs/4.7/modules/qutip/about.html:163,Testability,Log,Log,163,". qutip.about — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.about. Source code for qutip.about; """"""; Command line output of information on QuTiP and dependencies.; """"""; __all__ = ['about']. import sys; import os; import platform; import numpy; import scipy; import inspect; from qutip.utilities import _blas_info, available_cpu_count; import qutip.settings. [docs]def about():; """"""; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib.; """"""; print(""""); print(""QuTiP: Quantum Toolbox in Python""); print(""================================""); print(""Copyright (c) QuTiP team 2011 and later.""); print(; ""Current admin team: Alexander Pitchford, ""; ""Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, ""; ""Boxi Li, Jake Lishman, Simon Cross and Asier Galicia.""; ); print(; ""Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, ""; ""Franco Nori and Will Zeng.""; ); print(""Original developers: R. J. Johansson & P. D. Nation.""); print(""Previous lead developers: Chris Granade & A. Grimsmo.""); print(""Currently developed through wide collaboration. ""; ""See https://github.com/qutip for details.""); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except ImportError:; matplotlib_ver = 'None'; print(""Matplotlib Version: %s"" % matplotlib_ver); print(""Python Version: %d.%d.%d"" % sys.version_info[0:3]); print(""Number of CPUs: %s"" % available_cpu_count()); print(""BLAS Info: %s"" % _blas_info());",MatchSource.WIKI,docs/4.7/modules/qutip/about.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/about.html
https://qutip.org/docs/4.7/modules/qutip/about.html:121,Usability,Guid,Guide,121,". qutip.about — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.about. Source code for qutip.about; """"""; Command line output of information on QuTiP and dependencies.; """"""; __all__ = ['about']. import sys; import os; import platform; import numpy; import scipy; import inspect; from qutip.utilities import _blas_info, available_cpu_count; import qutip.settings. [docs]def about():; """"""; About box for QuTiP. Gives version numbers for QuTiP, NumPy, SciPy, Cython,; and MatPlotLib.; """"""; print(""""); print(""QuTiP: Quantum Toolbox in Python""); print(""================================""); print(""Copyright (c) QuTiP team 2011 and later.""); print(; ""Current admin team: Alexander Pitchford, ""; ""Nathan Shammah, Shahnawaz Ahmed, Neill Lambert, Eric Giguère, ""; ""Boxi Li, Jake Lishman, Simon Cross and Asier Galicia.""; ); print(; ""Board members: Daniel Burgarth, Robert Johansson, Anton F. Kockum, ""; ""Franco Nori and Will Zeng.""; ); print(""Original developers: R. J. Johansson & P. D. Nation.""); print(""Previous lead developers: Chris Granade & A. Grimsmo.""); print(""Currently developed through wide collaboration. ""; ""See https://github.com/qutip for details.""); print(""""); print(""QuTiP Version: %s"" % qutip.__version__); print(""Numpy Version: %s"" % numpy.__version__); print(""Scipy Version: %s"" % scipy.__version__); try:; import Cython; cython_ver = Cython.__version__; except ImportError:; cython_ver = 'None'; print(""Cython Version: %s"" % cython_ver); try:; import matplotlib; matplotlib_ver = matplotlib.__version__; except ImportError:; matplotlib_ver = 'None'; print(""Matplotlib Version: %s"" % matplotlib_ver); print(""Python Version: %d.%d.%d"" % sys.version_info[0:3]); print(""Number of CPUs: %s"" % available_cpu_count()); print(""BLAS Info: %s"" % _blas_info());",MatchSource.WIKI,docs/4.7/modules/qutip/about.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/about.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:101,Deployability,Install,Installation,101,". qutip.bloch — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch. Source code for qutip.bloch; __all__ = ['Bloch']. import os. from numpy import (ndarray, array, linspace, pi, outer, cos, sin, ones, size,; sqrt, real, mod, append, ceil, arange); import numpy as np. from packaging.version import parse as parse_version. from qutip.qobj import Qobj; from qutip.expect import expect; from qutip.operators import sigmax, sigmay, sigmaz. try:; import matplotlib; import matplotlib.pyplot as plt; from mpl_toolkits.mplot3d import Axes3D; from matplotlib.patches import FancyArrowPatch; from mpl_toolkits.mplot3d import proj3d. # Define a custom _axes3D function based on the matplotlib version.; # The auto_add_to_figure keyword is new for matplotlib>=3.4.; if parse_version(matplotlib.__version__) >= parse_version('3.4'):; def _axes3D(fig, *args, **kwargs):; ax = Axes3D(fig, *args, auto_add_to_figure=False, **kwargs); return fig.add_axes(ax); else:; def _axes3D(*args, **kwargs):; return Axes3D(*args, **kwargs). class Arrow3D(FancyArrowPatch):; def __init__(self, xs, ys, zs, *args, **kwargs):; FancyArrowPatch.__init__(self, (0, 0), (0, 0), *args, **kwargs). self._verts3d = xs, ys, zs. def draw(self, renderer):; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M). self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); FancyArrowPatch.draw(self, renderer). def do_3d_projection(self, renderer=None):; # only called by matplotlib >= 3.5; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M); self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); return np.min(zs); except ImportError:; pass. try:; from IPython.display import display; except ImportError:; pass. [",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:794,Deployability,patch,patches,794,". qutip.bloch — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch. Source code for qutip.bloch; __all__ = ['Bloch']. import os. from numpy import (ndarray, array, linspace, pi, outer, cos, sin, ones, size,; sqrt, real, mod, append, ceil, arange); import numpy as np. from packaging.version import parse as parse_version. from qutip.qobj import Qobj; from qutip.expect import expect; from qutip.operators import sigmax, sigmay, sigmaz. try:; import matplotlib; import matplotlib.pyplot as plt; from mpl_toolkits.mplot3d import Axes3D; from matplotlib.patches import FancyArrowPatch; from mpl_toolkits.mplot3d import proj3d. # Define a custom _axes3D function based on the matplotlib version.; # The auto_add_to_figure keyword is new for matplotlib>=3.4.; if parse_version(matplotlib.__version__) >= parse_version('3.4'):; def _axes3D(fig, *args, **kwargs):; ax = Axes3D(fig, *args, auto_add_to_figure=False, **kwargs); return fig.add_axes(ax); else:; def _axes3D(*args, **kwargs):; return Axes3D(*args, **kwargs). class Arrow3D(FancyArrowPatch):; def __init__(self, xs, ys, zs, *args, **kwargs):; FancyArrowPatch.__init__(self, (0, 0), (0, 0), *args, **kwargs). self._verts3d = xs, ys, zs. def draw(self, renderer):; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M). self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); FancyArrowPatch.draw(self, renderer). def do_3d_projection(self, renderer=None):; # only called by matplotlib >= 3.5; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M); self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); return np.min(zs); except ImportError:; pass. try:; from IPython.display import display; except ImportError:; pass. [",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:19847,Deployability,update,update,19847,"if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_lines(); self.plot_arcs(); self.plot_front(); self.plot_axes_labels(); self.plot_annotations(); # Trigger an update of the Bloch sphere if it is already shown:; self.fig.canvas.draw(). def plot_back(self):; # back half of sphere; u = linspace(0, pi, 25); v = linspace(0, pi, 25); x = outer(cos(u), sin(v)); y = outer(sin(u), sin(v)); z = outer(ones(size(u)), cos(v)); self.axes.plot_surface(x, y, z, rstride=2, cstride=2,; color=self.sphere_color, linewidth=0,; alpha=self.sphere_alpha); # wireframe; self.axes.plot_wireframe(x, y, z, rstride=5, cstride=5,; color=self.frame_color,; alpha=self.frame_alpha); # equator; self.axes.plot(1.0 * cos(u), 1.0 * sin(u), zs=0, zdir='z',; lw=self.frame_width, color=self.frame_color); self.axes.plot(1.0 * cos(u), 1.0 * sin(u), zs=0, zdir='x',; lw=self.frame_width, color=self.frame_color). def plot_front(self):; # front half of sphere; u = linspace(-pi, 0, 25); v = linspace(0, pi, 25); x = outer(cos(u), sin(v)); y = outer(sin(u), sin(v)); z = outer(ones(size(u)), cos(v)); self.axes.plot_surface(x, y, z, rstride=2, cstride=2,; color=self.sphere_color, linewidth=0,; alpha=self",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:25122,Deployability,update,update,25122,"int_color *; int(ceil(num / float(; len(self.point_color))))). pnt_colors = pnt_colors[0:num]; pnt_colors = list(pnt_colors[indperm]); marker = self.point_marker[mod(k, len(self.point_marker))]; s = self.point_size[mod(k, len(self.point_size))]; self.axes.scatter(real(self.points[k][1][indperm]),; -real(self.points[k][0][indperm]),; real(self.points[k][2][indperm]),; s=s, alpha=self.point_alpha[k],; edgecolor=None, zdir='z',; color=pnt_colors, marker=marker). elif self.point_style[k] == 'l':; color = self.point_color[mod(k, len(self.point_color))]; self.axes.plot(real(self.points[k][1]),; -real(self.points[k][0]),; real(self.points[k][2]),; alpha=self.point_alpha[k],; zdir='z', color=color). def plot_annotations(self):; # -X and Y data are switched for plotting purposes; for annotation in self.annotations:; vec = annotation['position']; opts = {'fontsize': self.font_size,; 'color': self.font_color,; 'horizontalalignment': 'center',; 'verticalalignment': 'center'}; opts.update(annotation['opts']); self.axes.text(vec[1], -vec[0], vec[2],; annotation['text'], **opts). def plot_lines(self):; for line, fmt, kw in self._lines:; self.axes.plot(line[0], line[1], line[2], fmt, **kw). def plot_arcs(self):; for arc, fmt, kw in self._arcs:; self.axes.plot(arc[1, :], -arc[0, :], arc[2, :], fmt, **kw). [docs] def show(self):; """"""; Display Bloch sphere and corresponding data sets. Notes; -----. When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""; self.render(); if self.run_from_ipython():; display(self.fig); else:; self.fig.show(). [docs] def save(self, name=None, format='png', dirc=None",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:27532,Deployability,update,updated,27532,"isplayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""; self.render(); if self.run_from_ipython():; display(self.fig); else:; self.fig.show(). [docs] def save(self, name=None, format='png', dirc=None, dpin=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory.; dpin : int; Resolution in dots per inch. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(); # Conditional variable for first argument to savefig; # that is set in subsequent if-elses; complete_path = """"; if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; complete_path = os.getcwd() + ""/"" + str(dirc) + '/bloch_' \; + str(self.savenum) + '.' + format; else:; complete_path = os.getcwd() + '/bloch_' + \; str(self.savenum) + '.' + format; else:; complete_path = name. if dpin:; self.fig.savefig(complete_path, dpi=dpin); else:; self.fig.savefig(complete_path); self.savenum += 1; if self.fig:; plt.close(self.fig). def _hide_tick_lines_and_labels(axis):; '''; Set visible property of ticklines and ticklabels of an axis to False; '''; for a in axis.get_ticklines() + axis.get_ticklabels():; a.set_visible(False). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:26662,Modifiability,variab,variable,26662,"isplayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""; self.render(); if self.run_from_ipython():; display(self.fig); else:; self.fig.show(). [docs] def save(self, name=None, format='png', dirc=None, dpin=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory.; dpin : int; Resolution in dots per inch. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(); # Conditional variable for first argument to savefig; # that is set in subsequent if-elses; complete_path = """"; if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; complete_path = os.getcwd() + ""/"" + str(dirc) + '/bloch_' \; + str(self.savenum) + '.' + format; else:; complete_path = os.getcwd() + '/bloch_' + \; str(self.savenum) + '.' + format; else:; complete_path = name. if dpin:; self.fig.savefig(complete_path, dpi=dpin); else:; self.fig.savefig(complete_path); self.savenum += 1; if self.fig:; plt.close(self.fig). def _hide_tick_lines_and_labels(axis):; '''; Set visible property of ticklines and ticklabels of an axis to False; '''; for a in axis.get_ticklines() + axis.get_ticklabels():; a.set_visible(False). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:18772,Safety,avoid,avoid,18772,"rror:; return False. def _is_inline_backend(self):; backend = matplotlib.get_backend(); return backend == ""module://matplotlib_inline.backend_inline"". [docs] def render(self):; """"""; Render the Bloch sphere and its data sets in on given figure and axes.; """"""; if not self._ext_fig and not self._is_inline_backend():; # If no external figure was supplied, we check to see if the; # figure we created in a previous call to .render() has been; # closed, and re-create if has been. This has the unfortunate; # side effect of losing any modifications made to the axes or; # figure, but the alternative is to crash the matplotlib backend.; #; # The inline backend used by, e.g. jupyter notebooks, is happy to; # use closed figures so we leave those figures intact.; if (; self.fig is not None and; not plt.fignum_exists(self.fig.number); ):; self.fig = None; self.axes = None. if self.fig is None:; self.fig = plt.figure(figsize=self.figsize); if self._is_inline_backend():; # We immediately close the inline figure do avoid displaying; # the figure twice when .show() calls display.; plt.close(self.fig). if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_lines(); self.plot_arc",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:163,Testability,Log,Log,163,". qutip.bloch — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch. Source code for qutip.bloch; __all__ = ['Bloch']. import os. from numpy import (ndarray, array, linspace, pi, outer, cos, sin, ones, size,; sqrt, real, mod, append, ceil, arange); import numpy as np. from packaging.version import parse as parse_version. from qutip.qobj import Qobj; from qutip.expect import expect; from qutip.operators import sigmax, sigmay, sigmaz. try:; import matplotlib; import matplotlib.pyplot as plt; from mpl_toolkits.mplot3d import Axes3D; from matplotlib.patches import FancyArrowPatch; from mpl_toolkits.mplot3d import proj3d. # Define a custom _axes3D function based on the matplotlib version.; # The auto_add_to_figure keyword is new for matplotlib>=3.4.; if parse_version(matplotlib.__version__) >= parse_version('3.4'):; def _axes3D(fig, *args, **kwargs):; ax = Axes3D(fig, *args, auto_add_to_figure=False, **kwargs); return fig.add_axes(ax); else:; def _axes3D(*args, **kwargs):; return Axes3D(*args, **kwargs). class Arrow3D(FancyArrowPatch):; def __init__(self, xs, ys, zs, *args, **kwargs):; FancyArrowPatch.__init__(self, (0, 0), (0, 0), *args, **kwargs). self._verts3d = xs, ys, zs. def draw(self, renderer):; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M). self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); FancyArrowPatch.draw(self, renderer). def do_3d_projection(self, renderer=None):; # only called by matplotlib >= 3.5; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M); self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); return np.min(zs); except ImportError:; pass. try:; from IPython.display import display; except ImportError:; pass. [",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:121,Usability,Guid,Guide,121,". qutip.bloch — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch. Source code for qutip.bloch; __all__ = ['Bloch']. import os. from numpy import (ndarray, array, linspace, pi, outer, cos, sin, ones, size,; sqrt, real, mod, append, ceil, arange); import numpy as np. from packaging.version import parse as parse_version. from qutip.qobj import Qobj; from qutip.expect import expect; from qutip.operators import sigmax, sigmay, sigmaz. try:; import matplotlib; import matplotlib.pyplot as plt; from mpl_toolkits.mplot3d import Axes3D; from matplotlib.patches import FancyArrowPatch; from mpl_toolkits.mplot3d import proj3d. # Define a custom _axes3D function based on the matplotlib version.; # The auto_add_to_figure keyword is new for matplotlib>=3.4.; if parse_version(matplotlib.__version__) >= parse_version('3.4'):; def _axes3D(fig, *args, **kwargs):; ax = Axes3D(fig, *args, auto_add_to_figure=False, **kwargs); return fig.add_axes(ax); else:; def _axes3D(*args, **kwargs):; return Axes3D(*args, **kwargs). class Arrow3D(FancyArrowPatch):; def __init__(self, xs, ys, zs, *args, **kwargs):; FancyArrowPatch.__init__(self, (0, 0), (0, 0), *args, **kwargs). self._verts3d = xs, ys, zs. def draw(self, renderer):; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M). self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); FancyArrowPatch.draw(self, renderer). def do_3d_projection(self, renderer=None):; # only called by matplotlib >= 3.5; xs3d, ys3d, zs3d = self._verts3d; xs, ys, zs = proj3d.proj_transform(xs3d, ys3d, zs3d, self.axes.M); self.set_positions((xs[0], ys[0]), (xs[1], ys[1])); return np.min(zs); except ImportError:; pass. try:; from IPython.display import display; except ImportError:; pass. [",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:6102,Usability,simpl,simple,6102,"1; self.frame_width = 1; # Transparency of wireframe, default = 0.2; self.frame_alpha = 0.2; # Labels for x-axis (in LaTex), default = ['$x$', '']; self.xlabel = ['$x$', '']; # Position of x-axis labels, default = [1.2, -1.2]; self.xlpos = [1.2, -1.2]; # Labels for y-axis (in LaTex), default = ['$y$', '']; self.ylabel = ['$y$', '']; # Position of y-axis labels, default = [1.1, -1.1]; self.ylpos = [1.2, -1.2]; # Labels for z-axis (in LaTex),; # default = [r'$\left\|0\right>$', r'$\left|1\right>$']; self.zlabel = [r'$\left|0\right>$', r'$\left|1\right>$']; # Position of z-axis labels, default = [1.2, -1.2]; self.zlpos = [1.2, -1.2]; # ---font options---; # Color of fonts, default = 'black'; self.font_color = 'black'; # Size of fonts, default = 20; self.font_size = 20. # ---vector options---; # List of colors for Bloch vectors, default = ['b','g','r','y']; self.vector_color = ['g', '#CC6600', 'b', 'r']; #: Width of Bloch vectors, default = 5; self.vector_width = 3; #: Style of Bloch vectors, default = '-\|>' (or 'simple'); self.vector_style = '-|>'; #: Sets the width of the vectors arrowhead; self.vector_mutation = 20. # ---point options---; # List of colors for Bloch point markers, default = ['b','g','r','y']; self.point_color = ['b', 'r', 'g', '#CC6600']; # Size of point markers, default = 25; self.point_size = [25, 32, 35, 45]; # Shape of point markers, default = ['o','^','d','s']; self.point_marker = ['o', 's', 'd', '^']. # ---data lists---; # Data for point markers; self.points = []; # Data for Bloch vectors; self.vectors = []; # Transparency of vectors, alpha value from 0 to 1; self.vector_alpha = []; # Data for annotations; self.annotations = []; # Number of times sphere has been saved; self.savenum = 0; # Style of points, 'm' for multiple colors, 's' for single color; self.point_style = []; # Transparency of points, alpha value from 0 to 1; self.point_alpha = []; # Data for line segment; self._lines = []; # Data for arcs and arc style; self._arcs = []. [docs] d",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:10591,Usability,clear,clear,10591,"n""; s += ""sphere_color: "" + str(self.sphere_color) + ""\n""; s += ""figsize: "" + str(self.figsize) + ""\n""; s += ""vector_color: "" + str(self.vector_color) + ""\n""; s += ""vector_width: "" + str(self.vector_width) + ""\n""; s += ""vector_style: "" + str(self.vector_style) + ""\n""; s += ""vector_mutation: "" + str(self.vector_mutation) + ""\n""; s += ""view: "" + str(self.view) + ""\n""; s += ""xlabel: "" + str(self.xlabel) + ""\n""; s += ""xlpos: "" + str(self.xlpos) + ""\n""; s += ""ylabel: "" + str(self.ylabel) + ""\n""; s += ""ylpos: "" + str(self.ylpos) + ""\n""; s += ""zlabel: "" + str(self.zlabel) + ""\n""; s += ""zlpos: "" + str(self.zlpos) + ""\n""; return s. def _repr_png_(self):; from IPython.core.pylabtools import print_figure; self.render(); fig_data = print_figure(self.fig, 'png'); plt.close(self.fig); return fig_data. def _repr_svg_(self):; from IPython.core.pylabtools import print_figure; self.render(); fig_data = print_figure(self.fig, 'svg'); plt.close(self.fig); return fig_data. [docs] def clear(self):; """"""Resets Bloch sphere data sets to empty.; """"""; self.points = []; self.vectors = []; self.point_style = []; self.point_alpha = []; self.vector_alpha = []; self.annotations = []; self._lines = []; self._arcs = []. [docs] def add_points(self, points, meth='s', alpha=1.0):; """"""Add a list of data points to bloch sphere. Parameters; ----------; points : array_like; Collection of data points. meth : {'s', 'm', 'l'}; Type of points to plot, use 'm' for multicolored, 'l' for points; connected with a line. alpha : float, default=1.; Transparency value for the vectors. Values between 0 and 1. .. note::. When using ``meth=l`` in QuTiP 4.6, the line transparency defaulted; to ``0.75`` and there was no way to alter it.; When the ``alpha`` parameter was added in QuTiP 4.7, the default; became ``alpha=1.0`` for values of ``meth``.; """"""; if not isinstance(points[0], (list, tuple, ndarray)):; points = [[points[0]], [points[1]], [points[2]]]; points = array(points); if meth == 's':; if len(points[0]) == 1:; pn",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:18953,Usability,Clear,Clearing,18953,"self._ext_fig and not self._is_inline_backend():; # If no external figure was supplied, we check to see if the; # figure we created in a previous call to .render() has been; # closed, and re-create if has been. This has the unfortunate; # side effect of losing any modifications made to the axes or; # figure, but the alternative is to crash the matplotlib backend.; #; # The inline backend used by, e.g. jupyter notebooks, is happy to; # use closed figures so we leave those figures intact.; if (; self.fig is not None and; not plt.fignum_exists(self.fig.number); ):; self.fig = None; self.axes = None. if self.fig is None:; self.fig = plt.figure(figsize=self.figsize); if self._is_inline_backend():; # We immediately close the inline figure do avoid displaying; # the figure twice when .show() calls display.; plt.close(self.fig). if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_lines(); self.plot_arcs(); self.plot_front(); self.plot_axes_labels(); self.plot_annotations(); # Trigger an update of the Bloch sphere if it is already shown:; self.fig.canvas.draw(). def plot_back(self):; # back half of sphere; u = linspace(0, pi, 25); v = linspace(0, pi, 25); x = oute",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:19117,Usability,clear,clear,19117,"o see if the; # figure we created in a previous call to .render() has been; # closed, and re-create if has been. This has the unfortunate; # side effect of losing any modifications made to the axes or; # figure, but the alternative is to crash the matplotlib backend.; #; # The inline backend used by, e.g. jupyter notebooks, is happy to; # use closed figures so we leave those figures intact.; if (; self.fig is not None and; not plt.fignum_exists(self.fig.number); ):; self.fig = None; self.axes = None. if self.fig is None:; self.fig = plt.figure(figsize=self.figsize); if self._is_inline_backend():; # We immediately close the inline figure do avoid displaying; # the figure twice when .show() calls display.; plt.close(self.fig). if self.axes is None:; self.axes = _axes3D(self.fig, azim=self.view[0], elev=self.view[1]). # Clearing the axes is horrifically slow and loses a lot of the; # axes state, but matplotlib doesn't seem to provide a better way; # to redraw Axes3D. :/; self.axes.clear(); self.axes.grid(False); if self.background:; self.axes.set_xlim3d(-1.3, 1.3); self.axes.set_ylim3d(-1.3, 1.3); self.axes.set_zlim3d(-1.3, 1.3); else:; self.axes.set_axis_off(); self.axes.set_xlim3d(-0.7, 0.7); self.axes.set_ylim3d(-0.7, 0.7); self.axes.set_zlim3d(-0.7, 0.7); # Manually set aspect ratio to fit a square bounding box.; # Matplotlib did this stretching for < 3.3.0, but not above.; if parse_version(matplotlib.__version__) >= parse_version('3.3'):; self.axes.set_box_aspect((1, 1, 1)); if not self.background:; self.plot_axes(). self.plot_back(); self.plot_points(); self.plot_vectors(); self.plot_lines(); self.plot_arcs(); self.plot_front(); self.plot_axes_labels(); self.plot_annotations(); # Trigger an update of the Bloch sphere if it is already shown:; self.fig.canvas.draw(). def plot_back(self):; # back half of sphere; u = linspace(0, pi, 25); v = linspace(0, pi, 25); x = outer(cos(u), sin(v)); y = outer(sin(u), sin(v)); z = outer(ones(size(u)), cos(v)); self.axes.plot_sur",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:22810,Usability,simpl,simple,22810,"f.xlabel[0], **opts); self.axes.text(0, -self.xlpos[1], 0, self.xlabel[1], **opts). self.axes.text(self.ylpos[0], 0, 0, self.ylabel[0], **opts); self.axes.text(self.ylpos[1], 0, 0, self.ylabel[1], **opts). self.axes.text(0, 0, self.zlpos[0], self.zlabel[0], **opts); self.axes.text(0, 0, self.zlpos[1], self.zlabel[1], **opts). for a in (self.axes.xaxis.get_ticklines() +; self.axes.xaxis.get_ticklabels()):; a.set_visible(False); for a in (self.axes.yaxis.get_ticklines() +; self.axes.yaxis.get_ticklabels()):; a.set_visible(False); for a in (self.axes.zaxis.get_ticklines() +; self.axes.zaxis.get_ticklabels()):; a.set_visible(False). def plot_vectors(self):; # -X and Y data are switched for plotting purposes; for k in range(len(self.vectors)):. xs3d = self.vectors[k][1] * array([0, 1]); ys3d = -self.vectors[k][0] * array([0, 1]); zs3d = self.vectors[k][2] * array([0, 1]). color = self.vector_color[mod(k, len(self.vector_color))]; alpha = self.vector_alpha[k]. if self.vector_style == '':; # simple line style; self.axes.plot(xs3d, ys3d, zs3d,; zs=0, zdir='z', label='Z',; lw=self.vector_width, color=color,; alpha=alpha); else:; # decorated style, with arrow heads; a = Arrow3D(xs3d, ys3d, zs3d,; mutation_scale=self.vector_mutation,; lw=self.vector_width,; arrowstyle=self.vector_style,; color=color, alpha=alpha). self.axes.add_artist(a). def plot_points(self):; # -X and Y data are switched for plotting purposes; for k in range(len(self.points)):; num = len(self.points[k][0]); dist = [sqrt(self.points[k][0][j] ** 2 +; self.points[k][1][j] ** 2 +; self.points[k][2][j] ** 2) for j in range(num)]; if any(abs(dist - dist[0]) / dist[0] > 1e-12):; # combine arrays so that they can be sorted together; zipped = list(zip(dist, range(num))); zipped.sort() # sort rates from lowest to highest; dist, indperm = zip(*zipped); indperm = array(indperm); else:; indperm = arange(num); if self.point_style[k] == 's':; self.axes.scatter(; real(self.points[k][1][indperm]),; - real(self.points[k][0][i",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch.html:25898,Usability,simpl,simplest,25898," plotting purposes; for annotation in self.annotations:; vec = annotation['position']; opts = {'fontsize': self.font_size,; 'color': self.font_color,; 'horizontalalignment': 'center',; 'verticalalignment': 'center'}; opts.update(annotation['opts']); self.axes.text(vec[1], -vec[0], vec[2],; annotation['text'], **opts). def plot_lines(self):; for line, fmt, kw in self._lines:; self.axes.plot(line[0], line[1], line[2], fmt, **kw). def plot_arcs(self):; for arc, fmt, kw in self._arcs:; self.axes.plot(arc[1, :], -arc[0, :], arc[2, :], fmt, **kw). [docs] def show(self):; """"""; Display Bloch sphere and corresponding data sets. Notes; -----. When using inline plotting in Jupyter notebooks, any figure created; in a notebook cell is displayed after the cell executes. Thus if you; create a figure yourself and use it create a Bloch sphere with; ``b = Bloch(..., fig=fig)`` and then call ``b.show()`` in the same; cell, then the figure will be displayed twice. If you do create your; own figure, the simplest solution to this is to not call ``.show()``; in the cell you create the figure in.; """"""; self.render(); if self.run_from_ipython():; display(self.fig); else:; self.fig.show(). [docs] def save(self, name=None, format='png', dirc=None, dpin=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------. name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image.; dirc : str; Directory for output images. Defaults to current working directory.; dpin : int; Resolution in dots per inch. Returns; -------; File containing plot of Bloch sphere. """"""; self.render(); # Conditional variable for first argument to savefig; # that is set in subsequent if-elses; complete_path = """"; if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; comp",MatchSource.WIKI,docs/4.7/modules/qutip/bloch.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch.html
https://qutip.org/docs/4.7/modules/qutip/bloch3d.html:103,Deployability,Install,Installation,103,". qutip.bloch3d — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch3d. Source code for qutip.bloch3d; __all__ = ['Bloch3d']. import numpy as np; from qutip.qobj import Qobj; from qutip.expect import expect; from qutip.operators import sigmax, sigmay, sigmaz. [docs]class Bloch3d:; """"""Class for plotting data on a 3D Bloch sphere using mayavi.; Valid data can be either points, vectors, or qobj objects; corresponding to state vectors or density matrices. for; a two-state system (or subsystem). Attributes; ----------; fig : instance {None}; User supplied Matplotlib Figure instance for plotting Bloch sphere.; font_color : str {'black'}; Color of font used for Bloch sphere labels.; font_scale : float {0.08}; Scale for font used for Bloch sphere labels.; frame : bool {True}; Draw frame for Bloch sphere; frame_alpha : float {0.05}; Sets transparency of Bloch sphere frame.; frame_color : str {'gray'}; Color of sphere wireframe.; frame_num : int {8}; Number of frame elements to draw.; frame_radius : floats {0.005}; Width of wireframe.; point_color : list {['r', 'g', 'b', 'y']}; List of colors for Bloch sphere point markers to cycle through.; i.e. By default, points 0 and 4 will both be blue ('r').; point_mode : string {'sphere','cone','cube','cylinder','point'}; Point marker shapes.; point_size : float {0.075}; Size of points on Bloch sphere.; sphere_alpha : float {0.1}; Transparency of Bloch sphere itself.; sphere_color : str {'#808080'}; Color of Bloch sphere.; size : list {[500,500]}; Size of Bloch sphere plot in pixels. Best to have both numbers the same; otherwise you will have a Bloch sphere that looks like a football.; vector_color : list {['r', 'g', 'b', 'y']}; List of vector colors to cycle through.; vector_width : int {3}; Width",MatchSource.WIKI,docs/4.7/modules/qutip/bloch3d.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch3d.html
https://qutip.org/docs/4.7/modules/qutip/bloch3d.html:16413,Deployability,update,updated,16413,"b(self.font_color),; scale=self.font_scale); mlab.text3d(self.xlpos[0], 0, 0, self.xlabel[0],; color=colors.colorConverter.to_rgb(self.font_color),; scale=self.font_scale); mlab.text3d(self.xlpos[1], 0, 0, self.xlabel[1],; color=colors.colorConverter.to_rgb(self.font_color),; scale=self.font_scale); mlab.text3d(0, self.ylpos[0], 0, self.ylabel[0],; color=colors.colorConverter.to_rgb(self.font_color),; scale=self.font_scale); mlab.text3d(0, self.ylpos[1], 0, self.ylabel[1],; color=colors.colorConverter.to_rgb(self.font_color),; scale=self.font_scale). [docs] def show(self):; """"""; Display the Bloch sphere and corresponding data sets.; """"""; from mayavi import mlab; self.make_sphere(); mlab.view(azimuth=self.view[0], elevation=self.view[1], distance=5); if self.fig:; mlab.show(). [docs] def save(self, name=None, format='png', dirc=None):; """"""Saves Bloch sphere to file of type ``format`` in directory ``dirc``. Parameters; ----------; name : str; Name of saved image. Must include path and format as well.; i.e. '/Users/Paul/Desktop/bloch.png'; This overrides the 'format' and 'dirc' arguments.; format : str; Format of output image. Default is 'png'.; dirc : str; Directory for output images. Defaults to current working directory. Returns; -------; File containing plot of Bloch sphere. """"""; from mayavi import mlab; import os; self.make_sphere(); mlab.view(azimuth=self.view[0], elevation=self.view[1], distance=5); if dirc:; if not os.path.isdir(os.getcwd() + ""/"" + str(dirc)):; os.makedirs(os.getcwd() + ""/"" + str(dirc)); if name is None:; if dirc:; mlab.savefig(os.getcwd() + ""/"" + str(dirc) + '/bloch_' +; str(self.savenum) + '.' + format); else:; mlab.savefig(os.getcwd() + '/bloch_' + str(self.savenum) +; '.' + format); else:; mlab.savefig(name); self.savenum += 1; if self.fig:; mlab.close(self.fig). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch3d.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch3d.html
https://qutip.org/docs/4.7/modules/qutip/bloch3d.html:165,Testability,Log,Log,165,". qutip.bloch3d — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch3d. Source code for qutip.bloch3d; __all__ = ['Bloch3d']. import numpy as np; from qutip.qobj import Qobj; from qutip.expect import expect; from qutip.operators import sigmax, sigmay, sigmaz. [docs]class Bloch3d:; """"""Class for plotting data on a 3D Bloch sphere using mayavi.; Valid data can be either points, vectors, or qobj objects; corresponding to state vectors or density matrices. for; a two-state system (or subsystem). Attributes; ----------; fig : instance {None}; User supplied Matplotlib Figure instance for plotting Bloch sphere.; font_color : str {'black'}; Color of font used for Bloch sphere labels.; font_scale : float {0.08}; Scale for font used for Bloch sphere labels.; frame : bool {True}; Draw frame for Bloch sphere; frame_alpha : float {0.05}; Sets transparency of Bloch sphere frame.; frame_color : str {'gray'}; Color of sphere wireframe.; frame_num : int {8}; Number of frame elements to draw.; frame_radius : floats {0.005}; Width of wireframe.; point_color : list {['r', 'g', 'b', 'y']}; List of colors for Bloch sphere point markers to cycle through.; i.e. By default, points 0 and 4 will both be blue ('r').; point_mode : string {'sphere','cone','cube','cylinder','point'}; Point marker shapes.; point_size : float {0.075}; Size of points on Bloch sphere.; sphere_alpha : float {0.1}; Transparency of Bloch sphere itself.; sphere_color : str {'#808080'}; Color of Bloch sphere.; size : list {[500,500]}; Size of Bloch sphere plot in pixels. Best to have both numbers the same; otherwise you will have a Bloch sphere that looks like a football.; vector_color : list {['r', 'g', 'b', 'y']}; List of vector colors to cycle through.; vector_width : int {3}; Width",MatchSource.WIKI,docs/4.7/modules/qutip/bloch3d.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch3d.html
https://qutip.org/docs/4.7/modules/qutip/bloch3d.html:123,Usability,Guid,Guide,123,". qutip.bloch3d — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch3d. Source code for qutip.bloch3d; __all__ = ['Bloch3d']. import numpy as np; from qutip.qobj import Qobj; from qutip.expect import expect; from qutip.operators import sigmax, sigmay, sigmaz. [docs]class Bloch3d:; """"""Class for plotting data on a 3D Bloch sphere using mayavi.; Valid data can be either points, vectors, or qobj objects; corresponding to state vectors or density matrices. for; a two-state system (or subsystem). Attributes; ----------; fig : instance {None}; User supplied Matplotlib Figure instance for plotting Bloch sphere.; font_color : str {'black'}; Color of font used for Bloch sphere labels.; font_scale : float {0.08}; Scale for font used for Bloch sphere labels.; frame : bool {True}; Draw frame for Bloch sphere; frame_alpha : float {0.05}; Sets transparency of Bloch sphere frame.; frame_color : str {'gray'}; Color of sphere wireframe.; frame_num : int {8}; Number of frame elements to draw.; frame_radius : floats {0.005}; Width of wireframe.; point_color : list {['r', 'g', 'b', 'y']}; List of colors for Bloch sphere point markers to cycle through.; i.e. By default, points 0 and 4 will both be blue ('r').; point_mode : string {'sphere','cone','cube','cylinder','point'}; Point marker shapes.; point_size : float {0.075}; Size of points on Bloch sphere.; sphere_alpha : float {0.1}; Transparency of Bloch sphere itself.; sphere_color : str {'#808080'}; Color of Bloch sphere.; size : list {[500,500]}; Size of Bloch sphere plot in pixels. Best to have both numbers the same; otherwise you will have a Bloch sphere that looks like a football.; vector_color : list {['r', 'g', 'b', 'y']}; List of vector colors to cycle through.; vector_width : int {3}; Width",MatchSource.WIKI,docs/4.7/modules/qutip/bloch3d.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch3d.html
https://qutip.org/docs/4.7/modules/qutip/bloch3d.html:7641,Usability,clear,clear,7641,"or) + ""\n""; s += ""frame_num: "" + str(self.frame_num) + ""\n""; s += ""frame_radius: "" + str(self.frame_radius) + ""\n""; s += ""point_color: "" + str(self.point_color) + ""\n""; s += ""point_mode: "" + str(self.point_mode) + ""\n""; s += ""point_size: "" + str(self.point_size) + ""\n""; s += ""sphere_alpha: "" + str(self.sphere_alpha) + ""\n""; s += ""sphere_color: "" + str(self.sphere_color) + ""\n""; s += ""size: "" + str(self.size) + ""\n""; s += ""vector_color: "" + str(self.vector_color) + ""\n""; s += ""vector_width: "" + str(self.vector_width) + ""\n""; s += ""vector_head_height: "" + str(self.vector_head_height) + ""\n""; s += ""vector_head_radius: "" + str(self.vector_head_radius) + ""\n""; s += ""view: "" + str(self.view) + ""\n""; s += ""xlabel: "" + str(self.xlabel) + ""\n""; s += ""xlpos: "" + str(self.xlpos) + ""\n""; s += ""ylabel: "" + str(self.ylabel) + ""\n""; s += ""ylpos: "" + str(self.ylpos) + ""\n""; s += ""zlabel: "" + str(self.zlabel) + ""\n""; s += ""zlpos: "" + str(self.zlpos) + ""\n""; return s. [docs] def clear(self):; """"""Resets the Bloch sphere data sets to empty.; """"""; self.points = []; self.vectors = []; self.point_style = []. [docs] def add_points(self, points, meth='s', alpha=1.0):; """"""Add a list of data points to bloch sphere. Parameters; ----------; points : array/list; Collection of data points. meth : str {'s','m'}; Type of points to plot, use 'm' for multicolored. alpha : float, default=1.; Transparency value for the vectors. Values between 0 and 1. """"""; if not isinstance(points[0], (list, np.ndarray)):; points = [[points[0]], [points[1]], [points[2]]]; points = np.array(points); if meth == 's':; if len(points[0]) == 1:; pnts = np.array(; [[points[0][0]], [points[1][0]], [points[2][0]]]); pnts = np.append(pnts, points, axis=1); else:; pnts = points; self.points.append(pnts); self.point_style.append('s'); else:; self.points.append(points); self.point_style.append('m'); self.point_alpha.append(alpha). [docs] def add_states(self, state, kind='vector', alpha=1.0):; """"""Add a state vector Qobj to Bloch sph",MatchSource.WIKI,docs/4.7/modules/qutip/bloch3d.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch3d.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:4001,Availability,Toler,Tolerance,4001,"f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. options : :class:`qutip.solver.Options`; Options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spect",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8960,Availability,error,error,8960,"list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None,; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):. if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]. H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15183,Availability,error,error,15183,"t(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, i",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:110,Deployability,Install,Installation,110,". qutip.bloch_redfield — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:504,Deployability,integrat,integrate,504,". qutip.bloch_redfield — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8344,Deployability,integrat,integrator,8344,"lver. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_id",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8410,Deployability,integrat,integrate,8410,"esult`. An instance of the class :class:`qutip.solver.Result`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8888,Deployability,update,update,8888,"0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None,; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):. if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]. H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_t",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8948,Deployability,integrat,integration,8948,"list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None,; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):. if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]. H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:9476,Deployability,integrat,integrate,9476,".data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None,; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):. if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]. H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; coupled_lengths = []; coupled_spectra = []. if isinstance(H, Qobj):; H_terms.append(H.full('f')); H_td_terms.append('1'); else:; for kk, h in enumerate(H):; if isinstance(h, Qobj):; H_terms.append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'). for kk, c in enumerat",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13722,Deployability,integrat,integrate,13722,"name is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15108,Deployability,update,update,15108,"(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastc",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15171,Deployability,integrat,integration,15171,"t(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, i",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15804,Deployability,integrat,integrate,15804,"t):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:16325,Deployability,update,updated,16325,"t):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:504,Integrability,integrat,integrate,504,". qutip.bloch_redfield — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2173,Integrability,depend,dependent,2173," qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; Sy",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2306,Integrability,depend,dependent,2306," qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; Sy",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2479,Integrability,depend,dependence,2479,"docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2635,Integrability,depend,dependence,2635,"=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for wh",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2850,Integrability,depend,dependence,2850," as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:3140,Integrability,depend,dependence,3140," a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. opti",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:5280,Integrability,depend,dependent,5280,"s of the simulation. Returns; -------; result: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_str == 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:5600,Integrability,depend,dependence,5600,"); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_str == 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose,; _prep_time=_prep_time). return output. else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield master equation g",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8344,Integrability,integrat,integrator,8344,"lver. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_id",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8410,Integrability,integrat,integrate,8410,"esult`. An instance of the class :class:`qutip.solver.Result`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). #; # check initial state; #; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(). #; # prepare output array; #; n_tsteps = len(tlist); dt = tlist[1] - tlist[0]; result_list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:8948,Integrability,integrat,integration,8948,"list = []. #; # transform the initial density matrix and the e_ops opterators to the; # eigenbasis; #; rho_eb = rho0.transform(ekets); e_eb_ops = [e.transform(ekets) for e in e_ops]. for e_eb in e_eb_ops:; if e_eb.isherm:; result_list.append(np.zeros(n_tsteps, dtype=float)); else:; result_list.append(np.zeros(n_tsteps, dtype=complex)). #; # setup integrator; #; initial_vector = mat2vec(rho_eb.full()); r = scipy.integrate.ode(cy_ode_rhs); r.set_f_params(R.data.data, R.data.indices, R.data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None,; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):. if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]. H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:9476,Integrability,integrat,integrate,9476,".data.indptr); r.set_integrator('zvode', method=options.method, order=options.order,; atol=options.atol, rtol=options.rtol,; nsteps=options.nsteps, first_step=options.first_step,; min_step=options.min_step, max_step=options.max_step); r.set_initial_value(initial_vector, tlist[0]). #; # start evolution; #; dt = np.diff(tlist); progress_bar.start(n_tsteps); for t_idx, _ in enumerate(tlist):; progress_bar.update(t_idx); if not r.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). rho_eb.data = dense2D_to_fastcsr_fmode(vec2mat(r.y), rho0.shape[0], rho0.shape[1]). # calculate all the expectation values, or output rho_eb if no; # expectation value operators are given; if e_ops:; rho_eb_tmp = Qobj(rho_eb); for m, e in enumerate(e_eb_ops):; result_list[m][t_idx] = expect(e, rho_eb_tmp); else:; result_list.append(rho_eb.transform(ekets, True)). if t_idx < n_tsteps - 1:; r.integrate(r.t + dt[t_idx]); progress_bar.finished(); return result_list. def _td_brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[], args={},; use_secular=True, sec_cutoff=0.1,; tol=qset.atol, options=None,; progress_bar=None,_safe_mode=True,; verbose=False,; _prep_time=0):. if isket(psi0):; rho0 = ket2dm(psi0); else:; rho0 = psi0; nrows = rho0.shape[0]. H_terms = []; H_td_terms = []; H_obj = []; A_terms = []; A_td_terms = []; C_terms = []; C_td_terms = []; CA_obj = []; spline_count = [0,0]; coupled_ops = []; coupled_lengths = []; coupled_spectra = []. if isinstance(H, Qobj):; H_terms.append(H.full('f')); H_td_terms.append('1'); else:; for kk, h in enumerate(H):; if isinstance(h, Qobj):; H_terms.append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'). for kk, c in enumerat",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13722,Integrability,integrat,integrate,13722,"name is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15171,Integrability,integrat,integration,15171,"t(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, i",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15804,Integrability,integrat,integrate,15804,"t):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:722,Modifiability,config,config,722,". qutip.bloch_redfield — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:1762,Modifiability,coupling,coupling,1762,"Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a t",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:1957,Modifiability,coupling,coupling,1957,"ar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input for",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2099,Modifiability,variab,variable,2099,"ar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input for",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2361,Modifiability,variab,variable,2361,"docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2424,Modifiability,variab,variables,2424,"docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:2507,Modifiability,variab,variable,2507,"docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a nested list; of operator - spectrum function pairs, where the frequency is specified by; the `w` variable. *Example*. a_ops = [[a+a.dag(),lambda w: 0.2*(w>=0)]]. For time-dependent systems, the Hamiltonian, a_ops, and Lindblad collapse; operators (c_ops), can be specified in the QuTiP string-based time-dependent; format. For the a_op spectra, the frequency variable must be `w`, and the; string cannot contain any other variables other than the possibility of having; a time-dependence through the time variable `t`:. *Example*. a_ops = [[a+a.dag(), '0.2*exp(-t)*(w>=0)']]. It is also possible to use Cubic_Spline objects for time-dependence. In; the case of a_ops, Cubic_Splines must be passed as a tuple:. *Example*. a_ops = [ [a+a.dag(), ( f(w), g(t)] ]. where f(w) and g(t) are strings or Cubic_spline objects for the bath; spectrum and time-dependence, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:3889,Modifiability,coupling,coupling,3889,"e, respectively. Finally, if one has bath-couplimg terms of the form; H = f(t)*a + conj[f(t)]*a.dag(), then the correct input format is. *Example*. a_ops = [ [(a,a.dag()), (f(w), g1(t), g2(t))],... ]. where f(w) is the spectrum of the operators while g1(t) and g2(t); are the time-dependence of the operators `a` and `a.dag()`, respectively. Parameters; ----------; H : Qobj / list; System Hamiltonian given as a Qobj or; nested list in string-based format. psi0: Qobj; Initial density matrix or state vector (ket). tlist : array_like; List of times for evaluating evolution. a_ops : list; Nested list of Hermitian system operators that couple to; the bath degrees of freedom, along with their associated; spectra. e_ops : list; List of operators for which to evaluate expectation values. c_ops : list; List of system collapse operators, or nested list in; string-based format. args : dict; Placeholder for future implementation, kept for API consistency. use_secular : bool {True}; Use secular approximation when evaluating bath-coupling terms. sec_cutoff : float {0.1}; Cutoff for secular approximation. tol : float {qutip.setttings.atol}; Tolerance used for removing small values after; basis transformation. spectra_cb : list; DEPRECIATED. Do not use. options : :class:`qutip.solver.Options`; Options for the solver. progress_bar : BaseProgressBar; Optional instance of BaseProgressBar, or a subclass thereof, for; showing the progress of the simulation. Returns; -------; result: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains; either an array of expectation values, for operators given in e_ops,; or a list of states for the times specified by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:5550,Modifiability,config,config,5550,"imes specified by `tlist`.; """"""; _prep_time = time.time(); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_str == 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose,; _prep_time=_prep_time). return output. else:; raise Exception('Cannot mix func and str formats.'). # --------------------------------------------------------------------------",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:5575,Modifiability,config,config,5575,"); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_str == 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose,; _prep_time=_prep_time). return output. else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield master equation g",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:5636,Modifiability,config,config,5636,"); #This allows for passing a list of time-independent Qobj; #as allowed by mesolve; if isinstance(H, list):; if np.all([isinstance(h,Qobj) for h in H]):; H = sum(H). if isinstance(c_ops, Qobj):; c_ops = [c_ops]. if isinstance(e_ops, Qobj):; e_ops = [e_ops]. if isinstance(e_ops, dict):; e_ops_dict = e_ops; e_ops = [e for e in e_ops.values()]; else:; e_ops_dict = None. if not (spectra_cb is None):; warnings.warn(""The use of spectra_cb is depreciated."", DeprecationWarning); _a_ops = []; for kk, a in enumerate(a_ops):; _a_ops.append([a,spectra_cb[kk]]); a_ops = _a_ops. if _safe_mode:; _solver_safety_check(H, psi0, a_ops+c_ops, e_ops, args). # check for type (if any) of time-dependent inputs; _, n_func, n_str = _td_format_check(H, a_ops+c_ops). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progress_bar is True:; progress_bar = TextProgressBar(). if options is None:; options = Options(). if (not options.rhs_reuse) or (not config.tdfunc):; # reset config collapse and time-dependence flags to default values; config.reset(). #check if should use OPENMP; check_use_openmp(options). if n_str == 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose,; _prep_time=_prep_time). return output. else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield master equation g",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:6743,Modifiability,Evolve,Evolve,6743,"== 0:. R, ekets = bloch_redfield_tensor(H, a_ops, spectra_cb=None, c_ops=c_ops,; use_secular=use_secular, sec_cutoff=sec_cutoff). output = Result(); output.solver = ""brmesolve""; output.times = tlist. results = bloch_redfield_solve(R, ekets, psi0, tlist, e_ops, options,; progress_bar=progress_bar). if e_ops:; output.expect = results; else:; output.states = results. return output. elif n_str != 0 and n_func == 0:; output = _td_brmesolve(H, psi0, tlist, a_ops=a_ops, e_ops=e_ops,; c_ops=c_ops, args=args, use_secular=use_secular,; sec_cutoff=sec_cutoff,; tol=tol, options=options,; progress_bar=progress_bar,; _safe_mode=_safe_mode, verbose=verbose,; _prep_time=_prep_time). return output. else:; raise Exception('Cannot mix func and str formats.'). # -----------------------------------------------------------------------------; # Evolution of the Bloch-Redfield master equation given the Bloch-Redfield; # tensor.; #; [docs]def bloch_redfield_solve(R, ekets, rho0, tlist, e_ops=[], options=None, progress_bar=None):; """"""; Evolve the ODEs defined by Bloch-Redfield master equation. The; Bloch-Redfield tensor can be calculated by the function; :func:`bloch_redfield_tensor`. Parameters; ----------. R : :class:`qutip.qobj`; Bloch-Redfield tensor. ekets : array of :class:`qutip.qobj`; Array of kets that make up a basis tranformation for the eigenbasis. rho0 : :class:`qutip.qobj`; Initial density matrix. tlist : *list* / *array*; List of times for :math:`t`. e_ops : list of :class:`qutip.qobj` / callback function; List of operators for which to evaluate expectation values. options : :class:`qutip.solver.Options`; Options for the ODE solver. Returns; -------. output: :class:`qutip.solver.Result`. An instance of the class :class:`qutip.solver.Result`, which contains either; an *array* of expectation values for the times specified by `tlist`. """""". if options is None:; options = Options(). if options.tidy:; R.tidyup(). if progress_bar is None:; progress_bar = BaseProgressBar(); elif progre",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:11277,Modifiability,coupling,coupling,11277,"terms.append(h.full('f')); H_td_terms.append('1'); elif isinstance(h, list):; H_terms.append(h[0].full('f')); if isinstance(h[1], Cubic_Spline):; H_obj.append(h[1].coeffs); spline_count[0] += 1; H_td_terms.append(h[1]); else:; raise Exception('Invalid Hamiltonian specification.'). for kk, c in enumerate(c_ops):; if isinstance(c, Qobj):; C_terms.append(c.full('f')); C_td_terms.append('1'); elif isinstance(c, list):; C_terms.append(c[0].full('f')); if isinstance(c[1], Cubic_Spline):; CA_obj.append(c[1].coeffs); spline_count[0] += 1; C_td_terms.append(c[1]); else:; raise Exception('Invalid collapse operator specification.'). coupled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'). coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1. for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1. else:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(k",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:11820,Modifiability,coupling,coupling,11820,"pled_offset = 0; for kk, a in enumerate(a_ops):; if isinstance(a, list):; if isinstance(a[0], Qobj):; A_terms.append(a[0].full('f')); A_td_terms.append(a[1]); if isinstance(a[1], tuple):; if not len(a[1])==2:; raise Exception('Tuple must be len=2.'); if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1; if isinstance(a[1][1],Cubic_Spline):; spline_count[1] += 1; elif isinstance(a[0], tuple):; if not isinstance(a[1], tuple):; raise Exception('Invalid bath-coupling specification.'); if (len(a[0])+1) != len(a[1]):; raise Exception('BR a_ops tuple lengths not compatible.'). coupled_ops.append(kk+coupled_offset); coupled_lengths.append(len(a[0])); coupled_spectra.append(a[1][0]); coupled_offset += len(a[0])-1; if isinstance(a[1][0],Cubic_Spline):; spline_count[1] += 1. for nn, _a in enumerate(a[0]):; A_terms.append(_a.full('f')); A_td_terms.append(a[1][nn+1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1. else:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:;",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:12684,Modifiability,config,config,12684,"1]); if isinstance(a[1][nn+1],Cubic_Spline):; CA_obj.append(a[1][nn+1].coeffs); spline_count[1] += 1. else:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = ma",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:12742,Modifiability,config,config,12742,"append(a[1][nn+1].coeffs); spline_count[1] += 1. else:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.od",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:12789,Modifiability,config,config,12789,"lse:; raise Exception('Invalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:12814,Modifiability,config,config,12814,"nvalid bath-coupling specification.'). string_list = []; for kk,_ in enumerate(H_td_terms):; string_list.append(""H_terms[{0}]"".format(kk)); for kk,_ in enumerate(H_obj):; string_list.append(""H_obj[{0}]"".format(kk)); for kk,_ in enumerate(C_td_terms):; string_list.append(""C_terms[{0}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13193,Modifiability,config,config,13193,"}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initia",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13200,Modifiability,config,config,13200,"}]"".format(kk)); for kk,_ in enumerate(CA_obj):; string_list.append(""CA_obj[{0}]"".format(kk)); for kk,_ in enumerate(A_td_terms):; string_list.append(""A_terms[{0}]"".format(kk)); #Add nrows to parameters; string_list.append('nrows'); for name, value in args.items():; if isinstance(value, np.ndarray):; raise TypeError('NumPy arrays not valid args for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initia",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13438,Modifiability,config,config,13438,"for BR solver.'); else:; string_list.append(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13488,Modifiability,config,config,13488,"ppend(str(value)); parameter_string = "","".join(string_list). if verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13574,Modifiability,config,config,13574," verbose:; print('BR prep time:', time.time()-_prep_time); #; # generate and compile new cython code if necessary; #; if not options.rhs_reuse or config.tdfunc is None:; if options.rhs_filename is None:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.st",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:13736,Modifiability,config,config,13736,"ne:; config.tdname = ""rhs"" + str(os.getpid()) + str(config.cgen_num); else:; config.tdname = opt.rhs_filename; if verbose:; _st = time.time(); cgen = BR_Codegen(h_terms=len(H_terms),; h_td_terms=H_td_terms, h_obj=H_obj,; c_terms=len(C_terms),; c_td_terms=C_td_terms, c_obj=CA_obj,; a_terms=len(A_terms), a_td_terms=A_td_terms,; spline_count=spline_count,; coupled_ops = coupled_ops,; coupled_lengths = coupled_lengths,; coupled_spectra = coupled_spectra,; config=config, sparse=False,; use_secular = use_secular,; sec_cutoff = sec_cutoff,; args=args,; use_openmp=options.use_openmp,; omp_thresh=qset.openmp_thresh if qset.has_openmp else None,; omp_threads=options.num_cpus,; atol=tol). cgen.generate(config.tdname + "".pyx""); code = compile('from ' + config.tdname + ' import cy_td_ode_rhs',; '<string>', 'exec'); exec(code, globals()); config.tdfunc = cy_td_ode_rhs; if verbose:; print('BR compile time:', time.time()-_st); initial_vector = mat2vec(rho0.full()).ravel(). _ode = scipy.integrate.ode(config.tdfunc); code = compile('_ode.set_f_params(' + parameter_string + ')',; '<string>', 'exec'); _ode.set_integrator('zvode', method=options.method,; order=options.order, atol=options.atol,; rtol=options.rtol, nsteps=options.nsteps,; first_step=options.first_step,; min_step=options.min_step,; max_step=options.max_step); _ode.set_initial_value(initial_vector, tlist[0]); exec(code, locals()). #; # prepare output array; #; n_tsteps = len(tlist); e_sops_data = []. output = Result(); output.solver = ""brmesolve""; output.times = tlist. if options.store_states:; output.states = []. if isinstance(e_ops, types.FunctionType):; n_expt_op = 0; expt_callback = True. elif isinstance(e_ops, list):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_ts",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:15990,Modifiability,config,config,15990,"t):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:16041,Modifiability,config,config,16041,"t):; n_expt_op = len(e_ops); expt_callback = False. if n_expt_op == 0:; # fall back on storing states; output.states = []; options.store_states = True; else:; output.expect = []; output.num_expect = n_expt_op; for op in e_ops:; e_sops_data.append(spre(op).data); if op.isherm:; output.expect.append(np.zeros(n_tsteps)); else:; output.expect.append(np.zeros(n_tsteps, dtype=complex)). else:; raise TypeError(""Expectation parameter must be a list or a function""). #; # start evolution; #; if type(progress_bar)==BaseProgressBar and verbose:; _run_time = time.time(). progress_bar.start(n_tsteps). rho = Qobj(rho0). dt = np.diff(tlist); for t_idx, t in enumerate(tlist):; progress_bar.update(t_idx). if not _ode.successful():; raise Exception(""ODE integration error: Try to increase ""; ""the allowed number of substeps by increasing ""; ""the nsteps parameter in the Options class.""). if options.store_states or expt_callback:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]). if options.store_states:; output.states.append(Qobj(rho, isherm=True)). if expt_callback:; # use callback method; e_ops(t, rho). for m in range(n_expt_op):; if output.expect[m].dtype == complex:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 0); else:; output.expect[m][t_idx] = expect_rho_vec(e_sops_data[m],; _ode.y, 1). if t_idx < n_tsteps - 1:; _ode.integrate(_ode.t + dt[t_idx]). progress_bar.finished(). if type(progress_bar)==BaseProgressBar and verbose:; print('BR runtime:', time.time()-_run_time). if (not options.rhs_reuse) and (config.tdname is not None):; _cython_build_cleanup(config.tdname). if options.store_final_state:; rho.data = dense2D_to_fastcsr_fmode(vec2mat(_ode.y), rho.shape[0], rho.shape[1]); output.final_state = Qobj(rho, dims=rho0.dims, isherm=True). return output. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:172,Testability,Log,Log,172,". qutip.bloch_redfield — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html:130,Usability,Guid,Guide,130,". qutip.bloch_redfield — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.bloch_redfield. Source code for qutip.bloch_redfield; __all__ = ['brmesolve', 'bloch_redfield_solve']. import numpy as np; import os; import time; import types; import warnings; import scipy.integrate; from qutip.qobj import Qobj, isket; from qutip.states import ket2dm; from qutip.superoperator import spre, spost, vec2mat, mat2vec; from qutip.expect import expect; from qutip.solver import Options, Result, config, _solver_safety_check; from qutip.cy.spmatfuncs import cy_ode_rhs; from qutip.cy.spconvert import dense2D_to_fastcsr_fmode; from qutip.interpolate import Cubic_Spline; from qutip.cy.br_codegen import BR_Codegen; from qutip.ui.progressbar import BaseProgressBar, TextProgressBar; from qutip.cy.utilities import _cython_build_cleanup; from qutip.expect import expect_rho_vec; from qutip.rhs_generate import _td_format_check; from qutip.cy.openmp.utilities import check_use_openmp; import qutip.settings as qset; from qutip.cy.br_tensor import bloch_redfield_tensor. # -----------------------------------------------------------------------------; # Solve the Bloch-Redfield master equation; #; [docs]def brmesolve(H, psi0, tlist, a_ops=[], e_ops=[], c_ops=[],; args={}, use_secular=True, sec_cutoff = 0.1,; tol=qset.atol,; spectra_cb=None, options=None,; progress_bar=None, _safe_mode=True, verbose=False):; """"""; Solves for the dynamics of a system using the Bloch-Redfield master equation,; given an input Hamiltonian, Hermitian bath-coupling terms and their associated; spectrum functions, as well as possible Lindblad collapse operators. For time-independent systems, the Hamiltonian must be given as a Qobj,; whereas the bath-coupling terms (a_ops), must be written as a",MatchSource.WIKI,docs/4.7/modules/qutip/bloch_redfield.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/bloch_redfield.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:116,Deployability,Install,Installation,116,". qutip.continuous_variables — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.continuous_variables. Source code for qutip.continuous_variables; """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \langle a_m a_n \rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """"""; if rho is None:; # return array of operators; out = np.empty((len(basis), len(basis)), dtype=object); for i, op2 in enumerate(basis):; out[i, :] = [op1 * op2 for op1 in basis]; return out; else:; # return array of expectation values; return np.array([[expect(op1 * op2, rho); for op1 in basis] for op2 in basis]). [docs]def covariance_matrix(basis, rho, symmetrized=True):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the covariance; matrix:. .. math::. V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle. or, if of the optional argument `symmetrized=False`,.",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:450,Deployability,continuous,continuous,450,". qutip.continuous_variables — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.continuous_variables. Source code for qutip.continuous_variables; """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \langle a_m a_n \rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """"""; if rho is None:; # return array of operators; out = np.empty((len(basis), len(basis)), dtype=object); for i, op2 in enumerate(basis):; out[i, :] = [op1 * op2 for op1 in basis]; return out; else:; # return array of expectation values; return np.array([[expect(op1 * op2, rho); for op1 in basis] for op2 in basis]). [docs]def covariance_matrix(basis, rho, symmetrized=True):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the covariance; matrix:. .. math::. V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle. or, if of the optional argument `symmetrized=False`,.",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7641,Deployability,update,updated,7641,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:461,Modifiability,variab,variable,461,". qutip.continuous_variables — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.continuous_variables. Source code for qutip.continuous_variables; """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \langle a_m a_n \rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """"""; if rho is None:; # return array of operators; out = np.empty((len(basis), len(basis)), dtype=object); for i, op2 in enumerate(basis):; out[i, :] = [op1 * op2 for op1 in basis]; return out; else:; # return array of expectation values; return np.array([[expect(op1 * op2, rho); for op1 in basis] for op2 in basis]). [docs]def covariance_matrix(basis, rho, symmetrized=True):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the covariance; matrix:. .. math::. V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle. or, if of the optional argument `symmetrized=False`,.",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:178,Testability,Log,Log,178,". qutip.continuous_variables — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.continuous_variables. Source code for qutip.continuous_variables; """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \langle a_m a_n \rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """"""; if rho is None:; # return array of operators; out = np.empty((len(basis), len(basis)), dtype=object); for i, op2 in enumerate(basis):; out[i, :] = [op1 * op2 for op1 in basis]; return out; else:; # return array of expectation values; return np.array([[expect(op1 * op2, rho); for op1 in basis] for op2 in basis]). [docs]def covariance_matrix(basis, rho, symmetrized=True):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the covariance; matrix:. .. math::. V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle. or, if of the optional argument `symmetrized=False`,.",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:6534,Testability,log,logarithmic,6534,"in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------; cov_mat : ndarray; A 2-dimensional array of covariance values. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logne",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7104,Testability,log,logarithmic,7104,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7498,Testability,log,lognu,7498,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7510,Testability,log,log,7510,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7523,Testability,log,logneg,7523,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7539,Testability,log,lognu,7539,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:7554,Testability,log,logneg,7554,"lues. """"""; if R is not None:; if rho is None:; return np.array([[0.5 * np.real(R[i, j] + R[j, i]); for i in range(4)]; for j in range(4)], dtype=np.float64); else:; return np.array([[0.5 * np.real(expect(R[i, j] + R[j, i], rho)); for i in range(4)]; for j in range(4)], dtype=np.float64); elif a1 is not None and a2 is not None:; if rho is not None:; x1 = (a1 + a1.dag()) / g; p1 = -1j * (a1 - a1.dag()) / g; x2 = (a2 + a2.dag()) / g; p2 = -1j * (a2 - a2.dag()) / g; return covariance_matrix([x1, p1, x2, p2], rho); else:; raise ValueError(""Must give rho if using field operators "" +; ""(a1 and a2)""); else:; raise ValueError(""Must give either field operators (a1 and a2) "" +; ""or a precomputed correlation matrix (R)""). [docs]def logarithmic_negativity(V, g=np.sqrt(2)):; """"""; Calculates the logarithmic negativity given a symmetrized covariance; matrix, see :func:`qutip.continuous_variables.covariance_matrix`. Note that; the two-mode field state that is described by `V` must be Gaussian for this; function to applicable. Parameters; ----------. V : *2d array*; The covariance matrix. g : float; Scaling factor for `a = 0.5 * g * (x + iy)`, default `g = sqrt(2)`.; The value of `g` is related to the value of `hbar` in the commutation ; relation `[x, y] = i * hbar` via `hbar=2/g ** 2` giving the default ; value `hbar=1`. . Returns; -------. N : float ; The logarithmic negativity for the two-mode Gaussian state; that is described by the the Wigner covariance matrix V. """"""; A = 0.5 * V[0:2, 0:2] * g ** 2; B = 0.5 * V[2:4, 2:4] * g ** 2; C = 0.5 * V[0:2, 2:4] * g ** 2; sigma = np.linalg.det(A) + np.linalg.det(B) - 2 * np.linalg.det(C); nu_ = sigma / 2 - np.sqrt(sigma ** 2 - 4 * np.linalg.det(V)) / 2; if nu_ < 0.0:; return 0.0; nu = np.sqrt(nu_); lognu = -np.log(2 * nu); logneg = max(0, lognu); return logneg. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html:136,Usability,Guid,Guide,136,". qutip.continuous_variables — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.continuous_variables. Source code for qutip.continuous_variables; """"""; This module contains a collection functions for calculating continuous variable; quantities from fock-basis representation of the state of multi-mode fields.; """""". __all__ = ['correlation_matrix', 'covariance_matrix',; 'correlation_matrix_field', 'correlation_matrix_quadrature',; 'wigner_covariance_matrix', 'logarithmic_negativity']. from qutip.expect import expect; import numpy as np. [docs]def correlation_matrix(basis, rho=None):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the correlation; matrix:. .. math::. C_{mn} = \langle a_m a_n \rangle. Parameters; ----------; basis : list; List of operators that defines the basis for the correlation matrix.; rho : Qobj; Density matrix for which to calculate the correlation matrix. If; `rho` is `None`, then a matrix of correlation matrix operators is; returned instead of expectation values of those operators. Returns; -------; corr_mat : ndarray; A 2-dimensional *array* of correlation values or operators. """"""; if rho is None:; # return array of operators; out = np.empty((len(basis), len(basis)), dtype=object); for i, op2 in enumerate(basis):; out[i, :] = [op1 * op2 for op1 in basis]; return out; else:; # return array of expectation values; return np.array([[expect(op1 * op2, rho); for op1 in basis] for op2 in basis]). [docs]def covariance_matrix(basis, rho, symmetrized=True):; r""""""; Given a basis set of operators :math:`\{a\}_n`, calculate the covariance; matrix:. .. math::. V_{mn} = \frac{1}{2}\langle a_m a_n + a_n a_m \rangle -; \langle a_m \rangle \langle a_n\rangle. or, if of the optional argument `symmetrized=False`,.",MatchSource.WIKI,docs/4.7/modules/qutip/continuous_variables.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/continuous_variables.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:3131,Availability,error,errors,3131," : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], taulist, c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state de",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:5355,Availability,error,errors,5355,"rray_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : ndarray; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options); else:; if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, tlist, taulist,; c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options). [docs]def correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:7614,Availability,error,errors,7614,":`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initi",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:9740,Availability,error,errors,9740," used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options); else:; return _correlation_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:11823,Availability,error,errors,11823,"m regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * n). return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}. using the quan",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:13888,Availability,error,errors,13888,"e `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op], args=args).expect[0]. # calculate the correlation function G2 and normalize with n to obtain g2; G2 = correlation_3op_1t(H, state0, taulist, c_ops,; a_op.dag(), a_op.dag()*a_op, a_op,; solver=solver, args=args, options=options); g2 = G2 / (n[0] * n). return g2, G2. # spectrum. [docs]def spectrum(H, wlist, c_ops, a_op, b_op, solver=""es"", use_pinv=False):; r""""""; Calculate the spectrum of the correlation function; :math:`\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>`,; i.e., the Fourier transform of the correlation function:. .. math::. S(\omega) = \int_{-\infty}^{\infty}; \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>; e^{-i\omega",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:18495,Availability,error,errors,18495,"he two-operator two-time correlation function:. .. math::. \lim_{t \to \infty} \left<A(t+\tau)B(t)\right>. along one time axis (given steady-state initial conditions) using the; quantum regression theorem and the evolution solver indicated by the; `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate; :math:`\lim_{t \to \infty} \left<A(t)B(t+\tau)\right>` instead of; :math:`\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equation and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_vec : array; An array of correlation values for the times specified by `tlist`. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_ss() now legacy, please use correlation_2op_1t() with"" +; ""initial state as None"", FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_1t(H, None, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:20723,Availability,error,errors,20723," solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlation_2op_2t()"",; FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by th",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:22865,Availability,error,errors,22865,"s; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. .. note:: Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_1t(H, state0, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). [docs]def correlation_4op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op, c_op, d_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along two time axes using the quantum regression theorem and t",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:25306,Availability,error,errors,25306,"ial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use correlation_3op_2t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). # spectrum. [docs]def spectrum_ss(H, wlist, c_ops, a_op, b_op):; r""""""; Calculate the spectrum of the correlation function; :math:`\lim_{t \to \infty} \left<A(t+\tau)B(t)\right>`,; i.e., the Fourier transform of the correlation ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:35376,Availability,error,errors,35376,"on of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:107,Deployability,Install,Installation,107,". qutip.correlation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.correlation. Source code for qutip.correlation; __all__ = ['correlation_2op_1t', 'correlation_2op_2t', 'correlation_3op_1t',; 'correlation_3op_2t', 'coherence_function_g1',; 'coherence_function_g2', 'spectrum', 'spectrum_correlation_fft',; 'correlation_ss', 'correlation', 'correlation_4op_1t',; 'correlation_4op_2t', 'spectrum_ss', 'spectrum_pi']. from re import sub; from warnings import warn; import warnings; import types. import numpy as np; import scipy.fftpack. from qutip.eseries import esval, esspec; from qutip.essolve import ode2es; from qutip.expect import expect; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.operators import qeye; from qutip.qobj import Qobj, isket, issuper; from qutip.qobjevo import QobjEvo; from qutip.rhs_generate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by t",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:37132,Deployability,update,updated,37132," = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:15980,Energy Efficiency,power,power,15980,"is spectrum; is only defined for stationary statistics (uses steady state rho0). Parameters; ----------; H : :class:`qutip.qobj`; system Hamiltonian.; wlist : array_like; list of frequencies for :math:`\omega`.; c_ops : list; list of collapse operators.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; solver : str; choice of solver (`es` for exponential series and; `pi` for psuedo-inverse).; use_pinv : bool; For use with the `pi` solver: if `True` use numpy's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y, inverse=False):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'). if inverse:; F = N * scipy.fftpack.ifft(y); else:; F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # re-order frequencies from most negative to most positive (cent",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:16483,Energy Efficiency,power,power,16483,"py's pinv method,; otherwise use a generic solver. Returns; -------; spectrum : array; An array with spectrum :math:`S(\omega)` for the frequencies; specified in `wlist`. """""". if debug:; print(inspect.stack()[0][3]). if solver == ""es"":; return _spectrum_es(H, wlist, c_ops, a_op, b_op); elif solver == ""pi"":; return _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use es or pi)."" % solver). [docs]def spectrum_correlation_fft(tlist, y, inverse=False):; """"""; Calculate the power spectrum corresponding to a two-time correlation; function using FFT. Parameters; ----------; tlist : array_like; list/array of times :math:`t` which the correlation function is given.; y : array_like; list/array of correlations corresponding to time delays :math:`t`.; inverse: boolean; boolean parameter for using a positive exponent in the Fourier Transform instead. Default is False. Returns; -------; w, S : tuple; Returns an array of angular frequencies 'w' and the corresponding; two-sided power spectrum 'S(w)'. """""". if debug:; print(inspect.stack()[0][3]); tlist = np.asarray(tlist); N = tlist.shape[0]; dt = tlist[1] - tlist[0]; if not np.allclose(np.diff(tlist), dt*np.ones(N-1,dtype=float)):; raise Exception('tlist must be equally spaced for FFT.'). if inverse:; F = N * scipy.fftpack.ifft(y); else:; F = scipy.fftpack.fft(y). # calculate the frequencies for the components in F; f = scipy.fftpack.fftfreq(N, dt). # re-order frequencies from most negative to most positive (centre on 0); idx = np.array([], dtype = 'int'); idx = np.append(idx, np.where(f < 0.0)); idx = np.append(idx, np.where(f >= 0.0)). return 2 * np.pi * f[idx], 2 * dt * np.real(F[idx]). # -----------------------------------------------------------------------------; # LEGACY API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_ss(H, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=Fa",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:2090,Integrability,depend,dependent,2090,"ate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:2552,Integrability,depend,dependent,2552,"IC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str {'me', 'mc', 'es'}; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; Solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:4066,Integrability,depend,dependent,4066,"vely; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : ndarray; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, [0], taulist, c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str; choice of so",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:4795,Integrability,depend,dependent,4795,"ulate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; reverse : bool {False, True}; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : ndarray; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:6703,Integrability,depend,dependent,6703,"nces; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options); else:; if reverse:; A_op = a_op; B_op = b_op; C_op = 1; else:; A_op = 1; B_op = a_op; C_op = b_op. return _correlation_2t(H, state0, tlist, taulist,; c_ops, A_op, B_op, C_op,; solver=solver, args=args, options=options). [docs]def correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; ----",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:7163,Integrability,depend,dependent,7163,"ptions). [docs]def correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):;",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:8562,Integrability,depend,dependent,8562,"ult,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). return _correlation_2t(H, state0, [0], taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options)[0]. [docs]def correlation_3op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the three-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; so",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:9289,Integrability,depend,dependent,9289,"es using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; b_op : Qobj; operator B.; c_op : Qobj; operator C.; solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solv",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:10985,Integrability,depend,dependent,10985," If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". if debug:; print(inspect.stack()[0][3]). if tlist is None:; return correlation_3op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options); else:; return _correlation_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; solver=solver, args=args, options=options). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order coheren",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:11447,Integrability,depend,dependent,11447,"s). # high level correlation. [docs]def coherence_function_g1(H, state0, taulist, c_ops, a_op, solver=""me"",; args={}, options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized first-order quantum coherence function:. .. math::. g^{(1)}(\tau) =; \frac{\langle A^\dagger(\tau)A(0)\rangle}; {\sqrt{\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g1, G1 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:12988,Integrability,depend,dependent,12988,"function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op],; options=options).expect[0]. # calculate the correlation function G1 and normalize with n to obtain g1; G1 = correlation_2op_1t(H, state0, taulist, c_ops, a_op.dag(), a_op,; solver=solver, args=args, options=options); g1 = G1 / np.sqrt(n[0] * n). return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:13450,Integrability,depend,dependent,13450,". return g1, G1. [docs]def coherence_function_g2(H, state0, taulist, c_ops, a_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the normalized second-order quantum coherence function:. .. math::. g^{(2)}(\tau) =; \frac{\langle A^\dagger(0)A^\dagger(\tau)A(\tau)A(0)\rangle}; {\langle A^\dagger(\tau)A(\tau)\rangle; \langle A^\dagger(0)A(0)\rangle}. using the quantum regression theorem and the evolution solver indicated by; the `solver` parameter. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`.; a_op : Qobj; operator A.; args : dict; Dictionary of arguments to be passed to solver.; solver : str; choice of solver (`me` for master-equation and; `es` for exponential series).; options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; g2, G2 : tuple; The normalized and unnormalized second-order coherence function. """""". # first calculate the photon number; if state0 is None:; state0 = steadystate(H, c_ops); n = np.array([expect(state0, a_op.dag() * a_op)]); else:; n = mesolve(H, state0, taulist, c_ops, [a_op.dag() * a_op], args=args).expect[0]. # calculate the correlation function G2 and normalize with n to obtain g2; G2 = correlation_3op_1t(H, state0, taulist, c_ops,; a_op.dag(), a_op.dag()*a_op, a_o",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:19449,Integrability,depend,dependent,19449,"100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_vec : array; An array of correlation values for the times specified by `tlist`. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_ss() now legacy, please use correlation_2op_1t() with"" +; ""initial state as None"", FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_1t(H, None, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equa",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:20180,Integrability,depend,dependent,20180,"te the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. reverse : *bool*; If `True`, calculate :math:`\left<A(t)B(t+\tau)\right>` instead of; :math:`\left<A(t+\tau)B(t)\right>`. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlat",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:21934,Integrability,depend,dependent,21934,"dex) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation() now legacy, please use correlation_2op_2t()"",; FutureWarning). if debug:; print(inspect.stack()[0][3]). return correlation_2op_2t(H, state0, tlist, taulist, c_ops, a_op, b_op,; solver=solver, reverse=reverse, args=args,; options=options). [docs]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:22394,Integrability,depend,dependent,22394,"]def correlation_4op_1t(H, state0, taulist, c_ops, a_op, b_op, c_op, d_op,; solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along one time axis using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------; H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; rho0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers.; taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`.; c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------; corr_vec : array; An array of correlation values for the times specified by `taulist`. References; ----------; See, Gardiner, Quantum Noise, Section 5.2. .. note:: Deprecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:24112,Integrability,depend,dependent,24112,"eprecated in QuTiP 3.1; Use correlation_3op_1t() instead. """""". warn(""correlation_4op_1t() now legacy, please use correlation_3op_1t()"",; FutureWarning); warn(""the reverse argument has been removed as it did not contain any"" +; ""new physical information"", DeprecationWarning). if debug:; print(inspect.stack()[0][3]). return correlation_3op_1t(H, state0, taulist, c_ops,; a_op, b_op * c_op, d_op,; solver=solver, args=args, options=options). [docs]def correlation_4op_2t(H, state0, tlist, taulist, c_ops,; a_op, b_op, c_op, d_op, solver=""me"", args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the four-operator two-time correlation function:; :math:`\left<A(t)B(t+\tau)C(t+\tau)D(t)\right>`; along two time axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:24835,Integrability,depend,dependent,24835," axes using the quantum regression theorem and the; evolution solver indicated by the `solver` parameter. Note: it is not possibly to calculate a physically meaningful correlation; of this form where :math:`\tau<0`. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`. rho0 : Qobj; Initial state density matrix :math:`\rho_0` or state vector; :math:`\psi_0`. If 'state0' is 'None', then the steady state will; be used as the initial state. The 'steady-state' is only implemented; for the `me` and `es` solvers. tlist : array_like; list of times for :math:`t`. tlist must be positive and contain the; element `0`. When taking steady-steady correlations only one tlist; value is necessary, i.e. when :math:`t \rightarrow \infty`; here; tlist is automatically set, ignoring user input. taulist : array_like; list of times for :math:`\tau`. taulist must be positive and contain; the element `0`. c_ops : list; list of collapse operators, may be time-dependent for solver choice of; `me` or `mc`. a_op : Qobj; operator A. b_op : Qobj; operator B. c_op : Qobj; operator C. d_op : Qobj; operator D. solver : str; choice of solver (`me` for master-equation, `mc` for Monte Carlo, and; `es` for exponential series). options : Options; solver options class. `ntraj` is taken as a two-element list because; the `mc` correlator calls `mcsolve()` recursively; by default,; `ntraj=[20, 100]`. `mc_corr_eps` prevents divide-by-zero errors in; the `mc` correlator; by default, `mc_corr_eps=1e-10`. Returns; -------. corr_mat : array; An 2-dimensional array (matrix) of correlation values for the times; specified by `tlist` (first index) and `taulist` (second index). If; `tlist` is `None`, then a 1-dimensional array of correlation values; is returned instead. References; ----------. See, Gardiner, Quantum Noise, Section 5.2. """""". warn(""correlation_4op_2t() now legacy, please use correlation_3op_2t()"",; FutureWarning); warn(""the reverse argument has be",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:1255,Modifiability,config,config,1255,"uTiP: Quantum Toolbox in Python. »; Module code »; qutip.correlation. Source code for qutip.correlation; __all__ = ['correlation_2op_1t', 'correlation_2op_2t', 'correlation_3op_1t',; 'correlation_3op_2t', 'coherence_function_g1',; 'coherence_function_g2', 'spectrum', 'spectrum_correlation_fft',; 'correlation_ss', 'correlation', 'correlation_4op_1t',; 'correlation_4op_2t', 'spectrum_ss', 'spectrum_pi']. from re import sub; from warnings import warn; import warnings; import types. import numpy as np; import scipy.fftpack. from qutip.eseries import esval, esspec; from qutip.essolve import ode2es; from qutip.expect import expect; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.operators import qeye; from qutip.qobj import Qobj, isket, issuper; from qutip.qobjevo import QobjEvo; from qutip.rhs_generate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by the `solver` parameter. Parameters; ----------. H : Qobj; system Hamiltonian, may be time-dependent for solver choice of `me` or; `mc`.; state0 : Qobj; Initial state density matrix :math:`\rho(t_0)` or state vector; :math:`\psi(t_0)`. If 'state0' is 'No",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:29253,Modifiability,config,config,29253,", c_ops, a_op, b_op,; solver=""pi"", use_pinv=use_pinv). # -----------------------------------------------------------------------------; # PRIVATE SOLVER METHODS; # -----------------------------------------------------------------------------. # master 2t correlation solver. def _correlation_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={}, options=Options()):; """"""; Internal function for calling solvers in order to calculate the; three-operator two-time correlation function:; <A(t)B(t+tau)C(t)>; """""". # Note: the current form of the correlator is sufficient for all possible; # two-time correlations (incuding those with 2ops vs 3). Ex: to compute a; # correlation of the form <A(t+tau)B(t)>: a_op = identity, b_op = A,; # and c_op = B. if debug:; print(inspect.stack()[0][3]). if min(tlist) != 0:; raise TypeError(""tlist must be positive and contain the element 0.""); if min(taulist) != 0:; raise TypeError(""taulist must be positive and contain the element 0.""). if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(); H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). if solver == ""me"":; return _correlation_me_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""mc"":; return _correlation_mc_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadysta",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:29291,Modifiability,config,config,29291,"ver=""pi"", use_pinv=use_pinv). # -----------------------------------------------------------------------------; # PRIVATE SOLVER METHODS; # -----------------------------------------------------------------------------. # master 2t correlation solver. def _correlation_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; solver=""me"", args={}, options=Options()):; """"""; Internal function for calling solvers in order to calculate the; three-operator two-time correlation function:; <A(t)B(t+tau)C(t)>; """""". # Note: the current form of the correlator is sufficient for all possible; # two-time correlations (incuding those with 2ops vs 3). Ex: to compute a; # correlation of the form <A(t+tau)B(t)>: a_op = identity, b_op = A,; # and c_op = B. if debug:; print(inspect.stack()[0][3]). if min(tlist) != 0:; raise TypeError(""tlist must be positive and contain the element 0.""); if min(taulist) != 0:; raise TypeError(""taulist must be positive and contain the element 0.""). if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(); H, c_ops, args = _td_wrap_array_str(H, c_ops, args, tlist). if solver == ""me"":; return _correlation_me_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""mc"":; return _correlation_mc_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:30575,Modifiability,config,config,30575,"tlist, taulist,; c_ops, a_op, b_op, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; corr_mat[t_idx, :] = mesolve(; H, c_op * rho * a_op, taulist + tlist[t_idx], c_ops,; [b_op], args=args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.si",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:30613,Modifiability,config,config,30613,"p, c_op,; args=args, options=options); elif solver == ""es"":; return _correlation_es_2t(H, state0, tlist, taulist,; c_ops, a_op, b_op, c_op); else:; raise ValueError(""Unrecognized choice of solver"" +; ""%s (use me, mc, or es)."" % solver). # master equation solvers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; corr_mat[t_idx, :] = mesolve(; H, c_op * rho * a_op, taulist + tlist[t_idx], c_ops,; [b_op], args=args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex). # T",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:30858,Modifiability,config,config,30858,"vers. def _correlation_me_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; corr_mat[t_idx, :] = mesolve(; H, c_op * rho * a_op, taulist + tlist[t_idx], c_ops,; [b_op], args=args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex). # The user-facing eseries and ode2es are deprecated from QuTiP 4.6, pending; # removal in QuTiP 5.0, however they are being maintained for internal use; # in correlation, so should not raise warnings to the user not matter what; # their settings.; with warnings.",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:30896,Modifiability,config,config,30896,"_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a master equation solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). rho_t = mesolve(H, rho0, tlist, c_ops, [],; args=args, options=options).states; corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). for t_idx, rho in enumerate(rho_t):; corr_mat[t_idx, :] = mesolve(; H, c_op * rho * a_op, taulist + tlist[t_idx], c_ops,; [b_op], args=args, options=options; ).expect[0]. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # exponential series solvers. def _correlation_es_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using an exponential series solver.; """""". # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; rho0 = steadystate(H, c_ops); tlist = [0]; elif isket(state0):; rho0 = ket2dm(state0); else:; rho0 = state0. if debug:; print(inspect.stack()[0][3]). # contruct the Liouvillian; L = liouvillian(H, c_ops). corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex). # The user-facing eseries and ode2es are deprecated from QuTiP 4.6, pending; # removal in QuTiP 5.0, however they are being maintained for internal use; # in correlation, so should not raise warnings to the user not matter what; # their settings.; with warnings.catch_warnings():; warni",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:34276,Modifiability,config,config,34276,"ist). # Monte Carlo solvers. def _correlation_mc_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a Monte Carlo solver.; """""". if not c_ops:; raise TypeError(""If no collapse operators are required, use the `me`"" +; ""or `es` solvers""). # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); tlist = np.asarray(tlist); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:34314,Modifiability,config,config,34314,"_correlation_mc_2t(H, state0, tlist, taulist, c_ops, a_op, b_op, c_op,; args={}, options=Options()):; """"""; Internal function for calculating the three-operator two-time; correlation function:; <A(t)B(t+tau)C(t)>; using a Monte Carlo solver.; """""". if not c_ops:; raise TypeError(""If no collapse operators are required, use the `me`"" +; ""or `es` solvers""). # the solvers only work for positive time differences and the correlators; # require positive tau; if state0 is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); tlist = np.asarray(tlist); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; #",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:34731,Modifiability,evolve,evolve,34731," is None:; raise NotImplementedError(""steady state not implemented for "" +; ""mc solver, please use `es` or `me`""); elif not isket(state0):; raise TypeError(""state0 must be a state vector.""); psi0 = state0. if debug:; print(inspect.stack()[0][3]). psi_t_mat = mcsolve(; H, psi0, tlist, c_ops, [],; args=args, ntraj=options.ntraj[0], options=options, progress_bar=None; ).states. corr_mat = np.zeros([np.size(tlist), np.size(taulist)], dtype=complex); tlist = np.asarray(tlist); taulist = np.asarray(taulist); if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). # calculation of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; ",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:35526,Modifiability,evolve,evolve,35526,"sinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.tr",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:36066,Modifiability,config,config,36066,"/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. © Copyright 201",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:36104,Modifiability,config,config,36104," # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.; """""". L = H if issuper(H) else liouvillian(H, c_ops). tr_mat = tensor([qeye(n) for n in L.dims[0][0]]); N = np.prod(L.dims[0][0]). A = L.full(); b = spre(b_op).full(); a = spre(a_op).full(). tr_vec = np.transpose(mat2vec(tr_mat.full())). rho_ss = steadystate(L); rho = np.transpose(mat2vec(rho_ss.full())). I = np.identity(N * N); P = np.kron(np.transpose(rho), tr_vec); Q = I - P. spectrum = np.zeros(len(wlist)). for idx, w in enumerate(wlist):; if use_pinv:; MMR = np.linalg.pinv(-1.0j * w * I + A); else:; MMR = np.dot(Q, np.linalg.solve(-1.0j * w * I + A, Q)). s = np.dot(tr_vec,; np.dot(a, np.dot(MMR, np.dot(b, np.transpose(rho))))); spectrum[idx] = -2 * np.real(s[0, 0]). return spectrum. © Copyright 2011 to 2021 inclusive, QuT",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:35336,Performance,load,loaded,35336,"on of <A(t)B(t+tau)C(t)> from only knowledge of psi0 requires; # averaging over both t and tau; for t_idx in range(np.size(tlist)):; for trial_idx in range(options.ntraj[0]):; if isinstance(a_op, Qobj) and isinstance(c_op, Qobj):; if a_op.dag() == c_op:; # A shortcut here, requires only 1/4 the trials; chi_0 = (options.mc_corr_eps + c_op) * \; psi_t_mat[trial_idx, t_idx]. # evolve these states and calculate expectation value of B; c_tau = chi_0.norm()**2 * mcsolve(; H, chi_0/chi_0.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]. # final correlation vector computed by combining the; # averages; corr_mat[t_idx, :] += c_tau/options.ntraj[1]; else:; # otherwise, need four trial wavefunctions; # (Ad+C)*psi_t, (Ad+iC)*psi_t, (Ad-C)*psi_t, (Ad-iC)*psi_t; if isinstance(a_op, Qobj):; a_op_dag = a_op.dag(); else:; # assume this is a number, ex. i.e. a_op = 1; # if this is not correct, the over-loaded addition; # operation will raise errors; a_op_dag = a_op; chi_0 = [(options.mc_corr_eps + a_op_dag +; np.exp(1j*x*np.pi/2)*c_op) *; psi_t_mat[trial_idx, t_idx]; for x in range(4)]. # evolve these states and calculate expectation value of B; c_tau = [; chi.norm()**2 * mcsolve(; H, chi/chi.norm(), taulist + tlist[t_idx], c_ops,; [b_op],; args=args, ntraj=options.ntraj[1], options=options,; progress_bar=None; ).expect[0]; for chi in chi_0; ]. # final correlation vector computed by combining the averages; corr_mat_add = np.asarray(; 1.0 / (4*options.ntraj[0]) *; (c_tau[0] - c_tau[2] - 1j*c_tau[1] + 1j*c_tau[3]),; dtype=corr_mat.dtype; ); corr_mat[t_idx, :] += corr_mat_add. if t_idx == 1:; options.rhs_reuse = True. if config.tdname:; _cython_build_cleanup(config.tdname); rhs_clear(). return corr_mat. # pseudo-inverse solvers; def _spectrum_pi(H, wlist, c_ops, a_op, b_op, use_pinv=False):; r""""""; Internal function for calculating the spectrum of the correlation function; :math:`\left<A(\tau)B(0)\right>`.",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:169,Testability,Log,Log,169,". qutip.correlation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.correlation. Source code for qutip.correlation; __all__ = ['correlation_2op_1t', 'correlation_2op_2t', 'correlation_3op_1t',; 'correlation_3op_2t', 'coherence_function_g1',; 'coherence_function_g2', 'spectrum', 'spectrum_correlation_fft',; 'correlation_ss', 'correlation', 'correlation_4op_1t',; 'correlation_4op_2t', 'spectrum_ss', 'spectrum_pi']. from re import sub; from warnings import warn; import warnings; import types. import numpy as np; import scipy.fftpack. from qutip.eseries import esval, esspec; from qutip.essolve import ode2es; from qutip.expect import expect; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.operators import qeye; from qutip.qobj import Qobj, isket, issuper; from qutip.qobjevo import QobjEvo; from qutip.rhs_generate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by t",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/correlation.html:127,Usability,Guid,Guide,127,". qutip.correlation — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.correlation. Source code for qutip.correlation; __all__ = ['correlation_2op_1t', 'correlation_2op_2t', 'correlation_3op_1t',; 'correlation_3op_2t', 'coherence_function_g1',; 'coherence_function_g2', 'spectrum', 'spectrum_correlation_fft',; 'correlation_ss', 'correlation', 'correlation_4op_1t',; 'correlation_4op_2t', 'spectrum_ss', 'spectrum_pi']. from re import sub; from warnings import warn; import warnings; import types. import numpy as np; import scipy.fftpack. from qutip.eseries import esval, esspec; from qutip.essolve import ode2es; from qutip.expect import expect; from qutip.mesolve import mesolve; from qutip.mcsolve import mcsolve; from qutip.operators import qeye; from qutip.qobj import Qobj, isket, issuper; from qutip.qobjevo import QobjEvo; from qutip.rhs_generate import rhs_clear, _td_wrap_array_str; from qutip.cy.utilities import _cython_build_cleanup; from qutip.settings import debug; from qutip.solver import Options, config; from qutip.steadystate import steadystate; from qutip.states import ket2dm; from qutip.superoperator import liouvillian, spre, mat2vec; from qutip.tensor import tensor. if debug:; import inspect. # -----------------------------------------------------------------------------; # PUBLIC API; # -----------------------------------------------------------------------------. # low level correlation. [docs]def correlation_2op_1t(H, state0, taulist, c_ops, a_op, b_op,; solver=""me"", reverse=False, args={},; options=Options(ntraj=[20, 100])):; r""""""; Calculate the two-operator two-time correlation function:; :math:`\left<A(t+\tau)B(t)\right>`; along one time axis using the quantum regression theorem and the evolution; solver indicated by t",MatchSource.WIKI,docs/4.7/modules/qutip/correlation.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/correlation.html
https://qutip.org/docs/4.7/modules/qutip/dimensions.html:490,Availability,avail,available,490,". qutip.dimensions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.dimensions. Source code for qutip.dimensions; """"""; Internal use module for manipulating dims specifications.; """""". __all__ = [] # Everything should be explicitly imported, not made available; # by default. import numpy as np; from operator import getitem; from functools import partial. [docs]def is_scalar(dims):; """"""; Returns True if a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_square; ); ):; return 'super'. return 'other'. [docs]def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). [docs]def deep_remove(l, *what):; """"""Removes scalars from all levels of a nested list. Given a list containing a mix of scalars and li",MatchSource.WIKI,docs/4.7/modules/qutip/dimensions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/dimensions.html
https://qutip.org/docs/4.7/modules/qutip/dimensions.html:1648,Availability,down,down,1648," a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_square; ); ):; return 'super'. return 'other'. [docs]def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). [docs]def deep_remove(l, *what):; """"""Removes scalars from all levels of a nested list. Given a list containing a mix of scalars and lists,; returns a list of the same structure, but where one or; more scalars have been removed. Examples; --------. >>> deep_remove([[[[0, 1, 2]], [3, 4], [5], [6, 7]]], 0, 5) # doctest: +SKIP; [[[[1, 2]], [3, 4], [], [6, 7]]]. """"""; if isinstance(l, list):; # Make a shallow copy at this level.; l = l[:]; for to_remove in what:; if to_remove in l:; l.remove(to_remove); else:; l = list(map(lambda elem: deep_remove(elem, to_remove), l)); return l. [docs]def unflatten(l, idxs):; """"""Unflattens a list by a given structure. Given a list of scalars and a deep list of indices; as produced by `flatten`, returns an ""unflattened""; form of the list. T",MatchSource.WIKI,docs/4.7/modules/qutip/dimensions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/dimensions.html
https://qutip.org/docs/4.7/modules/qutip/dimensions.html:106,Deployability,Install,Installation,106,". qutip.dimensions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.dimensions. Source code for qutip.dimensions; """"""; Internal use module for manipulating dims specifications.; """""". __all__ = [] # Everything should be explicitly imported, not made available; # by default. import numpy as np; from operator import getitem; from functools import partial. [docs]def is_scalar(dims):; """"""; Returns True if a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_square; ); ):; return 'super'. return 'other'. [docs]def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). [docs]def deep_remove(l, *what):; """"""Removes scalars from all levels of a nested list. Given a list containing a mix of scalars and li",MatchSource.WIKI,docs/4.7/modules/qutip/dimensions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/dimensions.html
https://qutip.org/docs/4.7/modules/qutip/dimensions.html:9272,Deployability,update,updated,9272,"forming the result to swap; # input and output indices of vectorized matrices, then flattening; # the result. We'll then rebuild indices using this permutation. if dims_type in ('operator-ket', 'super'):; # Swap the input and output spaces of the right part of; # perm.; perm[1] = list(reversed(perm[1])). if dims_type in ('operator-bra', 'super'):; # Ditto, but for the left indices.; perm[0] = list(reversed(perm[0])). return flatten(perm). [docs]def dims_to_tensor_shape(dims):; """"""; Given the dims of a Qobj instance, returns the shape of the; corresponding tensor. This helps, for instance, resolve the; column-stacking convention for superoperators. Parameters; ----------. dims : list; Dimensions specification for a Qobj. Returns; -------. tensor_shape : tuple; NumPy shape of the corresponding tensor.; """""". perm = dims_to_tensor_perm(dims); dims = flatten(dims). return tuple(map(partial(getitem, dims), perm)). [docs]def dims_idxs_to_tensor_idxs(dims, indices):; """"""; Given the dims of a Qobj instance, and some indices into; dims, returns the corresponding tensor indices. This helps; resolve, for instance, that column-stacking for superoperators,; oper-ket and oper-bra implies that the input and output tensor; indices are reversed from their order in dims. Parameters; ----------. dims : list; Dimensions specification for a Qobj. indices : int, list or tuple; Indices to convert to tensor indices. Can be specified; as a single index, or as a collection of indices.; In the latter case, this can be nested arbitrarily; deep. For instance, [0, [0, (2, 3)]]. Returns; -------. tens_indices : int, list or tuple; Container of the same structure as indices containing; the tensor indices for each element of indices.; """""". perm = dims_to_tensor_perm(dims); return deep_map(partial(getitem, perm), indices). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/dimensions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/dimensions.html
https://qutip.org/docs/4.7/modules/qutip/dimensions.html:168,Testability,Log,Log,168,". qutip.dimensions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.dimensions. Source code for qutip.dimensions; """"""; Internal use module for manipulating dims specifications.; """""". __all__ = [] # Everything should be explicitly imported, not made available; # by default. import numpy as np; from operator import getitem; from functools import partial. [docs]def is_scalar(dims):; """"""; Returns True if a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_square; ); ):; return 'super'. return 'other'. [docs]def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). [docs]def deep_remove(l, *what):; """"""Removes scalars from all levels of a nested list. Given a list containing a mix of scalars and li",MatchSource.WIKI,docs/4.7/modules/qutip/dimensions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/dimensions.html
https://qutip.org/docs/4.7/modules/qutip/dimensions.html:126,Usability,Guid,Guide,126,". qutip.dimensions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.dimensions. Source code for qutip.dimensions; """"""; Internal use module for manipulating dims specifications.; """""". __all__ = [] # Everything should be explicitly imported, not made available; # by default. import numpy as np; from operator import getitem; from functools import partial. [docs]def is_scalar(dims):; """"""; Returns True if a dims specification is effectively; a scalar (has dimension 1).; """"""; return np.prod(flatten(dims)) == 1. def is_vector(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], (int, np.integer)); ). def is_vectorized_oper(dims):; return (; isinstance(dims, list) and; isinstance(dims[0], list); ). def type_from_dims(dims, enforce_square=False):; bra_like, ket_like = map(is_scalar, dims). if bra_like:; if is_vector(dims[1]):; return 'bra'; elif is_vectorized_oper(dims[1]):; return 'operator-bra'. if ket_like:; if is_vector(dims[0]):; return 'ket'; elif is_vectorized_oper(dims[0]):; return 'operator-ket'. elif is_vector(dims[0]) and (dims[0] == dims[1] or not enforce_square):; return 'oper'. elif (; is_vectorized_oper(dims[0]) and; (; (; dims[0] == dims[1] and; dims[0][0] == dims[1][0]; ) or not enforce_square; ); ):; return 'super'. return 'other'. [docs]def flatten(l):; """"""Flattens a list of lists to the first level. Given a list containing a mix of scalars and lists,; flattens down to a list of the scalars within the original; list. Examples; --------. >>> flatten([[[0], 1], 2]) # doctest: +SKIP; [0, 1, 2]. """"""; if not isinstance(l, list):; return [l]; else:; return sum(map(flatten, l), []). [docs]def deep_remove(l, *what):; """"""Removes scalars from all levels of a nested list. Given a list containing a mix of scalars and li",MatchSource.WIKI,docs/4.7/modules/qutip/dimensions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/dimensions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:109,Deployability,Install,Installation,109,". qutip.distributions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.distributions. Source code for qutip.distributions; """"""; This module provides classes and functions for working with spatial; distributions, such as Wigner distributions, etc. .. note::. Experimental. """""". __all__ = ['Distribution', 'WignerDistribution', 'QDistribution',; 'TwoModeQuadratureCorrelation',; 'HarmonicOscillatorWaveFunction',; 'HarmonicOscillatorProbabilityFunction']. import numpy as np; from numpy import pi, exp, sqrt. from scipy.special import hermite, factorial. from qutip.qobj import isket; from qutip.wigner import wigner, qfunc; from qutip.states import ket2dm, state_number_index. try:; import matplotlib as mpl; import matplotlib.pyplot as plt; from mpl_toolkits.mplot3d import Axes3D; except:; pass. [docs]class Distribution:; """"""A class for representation spatial distribution functions. The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far). It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters; ----------; data : array_like; Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs : list; List of arrays that spans the space for each coordinate.; xlabels : list; List of labels for each coordinate. """""". def __init__(self, data=None, xvecs=[], xlabels=[]):; self.data = data; self.xvecs = xvecs; self.xlabels = xlabels. [docs] def visualize(self, fig=None, ax=None, figsize=(8, 6),; colorbar=True, cmap=None, styl",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:6392,Deployability,update,update,6392,"bes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:6409,Deployability,update,update,6409,"distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:6782,Deployability,update,update,6782,"int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. f",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:6799,Deployability,update,update,6799," (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. for n1 in range(N):",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:7244,Deployability,update,update,7244,"[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. for n1 in range(N):; kn1 = exp(-1j * self.theta1 * n1) / \; sqrt(sqrt(pi) * 2 ** n1 * factorial(n1)) * \; exp(-X1 ** 2 / 2.0) * np.polyval(hermite(n1), X1). for n2 in range(N):; kn2 = exp(-1j * self.theta2 * n2) / \; sqrt(sqrt(pi) * 2 ** n2 * factorial(n2)) * \; exp(-X2 ** 2 / 2.0) * np.polyval(hermite(n2), X2); i = state_number_index([N, N], [n1, n2]); p += kn1 * kn2 * psi.data[i, 0]. self.data = abs(p) ** 2. [docs] def update_rho(self, rho):; """"""; calculate ",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:7270,Deployability,update,update,7270,"', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = qfunc(rho, self.xvecs[0], self.xvecs[1]). [docs]class TwoModeQuadratureCorrelation(Distribution):. def __init__(self, state=None, theta1=0.0, theta2=0.0,; extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$X_1(\theta_1)$', r'$X_2(\theta_2)$']. self.theta1 = theta1; self.theta2 = theta2. self.update(state). [docs] def update(self, state):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction or density matrix; """"""; if isket(state):; self.update_psi(state); else:; self.update_rho(state). [docs] def update_psi(self, psi):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode wavefunction; """""". X1, X2 = np.meshgrid(self.xvecs[0], self.xvecs[1]). p = np.zeros((len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex); N = psi.dims[0][0]. for n1 in range(N):; kn1 = exp(-1j * self.theta1 * n1) / \; sqrt(sqrt(pi) * 2 ** n1 * factorial(n1)) * \; exp(-X1 ** 2 / 2.0) * np.polyval(hermite(n1), X1). for n2 in range(N):; kn2 = exp(-1j * self.theta2 * n2) / \; sqrt(sqrt(pi) * 2 ** n2 * factorial(n2)) * \; exp(-X2 ** 2 / 2.0) * np.polyval(hermite(n2), X2); i = state_number_index([N, N], [n1, n2]); p += kn1 * kn2 * psi.data[i, 0]. self.data = abs(p) ** 2. [docs] def update_rho(self, rho):; """"""; calculate probability distribution for quadrature measurement; outcomes given a two-mode density matrix; """""". X",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:9534,Deployability,update,update,9534,"(self.xvecs[1])), dtype=complex); M2 = np.zeros(; (N, N, len(self.xvecs[0]), len(self.xvecs[1])), dtype=complex). for m in range(N):; for n in range(N):; M1[m, n] = exp(-1j * self.theta1 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X1 ** 2) * np.polyval(; hermite(m), X1) * np.polyval(hermite(n), X1); M2[m, n] = exp(-1j * self.theta2 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X2 ** 2) * np.polyval(; hermite(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) *",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:9558,Deployability,update,update,9558,"f.xvecs[0]), len(self.xvecs[1])), dtype=complex). for m in range(N):; for n in range(N):; M1[m, n] = exp(-1j * self.theta1 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X1 ** 2) * np.polyval(; hermite(m), X1) * np.polyval(hermite(n), X1); M2[m, n] = exp(-1j * self.theta2 * (m - n)) / \; sqrt(pi * 2 ** (m + n) * factorial(n) * factorial(m)) * \; exp(-X2 ** 2) * np.polyval(; hermite(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), s",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:10186,Deployability,update,update,10186,"e(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:10210,Deployability,update,update,10210,"e(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:10919,Deployability,update,updated,10919,"e(m), X2) * np.polyval(hermite(n), X2). for n1 in range(N):; for n2 in range(N):; i = state_number_index([N, N], [n1, n2]); for p1 in range(N):; for p2 in range(N):; j = state_number_index([N, N], [p1, p2]); p += M1[n1, p1] * M2[n2, p2] * rho.data[i, j]. self.data = p. [docs]class HarmonicOscillatorWaveFunction(Distribution):. def __init__(self, psi=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if psi:; self.update(psi). [docs] def update(self, psi):; """"""; Calculate the wavefunction for the given state of an harmonic; oscillator; """""". self.data = np.zeros(len(self.xvecs[0]), dtype=complex); N = psi.shape[0]. for n in range(N):; k = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += k * psi.data[n, 0]. [docs]class HarmonicOscillatorProbabilityFunction(Distribution):. def __init__(self, rho=None, omega=1.0, extent=[-5, 5], steps=250):. self.xvecs = [np.linspace(extent[0], extent[1], steps)]; self.xlabels = [r'$x$']; self.omega = omega. if rho:; self.update(rho). [docs] def update(self, rho):; """"""; Calculate the probability function for the given state of an harmonic; oscillator (as density matrix); """""". if isket(rho):; rho = ket2dm(rho). self.data = np.zeros(len(self.xvecs[0]), dtype=complex); M, N = rho.shape. for m in range(M):; k_m = pow(self.omega / pi, 0.25) / \; sqrt(2 ** m * factorial(m)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(m), self.xvecs[0]). for n in range(N):; k_n = pow(self.omega / pi, 0.25) / \; sqrt(2 ** n * factorial(n)) * \; exp(-self.xvecs[0] ** 2 / 2.0) * \; np.polyval(hermite(n), self.xvecs[0]). self.data += np.conjugate(k_n) * k_m * rho.data[m, n]. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:5161,Energy Efficiency,reduce,reduced,5161,"igsize); ax = Axes3D(fig, azim=-62, elev=25). if cmap is None:; cmap = mpl.cm.get_cmap('RdBu'). lim = abs(self.data).max(). X, Y = np.meshgrid(self.xvecs[0], self.xvecs[1]); s = ax.plot_surface(X, Y, self.data,; norm=mpl.colors.Normalize(-lim, lim),; rstride=5, cstride=5, cmap=cmap, lw=0.1). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(self.xlabels[1], fontsize=12). if colorbar:; cb = fig.colorbar(s, ax=ax, shrink=0.5). return fig, ax. def visualize_1d(self, fig=None, ax=None, figsize=(8, 6),; show_xlabel=True, show_ylabel=True):. if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). p = ax.plot(self.xvecs[0], self.data). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(""Marginal distribution"", fontsize=12). return fig, ax. [docs] def marginal(self, dim=0):; """"""; Calculate the marginal distribution function along the dimension; `dim`. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns; -------. d : Distributions; A new instances of Distribution that describes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self,",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:5721,Energy Efficiency,reduce,reduced-dimensionality,5721,"=True, show_ylabel=True):. if not fig and not ax:; fig, ax = plt.subplots(1, 1, figsize=figsize). p = ax.plot(self.xvecs[0], self.data). if show_xlabel:; ax.set_xlabel(self.xlabels[0], fontsize=12); if show_ylabel:; ax.set_ylabel(""Marginal distribution"", fontsize=12). return fig, ax. [docs] def marginal(self, dim=0):; """"""; Calculate the marginal distribution function along the dimension; `dim`. Return a new Distribution instance describing this reduced-; dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; marginal distribution. Returns; -------. d : Distributions; A new instances of Distribution that describes the marginal; distribution. """"""; return Distribution(data=self.data.mean(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs] def project(self, dim=0):; """"""; Calculate the projection (max value) distribution function along the; dimension `dim`. Return a new Distribution instance describing this; reduced-dimensionality distribution. Parameters; ----------; dim : int; The dimension (coordinate index) along which to obtain the; projected distribution. Returns; -------; d : Distributions; A new instances of Distribution that describes the projection. """"""; return Distribution(data=self.data.max(axis=dim),; xvecs=[self.xvecs[dim]],; xlabels=[self.xlabels[dim]]). [docs]class WignerDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.xlabels = [r'$\rm{Re}(\alpha)$', r'$\rm{Im}(\alpha)$']. if rho:; self.update(rho). def update(self, rho):. self.data = wigner(rho, self.xvecs[0], self.xvecs[1]). [docs]class QDistribution(Distribution):. def __init__(self, rho=None, extent=[[-5, 5], [-5, 5]], steps=250):. self.xvecs = [np.linspace(extent[0][0], extent[0][1], steps),; np.linspace(extent[1][0], extent[1][1], steps)]. self.x",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:2111,Integrability,depend,depending,2111,"cs]class Distribution:; """"""A class for representation spatial distribution functions. The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far). It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters; ----------; data : array_like; Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs : list; List of arrays that spans the space for each coordinate.; xlabels : list; List of labels for each coordinate. """""". def __init__(self, data=None, xvecs=[], xlabels=[]):; self.data = data; self.xvecs = xvecs; self.xlabels = xlabels. [docs] def visualize(self, fig=None, ax=None, figsize=(8, 6),; colorbar=True, cmap=None, style=""colormap"",; show_xlabel=True, show_ylabel=True):; """"""; Visualize the data of the distribution in 1D or 2D, depending; on the dimensionality of the underlaying distribution. Parameters:. fig : matplotlib Figure instance; If given, use this figure instance for the visualization,. ax : matplotlib Axes instance; If given, render the visualization using this axis instance. figsize : tuple; Size of the new Figure instance, if one needs to be created. colorbar: Bool; Whether or not the colorbar (in 2D visualization) should be used. cmap: matplotlib colormap instance; If given, use this colormap for 2D visualizations. style : string; Type of visualization: 'colormap' (default) or 'surface'. Returns; -------. fig, ax : tuple; A tuple of matplotlib figure and axes instances. """"""; n = len(self.xvecs); if n == 2:; if style == ""colormap"":; return self.visualize_2d_colormap(fig=fig, ax=ax,; figsize=figsize,; colorbar=colorbar,; cmap=cmap,; show_xlabel=show_xlabel,; show_ylabel=show_ylabel); else:; return self.visualize_2d_surface(fig=fi",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:171,Testability,Log,Log,171,". qutip.distributions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.distributions. Source code for qutip.distributions; """"""; This module provides classes and functions for working with spatial; distributions, such as Wigner distributions, etc. .. note::. Experimental. """""". __all__ = ['Distribution', 'WignerDistribution', 'QDistribution',; 'TwoModeQuadratureCorrelation',; 'HarmonicOscillatorWaveFunction',; 'HarmonicOscillatorProbabilityFunction']. import numpy as np; from numpy import pi, exp, sqrt. from scipy.special import hermite, factorial. from qutip.qobj import isket; from qutip.wigner import wigner, qfunc; from qutip.states import ket2dm, state_number_index. try:; import matplotlib as mpl; import matplotlib.pyplot as plt; from mpl_toolkits.mplot3d import Axes3D; except:; pass. [docs]class Distribution:; """"""A class for representation spatial distribution functions. The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far). It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters; ----------; data : array_like; Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs : list; List of arrays that spans the space for each coordinate.; xlabels : list; List of labels for each coordinate. """""". def __init__(self, data=None, xvecs=[], xlabels=[]):; self.data = data; self.xvecs = xvecs; self.xlabels = xlabels. [docs] def visualize(self, fig=None, ax=None, figsize=(8, 6),; colorbar=True, cmap=None, styl",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/distributions.html:129,Usability,Guid,Guide,129,". qutip.distributions — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.distributions. Source code for qutip.distributions; """"""; This module provides classes and functions for working with spatial; distributions, such as Wigner distributions, etc. .. note::. Experimental. """""". __all__ = ['Distribution', 'WignerDistribution', 'QDistribution',; 'TwoModeQuadratureCorrelation',; 'HarmonicOscillatorWaveFunction',; 'HarmonicOscillatorProbabilityFunction']. import numpy as np; from numpy import pi, exp, sqrt. from scipy.special import hermite, factorial. from qutip.qobj import isket; from qutip.wigner import wigner, qfunc; from qutip.states import ket2dm, state_number_index. try:; import matplotlib as mpl; import matplotlib.pyplot as plt; from mpl_toolkits.mplot3d import Axes3D; except:; pass. [docs]class Distribution:; """"""A class for representation spatial distribution functions. The Distribution class can be used to prepresent spatial distribution; functions of arbitray dimension (although only 1D and 2D distributions; are used so far). It is indented as a base class for specific distribution function, and; provide implementation of basic functions that are shared among all; Distribution functions, such as visualization, calculating marginal; distributions, etc. Parameters; ----------; data : array_like; Data for the distribution. The dimensions must match the lengths of; the coordinate arrays in xvecs.; xvecs : list; List of arrays that spans the space for each coordinate.; xlabels : list; List of labels for each coordinate. """""". def __init__(self, data=None, xvecs=[], xlabels=[]):; self.data = data; self.xvecs = xvecs; self.xlabels = xlabels. [docs] def visualize(self, fig=None, ax=None, figsize=(8, 6),; colorbar=True, cmap=None, styl",MatchSource.WIKI,docs/4.7/modules/qutip/distributions.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/distributions.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:3284,Availability,mask,mask,3284,"ho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:3377,Availability,mask,mask,3377,"st be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:5302,Availability,Toler,Tolerance,5302,"ho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueE",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:103,Deployability,Install,Installation,103,". qutip.entropy — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.entropy. Source code for qutip.entropy; __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concu",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:9810,Deployability,update,updated,9810,"omposite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:8894,Energy Efficiency,power,power,8894,"omposite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:9134,Energy Efficiency,power,power,9134,"omposite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero of nonentangling gates and 1 and 2/9 for maximally; entangling gates. Parameters; ----------; U : qobj; Qobj instance representing a two-qubit gate. Returns; -------; ep : float; The entanglement power of U (real number between 0 and 1). References:. Explorations in Quantum Computing, Colin P. Williams (Springer, 2011); """""". if not U.isoper:; raise Exception(""U must be an operator.""). if U.dims != [[2, 2], [2, 2]]:; raise Exception(""U must be a two-qubit gate.""). from qutip.qip.operations.gates import swap; a = (tensor(U, U).dag() * swap(N=4, targets=[1, 3]) *; tensor(U, U) * swap(N=4, targets=[1, 3])); b = (tensor(swap() * U, swap() * U).dag() * swap(N=4, targets=[1, 3]) *; tensor(swap() * U, swap() * U) * swap(N=4, targets=[1, 3])). return 5.0/9 - 1.0/36 * (a.tr() + b.tr()).real. © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:423,Performance,concurren,concurrence,423,". qutip.entropy — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.entropy. Source code for qutip.entropy; __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concu",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:1958,Performance,concurren,concurrence,1958,"garithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def neg",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:1996,Performance,concurren,concurrence,1996,"garithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def neg",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:2175,Performance,Concurren,Concurrence,2175,"0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:2807,Safety,avoid,avoid,2807,"ho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters;",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:5322,Safety,detect,detect,5322,"ho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueE",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:7303,Safety,Avoid,Avoid,7303," e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effectiv",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:7621,Safety,avoid,avoid,7621," e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effectiv",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:165,Testability,Log,Log,165,". qutip.entropy — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.entropy. Source code for qutip.entropy; __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concu",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:595,Testability,log,log,595,". qutip.entropy — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.entropy. Source code for qutip.entropy; __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concu",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:997,Testability,log,logarithm,997,". qutip.entropy — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.entropy. Source code for qutip.entropy; __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concu",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:1386,Testability,log,logvals,1386,"al', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:1427,Testability,log,logvals,1427,"al', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:1437,Testability,log,log,1437,"al', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:1531,Testability,log,logvals,1531,"t conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concurrence entanglement measure for a two-qubit state. Parameters; ----------; state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.i",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:3040,Testability,log,logarithmic,3040," state : qobj; Ket, bra, or density matrix for a two-qubit state. Returns; -------; concur : float; Concurrence. References; ----------. .. [1] https://en.wikipedia.org/wiki/Concurrence_(quantum_computing). """"""; if rho.isket and rho.dims != [[2, 2], [1, 1]]:; raise Exception(""Ket must be tensor product of two qubits.""). elif rho.isbra and rho.dims != [[1, 1], [2, 2]]:; raise Exception(""Bra must be tensor product of two qubits.""). elif rho.isoper and rho.dims != [[2, 2], [2, 2]]:; raise Exception(""Density matrix must be tensor product of two qubits.""). if rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.;",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:3611,Testability,log,logarithmic,3611,"rho.isket or rho.isbra:; rho = ket2dm(rho). sysy = tensor(sigmay(), sigmay()). rho_tilde = (rho * sysy) * (rho.conj() * sysy). evals = rho_tilde.eigenenergies(). # abs to avoid problems with sqrt for very small negative numbers; evals = abs(sort(real(evals))). lsum = sqrt(evals[3]) - sqrt(evals[2]) - sqrt(evals[1]) - sqrt(evals[0]). return max(0, lsum). def negativity(rho, subsys, method='tracenorm', logarithmic=False):; """"""; Compute the negativity for a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; ",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:4099,Testability,log,logarithm,4099," a multipartite quantum system described; by the density matrix rho. The subsys argument is an index that; indicates which system to compute the negativity for. .. note::. Experimental.; """"""; mask = [idx == subsys for idx, n in enumerate(rho.dims[0])]; rho_pt = partial_transpose(rho, mask). if method == 'tracenorm':; N = ((rho_pt.dag() * rho_pt).sqrtm().tr().real - 1)/2.0; elif method == 'eigenvalues':; l = rho_pt.eigenenergies(); N = ((abs(l)-l)/2).sum(); else:; raise ValueError(""Unknown method %s"" % method). if logarithmic:; return log2(2 * N + 1); else:; return N. [docs]def entropy_mutual(rho, selA, selB, base=e, sparse=False):; """"""; Calculates the mutual information S(A:B) between selection; components of a system density matrix. Parameters; ----------; rho : qobj; Density matrix for composite quantum systems; selA : int/list; `int` or `list` of first selected density matrix components.; selB : int/list; `int` or `list` of second selected density matrix components.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be convert",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:5141,Testability,log,logarithm,5141,"Use sparse eigensolver. Returns; -------; ent_mut : float; Mutual information between selected components. """"""; if isinstance(selA, int):; selA = [selA]; if isinstance(selB, int):; selB = [selB]; if rho.type != 'oper':; raise TypeError(""Input must be a density matrix.""); if (len(selA) + len(selB)) != len(rho.dims[0]):; raise TypeError(""Number of selected components must match "" +; ""total number.""). rhoA = ptrace(rho, selA); rhoB = ptrace(rho, selB); out = (entropy_vn(rhoA, base, sparse=sparse) +; entropy_vn(rhoB, base, sparse=sparse) -; entropy_vn(rho, base, sparse=sparse)); return out. [docs]def entropy_relative(rho, sigma, base=e, sparse=False, tol=1e-12):; """"""; Calculates the relative entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:5826,Testability,log,log,5826,"ve entropy S(rho||sigma) between two density; matrices. Parameters; ----------; rho : :class:`qutip.Qobj`; First density matrix (or ket which will be converted to a density; matrix).; sigma : :class:`qutip.Qobj`; Second density matrix (or ket which will be converted to a density; matrix).; base : {e,2}; Base of logarithm. Defaults to e.; sparse : bool; Flag to use sparse solver when determining the eigenvectors; of the density matrices. Defaults to False.; tol : float; Tolerance to use to detect 0 eigenvalues or dot producted between; eigenvectors. Defaults to 1e-12. Returns; -------; rel_ent : float; Value of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueError(""Inputs must have the same shape and dims.""); if base == 2:; log_base = log2; elif base == e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise Val",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:6446,Testability,log,log,6446,"lue of relative entropy. Guaranteed to be greater than zero; and should equal zero only when rho and sigma are identical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueError(""Inputs must have the same shape and dims.""); if base == 2:; log_base = log2; elif base == e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:6530,Testability,log,log,6530,"entical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueError(""Inputs must have the same shape and dims.""); if base == 2:; log_base = log2; elif base == e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy i",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:6557,Testability,log,log,6557,"entical. Examples; --------. First we define two density matrices:. >>> rho = qutip.ket2dm(qutip.ket(""00"")); >>> sigma = rho + qutip.ket2dm(qutip.ket(""01"")); >>> sigma = sigma.unit(). Then we calculate their relative entropy using base 2 (i.e. ``log2``); and base e (i.e. ``log``). >>> qutip.entropy_relative(rho, sigma, base=2); 1.0; >>> qutip.entropy_relative(rho, sigma); 0.6931471805599453. References; ----------. See Nielsen & Chuang, ""Quantum Computation and Quantum Information"",; Section 11.3.1, pg. 511 for a detailed explanation of quantum relative; entropy.; """"""; if rho.isket:; rho = ket2dm(rho); if sigma.isket:; sigma = ket2dm(sigma); if not rho.isoper or not sigma.isoper:; raise TypeError(""Inputs must be density matrices.""); if rho.dims != sigma.dims:; raise ValueError(""Inputs must have the same shape and dims.""); if base == 2:; log_base = log2; elif base == e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy i",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:7319,Testability,log,log,7319," e:; log_base = log; else:; raise ValueError(""Base must be 2 or e.""); # S(rho || sigma) = sum_i(p_i log p_i) - sum_ij(p_i P_ij log q_i); #; # S is +inf if the kernel of sigma (i.e. svecs[svals == 0]) has non-trivial; # intersection with the support of rho (i.e. rvecs[rvals != 0]).; rvals, rvecs = sp_eigs(rho.data, rho.isherm, vecs=True, sparse=sparse); if any(abs(imag(rvals)) >= tol):; raise ValueError(""Input rho has non-real eigenvalues.""); rvals = real(rvals); svals, svecs = sp_eigs(sigma.data, sigma.isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effectiv",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:8009,Testability,log,logarithm,8009,".isherm, vecs=True, sparse=sparse); if any(abs(imag(svals)) >= tol):; raise ValueError(""Input sigma has non-real eigenvalues.""); svals = real(svals); # Calculate inner products of eigenvectors and return +inf if kernel; # of sigma overlaps with support of rho.; P = abs(inner(rvecs, conj(svecs))) ** 2; if (rvals >= tol) @ (P >= tol) @ (svals < tol):; return inf; # Avoid -inf from log(0) -- these terms will be multiplied by zero later; # anyway; svals[abs(svals) < tol] = 1; nzrvals = rvals[abs(rvals) >= tol]; # Calculate S; S = nzrvals @ log_base(nzrvals) - rvals @ P @ log_base(svals); # the relative entropy is guaranteed to be >= 0, so we clamp the; # calculated value to 0 to avoid small violations of the lower bound.; return max(0, S). [docs]def entropy_conditional(rho, selB, base=e, sparse=False):; """"""; Calculates the conditional entropy :math:`S(A|B)=S(A,B)-S(B)`; of a selected density matrix component. Parameters; ----------; rho : qobj; Density matrix of composite object; selB : int/list; Selected components for density matrix B; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; ent_cond : float; Value of conditional entropy. """"""; if rho.type != 'oper':; raise TypeError(""Input must be density matrix.""); if isinstance(selB, int):; selB = [selB]; B = ptrace(rho, selB); out = (entropy_vn(rho, base, sparse=sparse) -; entropy_vn(B, base, sparse=sparse)); return out. def participation_ratio(rho):; """"""; Returns the effective number of states for a density matrix. The participation is unity for pure states, and maximally N,; where N is the Hilbert space dimensionality, for completely; mixed states. Parameters; ----------; rho : qobj; Density matrix. Returns; -------; pr : float; Effective number of states in the density matrix. """"""; if rho.type == 'ket' or rho.type == 'bra':; return 1.0; else:; return 1.0 / (rho ** 2).tr(). def entangling_power(U):; """"""; Calculate the entangling power of a two-qubit gate U, which; is zero",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/entropy.html:123,Usability,Guid,Guide,123,". qutip.entropy — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.entropy. Source code for qutip.entropy; __all__ = ['entropy_vn', 'entropy_linear', 'entropy_mutual', 'negativity',; 'concurrence', 'entropy_conditional', 'entangling_power',; 'entropy_relative']. from numpy import conj, e, inf, imag, inner, real, sort, sqrt; from numpy.lib.scimath import log, log2; from qutip.qobj import ptrace; from qutip.states import ket2dm; from qutip.tensor import tensor; from qutip.operators import sigmay; from qutip.sparse import sp_eigs; from qutip.partial_transpose import partial_transpose. [docs]def entropy_vn(rho, base=e, sparse=False):; """"""; Von-Neumann entropy of density matrix. Parameters; ----------; rho : qobj; Density matrix.; base : {e,2}; Base of logarithm.; sparse : {False,True}; Use sparse eigensolver. Returns; -------; entropy : float; Von-Neumann entropy of `rho`. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_vn(rho,2); 1.0. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); vals = sp_eigs(rho.data, rho.isherm, vecs=False, sparse=sparse); nzvals = vals[vals != 0]; if base == 2:; logvals = log2(nzvals); elif base == e:; logvals = log(nzvals); else:; raise ValueError(""Base must be 2 or e.""); return float(real(-sum(nzvals * logvals))). [docs]def entropy_linear(rho):; """"""; Linear entropy of a density matrix. Parameters; ----------; rho : qobj; sensity matrix or ket/bra vector. Returns; -------; entropy : float; Linear entropy of rho. Examples; --------; >>> rho=0.5*fock_dm(2,0)+0.5*fock_dm(2,1); >>> entropy_linear(rho); 0.5. """"""; if rho.type == 'ket' or rho.type == 'bra':; rho = ket2dm(rho); return float(real(1.0 - (rho ** 2).tr())). [docs]def concurrence(rho):; """"""; Calculate the concu",MatchSource.WIKI,docs/4.7/modules/qutip/entropy.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/entropy.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:103,Deployability,Install,Installation,103,". qutip.eseries — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.eseries. Source code for qutip.eseries; __all__ = ['eseries', 'esval', 'esspec', 'estidy']. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5.; Please use :obj:`~qutip.QobjEvo` for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; self.rates = q.rates; self.dims = q.dims; self.shape = q.shape; elif isinstance(q, (np.ndarray, list)):; num = len(q) # number of elements in q; if any([Qobj(x).shape != Qobj(q[0]).shape for x in q]):; raise TypeError('All amplitudes must have same dimension.'); self.ampl =",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:9491,Deployability,update,updated,9491,"nique_rates.keys():; if abs(self.rates[r_idx] - unique_rates[ur_key]) < rate_tol:; idx = ur_key; break; if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:585,Integrability,depend,dependent,585,". qutip.eseries — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.eseries. Source code for qutip.eseries; __all__ = ['eseries', 'esval', 'esspec', 'estidy']. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5.; Please use :obj:`~qutip.QobjEvo` for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; self.rates = q.rates; self.dims = q.dims; self.shape = q.shape; elif isinstance(q, (np.ndarray, list)):; num = len(q) # number of elements in q; if any([Qobj(x).shape != Qobj(q[0]).shape for x in q]):; raise TypeError('All amplitudes must have same dimension.'); self.ampl =",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:730,Integrability,depend,dependence,730,". qutip.eseries — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.eseries. Source code for qutip.eseries; __all__ = ['eseries', 'esval', 'esspec', 'estidy']. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5.; Please use :obj:`~qutip.QobjEvo` for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; self.rates = q.rates; self.dims = q.dims; self.shape = q.shape; elif isinstance(q, (np.ndarray, list)):; num = len(q) # number of elements in q; if any([Qobj(x).shape != Qobj(q[0]).shape for x in q]):; raise TypeError('All amplitudes must have same dimension.'); self.ampl =",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:1433,Integrability,depend,dependence,1433,"s np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5.; Please use :obj:`~qutip.QobjEvo` for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; self.rates = q.rates; self.dims = q.dims; self.shape = q.shape; elif isinstance(q, (np.ndarray, list)):; num = len(q) # number of elements in q; if any([Qobj(x).shape != Qobj(q[0]).shape for x in q]):; raise TypeError('All amplitudes must have same dimension.'); self.ampl = np.empty((num,), dtype=object); self.ampl[:] = q; self.rates = np.zeros((num,)); self.dims = self.ampl[0].dims; self.shape = self.ampl[0].shape; elif isinstance(q, Qobj):; qo = Qobj(q); self.ampl = np.empty((1,), dtype=object); self.ampl[0] = qo; self.rates = np.array([0]); self.dims = qo.dims; self.shape = qo.shape; else:; self.ampl = np.array([q]); self.rates = np.array([0]); self.dims = [[1, 1]]; self.sh",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:8612,Integrability,wrap,wrapper,8612,"nique_rates.keys():; if abs(self.rates[r_idx] - unique_rates[ur_key]) < rate_tol:; idx = ur_key; break; if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:8634,Security,access,accessing,8634,"nique_rates.keys():; if abs(self.rates[r_idx] - unique_rates[ur_key]) < rate_tol:; idx = ur_key; break; if idx == -1:; # no matching rate, add it; unique_rates[ur_len] = self.rates[r_idx]; ampl_dict[ur_len] = [self.ampl[r_idx]]; ur_len = len(unique_rates); else:; # found matching rate, append amplitude to its list; ampl_dict[idx].append(self.ampl[r_idx]). # create new amplitude and rate list with only unique rates, and; # nonzero amplitudes; rates, ampl = [], []; for ur_key in unique_rates.keys():; total_ampl = sum(ampl_dict[ur_key]); if (isinstance(total_ampl, float) or; isinstance(total_ampl, complex)):; if abs(total_ampl) > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); else:; if abs(total_ampl.full()).max() > ampl_tol:; rates.append(unique_rates[ur_key]); ampl.append(total_ampl); self.rates = np.array(rates); self.ampl = np.empty((len(ampl),), dtype=object); self.ampl[:] = ampl; return self. # -----------------------------------------------------------------------------; #; # wrapper functions for accessing the class methods (for compatibility with; # quantum optics toolbox); #; def esval(es, tlist):; """"""; Evaluates an exponential series at the times listed in ``tlist``. Parameters; ----------; tlist : ndarray; Times at which to evaluate exponential series. Returns; -------; val_list : ndarray; Values of exponential at times in ``tlist``. """"""; return es.value(tlist). def esspec(es, wlist):; """"""Evaluate the spectrum of an exponential series at frequencies; in ``wlist``. Parameters; ----------; wlist : array_like; Array/list of frequenies. Returns; -------; val_list : ndarray; Values of exponential series at frequencies in ``wlist``. """"""; return es.spec(wlist). def estidy(es, *args):; """"""; Returns a tidier version of exponential series.; """"""; return es.tidyup(). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:165,Testability,Log,Log,165,". qutip.eseries — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.eseries. Source code for qutip.eseries; __all__ = ['eseries', 'esval', 'esspec', 'estidy']. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5.; Please use :obj:`~qutip.QobjEvo` for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; self.rates = q.rates; self.dims = q.dims; self.shape = q.shape; elif isinstance(q, (np.ndarray, list)):; num = len(q) # number of elements in q; if any([Qobj(x).shape != Qobj(q[0]).shape for x in q]):; raise TypeError('All amplitudes must have same dimension.'); self.ampl =",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/eseries.html:123,Usability,Guid,Guide,123,". qutip.eseries — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.eseries. Source code for qutip.eseries; __all__ = ['eseries', 'esval', 'esspec', 'estidy']. import numpy as np; import scipy.sparse as sp; from qutip.qobj import Qobj. import warnings. [docs]class eseries():; """"""; Class representation of an exponential-series expansion of; time-dependent quantum objects. .. deprecated:: 4.6.0; :obj:`~eseries` will be removed in QuTiP 5.; Please use :obj:`~qutip.QobjEvo` for general time-dependence. Attributes; ----------; ampl : ndarray; Array of amplitudes for exponential series.; rates : ndarray; Array of rates for exponential series.; dims : list; Dimensions of exponential series components; shape : list; Shape corresponding to exponential series components. Methods; -------; value(tlist); Evaluate an exponential series at the times listed in tlist; spec(wlist); Evaluate the spectrum of an exponential series at frequencies in wlist.; tidyup(); Returns a tidier version of the exponential series. """"""; __array_priority__ = 101. def __init__(self, q=None, s=np.array([])):; warnings.warn(; ""eseries is to be removed in QuTiP 5.0,""; "" consider swapping to QobjEvo for general time dependence."",; DeprecationWarning, stacklevel=2,; ). if isinstance(s, (int, float, complex)):; s = np.array([s]). if q is None:; self.ampl = np.array([]); self.rates = np.array([]); self.dims = [[1, 1]]; self.shape = [1, 1]. elif (len(s) == 0):; if isinstance(q, eseries):; self.ampl = q.ampl; self.rates = q.rates; self.dims = q.dims; self.shape = q.shape; elif isinstance(q, (np.ndarray, list)):; num = len(q) # number of elements in q; if any([Qobj(x).shape != Qobj(q[0]).shape for x in q]):; raise TypeError('All amplitudes must have same dimension.'); self.ampl =",MatchSource.WIKI,docs/4.7/modules/qutip/eseries.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/eseries.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:4131,Availability,error,error,4131," results[n, :]; for n, e in enumerate(e_ops)]. return data. # -----------------------------------------------------------------------------; #; #; [docs]@_deprecate(""direct eigenstate and -value calculation""); def ode2es(L, rho0):; """"""Creates an exponential series that describes the time evolution for the; initial density matrix (or state vector) `rho0`, given the Liouvillian; (or Hamiltonian) `L`. .. deprecated:: 4.6.0; :obj:`~ode2es` will be removed in QuTiP 5. Please use; :obj:`qutip.Qobj.eigenstates` to get the eigenstates and -values,; and use :obj:`~qutip.QobjEvo` for general time-dependence. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 =",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:4800,Availability,error,error,4800,"s,; and use :obj:`~qutip.QobjEvo` for general time-dependence. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rho0.full(); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(np.array(vv[:, i]).T, dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, -1.0j * w[i]); else:; out = eseries(qo, -1.0j * w[i]). else:; raise TypeError('First argument must be a Hamiltonian or Liouvillian.'). return estidy(out). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:103,Deployability,Install,Installation,103,". qutip.essolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.essolve. Source code for qutip.essolve; __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; -------",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:1866,Deployability,integrat,integration,1866," removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :class:`qutip.qobj`; Initial state density matrix. tlist : list/array; ``list`` of times for :math:`t`. c_op_list : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` collapse operators. e_ops : list of :class:`qutip.qobj`; ``list`` of :class:`qutip.qobj` operators for which to evaluate; expectation values. Returns; -------; expt_array : array; Expectation values of wavefunctions/density matrices for the; times specified in ``tlist``. .. note:: This solver does not support time-dependent Hamiltonians. """"""; n_expt_op = len(e_ops); n_tsteps = len(tlist). # Calculate the Liouvillian; if (c_op_list is None or len(c_op_list) == 0) and isket(rho0):; L = H; else:; L = liouvillian(H, c_op_list). es = ode2es(L, rho0). # evaluate the expectation values; if n_expt_op == 0:; results = [Qobj()] * n_tsteps; else:; r",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:5571,Deployability,update,updated,5571,"s,; and use :obj:`~qutip.QobjEvo` for general time-dependence. Parameters; ----------; L : qobj; Liouvillian of the system. rho0 : qobj; Initial state vector or density matrix. Returns; -------; eseries : :class:`qutip.eseries`; ``eseries`` represention of the system dynamics. """"""; if issuper(L):; # check initial state; if isket(rho0):; # Got a wave function as initial state: convert to density matrix.; rho0 = rho0 * rho0.dag(); # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-10 + 1e-24:; # enforce zero operator; return eseries(qzero(rho0.dims[0])); w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = mat2vec(rho0.full()); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(vec2mat(vv[:, i]), dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, w[i]); else:; out = eseries(qo, w[i]). elif isoper(L):. if not isket(rho0):; raise TypeError('Second argument must be a ket if first' +; 'is a Hamiltonian.'). # check if state is below error threshold; if abs(rho0.full()).sum() < 1e-5 + 1e-20:; # enforce zero operator; dims = rho0.dims; return eseries(Qobj(sp.csr_matrix((dims[0][0], dims[1][0]),; dtype=complex))). w, v = L.eigenstates(); v = np.hstack([ket.full() for ket in v]); # w[i] = eigenvalue i; # v[:,i] = eigenvector i. rlen = np.prod(rho0.shape); r0 = rho0.full(); v0 = la.solve(v, r0); vv = v * sp.spdiags(v0.T, 0, rlen, rlen). out = None; for i in range(rlen):; qo = Qobj(np.array(vv[:, i]).T, dims=rho0.dims, shape=rho0.shape); if out:; out += eseries(qo, -1.0j * w[i]); else:; out = eseries(qo, -1.0j * w[i]). else:; raise TypeError('First argument must be a Hamiltonian or Liouvillian.'). return estidy(out). © Copyright 2011 to 2021 inclusive, QuTiP developers and contributors.; ; Last updated on Jan 29, 2024.; . ; ; ; Built with Sphinx using a; ; theme; ; provided by Read the Docs. . ",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:843,Integrability,message,message,843,". qutip.essolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.essolve. Source code for qutip.essolve; __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; -------",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:959,Integrability,wrap,wraps,959,". qutip.essolve — QuTiP 4.7 Documentation. QuTiP: Quantum Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.essolve. Source code for qutip.essolve; __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; -------",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
https://qutip.org/docs/4.7/modules/qutip/essolve.html:1010,Integrability,message,message,1010," Toolbox in Python; . ; . 4.7; . Frontmatter; Installation; Users Guide; Gallery; API documentation; Change Log; Developers; Development Documentation; Bibliography; Copyright and Licensing. QuTiP: Quantum Toolbox in Python. »; Module code »; qutip.essolve. Source code for qutip.essolve; __all__ = ['essolve', 'ode2es']. import numpy as np; import scipy.linalg as la; import scipy.sparse as sp. from qutip.qobj import Qobj, issuper, isket, isoper; from qutip.eseries import eseries, estidy, esval; from qutip.expect import expect; from qutip.superoperator import liouvillian, mat2vec, vec2mat; from qutip.solver import Result; from qutip.operators import qzero. # Only used for deprecation warnings.; import functools; import warnings. def _deprecate(alternative):; def decorated(f):; message = (; f""{f.__name__} is to be removed in QuTiP 5.0""; f"", consider swapping to {alternative}.""; ). @functools.wraps(f); def out(*args, **kwargs):; warnings.warn(message, DeprecationWarning, stacklevel=2); return f(*args, **kwargs); return out; return decorated. # -----------------------------------------------------------------------------; # pass on to wavefunction solver or master equation solver depending on whether; # any collapse operators were given.; #; [docs]@_deprecate(""mesolve""); def essolve(H, rho0, tlist, c_op_list, e_ops):; """"""; Evolution of a state vector or density matrix (`rho0`) for a given; Hamiltonian (`H`) and set of collapse operators (`c_op_list`), by; expressing the ODE as an exponential series. The output is either; the state vector at arbitrary points in time (`tlist`), or the; expectation values of the supplied operators (`e_ops`). .. deprecated:: 4.6.0; :obj:`~essolve` will be removed in QuTiP 5. Please use; :obj:`~qutip.sesolve` or :obj:`~qutip.mesolve` for general-purpose; integration of the Schroedinger/Lindblad master equation.; This will likely be faster than :obj:`~essolve` for you. Parameters; ----------; H : qobj/function_type; System Hamiltonian. rho0 : :",MatchSource.WIKI,docs/4.7/modules/qutip/essolve.html,qutip,qutip,v5.0.4,https://qutip.org,https://qutip.org/docs/4.7/modules/qutip/essolve.html
