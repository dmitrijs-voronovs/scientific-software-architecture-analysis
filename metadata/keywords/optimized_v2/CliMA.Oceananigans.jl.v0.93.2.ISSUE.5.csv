quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,wiki,url,total_similar,target_keywords,target_matched_words
Modifiability,"> Ok, here's a multi-pronged strategy to address this:; > ; > 1. Rather than computing the next time step directly based on the schedules, compute the nearest _action time_ (either output or callback or the simulation is stopping). Then compute the time-step like we have been and as suggested by @tomchor for RK3, by taking the differences between the next action time and the current time.; > ; > 2. Change `TimeInterval` so that, rather than accumulating `previous_actuation_time`, we instead compute something like the `initialization_time` and `actuation_index`. Then we can compute the next actuation time with `t0 + T * (i + 1)` --- will this reduce round off error when computing the actuation time?. I'm confused as to what `T` would be here. It feels like it should be `simulation.Δt`, but that wouldn't work for variable `Δt`. > 3. Fix RK3 so it also uses differences to accumulate the substep times as suggested by @tomchor. We can also manually ensure that after the subtseps are complete the the clock time is in fact the current time plus the time-step.; > ; > 4. Should we also add a feature to the nonhydrostaticmodel, something like the minimum time step? If the time-step is below that minimum, then rather than doing a time-step + pressure correction, we simply advance the model clock. I think this could work. We probably would need to discuss how that would interact with `min_Δt` from the `TimeStepWizard`, no? Since they're putting two different lower boundaries (I think the one in `NonhydrostaticModel` would be more ""powerful"", correct?); ; > I wonder if, after all these changes, whether we still need a ""discretized time"" like I was suggesting or not. If we discretize time do we even need the stuff above?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106:823,variab,variable,823,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2104566106,2,['variab'],['variable']
Modifiability,"> Okay finally tests passed!; > ; > @navidcy I tried restarting the tests over and over (honestly more than 10 times over the past few days) and they always failed. I could only make them pass this morning when I restarted them one at a time. That is, starting one, and only restarting the next failed test when the previous one had fully run.; > ; > So maybe the variability we see in tests has to do with different processes trying to access the same resources... ?. Yes it is a race condition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307:364,variab,variability,364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307,1,['variab'],['variability']
Modifiability,"> One aspect of this change is that the models will no longer be concretely typed (because `OrderedDict{Symbol, Callback}` is not a concrete type). I'm not sure this matters, but it's worth noting this.; > ; > Thinking about the API issues, I wonder if there's another advantage in putting the state callbacks in `Simulation`, that we have a system in which a ""model"" is not modified after its created (eg we are not adding callbacks to it) --- that's something that we do with Simulations. With this PR, we mix the concepts of models and simulations. Which may be ok... Perhaps we could change it so you give the model a Tuple or NamedTuple of callbacks when you specify it so the API is more consistent and the model not modified after? I think it could be argued that state callbacks are part of the model rather than the simulation, like forcing functions are, since they could be an intrinsic part of how the model evolves, e.g. if it modified the tendencies. I suppose this argument could be made for some callbacks as well though so I don't know whats best!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1272521047:920,evolve,evolves,920,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1272521047,1,['evolve'],['evolves']
Modifiability,"> Or maybe we can do this just with `AbstractOperations`, the problem is that we have to define a ""helper"" model. I think extending the capabilities of the `DiscreteDiffusionFunction` is the right approach here. But I also think we should only make the necessary changes in abstract_scalar_diffusivity.jl and abstract_biharmonic_scalar_diffusivity.jl and leave the tendency kernels and existing closures (like AMD) unchanged. The only thing that needs to be done is `merge(U, C)` there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2580#issuecomment-1139148066:122,extend,extending,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2580#issuecomment-1139148066,1,['extend'],['extending']
Modifiability,"> Personally, I don't think it's confusing. I also don't feel strongly either way though. Ah yes, totally agree that it isn't confusing. I wasn't arguing that it was confusing though. . In terms of _reading_ these code statements I much prefer seeing `pressure_solver = poisson_solver`. Its even pedagogical because it teaches you that we solve the Poisson equation for pressure. I love that and that is exactly why we chose this design. Please bear with me to understand the reason I am proposing this change. In practical usage / when coding new experiments it is easy to mix up ""pressure"" with ""poisson"". I've been working testing lots of different solvers these past few days, and keep accidentally typing `pressure_solver = ConjugateGradientPressureSolver(grid)` which is wrong. If it becomes more common to configure the pressure / poisson solver in the future (because we have better support for different solvers for irregular geometries) then I would like to also help others that may run into this issue. It's nice to have syntax that ""rolls of the tongue"", ie, is what you would type if you were typing without concentrating very hard. It's not big deal either. I just tend to think that if one makes the same syntax mistake multiple times, it's important to make sure you step back and consider whether the problem is you, or the syntax.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377874234:813,config,configure,813,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3188#issuecomment-2377874234,1,['config'],['configure']
Modifiability,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:948,parameteriz,parameterization,948,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452,2,['parameteriz'],"['parameterization', 'parameterization-derived']"
Modifiability,"> Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at n and the time step at n-1 to be correct. It seems like a good idea to use this. . Although, I think we basically always recommend using RK3 for `NonhydrostaticModel`. . Would another path forward be to also implement RK3 for `HydrostaticFreeSurfaceModel`, and basically deprecate any recommendation to use AB2 at all? It's just so much more convenient to use RK3 and also seems to have better numerical properties, not least in light of this issue...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313369477:34,variab,variable,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313369477,2,['variab'],['variable']
Modifiability,"> Right yeah RegularRectilinearGrid called it grid.zC but VerticallyStretchedRectilinearGrid calls it grid.zᵃᵃᶠ to be more consistent with the curvilinear grids being added, but the output writers might not know this yet. Can we refactor the tests to use `all_z_nodes`? This could avoid issues with property names.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388:229,refactor,refactor,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1429#issuecomment-791630388,1,['refactor'],['refactor']
Modifiability,"> Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right?; > ; > I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me. I'm talking about the relationship between the vertical grid topology and the algorithm used by `ShallowWaterModel` to solve a problem on that grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717:104,layers,layers,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1156641717,2,['layers'],['layers']
Modifiability,"> Should also restructure the new `ShallowWaterModel` version in a similar way. Quite! In the context of `ShallowWaterModel`, this will only effect 1D models where adaptive time-stepping may not be that useful (because the vertical dimensions is `Flat` _a priori_). But we can add it there too if we think that's important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1309#issuecomment-763706226:164,adapt,adaptive,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1309#issuecomment-763706226,1,['adapt'],['adaptive']
Modifiability,"> So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`.; > ; > This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward...; > ; > Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation.; > ; > I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case... I also prefer the copy/paste method (that's what I used in https://github.com/CliMA/Oceananigans.jl/pull/3111). If I understand correctly these two functions are the only ones that need to be generalized, no?: . https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L74-L83. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L88. if so, that's not too bad. Is duplicating one of the tests in [test_batched_tridiagonal_solver.jl](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_batched_tridiagonal_solver.jl) but rotating everything to two different directions enough to test this new functionality?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584:26,extend,extend,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584,1,['extend'],['extend']
Modifiability,"> So what do you guys think if this tilting is implement at the AbstractBuoyancy level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe tilt, gravitational_direction or gravity_projection) that would default to (0, 0, 1) and a similar option could be given to FPlane, avoiding confusion. Ah, the issue is that abstract types cannot have properties --- they can only be used to organize type parameters and dispatch.; The logic and motivation of your suggestion is sound though (avoiding code duplication through good design); we just have to come up with a different solution. A similar solution could perhaps design a more hierarchical interface to `IncompressibleModel.buoyancy`. For example, we might write. ```julia; struct Buoyancy{G, B}; gravitational_direction :: G; model :: B; end; ```. The existing subtypes of `AbstractBuoyancy` are used for `Buoyancy.model`. The user API could be. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9), model=BuoyancyTracer()); ```. or. ```julia; buoyancy = Buoyancy(gravitational_direction=(0.1, 0, 0.9),; model=SeawaterBuoyancy(gravitational_acceleration=9.81, equation_of_state=LinearEquationOfState(α=2e-4, β=8e-5))); ```. This is more verbose but could avoid some of the issues that @tomchor sees. As for `Plane` and `BetaPlane`, I agree that those models are really predicated on a thin aspect ratio assumption that has to do with gravitational accelerations, and therefore ""know"" about the direction of gravity. We could either add a property `gravitational_direction` or, perhaps, add some wrapper / helper functions for constructing coriolis forces in tilted domains (eg `coriolis = TiltedCoriolisForces(FPlane(f=1e-4), vertical_direction=(0.1, 0.0, 0.9))` which returns `GeneralCoriolis` with 3D Coriolis forces --- or something). I think we will start to run into these sorts of issues more generically, where we need to specify ""global"" parameters that impact mu",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047:133,inherit,inherit,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782962047,1,['inherit'],['inherit']
Modifiability,"> So whatever's happening probably has to do with the HydrostaticModel, which I'm really not familiar with unfortunately.; > ; > What do you prefer that I do?. the hydrostatic model does not have `w` as state variable... try removing `w` and see if all is good.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1893650409:209,variab,variable,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1893650409,1,['variab'],['variable']
Modifiability,"> Some of the points that could be in the Goals/Mission section:; > ; > * Easy to install, understand and use; > * Versatile: model is made in blocks that could be combined and easily configured across scales; > * Modern: this might be no independent from the others. Yeah! ""Easy to install"" are ""versatile"" are definitely very important motivators of Julia. Here's some additional points from the ""Vision"" slide presented at Ocean Sciences 2022 Oceananigans town hall:. ![image](https://user-images.githubusercontent.com/15271942/156891514-6ae309ea-597c-4a6a-9ea4-aed1da6f231f.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059790533:184,config,configured,184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059790533,1,['config'],['configured']
Modifiability,"> Some of the validations are failing...?; > ; > What previously gave; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; > Stacktrace:; > [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; > [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; > [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; > [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); > @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; > [5] top-level scope; > @ REPL[3]:1; > ```; > ; > now it goes through:; > ; > ```julia; > julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); > 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; > ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; > └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; > ```; > ; > Note that it creates an x and y coord `[1.0, 1.0)`!. I think I fixed it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968:1569,variab,variably,1569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762146968,2,['variab'],['variably']
Modifiability,"> Some sandbox stuff might've been added by accident. Ah, thanks for catching that. I was investigating the stretched grid + timestep wizard thing. Should be good now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863622034:7,sandbox,sandbox,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863622034,1,['sandbox'],['sandbox']
Modifiability,"> Some stuff later in the docstring is also weird. For example it says; > ; > > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:; > ; > I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?. Good catch! I will work on the docstring and error after the weekend.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443:105,adapt,adapt,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1702121443,3,['adapt'],"['adapt', 'adaptation']"
Modifiability,"> Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?. It's natural variability in hardware instructions for GPU, which is pretty scary. sverdrup has a Quadro P6000 which is a bit older and intended more for gaming. I think weird stuff goes on deep inside. If we had billions of dollars we'd get a little cluster dedicated to CI up and running and make beautiful examples and have lightning fast tests (and an engineer to maintain them). Not there yet.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489:96,variab,variability,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881974489,2,['variab'],['variability']
Modifiability,"> Sorry, let me rephrase, users shouId pass clock and fields only when boundary conditions require it, so we need some type of warning to make sure the error is well documented.; > ; > I think it is nice to have `fill_halo_regions!(field)`, it will be a bit cumbersome to always have to pass a clock and fields also when non using complex BCs. It's not even possible to construct a field with `ContinuousForcing` outside a model constructor. The model constructor has to do things like compute the index of `fields(model)` that a field name belongs to. So its more than cumbersome, its not possible. Also we need to prioritize. We are trying to do simulations, not have uber fancy flexible field abstractions (this is just an auxiliary feature that's very nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179186646:681,flexible,flexible,681,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2179186646,1,['flexible'],['flexible']
Modifiability,"> Sounds like the plan is to switch to SolutionBoundaryConditions but that might involve more refactoring so maybe best left for another PR?. This is already done, because the model constructor calls the function `ModelBoundaryConditions` here:. https://github.com/climate-machine/Oceananigans.jl/blob/e41711f6b5db492d3aa5344d2e3bc9c2fe65dd70/src/models.jl#L64. which then dispatches based on whether the argument `boundary_conditions` is a `SolutionBoundaryConditions` or a `ModelBoundaryConditions`:. https://github.com/climate-machine/Oceananigans.jl/blob/e41711f6b5db492d3aa5344d2e3bc9c2fe65dd70/src/boundary_conditions.jl#L254. Thus in either case the model is constructed with a `ModelBoundaryConditions`. Edit: note that this is required for correct checkpointing, because the checkpointer passes a `ModelBoundaryConditions` to the model constructor, while we expect users to pass a `SolutionBoundaryConditions`. . The downside to this pattern is that the type of `model.boundary_conditions` will often be different than the keyword argument `boundary_conditions`. Hopefully this is not confusing or surprising... :-/ An alternative is perhaps to specifically delineate between them; ie change the keyword argument in the `Model` constructor to `solution_boundary_conditions`. However, something to consider is that the `tendency` and `pressure` fields of `ModelBoundaryConditions` should be uniquely determined by `SolutionBoundaryConditions`. Another factor to consider is that the pattern that keyword arguments correspond to fields is not a guaranteed julia pattern, it is simply an organizational principle that we feel is helpful. Thus I think we can break it occasionally if it improves the readability and simplicity of code. We should note the difference in the documentation to the `Model` constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531491747:94,refactor,refactoring,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405#issuecomment-531491747,1,['refactor'],['refactoring']
Modifiability,"> Stokes vorticity?. Ah, when using a GM parameterization?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1454#issuecomment-796822490:41,parameteriz,parameterization,41,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1454#issuecomment-796822490,1,['parameteriz'],['parameterization']
Modifiability,"> Storing constant values in diffusivities is possible, but could be interpreted as boilerplate. The coefficients need to be stored in closure, because that's where users specify them. So copying the constants or functions into diffusivities (this would have to be done individually for all closures) requires additional code. We don't have that many closures that would need this though, right? I think only `IsotropicConstant`, `AnisotropicConstant` and the biharmonic one that I see in the docs. (I think you have a TKE-based one that isn't listed in the docs also?). > I think of all the changes to diffusivities, the one that makes the most sense is to eliminate that field and change the API so that grid is a required argument for closures that have fields associated with them. This is a substantial internal refactor, but perhaps someone wants to take it up?. I like this option, but keeping the user from creating a closure without a grid seems a bit counter-productive... It's still not clear to me which one I'd vote for. For the time being, should we do something for the problem title refers to?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045:817,refactor,refactor,817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883732045,2,['refactor'],['refactor']
Modifiability,"> Sure, I think a problem might also be that it varies so much on a case by case basis. The most important case, which is supported by many other codes, is _nesting_. In this situation the entire 3D state outside the prognostic domain is provided. To support this we need to be able to extract the boundary state and potentially also sponge layers from the prescribed 3D state. I think cases where the boundary state is directly prescribed (perhaps for idealized simulations) will be a lot more rare. Yes there are some use cases (like the developing boundary layer case that @simone-silvestri referenced). But I think this will be a lot less common than nesting, which is already widely used for regional modeling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2005310948:341,layers,layers,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2005310948,1,['layers'],['layers']
Modifiability,"> Thank you for your help! I have installed the updated version of Julia and when running it appears to be Segfaulting when trying to add CUDA. I will open an issue with them if I cannot figure out how to solve it. Thank you again. @logan can you link the CUDA issue here please?. Also, if you haven't tried, erase everything on your `$JULIA_DEPOT_PATH` (really to be safe you should make a backup of everything there first) and then run the same script you've been running with `using Pkg; Pkg.instantiate()` on the first line. This should ""re-install"" all the packages from scratch. For context [`$JULIA_DEPOT_PATH`](https://docs.julialang.org/en/v1/manual/environment-variables/#JULIA_DEPOT_PATH) by default is `~/.julia`, I think, and that's where julia stores the package files it downloads. The hypothesis here is that at some point some package download/compilation went wrong and you have some broken code there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245639622:671,variab,variables,671,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245639622,1,['variab'],['variables']
Modifiability,"> Thank you for your replies!; > ; > The FFT-based preconditioner was the first one that I tried. It produced suspicious zonal jets in my simulations. This figure shows the difference between the two solvers. It seems to me that these zonal jets are numerical artifacts. Can you clarify --- is the simulation on the right with the FFT-based _direct_ solver, or is it with a preconditioned conjugate gradient solver that use an FFT as a preconditioner?. My suggestion is to use a preconditioned conjugate gradient solver, with the FFT-based solver as a _preconditioner_ (not as the direct solver). As for blow up I think the problem happens for very small time-steps? Perhaps try it without adaptive time-stepping for now and also cap the `max_iterations` as a small number.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2067298583:690,adapt,adaptive,690,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2067298583,1,['adapt'],['adaptive']
Modifiability,"> Thanks @tomchor for doing this.; > ; > I remember last year, Henry needed to use `@gpu_sync` when he was running stuff on multiple cores. Maybe why it is not necessary for a single core?. I think in this case it's not necessary because it's a multi-CPU testing script, so no GPUs involved. And that allows us to get rid of the `Benchmarks` dependence and make the script more portable.; ; > I presume you are going to try and run this on more than one core? If you try it and get an error I'd be curious to know what it is. I did! And I'm running into issues. Please check https://github.com/CliMA/Oceananigans.jl/issues/2433! Any help there is appreciated",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148:378,portab,portable,378,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2432#issuecomment-1098394148,1,['portab'],['portable']
Modifiability,"> Thanks a lot for your hint, I wanted to make sure what you mean by _number_ of actuations as a criteria. Do you mean; > ; > ```julia; > first_actuation_time::Number; > ```; > ; > and do you think this will potentially prevent the floating point issue?. Not quite. `TimeInterval` keeps a count of _how many times it has been actuated_. This is stored in the variable `TimeInterval.actuations`. It's use is illustrated in the computation of the `next_actuation_time`:. https://github.com/CliMA/Oceananigans.jl/blob/dc5dc28c6cf433dcb8a6668cef99e98309e6ead9/src/Utils/schedules.jl#L58-L63. To understand this consider an example. `TimeInterval` has been actuated 2 times, with an interval of 1.1. This means that the next actuation time --- the _third_ actuation_ -- will occur at the time. ```; t = 3 * 1.1 = 3.3; ```. Thus rather than storing the ""previous actuation time"" (a floating point number), we instead store the _number_ of actuations (an integer, and exact), and compute the next actuation time with the formula above. Does this make sense?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2286669182:359,variab,variable,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3670#issuecomment-2286669182,1,['variab'],['variable']
Modifiability,"> That's a really cool idea. I can see how we could do that with KernelComputedFields, but I can't really see how to do it for ComputedFields. I think we understand how to write a `compute!` function that fuses the kernels for multiple `ComputedField`s or `KernelComputedField`s. But the harder part is designing an API that implements fusion for an output writer. We might need to add a property called something like `fused_compute` to both `OutputWriter`s. For example, `JLD2OutputWriter` fetches output in a loop:. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/OutputWriters/jld2_output_writer.jl#L195-L196. where `fetch_and_convert_output` calls `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/OutputWriters/fetch_output.jl#L13-L16. which in turn calls `compute_at!`. But we want to trigger _one_ call to `compute_at!` for all the outputs at the same time ... I think ... so that requires some refactoring and API design.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800597659:1004,refactor,refactoring,1004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800597659,1,['refactor'],['refactoring']
Modifiability,"> The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way.; > ; > Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output. I find that using `Field(abstract_op, data=scratc.data)` saves a ton of space when compared to just passing `abstract_op` to the writer. Is that not expected? Also, at least for my simulation using `NetCDFWriter`, passing `Field(abstract_op)` or `abstract_op` makes no difference on memory allocation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509:109,variab,variables,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1302594509,1,['variab'],['variables']
Modifiability,"> The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})`. wut. > I'm not sure what already is expected to fail. Nothing is expected to fail. Where does `Fix1` come from?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447:111,Adapt,Adapt,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867004447,2,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"> The line should be `minimum(view(parent(grid.Δzᵃᵃᶜ), 1:grid.Nz))`. This is not quite right. We want a view of the interior indices; the indices `1:grid.Nz` of the parent array covers the halo region at the bottom, and does not cover all the points near the top / surface. It should be sufficient to compute the minimum of `parent(grid.Δzᵃᵃᶜ)` because the spacing in the halo region is extended from the interior points (and thus contains no new extrema).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866253813:387,extend,extended,387,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866253813,1,['extend'],['extended']
Modifiability,> The memory savings is a major advantage of this closure over `AnisotropicMinimumDissipation` for problems with very large numbers of tracers (eg biogeochemistry problems with 10+ tracers).; > ; > Note also that there is overhead to launching a kernel which cannot be ignored --- we can't estimate computational cost just by adding the number of operations. Typically (though not always) our goal is to reduce the number of kernel launches as much as possible. Good points. I also wasn't aware that the kernel launch time was an important issue. I'll close this PR and open another one extending `κᶠᶜᶜ()`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419839733:587,extend,extending,587,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419839733,1,['extend'],['extending']
Modifiability,"> The reason we used U10 in the ""theory wave"" is that the empirical relations we used to estimate the peak wave number are based on wind speed. We need a bulk formula to convert these relations to momentum flux. The relation between U10 and surface Stokes drift does vary with U10 (see, e.g., Fig. 6 of [Rascle & Ardhuin 2013](http://dx.doi.org/10.1016/j.ocemod.2012.12.001)). But Langmuir number also seems to vary with U10 even for fully developed waves (Below is an example showing the relation between the turbulent Langmuir number and U10 assuming Pierson-Moskowitz spectrum). So I'm not sure which way is better... @qingli411 curious your thoughts on Lenain and Pizzo (2020), who provide a model in terms of friction velocity. I think their opinion is that bulk formula tend to introduce further errors into an already approximate parameterization. I suppose this model wasn't available for prior work in 2017 so perhaps the situation is different now? One unique aspect of Lenain and Pizzo (2020) is that they can co-observe the air-sea flux directly (from R/P FLIP) along with high quality measurements of wave properties.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937:837,parameteriz,parameterization,837,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058503937,1,['parameteriz'],['parameterization']
Modifiability,"> There are a lot of new instances of `@allowscalar`, but rather than adding new instances we should be refactoring the tests so they don't appear. I added these because it was the only way to make tests pass locally. However, I can't fully reproduce tests results locally anyway, like I mentioned in my previous comment, so these may well be unnecessary (since these lines might be passing on buildkite).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411337468:104,refactor,refactoring,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411337468,1,['refactor'],['refactoring']
Modifiability,"> There could be consistency requirements between the treatment of pressure / height gradients in the momentum equation, and transport gradients in the continuity equation. @francispoulin do you know of any requirements here or is this not a concern?. Hmm, I don't believe so. If whatever finite volume scheme we use for the evolution of height, we will ensure mass is conserved. This presumably variable height will drive the motion, and that parts seems very distinct to me. However, if you wanted to ensure global conservation of energy, or something, maybe one needs to be careful about this? I don't believe this is a concern though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744544855:396,variab,variable,396,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-744544855,1,['variab'],['variable']
Modifiability,"> There's a lot of references to an 'embedded' model. Should we remove these @ali-ramadhan and simply call it a model ? It doesn't seem appropriate for documentation --- the model can be run without embedding it in anything. Yes, calling it a model and not an embedded model sounds like a good call. For context, the LaTeX notes I copied from envisioned this model being a super-parameterization or embedded model but this has changed since the notes were typeset.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470528243:379,parameteriz,parameterization,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/111#issuecomment-470528243,1,['parameteriz'],['parameterization']
Modifiability,"> There's no need for a new kernel because the diffusivities are `νₑ / Pr` so they can be calculated on the fly.; > ; > We need to extend `κᶠᶜᶜ` and `κᶜᶠᶜ` and `κᶜᶜᶠ`; > ; > ```julia; > @inline κᶠᶜᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑxᶠᵃᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; > @inline κᶜᶠᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑyᵃᶠᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; > @inline κᶜᶜᶠ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑzᵃᵃᶠ(i, j, k, grid, K.νₑ) / closure.Pr[id]; > ```. I may be missing something, but when I make those changes I still get the errors in #2869. The changes in this PR are the only ones I've tried that seem to solve the issue. I've implemented and pushed your solution to the [tc/smag-binary-op2 branch](https://github.com/CliMA/Oceananigans.jl/blob/tc/smag-binary-op2/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl) in case you wanna check if I understood your suggestion. Basically these are the changes:. https://github.com/CliMA/Oceananigans.jl/blob/56a76ae24d7199a3efe822d06969acc7b6ce6b16/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L127-L129. I'm getting a `device kernel image is invalid (code 200, ERROR_INVALID_IMAGE)` error with only those changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419454342:131,extend,extend,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419454342,1,['extend'],['extend']
Modifiability,"> Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions. Hopefully we don't have to pass boundary conditions 🥺 . Not all complexity is justified by the performance gains...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236:147,refactor,refactor,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236,1,['refactor'],['refactor']
Modifiability,"> This PR allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an interior kernel that calculates tendencies between, e.g., i = Hx and i = Nx - Hx, and a boundary kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries. @simone-silvestri I think this description is incomplete. Isn't there also a change to how the auxiliary computations are done?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1712193512:60,variab,variables,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1712193512,2,['variab'],['variables']
Modifiability,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:416,config,configuration,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850,2,['config'],['configuration']
Modifiability,"> This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm.; > ; > This PR also extends the tests to include non-uniform distributed partitioning; > ; > The proposal of this PR (up to discussion and tweaking) is to allow calling; > ; > ```julia; > arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); > ```; > ; > which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively. How would one manually specify the grid points on each rank with this API? This is a little non-standard since most of our APIs use words rather than symbols (ie it's not clear what `Rx` means just from reading the code).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912:134,extend,extends,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339#issuecomment-1762126912,2,['extend'],['extends']
Modifiability,"> This is WENO order 5 on a stretched grid on the GPU in the nonhydrostatic model right? Seems like the problem might be in the advection of `w`. look like an out of bound error. Maybe using explicit checkbounds it will point out the error. What version of the branch was working?. Yes it is. The manifest entry for the working version is. ```; [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""CUDAKernels"", ""Crayons"", ""CubedSphere"", ""Dates"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-rev = ""59cc53a3c6b579181932d55f94eae45ce51c6e14""; repo-url = ""https://github.com/CliMA/Oceananigans.jl.git""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.77.0""; ```. I couldn't quite figure out what version that refers to, but maybe you understand manifest entries better than I do...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940:372,Adapt,Adapt,372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1179773940,1,['Adapt'],['Adapt']
Modifiability,"> This is looking pretty good! My only comment is that it's not intuitive for a given user to figure out how to opt for a hydrostatic pressure separation. A flag called `separate_hydrostatic_pressure` that takes `true`/`false` would be much more intuitive, although we'd need a little more code. Should we prioritize user-friendliness here?. This is more flexible, because sometimes users want to have access to the pressure field prior to model construction. If we use a flag, then we either can't support that or have to put some annoying logic in the constructor. Since I feel it'll be rare that people want to change this kwarg, I think the trade-offs work out that its better to have a simpler constructor even if those rare users that want to separate hydrostatic pressure have to build `CenterField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711:355,flexible,flexible,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574#issuecomment-2088676711,2,['flexible'],['flexible']
Modifiability,"> This is of course a lot of overlap between this model and ShallowWaterModel. @francispoulin physically yes but numerically no. `ShallowWaterModel` uses a conservative formulation that solves for the thickness-weighted velocities `hu` and `hv`. Here we use the ""primitive"" variables `u`, and `v`. In addition to that, the free surface displacement equation is linearized. In the future, we could envision generalizing `HydrostaticFreeSurfaceModel` to have a nonlinear free surface and also to have a ""layered"" implementation that might use the thickness weighted velocities like `ShallowWaterModel`. At that point there might be overlap and we can consider merging the two and combining our work...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778464227:274,variab,variables,274,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-778464227,1,['variab'],['variables']
Modifiability,"> This looks like a symptom of a larger problem and, indeed, does not seem to be tested. I think to solve it we should fix the time-indexing of reduced FTS.; > ; > We seem to be missing the 4D indexing of reduced FTS:; > ; > ```julia; > @propagate_inbounds getindex(f::XYFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, i, j, 1, memory_index(f, n)); > @propagate_inbounds getindex(f::XZFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, i, 1, k, memory_index(f, n)); > @propagate_inbounds getindex(f::YZFTS, i::Int, j::Int, k::Int, n::Int) = getindex(f.data, 1, j, k, memory_index(f, n)); > ```; > ; > to be added [here](https://github.com/CliMA/Oceananigans.jl/blob/abb66e32d333562dd9aaeb7dd2ed8fac5e781368/src/OutputReaders/field_time_series_indexing.jl#L108); > ; > and the 2D-Time indexing of reduced FTS; > ; > ```julia; > @propagate_inbounds getindex(f::XYFTS, i::Int, j::Int, time_index::Time) = getindex(f, i, j, 1, time_index); > @propagate_inbounds getindex(f::XZFTS, i::Int, k::Int, time_index::Time) = getindex(f, i, 1, k, time_index); > @propagate_inbounds getindex(f::YZFTS, j::Int, k::Int, time_index::Time) = getindex(f, 1, j, k, time_index); > ```; > ; > maybe to be added [here](https://github.com/CliMA/Oceananigans.jl/blob/abb66e32d333562dd9aaeb7dd2ed8fac5e781368/src/OutputReaders/field_time_series_indexing.jl#L116); > ; > and all the respective methods for 1D and 0D FTS. In theory, the boundary conditions should work as intended. Indeed, we should add a test for it. and the GPU adapted versions right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251206241:1516,adapt,adapted,1516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251206241,1,['adapt'],['adapted']
Modifiability,"> This output writer works (but TimeInterval won't work):. One possibility is that there is a type promotion occurring within `align_time_step`:. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L24-L33. and. https://github.com/CliMA/Oceananigans.jl/blob/e16cdc6cfb67703df9e29368017868331f68b1c0/src/Simulations/run.jl#L133-L134. This would cause widespread issues in switching to single precision, so @simone-silvestri may want to take note. The quick fix is to convert after calculating the aligned time-step:. ```julia; Δt = aligned_time_step(sim, sim.Δt); Δt = convert(eltype(sim.model), Δt); ```. I think we need a more defined interface for this in the long run though. We really need both `eltype` (the floating point type used by state variables, grid metrics, etc) and a `timetype` (the type of `model.clock.time`). . (Also I'm not sure `eltype(model)` is defined yet, but it should be...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563:805,variab,variables,805,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732649563,1,['variab'],['variables']
Modifiability,> This provides another reason to include all the `Nz+1` face data for face-centered fields. Will this feature be easy to implement in the future?. So that comment is actually outdated now. The Neumann boundary conditions can be built into the `Nz x Nz` tridiagonal system. > Pretty simple PR I think because it basically just adds a test (please confirm... ?). Yes. It was originally going to add a vertically stretched pressure solver but then I realized it would be much better code design to do the refactoring I did PR #589 first then add the solver in. So this PR just adds a test that shows you can implement a vertically stretched pressure solver using the `BatchedTridiagonalSolver`. > I think the test may be incorrectly named and can also be greatly simplified. I'm not sure if the test is 1) not achieving its intended purpose or 2) is over-complicated. Either way I think it should be cleaned up a bit before merging. Yes it is unfortunately over-complicated because there is no abstraction for a vertically stretched grid or a stretched pressure so they are implemented in the test itself. This test will be massively cleaned up in PR #543.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/306#issuecomment-572266779:503,refactor,refactoring,503,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306#issuecomment-572266779,1,['refactor'],['refactoring']
Modifiability,> This warning means that you didn't configure MPI correctly to work with julia. There is some documentation on how to do it [here](https://juliaparallel.org/MPI.jl/stable/configuration/). We should add a link in the docs to this webpage. So I went to that doc pages but I wasn't sure -- do I need to install MPIPreferences? There is no other way?; We should definitely add a link to that docs page then.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278718087:37,config,configure,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278718087,2,['config'],"['configuration', 'configure']"
Modifiability,"> Thus because I do not think we should regard Value / Gradient boundary conditions as a ""core"" feature (this package is oriented towards ocean modeling from large eddy simulation up to global scales --- direct numerical simulation is not our core application) the trade-off points towards not supporting this. Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on **non-immersed** boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. I can't really conceive of any reasons why one would want Value / Gradient BCs on the immersed boundary though, and agree it is not alone worth a major refactor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690256956:915,refactor,refactor,915,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690256956,1,['refactor'],['refactor']
Modifiability,"> To properly handle the checkpoint pickup, we manually adjusted the actuation to match the correct value based on the pre-pickup simulation. Here's an [example](https://github.com/liuchihl/Oceananigans.jl/blob/correct-averagedtimeinterval/test_netcdf_timeaverage.jl#L105-L116) to illustrate what I mean.; While this resolves the issue of checkpoint for now, it's more of a workaround. Agree we need to refactor the Checkpointer. Thank you for documenting a way to proceed for the time being.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433143553:403,refactor,refactor,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2433143553,1,['refactor'],['refactor']
Modifiability,"> Using a discretized version of the thermal wind balance is a sound suggestion, but it does not explain why the error only appears when evolving the total fields. Why not? When evolving the total fields, the condition of geostrophic balance is computed during the prognostic evolution of the total variables. When evolving just the perturbation, the algorithm for mean-perturbaiton decomposition _assumes_ that the mean fields are balanced. There is no need to worry about the tiny difference between discrete and continuous balance in the case that you only evolve perturbations. But if you want to evolve the geostrophically balanced state, you must ensure that it is perfectly balanced to within machine precision, or you will have an adjustment. That's the basis for my suggestion. I'm not sure the computation I recommended achieves numerical balance (something might be missing) --- that should be checked.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487:299,variab,variables,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1712196487,3,"['evolve', 'variab']","['evolve', 'variables']"
Modifiability,"> Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :). I see what you're saying @dhruvbalwada ... ! :-D Maybe `IsopycnalTensorDiffusivity` ? The thing is, when users build this closure they have the option only to set _coefficients_ (which may be constants or nonlinear functions of model variables) of two tensors --- an ""isopycnal rotation tensor"" that is symmetric and rotates a vector into the isopycnal plane, and another skew-symmetric or antisymmetric tensor. So the tensor is not general; it has a specific form... On the other hand I think we are leaning towards more substantial changes to this parameterization than would be covered by this name. So we could have one `IsopycnalTensorDiffusivity` corresponding only to the symmetric component, and another `GentMcWilliamsDiffusivity`(or something?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-972010093:476,variab,variables,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-972010093,2,"['parameteriz', 'variab']","['parameterization', 'variables']"
Modifiability,> We could further simplify the time stepping code if we adapt the Field abstraction to be GPU compatible (#298). Just a note: I attempted this while working on abstract operations and was unable to solve the problem. But we are using new versions of julia + cuda tools all the time so it is / will be worth revisiting,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589270716:57,adapt,adapt,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631#issuecomment-589270716,1,['adapt'],['adapt']
Modifiability,"> We could procede in a couple of ways from here:. Let me provide a few other options:. * Compute the 2D boolean masks for reduced operations in `x`, `y`, and `z` when forming `ImmersedBoundaryGrid`. Then, use those masks for conditional differencing of reduced fields, rather than calling `immersed_inactive_node`. * For `GridFittedBottom` and `PartialCellBottom`, as a stop gap, define these methods:. ```julia; @inline conditional_δx_f(ℓy, ℓz, i, j, k, ibg::GFBIBG, δx, r::ZIRF, args...) = ifelse(immersed_inactive_node(i, j, ibg.Nz, ibg, c, ℓy, ℓz) |; immersed_inactive_node(i-1, j, ibg.Nz, ibg, c, ℓy, ℓz),; zero(ibg),; δx(i, j, k, ibg.underlying_grid, r, args...)). ```. That use a condition based on whether `k == Nz` is immersed. This will fix fields that are reduced in `z` without increasing memory storage or doing a computation in the immersed boundary grid constructor. And that's the most common case anyways. * When building a `ReducedField`, compute the mask that has to be applied to abstract operations. Then, extend the `_derivative` constructor for the combination of a `ReducedField` argument + `ImmersedBoundaryGrid` using conditional operation. This has the advantage of avoiding the mask computation in `ImmersedBoundaryGrid` (since its only needed to do operations on reduced fields). The disadvantage is that different reduced fields have to redo the computation. Also, this only fixes abstract operations and does not fix the internal operators. We also have to update the conditional operators to throw away the immersed boundary grid for reduced fields, or throw away the immersed boundary grid inside the abstract operation. * A variant on the above approach is to compute the mask when forming `Derivative`. But then a new mask is computed for every operation. There's probably a lot of other options. Keep the brainstorming coming.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099195353:1028,extend,extend,1028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099195353,1,['extend'],['extend']
Modifiability,> We should also add a test similar to the one that was added in #3512. Doesn't that already exist? . We just have to adapt the test,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2000835614:118,adapt,adapt,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515#issuecomment-2000835614,1,['adapt'],['adapt']
Modifiability,"> We should modify the netCDF variable names to `λF`, `λC` or something... I didn't do this in #2979 because I didn't know if NetCDF allows unicode (and because I felt it was outside of the scope of that PR). Sorry for the delay in chiming in here. Yes, NetCDF works fine with unicode, but I suspect that due to the [SGRID conventions](https://sgrid.github.io/sgrid/) we will have to name our coordinate a default, non-unicode name, which will be different from the names we use in Oceananigans. ~The downside of this is that I think it'll be a bit harder to output spacings and other metrics separately in meters and degrees, which I think would be useful for curvilinear coordinates.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188:30,variab,variable,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1516631188,1,['variab'],['variable']
Modifiability,"> Were you suggesting to combine these in a single `k`-long tuple, e.g.,; > ; > ```julia; > gravitational_acceleration .* (1, (ρ[k] - ρ[k-1]) / ρ[k-1], (ρ[k-1] - ρ[k-2]) / ρ[k-2], ..., (ρ[2] - ρ[1]) / ρ[1] ); > ```; > ; > which will become a number for single layers?. Yes, that's exactly what I was suggesting, since gravitational_acceleration could be understood as the value of g that each layer feels, so not sure why we need different parameters for both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1472879794:260,layers,layers,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1472879794,1,['layers'],['layers']
Modifiability,"> What I meant about trusting users for auxiliary fields is that you can do e.g. this: `model = NonhydrostaticModel(; grid, auxiliary_fields=(; A = randn(1, 2))` and it doesn't error. Why do we want to support arrays in `auxiliary_fields`?. The main usage for `auxiliary_fields` is that they can be invoked in continuous-form forcing functions. In that usage they have to be `AbstractField`, otherwise we can't figure out how to interpolate them into a forcing function. `auxiliary_fields` isn't meant to be a place to store just any information needed for a model (what would the purpose of that be?) We can adapt `auxiliary_fields` but it would be good to understand why. Separately, perhaps we should check that all `auxiliary_fields` are `AbstractField`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269340649:609,adapt,adapt,609,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269340649,1,['adapt'],['adapt']
Modifiability,"> What about on a non-immersed rectilinear spaced grid? The reduction is a little different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:583,variab,variable,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,5,"['Config', 'config', 'variab']","['Config', 'Configuration', 'config', 'variable']"
Modifiability,"> What about the topologically aware operators PR? Should that come first? That seems to me to be the most significant improvement.; > ; > Note there are some changes on #3867 to respect. Right, I guess we can first #3268, then #3841 and then we can refactor the split explicit code",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3873#issuecomment-2441610553:250,refactor,refactor,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3873#issuecomment-2441610553,1,['refactor'],['refactor']
Modifiability,"> What does `find_neighboring_panels` do that is not already included in the `grid.connectivity`? `find_neighboring_panels` seems like a bit of a ""hack"" to me that only works for 1-region-per-panel configs? `grid.connectivity` is general. Why don't we use the grid's connectivity to read out the rank of the neighboring panels.; > ; > (I really should have made this comment in #3488, but it's never too late..). It's been taken care of in commit [5cffc13](https://github.com/CliMA/Oceananigans.jl/pull/3547/commits/5cffc139eb93c1afbd68c520a95e21ba56d73990).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2046332671:198,config,configs,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2046332671,1,['config'],['configs']
Modifiability,> What make sense logically is that `validate_closure` is called first. Because if it's not a valid closure why bother doing anything else...; > ; > But I'm not sure if it's difficult to refactor. I don't think its hard.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2347634362:187,refactor,refactor,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2347634362,1,['refactor'],['refactor']
Modifiability,"> When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!. Thanks for asking the question! Also is it ok if I convert to discussion? If it remains an issue we might lose track of it when the issue is closed. But this might be useful to people if its more visible. > Why you need to define f², wouldn't work simply using ∂zᶠᶜᶠ and squaring the operation?. Because we need to interpolate `∂zᶠᶜᶠ` using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:84,parameteriz,parameterization,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,2,['parameteriz'],['parameterization']
Modifiability,"> Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?. I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; ```julia; transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.forward.x!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ; # Perform the implicit vertical solve here on storage.zfield... transpose_z_to_y!(storage); solver.plan.backward.y!(parent(storage.yfield), buffer.y); transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.backward.y!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ```. This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003:231,adapt,adapted,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003,1,['adapt'],['adapted']
Modifiability,"> Where in the model should we store the forcing array in this case?. The user would define an array in a script, declare it `const` to the compiler, and then write a function that indexes into it as a global:. ```julia; # define a; forcing(..., i, j, k) = a[i, j, k]; ```. We can also include a constructor for `Forcing` that allows the user to pass some function that defines a constant array, and set up the same functionality internally. > The main motivation being that we don't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write 5! = 120 new functions. The update_source_terms! function is already 52 lines long so I'd rather avoid having to dispatch on this function. I think the problem is that our functions are trying to do too much at once. We need smaller functions that perform more atomic operations so we can dispatch on atomic operations. I don't think we need to re-invent multiple dispatch with macros. We just need to refactor the code so we can use multiple dispatch effectively.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414:1027,refactor,refactor,1027,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414,1,['refactor'],['refactor']
Modifiability,"> Work with FieldTimeSeries as if it were a 4D array (with operations ignoring the halos). To clarify, are you referring to getting broadcasting and reduction to work?. If so I would clarify this comment: we need to extend our existing broadcasting and reduction machinery for 3D fields to 4D field time series. The problem is not merely to avoid operations on halos, but also to correctly interpolate between locations on a staggered grid and correctly apply derivatives on arbitrary grids. The built-in broadcasting machinery launches kernels via `launch!` so such functionality avoids operations on halos like all other `launch!` kernels.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835433735:216,extend,extend,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835433735,1,['extend'],['extend']
Modifiability,"> Yes, most containers are ""adapted"" on the GPU. We adapt `field` to `field.data`:; > ; > https://github.com/CliMA/Oceananigans.jl/blob/7debded91d24520d72857c120303bcd22b805104/src/Fields/field.jl#L394; > ; > And note that `field.data` will be further adapted. For example, `CuArray` becomes `CuDeviceArray`. GOTHCA!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370321014:28,adapt,adapted,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370321014,3,['adapt'],"['adapt', 'adapted']"
Modifiability,"> You can use `FluxBoundaryCondition` with `closure=nothing` (it's `Value` and `Gradient` that won't work). You can obtain global dissipation by differencing globally integrated TKE (and perhaps a pointwise dissipation by evaluating the TKE budget), but I agree that it's probably more difficult. @simone-silvestri may have some tips as he has been developing an implicit LES scheme for mesoscale turbulence.; > ; > Does `AnisotropicMinimumDissipation` work? Or other closures?. Nice catch! It does work for AMD. I hadn't tried that before because I assumed it wasn't gonna work. Unfortunately I can't really use AMD because it produces a lot of noise in the stratified regions of my domain, but hopefully adapting Smag isn't too hard?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403796249:706,adapt,adapting,706,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403796249,1,['adapt'],['adapting']
Modifiability,"> ```julia; > u_subsampled = XFaceField(subset_grid); > ; > function subsample_u(model); > u = model.velocities.u; > interpolate!(u_subsampled, u); > return u_subsampled; > end; > ; > outputs = (; u=subsample_u); > ```. I see, so there is no way to make this seamlessly work with a NamedTuple I already have with all variables I want to output?; I would need to create a function for each of the variables?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032422385:317,variab,variables,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2032422385,2,['variab'],['variables']
Modifiability,"> `clobber=false` is probably safer. That's what I was thinking too but apparently with NCDatasets.jl the other modes are append (`""a""`) and read-only (`""r""`) so if you're creating files for the first time (the most common use case) then clobber must be used. Otherwise you get NetCDF errors when it tries to open a non-existent file. > Named tuples are trivial to support; but maybe users don't care. Personally, I much prefer them in the JLD2OutputWriter. I actually wasn't able to get named tuples to work with JLD2 but I opened an issue about that: #562. I don't see the big advantage of a `NamedTuple` over a `Dict` in this case so I'm going to keep it simple and stick to named tuples here for now. The original point of this PR was that the documentation was wrong. `NetCDFOutputWriter` needs to be refactored a little anyways, and I'd like to add some features to it as well so I'll add support for named tuples then.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-564362931:806,refactor,refactored,806,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/556#issuecomment-564362931,1,['refactor'],['refactored']
Modifiability,"> and the GPU adapted versions right?. right, should be accounted for if we define the 1D and 0D FTS as we do the 2D ones; ```julia; const XYFTS = FlavorOfFTS{<:Any, <:Any, Nothing, <:Any, <:Any}; const XZFTS = FlavorOfFTS{<:Any, Nothing, <:Any, <:Any, <:Any}; const YZFTS = FlavorOfFTS{Nothing, <:Any, <:Any, <:Any, <:Any}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251230309:14,adapt,adapted,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3663#issuecomment-2251230309,1,['adapt'],['adapted']
Modifiability,"> but I guess you are telling me that it defaults to the position of the first variable?. Correct. > Actually, I needed to use model.solution.uh instead of uh and it seems to be working better (but I'm not done). Does that make sense or am I missing something. My apologies for being unclear! I would write. ```julia; uh, vh, h = model.solution; u = ComputedField(uh / h); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760280879:79,variab,variable,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1305#issuecomment-760280879,1,['variab'],['variable']
Modifiability,"> forcing at the surface to generate mixing (through convection or mechanical stress), while the forcing in the interior restores the stratification. Hi there. Talked briefly about this with @zhenwu0728 earlier and was suggesting something along those lines for the physics too. I could imagine additional applications for configs like these and am willing to help with e.g. exploring the parameter space a bit if needed. Maybe the simplest, yet rather tunable, approach I could think of would be something like:. - at the top: warming (e.g. via relaxation to SST0) + wind stress to mechanically generate turbulence; - below a certain depth z1: cooling (e.g. via relaxation to T1<SST0) to restore to positive stratification. I feel that this simple approach should lead to a statistically steady stratification within an appropriate ranges of [SST0 T1 z1] and piston velocities. . With this basic config in place, which maybe is not far from your `examples/ocean_wind_mixing_and_convection.jl`, my guess is that adding a diel or seasonal mixed layer deepening is straightforward -- e.g. via a time variation in SST0. Does that make sense? Am I missing something obvious?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629517072:323,config,configs,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/749#issuecomment-629517072,2,['config'],"['config', 'configs']"
Modifiability,"> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)). Nope, it's not erroring on main. ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); 1×1×3 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [1.0, 16.0] variably spaced with min(Δz)=3.0, max(Δz)=7.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757850869:330,variab,variably,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3331#issuecomment-1757850869,1,['variab'],['variably']
Modifiability,"> in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit.; > ; > The other option to not use MPI variables is to hardcode the number of processors. This advice seems to contradict the goal of having scripts that can be changed from non-distributed to distributed with a single line. I don't think user scripts should have to write `using MPI`. The API should have all the features necessary to support ""one-click"" distributed simulations. When we see `using MPI`, it measn that the API is incomplete and we have work to do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894651642:86,variab,variables,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1894651642,2,['variab'],['variables']
Modifiability,"> right, `particle` is a list of particles though. `p` is the index that we have to pass in. we can call it forcing but it is specifically an advective forcing (or velocity forcing) because it is added to the velocity. That's a detail and can be implemented regardless of the type of interface. The difference is. 1. Users _extend_ an Oceananigans function to implement a forcing, OR; 2. Users pass a function into `ParticleAdvectiveForcing` to implement a forcing. Option 1 is fine, no doubt. It's just that the rest of our user interfaces implements option 2. I think we should have a uniform interface across the code. Our original motivation for choosing option 2 is because we believed it would be easier to use for people who don't know Julia very well. People should be able to use Oceananigans without knowing what ""multiple dispatch"" is. We can revisit this. If we think that extending forcing function is a better pattern, we should change it throughout the code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238:885,extend,extending,885,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1819345238,1,['extend'],['extending']
Modifiability,"> right, sorry I confused `i, j, k` with particle position, I meant we have to pass the particle position `x, y, z`. Ah ok, that makes more sense!. The particle position is available via. ```julia; x = particles[p].x; ```. etc right?. We should implement a helper function,. ```julia; position(p) = (p.x, p.y, p.z); ```. Note that particles are also annoying on `Flat` grids. One needs to beware the particle position in the `Flat` direction, but they shouldn't have to. The same issue will affect `interpolate` once we merge #3395 . EDIT: even better would simply be to extend `interpolate` to work with the particle as an argument, eg something like. ```julia; up = interpolate(particles[p], u, u_loc, grid); ``` . I think ultimately it would be nice to push this under the hood with some nice user interface for `ParticleVelocity` or whatever",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876:571,extend,extend,571,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1854245876,2,['extend'],['extend']
Modifiability,> the time integral when we use variable time stepping that is a feature we use quite often. What do you mean by this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313367035:32,variab,variable,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313367035,1,['variab'],['variable']
Modifiability,"> then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. To re-use that code with a new `condition`, we can use a nesting technique:. ```julia; function getbc(open_bc::OpenBoundaryCondition, ...); state_value = getbc(open_bc.condition.external_state, ...); # other stuff related to matching; end; ```. This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. You could make the point that we have less _new_ code to write though, if we implement a design that allows conditions to be the same. And for users, this could be clearer, so I see the advantage of that. On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. So I see pros and cons to both, but the good news is that we can actually talk coherently about the pros and cons. And if there are other pros and cons please mention them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194:20,rewrite,rewrite,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194,4,['rewrite'],['rewrite']
Modifiability,"> these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature.; > ; > We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. I would include:; > ; > * buoyant particles (sinking or rising with a density-dependent vertical velocity); > * particles with drag. The discussion is fine but we first need to resolve something more fundamental: the particles do not have indices `i, j, k`. The only way to use Eulerian fields to determine particle forcing is to `interpolate` the Eulerian fields to the location of the particle. Obviously, that's how advecting particles works in the first place, by interpolating the velocity field to the location of the particle.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287:120,variab,variables,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852941287,1,['variab'],['variables']
Modifiability,> we need to extend our existing broadcasting and reduction machinery for 3D fields to 4D field time series. @glwagner Reductions on `Field`s don't all work on `master` but work now (without the `interior_copy` version) but trigger scalar operations on the GPU. Might be worth doing a bit of pair programming later around this? I'll see if I can add some CPU tests which should pass.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-839405428:13,extend,extend,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-839405428,1,['extend'],['extend']
Modifiability,> when I run; > ; > ```shell; > (base) navid:OceananigansDistributedExamples/ (glw/docs2) $ mpiexec -n 2 julia --project distributed_example.jl; > ┌ Warning: You appear to have run julia under a different `mpiexec` than the one used by MPI.jl.; > │ See the documentation for details.; > └ @ MPI ~/.julia/packages/MPI/is7GN/src/environment.jl:26; > ```. This warning means that you didn't configure MPI correctly to work with julia. There is some documentation on how to do it [here](https://juliaparallel.org/MPI.jl/stable/configuration/). We should add a link in the docs to this webpage,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278388760:388,config,configure,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2278388760,2,['config'],"['configuration', 'configure']"
Modifiability,"> yep broadcasting works. My thought was that `plan` can be hacked to store unified memory. I still have to look at the data structure to see how to do it.; > ; > cufftxt basically works in the same way (local FFT direction distributed among the workers then transpose and nonlocal FFT). I am not sure they use unified memory but they for sure use transposes https://on-demand.gputechconf.com/gtc/2014/presentations/S4788-rapid-multi-gpu-programming-cuda-libraries.pdf. Mmm ok. Is this proposal a way to avoid cuffxt basically? I think what you outlined is somehow roughly how PencilFTTs work:. 1. FFT along local direction (dim=1); 2. Simultaneously communicate and permute data to (2, 1, 3) (or is it (2, 3, 1)?); 3. FFT along local direction (dim=2); 4. Simultaneously communicate and permute data to (3, 2, 1); 5. FFT along dim=3. At the end, the data has permutation (3, 2, 1). The backwards transform then reverses this process. `solver.storage` is actually a tuple of 3 preallocated arrays to support this algorithm. For the tridiagonal solver I think we want to use the same algorithm, except that we skip step 1 (ie the first step is to communicate and permute data with no transform). Once the two other transforms are complete we have data in the configuration (x, y, z) where z is local, and we can do a tridiagonal solve in eigenfunction space. Then we transform back and obtain data back in the (z, y, x) permutation, with z local, and copy into the pressure. We have to extend the tridiagonal solver to accomodate this kind of permutation for distributed CPU, so if we have an algorithm like the one above we can then also use it for MultiRegionGrid solves on the GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674:1258,config,configuration,1258,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119916674,2,"['config', 'extend']","['configuration', 'extend']"
Modifiability,"> you are referring to including the horizontal components of the rotation vector within the tangent plane approximation?. Ah I should have been clearer. For the Cartesian domains we might want `FullCoriolis` but including the cosine term would only make sense if we're running on a sphere. > Do you think that we should not have the concept of a molecular transport coefficient at all?. I think it makes sense to have this, especially so that the default is a DNS. Not sure if this is the most common use case, in which case maybe we can spit out a warning to new users so they know what they're running. > The point is that density is not a variable in a Boussinesq code and the value of the reference density has no effect on the dynamics. This makes sense to me, but then I'm wondering if ρ₀ is important to know to calculate diagnostics etc. where should we store it? EOS makes the most sense to me as a storage place even though it doesn't influence the dynamics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491866754:643,variab,variable,643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491866754,1,['variab'],['variable']
Modifiability,">On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when bors try or bors r+ is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Definitely looking forward to that PR. > Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster and easier to maintain, if we are careful. I definitely agree with that. I just don't see how to do it. Being thorough with the tests (which I believe is something we want) necessarily comes with using the API many times, making changes to it a bit slower to implement, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440:731,rewrite,rewrite,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922529440,2,['rewrite'],['rewrite']
Modifiability,"@BrodiePearson I refactored `StokesDrifts.jl` very slightly --- I agree with the new terms you added!. I put together this script that reproduces the ""deep Eulerian return flow"" from McIntyre (1981):. ```julia; using Oceananigans; using Oceananigans.Units; using GLMakie. ϵ = 0.1; λ = 60 # meters; g = 9.81. const k = 2π / λ. c = sqrt(g / k); const δ = 1kilometer; const cᵍ = c / 2; const Uˢ = ϵ^2 * c. @inline A(ξ) = exp(- ξ^2 / 2δ^2); @inline A′(ξ) = - ξ / δ^2 * A(ξ); @inline A′′(ξ) = (ξ^2 / δ^2 - 1) * A(ξ) / δ^2. # Write the Stokes drift as; #; # uˢ(x, z, t) = A(x, t) * ûˢ(z); #; # which implies. @inline ûˢ(z) = Uˢ * exp(2k * z); @inline uˢ(x, z, t) = A(x - cᵍ * t) * ûˢ(z); @inline ∂z_uˢ(x, z, t) = 2k * A(x - cᵍ * t) * ûˢ(z); @inline ∂t_uˢ(x, z, t) = - cᵍ * A′(x - cᵍ * t) * ûˢ(z). # Note that if uˢ represents the solenoidal component of the Stokes drift,; # then; #; # ```math; # ∂z_wˢ = - ∂x_uˢ = - A′ * ûˢ .; # ```; #; # We therefore find that; #; # ```math; # wˢ = - A′ / 2k * ûˢ; # ```; #; # and. @inline ∂x_wˢ(x, z, t) = - 1 / 2k * A′′(x - cᵍ * t) * ûˢ(z); @inline ∂t_wˢ(x, z, t) = + cᵍ / 2k * A′′(x - cᵍ * t) * ûˢ(z). stokes_drift = StokesDrift(; ∂z_uˢ, ∂t_uˢ, ∂t_wˢ, ∂x_wˢ). grid = RectilinearGrid(size = (256, 64),; x = (-5kilometers, 15kilometers),; z = (-512, 0),; topology = (Periodic, Flat, Bounded)). model = NonhydrostaticModel(; grid, stokes_drift,; tracers = :b,; buoyancy = BuoyancyTracer(),; timestepper = :RungeKutta3). # Set Lagrangian-mean flow equal to uˢ,; uᵢ(x, z) = uˢ(x, z, 0). # And put in a stable stratification,; N² = 0; bᵢ(x, z) = N² * z; set!(model, u=uᵢ, b=bᵢ). Δx = xspacings(grid, Center()); Δt = 0.2 * Δx / cᵍ; simulation = Simulation(model; Δt, stop_iteration = 600). progress(sim) = @info string(""Iter: "", iteration(sim), "", time: "", prettytime(sim)); simulation.callbacks[:progress] = Callback(progress, IterationInterval(10)). filename = ""surface_wave_induced_flow.jld2""; outputs = model.velocities; simulation.output_writers[:jld2] = JLD2Ou",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085:17,refactor,refactored,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1832988085,1,['refactor'],['refactored']
Modifiability,"@Mikejmnez , could you maybe say a bit more of what you are hoping to do? If you initialize your flow to have a constant shear, for example, then there is a velocity associated with that shear and it will evolve because of the mometnum equations. . If you wanted a simple toy problem, we might be able to do something with `ShallowWaterModel`. It might be simple enough for your purposes, depending on what you wanted to learn, but that would be orthogonal to this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768492710:205,evolve,evolve,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/958#issuecomment-768492710,1,['evolve'],['evolve']
Modifiability,"@Sbozzolo, did I remove all the ENV variables I should have removed?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3489:36,variab,variables,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3489,1,['variab'],['variables']
Modifiability,"@Tinydog8 let me know if you're ok to convert this to discussion. Here's a sketch of how to accumulate `u_wm`:. ```julia; u_wall_model = XFaceField(grid, indices=(:, :, 1)) # It's purely a niceity to specify `indices` properly here --- the only thing we really need is a 2D array. # Also define other velocity components as needed; # Define drag boundary condition in terms of u_wall_model, other velocity components, etc using the `discrete_form=true`. # This function is meant to be used in a callback; function compute_wall_model_velocity!(sim); u, v, w = sim.model.velocities. filtering_time_scale = 1.0 # seconds --- for example; ϵ = sim.Δt / filtering_time_scale. u_wm = interior(u_wall_model, :, :, 1) # extract a view to broadcast over; u_LES = interior(u, :, :, 1) # a view into the LES velocity within the first grid cell; @. u_wm = (1 - ϵ) * u_wm + ϵ * u_LES. # Compute other components as needed; return nothing; end. simulation.callbacks[:wall_model] = Callback(compute_wall_model_velocity!); ```. An even more slick approach would build new auxiliary fields for the wall model velocities. In that case (if I'm not mistaken), then the wall model velocities are accessible from the argument to the boundary condition function (and don't have to be referenced as global variables).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493:1281,variab,variables,1281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1654114493,1,['variab'],['variables']
Modifiability,"@ali-ramadhan and I have discussed a potential redesign of `Simulation` and `run!` that has several key features:. 1. Coalesce all of the ""callbacks"" (arbitrary functions that are executed during a time-stepping loop) other than `OutputWriter`s into a single list. Current objects that we can classify / redesign as callbacks are: stop criteria, `TimeStepWizard`, and diagnostics. All callbacks are required to possess `callback.schedule`, and we can provide convenience objects for coupling simple callback functions to `AbstractSchedule`. 2. Within the time-stepping loop, execute `simulation.callbacks` prior to writing output. This ensures that data calculated in a callback can be output during the same time-step, such as `WindowedTimeAverage` and other non-local-in-time output. 3. Wrap the time-stepping loop inside a `try / catch` block and throw exceptions to stop a simulation. This generalizes the concept of stopping a simulation and also means that a simulation can be stopped inside any callback. Further, when an `AbstractStopException` is called we will loop over the `OutputWriter` callbacks a final time, passing the exception into the `OutputWriter` callback functions. This allows output behavior specialized on the type of exception. For example: . * If `NaNsDetected` is thrown, no output will be written.; * If `WallTimeExceeded` is thrown, the checkpointer may write output. 4. `simulation.Δt` becomes a number corresponding to the next time-step, always (rather than sometimes being a `TimeStepWizard`). The `TimeStepWizard` callback changes this number on its `schedule`. Otherwise, the time-step is held constant. This changes the API, since the initial time-step must now be provided to `Simulation`. 5. (Somewhat unrelated, but enabled by the new pattern) Use a new function `align!(simulation.Δt, writer.schedule, simulation.model)` to adjust a subsequent time-step if output writing is scheduled. This ensures output writing on `TimeInterval`s will always be on `schedu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1138:483,coupling,coupling,483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1138,1,['coupling'],['coupling']
Modifiability,"@ali-ramadhan does makes a fair point. But there will be some learning curve either way... The user should either know some git, or they should be familiar with Julia's syntax, or Julia's project management (`julia --project=...`). To that extend, perhaps the doc instructions could suggest few avenues that the user can start running the examples. Cloning the repo could be one of them. But also copy-paste from the docs after ensuring the the proper `Project.toml` is instantiated could also be a viable option!. By the way Literate.jl provides ways to output the examples in different forms other than markdown for the docs.; https://fredrikekre.github.io/Literate.jl/v2/outputformats/; With some pre/postprocessing we can have Literate.jl strip out things like `nothing #hide` and then point the users to cleaner `.jl` scripts or Jupyter notebooks.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1149#issuecomment-724231746:240,extend,extend,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1149#issuecomment-724231746,1,['extend'],['extend']
Modifiability,@ali-ramadhan let's focus first on #3801 and then we can revisit this PR. There are some additional challenges to resolving #3791 unfortunately that will also require some test refactoring.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2383828408:177,refactor,refactoring,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2383828408,1,['refactor'],['refactoring']
Modifiability,"@ali-ramadhan, the docs log says:; ```; ┌ Info:;   | │ Buildkite config:;   | │ Commit branch: ""tomchor-patch-1"";   | │ Pull request: ""false"";   | │ Commit tag: """";   | │ Detected build type: devbranch;   | │ - ✘ ENV[""BUILDKITE_BRANCH""] matches devbranch=""master"";   | │ - ✔ ENV[""DOCUMENTER_KEY""] exists;   | └ Deploying to folder ""dev"": ✘; ```; Seems like buildkite will only reply from master? I don't see where that setting in buildkite is though...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187:65,config,config,65,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782282187,1,['config'],['config']
Modifiability,"@elise-palethorpe, I don't see the AMGX package in `Project.toml` nor in `Manifest.toml`. Btw, when I tried to add it locally on my Mac I got this:. ```Julia; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. (Oceananigans) pkg> st; Project Oceananigans v0.77.1; Status `~/Research/OC.jl/Project.toml`; [c963dde9] AMGX v0.1.2; [79e6a3ab] Adapt v3.3.3; [2169fc97] AlgebraicMultigrid v0.5.1; [052768ef] CUDA v3.11.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.5.0; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.12.6; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.5; [4a48f351] PencilFFTs v0.14.0; [6038ab10] Rotations v1.3.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.11; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:564,Adapt,Adapt,564,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['Adapt'],['Adapt']
Modifiability,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:543,variab,variables,543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441,1,['variab'],['variables']
Modifiability,"@francispoulin and I ran some of the strong and weak scaling scripts recently up to 128 CPU cores. An extra bit of code was added into the files that handled the plotting. Also added was a small but vital configuration adjustment for the @benchmark macro which allowed for more than 64 cores to be benchmarked without what is perceived as deadlocking from occurring. I will PR my all my changes made to the benchmarking scripts shortly. Here are the results:. weak scaling shallow water model, with grid size being 8192 x 512R where R is the number of cores:; ```; ┌───────────────┬──────────┬─────────┬─────────┬─────────┬─────────┬──────────┬────────┬─────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼──────────┼─────────┼─────────┼─────────┼─────────┼──────────┼────────┼─────────┤; │ (8192, 512) │ (1, 1) │ 1.464 s │ 1.464 s │ 1.465 s │ 1.466 s │ 1.60 MiB │ 2804 │ 4 │; │ (8192, 1024) │ (1, 2) │ 1.475 s │ 1.475 s │ 1.477 s │ 1.486 s │ 1.49 MiB │ 3146 │ 8 │; │ (8192, 2048) │ (1, 4) │ 1.472 s │ 1.475 s │ 1.477 s │ 1.509 s │ 1.49 MiB │ 3146 │ 16 │; │ (8192, 4096) │ (1, 8) │ 1.500 s │ 1.503 s │ 1.508 s │ 1.537 s │ 1.49 MiB │ 3146 │ 32 │; │ (8192, 8192) │ (1, 16) │ 1.545 s │ 1.578 s │ 1.593 s │ 1.682 s │ 1.49 MiB │ 3146 │ 64 │; │ (8192, 16384) │ (1, 32) │ 1.744 s │ 1.803 s │ 1.805 s │ 1.894 s │ 1.49 MiB │ 3146 │ 96 │; │ (8192, 32768) │ (1, 64) │ 1.723 s │ 1.792 s │ 1.795 s │ 1.868 s │ 1.49 MiB │ 3155 │ 192 │; │ (8192, 65536) │ (1, 128) │ 1.679 s │ 1.809 s │ 1.811 s │ 1.907 s │ 1.49 MiB │ 3155 │ 384 │; └───────────────┴──────────┴─────────┴─────────┴─────────┴─────────┴──────────┴────────┴─────────┘. Shallow water model weak scaling speedup; ┌───────────────┬──────────┬──────────┬────────────┬──────────┬─────────┐; │ size │ ranks │ slowdown │ efficiency │ memory │ allocs │; ├───────────────┼──────────┼──────────┼────────────┼──────────┼─────────┤; │ (8192, 512) │ (1, 1) │ 1.0 │ 1.0 │ 1.0 │ 1.0 │; │ (8192, 1024) │ (1, 2) │ 1.00706",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-864572422:205,config,configuration,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-864572422,1,['config'],['configuration']
Modifiability,"@francispoulin explained the situation well for `Gradient` and `Value` boundary conditions. I'd like to restate what he said in the context of the finite volume method and clarify the situation for `Flux` boundary conditions because I said something wrong above... Oceananigans uses a weak formulation of PDEs via the finite volume method. We evolve the average value of fields, integrated over a cell volume. In this integral formulation there are two contributions to the tendency of a field: fluxes across cell interfaces (advective and diffusive usually, but also possibly others via user-defined forcing), and interior ""sources"" (such as pressure gradients, Coriolis forces, gravitational forces). When users invoke `Gradient` or `Value` boundary conditions, then the same model is used for fluxes across interior cell interfaces as for ""exterior"" interfaces (domain boundaries). Thus if users set `closure=nothing` and zero out diffusive fluxes, boundary fluxes are _always_ zero regardless of what `Gradient` or `Value` are specified. More specifically, we enforce `Gradient` or `Value` boundary conditions by filling halo regions and then calculating exterior fluxes using the same kernel that's evaluated in the interior. As @francispoulin points out this is not some quirk of our algorithm or numerics; this follows from the properties of the underlying PDE. Something different happens when `Flux` boundary conditions are specified and this is where I was wrong above. With `Flux` boundary conditions, users are really specifying two _different_ models for fluxes: one across ""interior"" cell interfaces, and another for fluxes across domain boundaries. Setting `closure=nothing` in this case only nullifies _interior_ diffusive fluxes. But since boundary fluxes are explicitly specified in this case, they still do have an impact on interior tendency values. . A further subtlety is that `Value` and `Gradient` boundary conditions do actually have an impact if there is non-zero `NormalFlow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191:343,evolve,evolve,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1630#issuecomment-832093191,1,['evolve'],['evolve']
Modifiability,"@francispoulin thanks for starting this discussion!. Broadly speaking I think we would like to implement an arbitrary Lagrangian-Eulerian vertical coordinate in the long run. As far as I understand, implementing an ALE scheme would require more changes than just a new `AbstractGrid`. We need to modify the time-stepping to include a regridding / interpolation stage, and I believe we also need to change the equations being solved (the tendency kernels). . My preliminary thought on software design is that this might be a new model property, something like `HydrostaticFreeSurfaceModel.vertical_coordinate`. Then one needs to interpret the z-coordinate in the chosen `HydrostaticFreeSurfaceModel.grid` in light of the choice of `HydrostaticFreeSurfaceModel.vertical_coordinate`. Other design ideas are certainly welcome!. Something less clear is what happens if we design a terrain following coordinate. Perhaps you are write @francispoulin that terrain following coordinates can be implemented purely by introducing a new type of grid (because the grid is not moving... ?) I think terrain-following, curvilinear grid would require three-dimensionally curvilinear operators, correct? So we would have to update the implementation of the `HydrostaticFreeSurfaceModel` operators as well. As for a horizontal grid for `ShallowWaterModel`, since we have horizontally-curvilinear operators I think you might be able to do `boundary_following` in the horizontal once you refactor `ShallowWaterModel` to use horizontally-curvilinear operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629:1467,refactor,refactor,1467,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549#issuecomment-814206629,2,['refactor'],['refactor']
Modifiability,"@francispoulin, sure, I'd like to discuss the implementation of advection in the `ShallowWaterModel`. We can also zoom if you want, send me an email and we can see when we both have time. @christophernhill I'll take a look at that! It will be nice when implementing the cubed sphere. @pvthinker thanks for the comment! In this case vorticity is still the quantity being upwinded. I agree that upwinding the velocity would lead to errors since you have to ensure consistency in `div(U)` which you break by using an upwinding stencil for U (at least on a C-grid). ; Here I just relied on U to assess the ""smoothness"" of the vorticity stencils for upwinding. (if we look it in an ENO fashion, the choice of wether to upwind strongly or use a (less dissipative) centered stencil for vorticity relies on the velocity field rather than the vorticity field). . This might also be consistent with how you choose the stencils in the advection of tracers, where the choice is based on the evolved quantity (I have no mathematical proof in this case). I agree though, that maybe some more quantitative study is required to ensure that this method plays nicely. Just to share, these are the spectra (KE and enstrophy) at the final time step of the _immersed_ simulation shown above compared with a 2nd oder vector invariant (ensthrophy conserving) scheme with additional biharmonic viscosity (at a resolution of 1024^2) ; ![vel_x_spec-bih](https://user-images.githubusercontent.com/33547697/160655542-18b59170-a928-44ac-85f4-60b22b8e8dce.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1082056720:979,evolve,evolved,979,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1082056720,1,['evolve'],['evolved']
Modifiability,"@glwagner ,. So then, based on the code snippet given by @johnryantaylor and our discussion, this validation could be adapted to something like:. ```julia; lamb = 1 # decay scale for slip velocity in meters; @inline w(x,y,z,t) = (tanh(max(-z/lamb,0))*tanh(max((z+H)/lamb,0))); sinking = SlipVelocity(WENO5(), w=w); ```. The way the code is, does it accept functions for velocity inputs?; Is that something I could do to help you?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129:118,adapt,adapted,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1083104129,1,['adapt'],['adapted']
Modifiability,"@glwagner ; I am really impressed with your effort to explain to me all details of the implementation. Thanks you!; In the past few days I am learning a lot reading the code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks fo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:300,parameteriz,parameterization,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688,4,['parameteriz'],['parameterization']
Modifiability,"@glwagner ; I should have reviewed your code instead, right?. This is now complaining about `af` variable; `nested task error: UndefVarError: af not defined`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082105665:97,variab,variable,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2390#issuecomment-1082105665,1,['variab'],['variable']
Modifiability,"@glwagner @simone-silvestri I took the liberty to modifying the [release notes for v0.84.0](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.84.0) to illustrate what my idea here was. @glwagner had already included something but I extended it a bit. Basically a user reading the release notes know quickly what changed: `compression` kwarg is gone and is replaced by `deflatelevel` (which also link directly to https://github.com/CliMA/Oceananigans.jl/pull/3153 for more info) and there's a quick summary of changes to `VectorInvariant` also with a link to https://github.com/CliMA/Oceananigans.jl/pull/3091. @simone-silvestri reading the description of https://github.com/CliMA/Oceananigans.jl/pull/3091 I couldn't understand what was breaking about that change. Seems like it just added more features/kwargs, with isn't necessarily breaking. Feel free to modify my description to clairfy. I also included a ""highlights"" section, which quickly points to a user what new features are available. At this point it only references to https://github.com/CliMA/Oceananigans.jl/pull/3145, but I think https://github.com/CliMA/Oceananigans.jl/pull/3145 probably should be there too; I just don't understand it well enough to be sure and summarize everything with a simple sentence. Feel free to add. This ""highlights"" section may be a bit repetitive, since similar information is contained in the list of PRs at the bottom. But my rationale is that most of those PRs don't really affect an average user (for example the doc examples parallelization is super important, but not relevant to users), so most people probably won't read their description. In any case, feel free to modify or undo what I wrote there. I did it mostly for illustration purposes :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754:239,extend,extended,239,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3147#issuecomment-1613894754,2,['extend'],['extended']
Modifiability,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:369,layers,layers,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426,2,['layers'],['layers']
Modifiability,@glwagner I won't ask for git history rewrite now but let's not get into the habit of calling me Dr Constantinou.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-777882397:38,rewrite,rewrite,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1352#issuecomment-777882397,1,['rewrite'],['rewrite']
Modifiability,"@glwagner Sorry for a late response. The current implementation I have going projects the velocity into tangential and normal directions (with respect to the immersed surface) before interpolating over the boundary. Since the boundary can be pretty variable in made more sense for us to take this approach. So the user would specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Obviously with tracers there is no projection because it's not a vector like that. I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that case, and also different from what you do for the usual boundary condition. My interpolation can handle Neumann and Dirichlet ie. `Value` and `Gradient` and the original idea was to infer `Flux` from `Gradient`, but right now everything is hard coded in. The normal and tangential though, would not hold with the current boundary condition set up with `North` or `East` or `Top` etc, but I don't think it would be hard to have whatever implementation is decided and just have 'Tang' and 'Normal' or whatever as well?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850539557:249,variab,variable,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850539557,1,['variab'],['variable']
Modifiability,"@glwagner These changes look great!. I fixed some typos in the refactored file, which were terms that would not have affected your new validation case. I moved my original example to validation and provided some minor tweaks to your first validation case. I did not look much at the ``surface_wave_quasi_geostrophic_flow.jl`` case you created",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430:63,refactor,refactored,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1836775430,1,['refactor'],['refactored']
Modifiability,"@glwagner and @simone-silvestri . Continuing the discussion.; https://github.com/CliMA/Oceananigans.jl/discussions/2788#discussioncomment-8101280. It looks like MPI needs to be initialized before accessing its communication variables. Thus, despite calling `Distributed` initializes MPI, we need to access `Nranks = MPI.Comm_size(comm)` before to define `Partition`. https://github.com/CliMA/Oceananigans.jl/blob/294602781e7a678ef3a662e1a31d2145d10d0800/validation/distributed_simulations/distributed_nonhydrostatic_turbulence.jl#L20-L22. Should we initialize MPI when importing DistributedComputations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124:224,variab,variables,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890460124,1,['variab'],['variables']
Modifiability,"@glwagner and @simone-silvestri : . I updated the Overleaf document to include what form of viscosity we should be using. In summary, following [Gent (1993) ](https://www.cgd.ucar.edu/staff/gent/swe.pdf), I think the should choose the viscosity for `ShallowWaterModel` to be. ν/h ∇⋅ ( h ∇ 𝐯 ) . The reasons he states are as follows:. - h ∇ 𝐯 is a parameterization of the turbulent flux and therefore should be proportional to the depth.; - This ensures that the diffusion of momentum is in the form of the divergence of a stress tensor (Schar and Smith 1993); - It has a negative definite effect on the KE budget if the viscous boundary condition is either no slip or free slip. Of course a problem occurs where h=0 but I guess we just don't apply viscosity where there is no fluid. If we wanted to generalize this to biharmonic viscosity, I would guess the following, . ν/h ∇² ( h ∇² 𝐯) . but this is something that should be done later, of course.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403:347,parameteriz,parameterization,347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403,1,['parameteriz'],['parameterization']
Modifiability,"@glwagner can you review this? The failures seem unrelated, e.g. `Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64})` and I'm not sure what already is expected to fail",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838:140,Adapt,Adapt,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1863593838,2,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"@glwagner or @ali-ramadhan probably can change that. I actually like the description as is. :); I'd probably just add the ""flexible"" to the current description: ""A flexible oceanic...""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-955788563:123,flexible,flexible,123,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-955788563,2,['flexible'],['flexible']
Modifiability,"@glwagner the idea is that the flow of the script for a user would be something like this:. (1) define a grid; (2) choose an architecture; .; .; code does not change from here on; .; . for this reason I was thinking you cannot have a `DistributedNonhydrostaticModel` vs a `NonhydrostaticModel` as much as you don't have a `CPUNonhydrostaticModel` vs a `GPUNonhydrostaticModel`. About the future direction: I was thinking that `Distributed` could be as much of an architecture as `CPU` and `GPU` are. As an example, there is no GPU.jl module which individually extends all the other modules for gpu execution like the extending the Fields.jl module with a `gpu_fields.jl` in GPU.jl. But I see what you mean when you say boundary conditions and fields have to take the precedence over distributed because it is maybe more linear to extend them in a separate module. Maybe integrating fields and boundary conditions in the respective modules (how is done for CPU and GPU which are not separated) for Distributed might make the code a little too complex and keeping it separate is the way to go. I am all up for that. . Now, discussing the `architecture` vs `grid` problem, step (1) and (2) are interlocked, and choosing which goes first (i.e. grid depend on architecture or other way around?) will make a big difference. At the moment they are kind of independent one another (i.e. some `grids` have an `architecture` field, distributed architecture depends on a grid). . In the future I believe we don't want to have the users fiddling with local_ and parent_ grids. I believe you want them to specify the parent grid, an architecture, and the code takes care of the rest. To achieve that, either a copy of the local or parent grid has to be stored in the architecture type when running `MultiArch`. For the constructor you where talking about `RectilinearGrid(arch=MultiArch; kwargs...)` which returns the local grid, we can do that, but the problem is that the connectivity of the architecture depends",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724:560,extend,extends,560,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2073#issuecomment-974677724,3,['extend'],"['extend', 'extending', 'extends']"
Modifiability,@glwagner the important changes are basically the `Advection` module and `conditional_fluxes.jl` in the `ImmersedBoundaries` module. The rest is only adapting here and there (and some small bugfixes in immersed boundaries and shallow water module),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177988301:150,adapt,adapting,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177988301,1,['adapt'],['adapting']
Modifiability,"@glwagner yes, that was more along the lines of what I was saying. From the docs it seemed to me using a Gaussian mask in the relaxation should be equivalent to a sponge layer, which is why I expected the gaussian function to be set-up with a sharp cut-off. But I think we're on the same page about what a sponge layer should be. . So I think it may be a matter of maybe making the docs clearer? Maybe also, like you said, constructing an example that uses sponge layers (I think there's an issue about there somewhere, right?). The Langmuir example might a good one. In the original paper by Jim they use a radiation boundary condition at the bottom which doesn't have an analog in the Langmuir example at the moment.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733365742:464,layers,layers,464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733365742,1,['layers'],['layers']
Modifiability,"@glwagner, @simone-silvestri: Question: How is Δx^faa, defined for the F at the edge of the domain?. Is it the distance between `C[1] - F[1]`? (don't think so...); Or distance between `C[1] - C[0]`?. For a curvilinear grid with variable distances (as the `OrthogonalSphericalShellGrid` we need to compute where the halo faces and centers would be if we actually extended the grid, right? We can't just replicate the `C[2] - C[1]` distances `Hx` times...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384614027:228,variab,variable,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384614027,2,"['extend', 'variab']","['extended', 'variable']"
Modifiability,"@glwagner, I think there was a misunderstanding about the test failing. For the background-flux-divergence PR, we were just confused as to why it wasn't passing the existing test suite. The separate issue of adding a new test is for the [unrelated PR](https://github.com/CliMA/Oceananigans.jl/pull/3721) related to refactoring `AveragedTimeInterval` to fix the existing bug. @liuchihl has some local branches where he'd merged both of those and was testing them in combination, so we got our signals crossed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3862#issuecomment-2433728389:315,refactor,refactoring,315,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3862#issuecomment-2433728389,1,['refactor'],['refactoring']
Modifiability,"@glwagner, I think you're right that the error is coming from this line:; https://github.com/CliMA/Oceananigans.jl/blob/10a9479ec462f4f5f053e7447ff667fdfe20542d/src/Distributed/distributed_fft_based_poisson_solver.jl#L65; I checked the sizes of these variables, and here xc is sized on the global grid while lambda x is sized on the local grid. I'm not sure which grid this operation is intended to be performed on. The code here is impressively compact but not particularly easy to decipher (at least for me).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658:251,variab,variables,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658,1,['variab'],['variables']
Modifiability,"@iuryt speaks truth... it's hard to say something _isn't_ ""feasible"". However, I do think that polishing off an n-layer extension of the existing ShallowWaterModel would require some time. I think you want to write not only the continuous equations, but also the finite volume discretization (and there's some issues around discretization of the advection operator now see #1866). There are some design questions regarding the user interface and the use of existing grids. One possibility is to use the existing grids (which all have a z-coordinate) to specify the _number_ of layers (via the vertical size), but to ignore the vertical grid. Then users would also have to input the buoyancy of each layer (I think I'd prefer buoyancy to density, if that's possible...) But another design might be possible that ""re-uses"" whatever users provide for the vertical grid. I just took a look at the code and was surprised to notice that all of the kernels and fields are already three-dimensional. That means that once the user interface is figured out and appropriate model modifications are made, the ""only"" thing left might be to generalize the kernels... I'm not sure how you do immersed boundaries, or how you blend ""explicit"" bathymetry (added through the pressure gradient) and immersed boundaries. Does anyone know?. @apaloczy may also be interested in this discussion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176:577,layers,layers,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115530176,1,['layers'],['layers']
Modifiability,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:513,refactor,refactoring,513,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444,4,"['config', 'refactor']","['configurations', 'refactor', 'refactoring']"
Modifiability,@jm-c there are two `ivd_diagonal` functions --- which one do you mean? Here are the two:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L52-L59. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/src/TurbulenceClosures/vertically_implicit_diffusion_solver.jl#L75-L82. We should adapt this dynamics test:. https://github.com/CliMA/Oceananigans.jl/blob/02f4d9dc17293a399ca3adf68b6de71ee7d59f16/test/test_dynamics.jl#L447. to use a vertically-stretched grid. Hopefully that would isolate this issue.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892:419,adapt,adapt,419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2065#issuecomment-973700892,1,['adapt'],['adapt']
Modifiability,"@jmbeckers thanks for the delucidation! Indeed, a conservative discretization might be more ""natural"" (have better discrete properties) in terms of momentum conservation. Especially because vector invariant formulations do not conserve momentum but angular momentum. @francispoulin, indeed, I think that, for a one layer model explicit dissipation might not be necessary because the noise associated with a horizontal velocity divergence is encoded in the mass equation which is discretized with a WENO formulation also (another way of repeating what @glwagner said). This is the difference with the hydrostatic model where we do not explicitly evolve a prognostic equation for the vertical velocity and we have to explicitly damp the noise contained in the vertical velocity `w` through a divergence damping closure. So you can think at that ""divergence damping"" closure as a ""WENO"" for an hypothetical `w` equation (which we have in the shallow water equations explicitly trough `h`). I agree also that we should introduce a diffusion term anyways. It is always good to be able to quickly quantify the dissipation you have in your model and with implicit dissipation that is very difficult (implicit LES is frowned upon by many purist of turbulence). for the documentation problem I think it's just because I changed the example. I ll fix the test",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1120046380:645,evolve,evolve,645,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1120046380,1,['evolve'],['evolve']
Modifiability,"@m3azevedo and me are doing a simulation of an unstable baroclinic jet in the context of the Nonhydrostatic model and having some success but some difficulties as well. We have tried two different approaches: . Method 1: define the jet and stratification to be part of the background field and evolve the perturbations. Method 2: define the jet and stratification as part of the initial conditons and evolve the total field. These are mathematically equivalent and should both yield the same results, but we are finding a difference and believe there is a problem with method 2 (evolving the total fields). . When pick there to be zero perturbations, the jet is an exact solution to the governing equations (even though it is an unstable one) and it should persist, until perturbations arise because of numerical errors. The good news is that when we use method 1, evolve the perturbations, when we pick zero perturbations, no pertrubations develop for a long time. . The not so good news, is that when we use method 2, evolve the total field, a distrubance develops right away,in the center of the jet that spans the entire depth, and this seems to radiate gravity waves to the left and right. The amplitude of the distrubance is small and it does decrease with increasing resolution but it seems problematic. I am going to include an animation that shows the problem that develops in the first 6 hours and the two codes, which are almost identical. Is there something that we are doing wrong here? @glwagner ?. Method 1: Evolve perturbations. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z, t) = U",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251:294,evolve,evolve,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251,3,['evolve'],['evolve']
Modifiability,"@matinraayai I made a bunch of suggestions!. I suggest leaving the tests untouched right now. The reason is that I think we should refactor the tests to be more architecture-indepedent _before_ merging this PR into `main`. Perhaps as an alternative, we can pick one of the validation tests in `validation/` to focus on as an integration test. We'll use that example script to test whether functionality works. As a starting point, something like. ```julia; using Oceananigans; grid = RectilinearGrid(GPU(), size=(128, 128), x=(0, 2π), y=(0, 2π), topology=(Periodic, Periodic, Flat)); model = NonhydrostaticModel(; grid, advection=WENO5()); ϵ(x, y, z) = 2rand() - 1; set!(model, u=ϵ, v=ϵ); simulation = Simulation(model; Δt=0.01, stop_time=4); run!(simulation); ```. should be enough?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085:131,refactor,refactor,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2494#issuecomment-1112412085,1,['refactor'],['refactor']
Modifiability,"@matinraayai I think it will also help us get those tests passing quicker, because keeping `GPU` will allow us to avoid refactoring a lot of existing code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281:120,refactor,refactoring,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2493#issuecomment-1112369281,1,['refactor'],['refactoring']
Modifiability,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521:420,config,configuration,420,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521,2,['config'],['configuration']
Modifiability,"@mncrowe it sounds like this happened when you weren't using adaptive time-stepping --- which is nice because it will help us construct an MWE more easily. Do you think you can help with that? We just need a very simple simulation that reproduces the issue, hopefully something 0D with no dynamics that runs fast.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150474033:61,adapt,adaptive,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614#issuecomment-2150474033,2,['adapt'],['adaptive']
Modifiability,"@navidcy . I just sent you an invite to the overleaf document. I thought maybe we want to have both the tracer and momentum equations before we create a PR, but I'm flexible. Thanks also for the reference. I remember seeing this paper before and liking it so I will look at it again. It seems that our advection schemes use the cell-averaged velocity to approximate the velocity at the edge. This is a perfectly valid choice and corresponds to a certain order of accuracy. I don't know what that is but I imagine using more cell averaged velocities would give a higher order accuracy. I'm not suggesting we do this, but I'm just trying to get a better understanding of the order of accuracy.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874314460:165,flexible,flexible,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1318#issuecomment-874314460,1,['flexible'],['flexible']
Modifiability,"@navidcy Good call! ; You can find here below the output of benchmarks/benchmark_advection_schemes.jl ran on main and this PR and adapted to test the new methods.; For validation, you can run validation/advection/validate_weno_schemes.jl to validate the methods on a 1D and 2D advection problem for different grids; (uniform and stretched). execution of benchmark_advection_schemes.jl on main; ```; ┌───────────────┬────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architectures │ Schemes │ min │ median │ mean │ max │ memory │ allocs │ samples │; ├───────────────┼────────────────────────┼───────────┼───────────┼───────────┼───────────┼──────────┼────────┼─────────┤; │ CPU │ CenteredFourthOrder │ 1.779 s │ 1.789 s │ 1.794 s │ 1.814 s │ 1.05 MiB │ 1685 │ 3 │; │ CPU │ CenteredSecondOrder │ 1.018 s │ 1.066 s │ 1.061 s │ 1.090 s │ 1.05 MiB │ 1685 │ 5 │; │ CPU │ UpwindBiasedFifthOrder │ 2.467 s │ 2.505 s │ 2.505 s │ 2.544 s │ 1.05 MiB │ 1685 │ 2 │; │ CPU │ UpwindBiasedThirdOrder │ 1.808 s │ 1.877 s │ 1.862 s │ 1.903 s │ 1.05 MiB │ 1685 │ 3 │; │ CPU │ WENO5 │ 6.775 s │ 6.775 s │ 6.775 s │ 6.775 s │ 1.05 MiB │ 1685 │ 1 │; │ GPU │ CenteredFourthOrder │ 20.879 ms │ 20.970 ms │ 21.078 ms │ 21.874 ms │ 2.17 MiB │ 20610 │ 10 │; │ GPU │ CenteredSecondOrder │ 11.402 ms │ 15.533 ms │ 15.138 ms │ 15.680 ms │ 2.05 MiB │ 13147 │ 10 │; │ GPU │ UpwindBiasedFifthOrder │ 23.356 ms │ 23.498 ms │ 24.055 ms │ 29.246 ms │ 2.21 MiB │ 23281 │ 10 │; │ GPU │ UpwindBiasedThirdOrder │ 18.863 ms │ 19.027 ms │ 19.298 ms │ 21.745 ms │ 2.12 MiB │ 17945 │ 10 │; │ GPU │ WENO5 │ 23.234 ms │ 28.467 ms │ 27.982 ms │ 28.684 ms │ 2.30 MiB │ 29259 │ 10 │; └───────────────┴────────────────────────┴───────────┴───────────┴───────────┴───────────┴──────────┴────────┴─────────┘; ```; This PR same file, (WENO5 on uniform grids); ```; ┌───────────────┬────────────────────────┬───────────┬───────────┬───────────┬───────────┬──────────┬────────┬─────────┐; │ Architec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738:130,adapt,adapted,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-974843738,1,['adapt'],['adapted']
Modifiability,"@navidcy Hmmm, digging into Documenter.jl's Buildkite config it looks like push previews are only provided if the build belongs to a PR?. https://github.com/JuliaDocs/Documenter.jl/blob/4be8243d31a6ffdbc64d779e3f8c2fb7c61de075/src/deployconfig.jl#L719-L725 . Maybe there was no push preview here since @tomchor pushed this branch at which Buildkite ran, before the PR existed, so Buildkite did not publish a preview. Maybe if a second commit was made on this PR, it would be detected by Buildkite as a PR and therefore a preview would be published?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428:54,config,config,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782289428,1,['config'],['config']
Modifiability,"@navidcy PyPlot is used for the log2 scale for the x-axis of certain graphs. The normal backend of Plots,jl only has natural log scale axis option. Log-base-2 scale works best for these plots since most of them have an independent variable that scales based on powers of 2. The inclusion of Oceananigans in `benchmark/Project.toml` is likely due to a Julia package config suggested by @ali-ramadhan. What was done was that in Julia's package manager, `dev ..` was inputted to enable what I assume is the dev version of the Oceananigans package folder. Before this was done, there were numerous output errors with the benchmark scripts, and doing so fixes them all.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-864599629:231,variab,variable,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746#issuecomment-864599629,2,"['config', 'variab']","['config', 'variable']"
Modifiability,"@navidcy is a tease! The ""other repo"" is https://github.com/CliMA/ClimaOcean.jl. That's where we plan to build out the features needed for high-quality realistic simulations, eg interpolating bathymetry from one grid to another, ""recipes for realism"" such as parameterization and boundary condition choices. There's already a tool there for downloading some repeat-year forcing JRA55 data; we still need to build a tool for the entire dataset, and also tools for restricting to some region, etc. The vision in the end though is to get as close as possible to ""one click regional modeling"" as we can. @navidcy is right that the tools are not so useful now unless you want to get into the weeds. But if you want to help, it's greatly appreciated. Feedback on issues or wishlist features could also be fun to discuss.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733:259,parameteriz,parameterization,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809327733,1,['parameteriz'],['parameterization']
Modifiability,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:233,config,configuration,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,2,['config'],"['config', 'configuration']"
Modifiability,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59:543,extend,extend,543,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59,2,"['Refactor', 'extend']","['Refactor', 'extend']"
Modifiability,"@peterahrens thanks for that tip!. @vchuravy, by closure-specific temporary variables (or fields), I am referring to domain-size quantities that can be re-used in computing the contribution of an LES closure to the 'source terms' for momentum and tracers. In other words, [this line, which computes the source term for `u`](https://github.com/ali-ramadhan/Oceananigans.jl/blob/a544300cabe6f8d872b7f9658284cad34c8619ad/src/time_steppers.jl#L223) could become something like. ```julia; kernel_temporaries!(subgrid_closure, ..., i, j, k); Gu[i, j, k] = ... + subgrid_closure.u(subgrid_closure_temporaries, ..., i, j, k); ```. ... I think. In physical terms, the intermediate variable is an 'eddy viscosity' that acts on all momentum terms. But I guess when I say the computation 'will benefit' from variables to store intermediate results, what I really mean is that I'm expecting the calculation of this temporary variable to be fairly involved (potentially >20 derivatives of velocity and tracer fields in x, y, z, plus scalar operations to combine the fields, and a 'clipping' function to make sure the viscosity is not negative --- see [the formula for the eddy viscosity predictor](https://dedales.readthedocs.io/en/latest/closures/anisotropic_minimum_dissipation.html#the-eddy-viscosity-predictor)). It is also of course possible to simply write a function that calculates the eddy viscosity, and call this function repeatedly to avoid temporaries altogether.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468747674:76,variab,variables,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/73#issuecomment-468747674,4,['variab'],"['variable', 'variables']"
Modifiability,"@sandreza thanks! We utilize this functionality for many of our objects, eg:. https://github.com/climate-machine/Oceananigans.jl/blob/9ef95e7bef2db1dc9ac04af78664418b0caaf99b/src/AbstractOperations/binary_operations.jl#L144. For some reason, during an undocumented attempt to apply this logic to fields back in October, we were unsuccessful to get code to work on the GPU. Back then, the field consisted of an OffsetArray wrapped around a CuArray, and a grid. Both of those objects can be adapted to GPU kernels, so it should have worked, I think. So I'm not 100% sure why our attempt to use `adapt_structure` failed for fields, while working for other objects. Any insight appreciated...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025:489,adapt,adapted,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-622472025,1,['adapt'],['adapted']
Modifiability,"@simonbyrne do you have any advice for how to avoid these annoying round-off errors? Basically I'm wondering if theres a robust way to get. ```; ├── Periodic x ∈ [0.0, 6.28319) regularly spaced with Δx=0.0490874; ```. here we are given the length of the domain (2pi), but then we have to construct a range of nodes which extends _left_ of 0, so that it includes our halo region. The problem is when we do that, the first face (which is then something like `range[4]` if we have 3 halo points) has round-off error (or at least that's how I'm interpreting it... maybe there's no way around it).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017:321,extend,extends,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2499#issuecomment-1113423017,1,['extend'],['extends']
Modifiability,"@simone-silvestri , thanks to your help I am now able to print out the norms of the perturbation buoyancy in the case when we evolve the total fields. The error that arises in this case, but not when we evolve the perturbation fields, decreases quadratically with increasing resolution. I could pick a resolution where this is small but in the first hour the norm or buoyancy grows by three orders of magnitude, which looks like an instability. It is not noisy and very well resolved, it can't be a baroclinic instability and does not look anything like an inertial instability.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762:126,evolve,evolve,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708614762,2,['evolve'],['evolve']
Modifiability,"@simone-silvestri I refactored the CFL calculation so that we only have one function all the time, rather than one ""ordinary"" and one ""accurate"". The tests still fail though. I'm not totally sure why, but I am somewhat confused how this is supposed to work on a staggered grid. I don't think we can apply wikipedia's definition; we need the definition that's correct for a C grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1058063997:20,refactor,refactored,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2252#issuecomment-1058063997,1,['refactor'],['refactored']
Modifiability,"@simone-silvestri I refactored the tuple halo filling (partly to shorten the code but also to filter more stuff from the tuples, and to avoid filling halos for the same fields twice --- sometimes a field can appear twice in a named tuple...) But it looks like my changes broke some stuff, so I might need some help fixing that up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2426#issuecomment-1094117367:20,refactor,refactored,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2426#issuecomment-1094117367,1,['refactor'],['refactored']
Modifiability,"@simone-silvestri You seem to be right. On the cluster I get:. ```julia; julia> using Oceananigans.Architectures: DEVICE_STREAMS, DEVICE_FREE_STREAMS; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> length(DEVICE_STREAMS); 1. julia> DEVICE_FREE_STREAMS; (CUDA.CuStream[],). julia> CUDA.dev^C. julia> using CUDA. julia> CUDA.devices(); CUDA.DeviceIterator() for 2 devices:; 0. Tesla V100-SXM2-32GB; 1. Tesla V100-SXM2-32GB. julia> CUDA.ndevices(); 2; ```. If you need to reproduce this and aren't able to, we can set up a PP session via zoom and I can share my screen.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310992343:191,variab,variable,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1310992343,4,"['Config', 'config', 'variab']","['Config', 'config', 'variable']"
Modifiability,"@simone-silvestri and I have discussed a number of improvements to solvers (mostly refactoring and cleanup); I'm opening this issue to record our discussion. Here are some items in no particular order:. 1. `HeptadiagonalIterativeSolver` should use our internal `PreconditionedConjugateGradientSolver`. This is important because we need to use `PreconditionedConjugateGradientSolver` elsewhere, and we want to a) ensure that it's optimized and b) ensure we can reason about _why_ one solver is faster than another. 2. Related to 1., we can refactor `PreconditionedConjugateGradientSolver` to have a similar interface as `cg` from `IterativeSolvers`. Then we can swap in and out. 3. `HeptadiagonalIterativeSolver` should solve linear systems only, and have nothing to do with time-stepping. Right now `solve!` for the `HeptadiagonalIterativeSolver` is entangled with time-stepping:. https://github.com/CliMA/Oceananigans.jl/blob/90f7de4cb3ed2fa9e22231177fd56b0f33c39df9/src/Solvers/heptadiagonal_iterative_solver.jl#L286-L308. since it ""knows"" about ""`previous_Δt`"". This logic should be moved to `MatrixIterativeFreeSurfaceSolver`. 4. We should disentangle / modularize the implementation of matrix-based preconditioners in `HeptadiagonalIterativeSolver`. In particular we should be able to use matrix-based preconditioners with any iterative solver that uses `PreconditionedConjugateGradientSolver`. Right now, the fastest way to compute left-hand-sides is with `PCGImplicitFreeSurfaceSolver`, but the best preconditioners can only be used with `MatrixIterativeSolver`. If our code were more modular, we could use the matrix-based preconditioners with `PCGImplicitFreeSurfaceSolver` to achieve the fastest possible combination of methods. Note that some of the changes in #2412 will help (in particular, an improvement to the interface into `PreconditionedConjugateGradientSolver` for defining preconditioners). There's probably a few other things on the todo list so please add them here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2418:83,refactor,refactoring,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2418,2,['refactor'],"['refactor', 'refactoring']"
Modifiability,"@simone-silvestri asked for a little more alignment, so we have. ```julia; julia> grid = RectilinearGrid(size = (32, 32, Nz), x = (0, 64),; y = (0, 64), z = hyperbolically_spaced_faces); 32×32×24 RectilinearGrid{Float64} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 64.0) regularly spaced with Δx = 2.0; ├── Periodic y ∈ [0.0, 64.0) regularly spaced with Δy = 2.0; └── Bounded z ∈ [-32.0, -0.0] variably spaced with min(Δz) = 0.682695, max(Δz) = 1.83091; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017983292:397,variab,variably,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017983292,1,['variab'],['variably']
Modifiability,"@simone-silvestri brainstormed today about ways to clean up `TurbulenceClosures`. One idea that came up is to combine `IsotropicDiffusivity` and `HorizontallyCurvilinearAnisotropicDiffusivity` into a single `ScalarDiffusivity` (where isotropy in various directions is _implied_). We'll also simplify the ""anisotropic"" diffusivity in this process. The user interface could look something like. ```julia; three_dimensional_diffusivity = ScalarDiffusivity(ThreeDimensional(), ν=1); horizontal_diffusivity = ScalarDiffusivity(Horizontal(), ν=1); vertical_diffusivity = ScalarDiffusivity(Vertical(), ν=1); ```. so, no more `νh` and `νz`. The advantage is that we eliminate / share much more code. Arguably the API is a bit cleaner as well. (We can discuss aliases and defaults like `HorizontalScalarDiffusivity`, etc.). Under the hood we'll add the `Directionality` type to the type parameters of `ScalarDiffusivity`:. ```julia; struct ScalarDiffusivity{TimeDisc, Nu, Kappa, Directionality} <: AbstractScalarDiffusivity{TimeDisc, Dir}; ν :: Nu; κ :: Kappa. function IsotropicDiffusivity{TimeDisc}(dir::Dir, ν::Nu, κ::Ka) where {TimeDisc, Dir, Nu, Ka}; return new{TimeDisc, Nu, Ka, Dir}(ν, κ); end; end; ```. Then `abstract_isotropic_diffusivity.jl` becomes `abstract_scalar_diffusivity.jl`, and will implement the necessary abstractions for 3D isotropic scalar diffusivities, horizontally-isotropic diffusivities (a la MITgcm), and vertical diffusivities. . Consolidating code is an important precursor to a larger refactor that might. 1) support `AbstractOperation` viscosities and diffusivities at all locations on the grid; 2) eliminate `diffusivity_fields` and; 3) perhaps also involve fixing `TwoDimLeith` and implementing a biharmonic Leith.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2239:1510,refactor,refactor,1510,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2239,1,['refactor'],['refactor']
Modifiability,"@simone-silvestri can I convince you to rewrite this section with updated benchmarks, and include results for distributed systems?. https://github.com/CliMA/Oceananigans.jl?tab=readme-ov-file#performance-benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3684:40,rewrite,rewrite,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684,1,['rewrite'],['rewrite']
Modifiability,@simone-silvestri can probably contribute a simple script (maybe something that adapts a baroclinic adjustment case) for `Distributed`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085674244:80,adapt,adapts,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-2085674244,2,['adapt'],['adapts']
Modifiability,"@simone-silvestri discussed the pros and cons of implementing this ""single process version"" of `MultiRegion`. ### Cons. The main con is the difficulty in maintaining code for `MultiRegionGrid` and `MultiRegionObject`, plus `apply_regionally!`. The difficulties we face here are identical to the issues that have plagued our maintenance of `CubedSphereGrid`: the need to redispatch and `apply_regionally!` a huge number of methods on `MultiRegionGrid` creates extensive cross dependencies between ""local"" implementations and their multi-region versions. This is unbelievably annoying to maintain when refactoring or adding features to existing local implementations. We can mitigate the above issue with (i) clever and careful code design and (ii) potentially a bit of metaprogramming, similar to how `@kernel` and `adapt(to, obj)` achieve CPU/GPU polymorphism. ### Pros. We identified 3 main pros:. 1. We can run problems distributed across many GPUs, or cubed sphere problems on GPU or CPU, on a single process without an MPI dependency. This is a huge win for user experience, interactivity, and ease-of-use (users don't need to invoke `mpiexec`). 2. Related to 1, we can debug complex multiregion applications (like the cubed sphere) without MPI. This is important, given the complexity of the cubed sphere (and extensions / generalizations of the quasi-unstructured cubed sphere algorithm). 3. CUDA provides functionality that works on multi-GPU nodes: CUDA FFT, matrix algebra, etc. Being able to launch these utilities from a single Julia process may greatly simplify the implementation of GPU-distributed elliptic solvers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426:600,refactor,refactoring,600,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1050206426,6,"['adapt', 'polymorphi', 'refactor']","['adapt', 'polymorphism', 'refactoring']"
Modifiability,"@simone-silvestri here's some description of the GVC problem. There's additional discussion on #1549. Today, we discussed whether the prognostic variable in a model formulated with a generalized vertical coordinate is thickness weighted velocity `hu`, or velocity `u` (which has also come up on #2522). Based on some discussion and consultation with papers it seems that we want both, because we evolve `hu` when we use ""flux form"" or ""conservative form"" momentum advection, but we evolve `u` when we use ""vector invariant"" advection. This choice has consequences beyond momentum advection though (I think). Also, whichever momentum variable we prognose, we always prognose the thickness weighted tracer concentration `hc`. Thoughts on this are very welcome @jm-c @jmbeckers !. In the ""z-tilde"" paper by [Leclair and Madec 2011](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=DHE0RUlG-WMAAAAA:lJV98AknVQXrbcNmIUI9sxHLYoqmw4I7lw0EKSMyhiX9lKR6sxreDJ5Kt86jhc2fbqFH88aAYew), we find. <img width=""544"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/167006545-ffff4819-a5a5-4fbc-88a6-aefbed6322cb.png"">. I think `e3` above is our `h`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-1118951226:145,variab,variable,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679#issuecomment-1118951226,4,"['evolve', 'variab']","['evolve', 'variable']"
Modifiability,@simone-silvestri this looks great. Have you thought about some sort of thickness weighting for vertical vorticity as a next step!! That could be a great step toward som flexible vertical coordinate options ( https://www.gfdl.noaa.gov/fv3/fv3-key-components/ ).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081920582:170,flexible,flexible,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081920582,1,['flexible'],['flexible']
Modifiability,"@simone-silvestri were discussing implementing some new closures such as K-epsilon / ""Generic Length Scale"", and the OSMOSIS scheme used by the NEMO ocean model. Both these closures, and `CATKEVerticalDiffusivity`, introduce new prognostic variables (such as turbulent kinetic energy, dissipation, or mixed layer depth) that must be evolved alongside the model state. For CATKE we have hacked in a turbulent kinetic energy equation that gets used when i) the tracer is named `:e` and ii) one of the closures is `CATKEVerticalDiffusivity`:. https://github.com/CliMA/Oceananigans.jl/blob/9e620637670cdd4defa32c07c51fd5574520de73/src/Models/HydrostaticFreeSurfaceModels/calculate_hydrostatic_free_surface_tendencies.jl#L99-L105. this works but the design is not sustainable. There are a few issues: first, we can't continue to abuse `model.tracers` to add new prognostic variables. Some prognostic variables shouldn't be called ""tracers"" --- like mixed layer depth. Also, we probably want a design in which `model.tracers` is unaffected by the closure being used. This will make it easier to switch between different closures in, for example, a large-scale ocean simulation. The second issue is that we need to design an interface so that the ""prognostic dynamics"" of a closure's auxiliary prognostic variable can be implemented and confined to the file where the closure is defined (ie, `HydrostaticFreeSurfaceModel` shouldn't know anything about `CATKE` in particular). One solution is to add a new model property called `auxiliary_prognostic_fields`. This might behave similarly to `model.diffusivity_fields`; eg every `closure` can populate this object in the model constructor. Then we'll add tendency fields for those terms, and time-step them forward. The ""tendency kernel function"" that get's called will also have be provided by the closure. Just to make things more logical, we could also rename `diffusivity_fields` to `auxiliary_diagnostic_fields` when we do this. This would all have to come",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2422:240,variab,variables,240,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422,4,"['evolve', 'variab']","['evolved', 'variables']"
Modifiability,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3067:291,variab,variables,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067,4,['variab'],"['variable', 'variables']"
Modifiability,"@simone-silvestri, from symmetry arguments, the metrics on the halo on one face should be the same as the metrics on some other face. E.g., `Δxᶠᶠᵃ[0]` on one face should be either `Δxᶠᶠᵃ[grid.Nx+1]` or `Δyᶠᶠᵃ[grid.Ny+1]` on the other face (or something like that, depending on whether a rotation applies). Right?. So we could hardcode these in from a single face instead of constructing 6 faces and filling halos to fill the halo metrics. It will assume, thought, that a specific face configuration is implied.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384677447:485,config,configuration,485,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384677447,1,['config'],['configuration']
Modifiability,"@simone-silvestri, in relation to why `cpu_face_constructors` require `with_halos=true`: note that before the grid_utils refactor `cpu_face_constructors` were using `cpu_face_constructors` were using `all_x/y/z_nodes` which is exactly equivalent to `x/y/znodes(; with_halos=true)`. ;). https://github.com/CliMA/Oceananigans.jl/blob/e7cb507b2645f04c6cdf52ee6f18c2c5b79f7bde/src/Grids/grid_utils.jl#L244-L246",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2979#issuecomment-1491077886:121,refactor,refactor,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2979#issuecomment-1491077886,1,['refactor'],['refactor']
Modifiability,"@simone-silvestri, sorry but I don't know of any exact solutions but I will think about this a bit more. One thougth that I have discussed with @glwagner a while ago is having a vector invariant form of the `ShallowWaterModel`. This is probably easy to put together from the current `HydrostaticModel`. But if we were to allow for a rigid-lid `ShallowWaterModel`, then we could test the exact solution in the context of this model where momentum evolves. I realize this is a multi-step process, but I for one have wanted to have a rigid lid shallow water model, and this would help to make it happen, as well as create a nice sandbox to test our advection schemes with a classical problem. Please feel free to ignor this idea but if you wanted to discuss it further please let me know.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227:446,evolve,evolves,446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1062097227,2,"['evolve', 'sandbox']","['evolves', 'sandbox']"
Modifiability,"@thabbott and I have been thinking about potential ways we can reuse LES/turbulence closures between incompressible and compressible models. One approach we came up is for all turbulence closures to define functions for the SGS stress tensor like ∂ⱼτᵢⱼ where τᵢⱼ = νˢᵍˢSᵢⱼ and where νˢᵍˢ will dispatch on the type of closure while the strain-rate tensor Sᵢⱼ will dispatch on whether the model is compressible or incompressible. For compressible models, Sᵢⱼ will instead compute and return the _traceless_ strain-rate tensor Sᵢⱼ - ⅓Sₖₖδᵢⱼ. A turbulence closure can define ∂ⱼτᵢⱼ directly to elide or short circuit computations or in case the SGS stress tensor is not of the form ∂ⱼτᵢⱼ = νˢᵍˢSᵢⱼ. Still learning more about this topic but it seems that as a start, just using the traceless strain-rate tensor for compressible models allows us to reuse a closure from an incompressible model. @thabbott suggested that νˢᵍˢ might have to dispatch on the thermodynamic variable as well. Is this true for the viscosity or only the diffusivities κˢᵍˢ? I.e. do we have to treat SGS fluxes of moisture and energy in a special way?. Couple of useful references for compressible LES (mostly with dynamic Smagorinsky):; 1. Moin et al. (1991), A dynamic subgrid‐scale model for compressible turbulence and scalar transport: https://doi.org/10.1063/1.858164; 2. Chai & Mahesh (2012), Dynamic k-equation model for large-eddy simulation of compressible flows: https://doi.org/10.1017/jfm.2012.115. ---. Some notational and misc. changes I'd like to make:. 1. Rename `∂ⱼ_2ν_Σ₁ⱼ` to `∂ⱼτ₁ⱼ` as τᵢⱼ = 2νSᵢⱼ is would no longer be true for `CompressibleModel`, it's τᵢⱼ = 2νSᵢⱼ + λSₘₘδᵢⱼ where λ is the _second viscosity_, or τᵢⱼ = 2μ(Sᵢⱼ - ⅓Sₖₖδᵢⱼ) + μᵥSₖₖδᵢⱼ where μᵥ is the _bulk_ or _volume viscosity_. 2. For constant isotropic viscosity: rename `∂ⱼνᵢⱼ∂ᵢu` to `ν∇²u`. For constant isotropic diffusivity: rename `∂ⱼκᵢⱼ∂ᵢc` to `κ∇²c`. 3. For constant anistropic viscosity: rename `∂ⱼνᵢⱼ∂ᵢu` to `νⱼ∂ⱼ²u`. For constant anis",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/654:962,variab,variable,962,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/654,1,['variab'],['variable']
Modifiability,"@tomchor . In terms of ""smoothness indicators"" yes, not in terms of polynomial reconstruction. The WENO we had before is `WENO5()`. This will be formally wrong on a stretched grid because the reconstruction at the face is not done accounting for variable spacing. . `WENO5(grid = grid, stretched_smoothness=false) ` accounts for variable spacing in the reconstruction polynomial (i.e., the <img src=""https://render.githubusercontent.com/render/math?math=c_{rj}""> coefficients are calculated based on grid spacing). This makes the scheme formally correct as, independently on how you weight the polynomials, the different stencils will have mathematically correct reconstructions at the face. This should _always_ be done in case of a stretched grid (and it does not decrease execution speed). Now, the `stretched_smoothness=true` calculates the <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> accounting for a stretched mesh. This means that the three reconstruction polynomials (<img src=""https://render.githubusercontent.com/render/math?math=p_{0}, p_{1}, p_{2}"">) are weighted accounting for their actual smoothness and not a ""uniform smoothness"" that `WENO5(grid = grid, stretched_smoothness=false) ` calculates. In my tests this did not give a noticeable benefit in terms of accuracy (apparently <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> for a stretched mesh are very similar to <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r}""> for a uniform mesh). In addition, it gives a non-negligible decrease in execution speed (especially on the GPU). For this reason, I think it is nice to have as an option, but to be used with parsimony :) and only when necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975684663:246,variab,variable,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975684663,2,['variab'],['variable']
Modifiability,@tomchor I extended both JLD2 and NetCDF tests to include a StepRange index specification. All that's potentially left is to spruce up the docstring if we have the motivation here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1526#issuecomment-810679001:11,extend,extended,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1526#issuecomment-810679001,1,['extend'],['extended']
Modifiability,@tomchor Not sure if this is the issue but have you tried adapting `ScaleInvariantSmagorinsky` for the GPU?. Looks like `ScalarBiharmonicDiffusivity` needed it here: https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/TurbulenceClosures/turbulence_closure_implementations/scalar_biharmonic_diffusivity.jl#L109-L113. Not sure why `update_frequency` is coming up as an `Integer` (which is an abstract supertype) instead of `Int` (which is a concrete type and an alias for `Int64`) but maybe adapting will fix this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313325100:58,adapt,adapting,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2313325100,2,['adapt'],['adapting']
Modifiability,"@tomchor and @francispoulin (and more) should this include ""flexible"" (to convey the LES <-> general circulation, lab/theory simulations <-> exoplanets, etc.... )?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945745910:60,flexible,flexible,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945745910,1,['flexible'],['flexible']
Modifiability,"@tomchor and @whitleyv this PR adds a script that we can use to _estimate_ the relative effect of bottom drag vs form drag in buoyancy-stratified simulations over hilly bathymetry. This script only produces an estimate, because the bottom drag is implemented in a flat bottom setup, while form drag requires bathymetry. I'd hypothesis that we get more drag when there are both hills and bottom drag, because 1) greater shear at the bottom and 2) stronger downwards mixing of momentum due to strong turbulence. We could use #2275 to extend the results obtained here to cases with both drag and hills. I think it'll also be interesting if more accurate bathymetry representations like the one in #2306 lead to a reduction in form drag (cc @francispoulin). Possibly the spurious form drag is a nice metric to use to judge developments in our representation of bathymetry... I'll run these simulations at high resolution and report some results, hopefully soon. Side note: it's annoying that we don't serialized the immersed boundary so I might try to fix that here too...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402:532,extend,extend,532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402,1,['extend'],['extend']
Modifiability,"@tomchor do you mind if I generalize this issue to talk about refactoring the examples in general?. Here are my thoughts:. 1. I agree we should combine Langmuir turbulence and Ocean wind mixing and convection. I think we should implement one LES example with all bells and whistles: surface waves, wind forcing and buoyancy forcing, temperature/salinity, and potentially also a nonlinear equation of state. 2. I think we should keep convecting plankton and continue to develop that as a pedagogical example for both time-dependent boundary conditions and to illustrate Oceananigans' potential for chemistry / biology modeling via nonlinear forcing functions. 3. I think we should convert the Eady turbulence example to something that uses the hydrostatic model with bathymetry (perhaps some baroclinic instability example with bathymetry). 4. We should get rid of the geostrophic adjustment example. 5. We need an example on `LatitudeLongitudeGrid`. I also think we should generate rough timings for all the examples so we understand which ones are costing us the most.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507:62,refactor,refactoring,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1062523507,1,['refactor'],['refactoring']
Modifiability,"@tomchor unfortunately we don't have an issue for this problem. @sandreza is it possible to open an issue to document the problem that we are seeing? In the case that this PR does not resolve the issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:478,config,configuration,478,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865,1,['config'],['configuration']
Modifiability,"@tomchor, I haven't implemented `MultiRegion` for `NonhydrostaticModel` yet. It would be quite easy to extent it if it weren't for the pressure solver which is done in two different ways and both of them are global (`FFT` and `TridiagonalFFT`). A quick and dirty solution would be to do as I have done with the `ImplicitFreeSurface` and reserve the calculation on 1 GPU only. The problem is that the pressure solve is 3D and not 2D so we would probably like to use the `cuFFT` multi-gpu functionality (in particular the cuFFTxt library, which I hope is implemented in `CUDA.jl` although I haven't checked yet) I ll open a PR to start implementing it. Regarding the `OutputWriters`, they are implemented in jld2 trivially with `reconstruct_global_field`. ; You can specify a `JLDOutputWriter` as you do for a single region grid, provided you don't want to slice the direction across the regions ; for example you cannot do; ```; indices = (1:10, :, :) ; ```; for an `XPartition` or ; ```; indices = (:, 1:10, :); ```; for a `YPartition`; (`MultiRegion` does not play well with `indices` at the moment). . It runs, but there is a weird bug for which the fields are not updated as the model timesteps (i.e., all the outputs are the initial condition). I think it is easily solvable but I have to take a deeper look. So basically, it is not working at the moment... On the other hand, to anticipate the `CubedSphere` refactor, we probably want to have `OutputWriters` which output all regions separately (as `reconstruct_global_field` does not mean much in a cubed sphere context). The `OutputReaders`, on the other hand, are completely undefined",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116860842:1413,refactor,refactor,1413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116860842,1,['refactor'],['refactor']
Modifiability,"@tomchor:. - I don't understand what ""really"" means in ""it didn't really work"". Did it work or it didn't work?. - In case there was an issue, can you elaborate what that was and why `Adapt` is the solution?. - Last, if there is still an issue and this PR fixes it then it worths a patch release. There is no quota of patch releases. We can release as many as we need to.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616:183,Adapt,Adapt,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2030#issuecomment-953473616,1,['Adapt'],['Adapt']
Modifiability,"A ""dynamic function invocation"" means that the compiler thinks a function is being called whose scope can change ""dynamically"" (I think). This is the error one gets when a function depends on a global variable that is not `const` (for example). In this case, the error tells us that the types of the objects involved in calling `getindex` defined on `BinaryOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/AbstractOperations/binary_operations.jl#L34. are not correctly inferred. The way getindex comes into play is in the kernel function `_compute!` that evaluates the `AbstractOperation`:. https://github.com/CliMA/Oceananigans.jl/blob/c3b688f9ef125faeac3aa9d7fd57f0dd2d392380/src/Fields/computed_field.jl#L84-L87. calling `getindex(operand, i, j, k)` (or equivalently `operand[i, j, k]`) triggers recursive `getindex` calls that traverse the `AbstractOperation` tree. It seems that when the tree is too large, this traversal cannot be entirely compiled. Perhaps there are tricks we might use to help the compiler parse this kind of operation, like putting some type annotations / hints into `getindex(b::BinaryOperation, ...)`. Not sure. Another possibility is to figure out how to simplify the object `BinaryOperation`, `MultiaryOperation`, so that the compiler is less stressed trying to compile them... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140:201,variab,variable,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738838140,1,['variab'],['variable']
Modifiability,"A ""schedule"" is a function or callable object with a method. ```julia; schedule(model); ```. that returns true or false based on a criterion. `true` means ""do something"". The cleanest way to get this feature is to refactor the output writers to have a more generic interface for splitting. If we have a property called `file_splitting` that _is_ a schedule, then we can write. ```julia; NetCDFOutputWriter(model, outputs; file_splitting = TimeInterval(30days), ...); ```. Then the decision about whether to start a new file will change from. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L275. to. ```julia; writer.file_splitting(model) && start_next_file(model, writer) ; ```. Next, you will have to add a new schedule in `Utils/schedules.jl` that can split based on filesize:. ```julia; mutable struct FileSizeLargerThan <: AbstractSchedule; max_filesize :: Float64; path :: String; end. (fslt::FileSizeLargerThan)(model) = filesize(fslt.path) >= fslt.max_filesize; ```. Finally, you need to add a user interface for initializing and modifying the schedules to smooth out the user experience (for example, we don't want users to have to specify the file path more than once, and the file path that is checked by the schedule has to be updated). This will have to take two parts. In `Utils/schedules.jl`, a constructor:. ```julia; FileSizeLargerThan(max_filesize) = FileSizeLargerThan(max_filesize, """"); ```. Then in output writers, an interface to be used in both the model constructor and `write_output!`:. ```julia; update_schedule!(schedule, path) = nothing; update_schedule!(schedule::FileSizeLargerThan, path) = schedule.path = path; ```. This function `update_schedule!(writer.schedule, path)` then replaces this line. https://github.com/CliMA/Oceananigans.jl/blob/9f3f8e6d1469e570b0778f328ab864e879785ffd/src/OutputWriters/jld2_output_writer.jl#L276. and also needs to be added in the output writer constructor ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793:214,refactor,refactor,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000029793,2,['refactor'],['refactor']
Modifiability,A bug in the limiting by `maximum_diffusivity` caused this scheme to blow up in default configuration (and be generally incorrect). This PR fixes that and makes a few more tweaks: horizontal filtering can be optionally added (and we implement an interface for adding new horizontal filters). We also add a minimum entrainment buoyancy gradient. Closes #3283,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3510:88,config,configuration,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3510,1,['config'],['configuration']
Modifiability,A default argument works great too! You can also capture data as a global variable:. ```julia; julia> a = 3; 3. julia> f(x) = x * a; f (generic function with 4 methods). julia> f(2); 6; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1002609481:74,variab,variable,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1002609481,1,['variab'],['variable']
Modifiability,"A few more comments:. * Perhaps we can name `SomethingBiogeochemistry` ""BasicBiogeochemistry"". I think this is appropriate communication about the purpose of this object; large, sophisticated packages should implement their own models from the ground up.; * I think `light_attenuation_model` is too specific for `BasicBiogeochemistry`. For example, it only pertains to biology; however some models are chemistry-only. @jagoosw do you mind if I address these, and also adapt `test_biogeochemistry.jl` into a form that's close to merge-ready?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1334717022:468,adapt,adapt,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1334717022,1,['adapt'],['adapt']
Modifiability,"A general question. In the tests a variable `results` is created, which is a mutable struct Dict. I see that map is a way to pick out elements of this object. When I ask for information on resutls I get something like this. ```julia> results; Dict{Any,Any} with 1 entry:; CenteredSecondOrder => fill((cx = (simulation = [-8.07688e-137, -2.28227e-125, -1.9026e-114, -4.67931e-104, -3.39525e-94, -7.26804e-…; ```. How do I get values from this object? . From looking in the scripts I gather that we need to use `map` but not sure what fields to get or how to get them. I found out that I can get a bit more inside using `results[CenteredSecondOrder]` but still not sure how to access the arrays.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363:35,variab,variable,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745408363,1,['variab'],['variable']
Modifiability,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:1161,parameteriz,parameterization,1161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142,4,['parameteriz'],['parameterization']
Modifiability,"A new idea for extending the pressure solver to `MultiRegion` is to divide the FFT computations into ""local"" and ""non-local"" directions. . The FFT in local directions can be easily performed wrapping the transform in `@apply_regionally`; For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). . This strategy would not be easily extensible to generally subdivided regions and will play well only with one direction partitioning, but given the current limitations of the FFT solver (only regular grid), I think it is a good strategy to get something to work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969:15,extend,extending,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969,1,['extend'],['extending']
Modifiability,"A number of issues are accumulating with `TurbulenceClosures` that we need to address:. 1. #1277 (inconsistency between docs and storage of molecular diffusivity in eddy viscosity scratch array); 2. #1278 (unfortunate default diffusivities for IsotropicDiffusivity and some of the LES closure diffusivities); 3. #1279 (incorrect usage of the term ""biharmonic"", and also the fact that there is no true biharmonic diffusivity). A second annoying issue is the use of `model.diffusivities` as auxiliary space for the eddy diffusivities. Now that we know a bit more about using `adapt_structure`, we can readily put references to eddy diffusivities inside the LES closure objects themselves. Doing this will require refactoring the constructor for `IncompressibleModel`, unfortunately, because we'll need to define a function `regularize_turbulence_closure` so that we can build scratch space once we know what the `grid` is. I also think it's high time that we nuked `RozemaAnisotropicMinimumDissipation` and `BlasiusSmagorinsky`, and also eliminated the ""buoyancy modification"" term from `VerstappenAnisotropicMinimumDissipation`, since it doesn't actually work --- and because we have reason to believe that it may not actually improve the accuracy of the closure, even _if_ correctly implemented. Lastly, I think much of the code in `TurbulenceClosures` could be consolidated. I wanted to put this issue out there in case anyone is somehow using the Rozema version of AMD or Blasius version of Smagorinsky that I don't know about. These are not our most urgent priorities now, but after peeking into the turbulence closures module recently I think it'll be useful to gather all the various improvements we need into one issue.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1381:711,refactor,refactoring,711,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1381,1,['refactor'],['refactoring']
Modifiability,"A question for @glwagner . At the moment the tendencies in the evolution equation for height is computed here using essentailly a second-order finite difference method. This is fine for a start, but as discussed elsehwere, it would be better to use finite volume and therefore using the advection schemes that already exist. https://github.com/CliMA/Oceananigans.jl/blob/fjp/update-convergence-tests/src/Models/ShallowWaterModels/solution_and_tracer_tendencies.jl#L71. In line 69 above you will see that I tried doing this by definig a new operator, div_UV, for partial_x U + partial_y V. This was clunky because I needed to pass variables U and V, and I had an error. The details can be found here,. https://github.com/CliMA/Oceananigans.jl/blob/9402a90af072a495ef130d540661be9327a51552/src/Models/ShallowWaterModels/shallow_water_advection_operators.jl#L24. Can you suggest a better way of doing this?. When I try running the tests most of the pass except at line 82 I get the following error . ```; [2021/01/11 15:36:04.735] INFO Testing time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]...; ERROR: a exception was thrown during kernel execution.; Run Julia on debug level 2 for device stack traces.; Time-stepping ShallowWaterModels [GPU(), (Periodic, Periodic, Bounded)]: Error During Test at /home/fpoulin/software/Oceananigans.jl/test/test_shallow_water_models.jl:82; Test threw exception; Expression: time_stepping_shallow_water_model_works(arch, topo, nothing); KernelException: exception thrown during kernel execution on device Quadro P400; Stacktrace:; [1] check_exceptions() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/compiler/exceptions.jl:94; [2] prepare_cuda_call() at /home/fpoulin/.julia/packages/CUDA/YeS8q/src/state.jl:85; [3] initialize_api() at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/error.jl:92; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/YeS8q/lib/cudadrv/libcuda.jl:975 [inlined]; [5] macro expansion at /home/fpoulin/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952:630,variab,variables,630,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-758077952,1,['variab'],['variables']
Modifiability,"A warning might make sense. `show` can be more specific (spacing `Array` doesn't mean that the spacing is variable, it means the spacing is given by an `Array`). It's good at least now that `show` helps you realize that `Array` spacings are special.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022770084:106,variab,variable,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2192#issuecomment-1022770084,1,['variab'],['variable']
Modifiability,Abstraction for configuring kernels,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3067:16,config,configuring,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067,1,['config'],['configuring']
Modifiability,"Actually I'll reopen this since I'm still getting an error, albeit a different one:. ```; julia> grid; 44×8×52 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [4.35026e-15, 894.427) regularly spaced with Δx=20.3279; ├── Periodic y ∈ [-8.74514e-15, 178.885) regularly spaced with Δy=22.3607; └── Bounded z ∈ [-178.885, 178.885] variably spaced with min(Δz)=4.76685, max(Δz)=21.2525. julia> minimum_zspacing(grid); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:89; [2] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/utils/call.jl:26; [4] #39; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CuStream, CuFunction, CuDim3, CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::CuDeviceArray{Float64, 4, 1}, ::KernelFunctionOperation{Center, Center, Center, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Of",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457:374,variab,variably,374,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490569457,1,['variab'],['variably']
Modifiability,"Adapt Field, AveragedField, and ComputedField for GPU, round 2",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1057:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057,1,['Adapt'],['Adapt']
Modifiability,Adapt `DiscreteForcing` for the GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1642:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1642,1,['Adapt'],['Adapt']
Modifiability,Adapt cell_advection_timescale for ShallowWaterModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307,1,['Adapt'],['Adapt']
Modifiability,Adapt for `ImmersedBoundaryCondition`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2564:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2564,1,['Adapt'],['Adapt']
Modifiability,"Adapt got a breaking change recently from v3 to v4. I'm not sure what the breaking change was tbh. We are using v3 up to now. @glwagner, is the help from Adapt you point out from v3 or v4?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028:0,Adapt,Adapt,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867881028,2,['Adapt'],['Adapt']
Modifiability,Adapting BoundaryCondition with AbstractArray to play nice with CUDA,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/205:0,Adapt,Adapting,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/205,1,['Adapt'],['Adapting']
Modifiability,"Adapting Smagorinsky seems an easy avenue. . In terms of Implicit LES, you could try using just WENO without any closure, but if you are in a true LES regime it would probably be too dissipative. A Smagorinsky viscosity combined with an energy-conserving advection scheme has been found to be less dissipative although noisier (here is an example applied to Burgers equation https://reader.elsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any s",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433:0,Adapt,Adapting,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433,1,['Adapt'],['Adapting']
Modifiability,Adaptive (CFL-based) time step in the SplitExplicit solver,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3145:0,Adapt,Adaptive,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3145,1,['Adapt'],['Adaptive']
Modifiability,Adaptive time stepping,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/189:0,Adapt,Adaptive,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/189,1,['Adapt'],['Adaptive']
Modifiability,Adaptive time stepping for VerticallyStretchedRectilinearGrid( ),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741:0,Adapt,Adaptive,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741,1,['Adapt'],['Adaptive']
Modifiability,Adaptive time stepping through wizardry,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297:0,Adapt,Adaptive,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297,1,['Adapt'],['Adaptive']
Modifiability,Adaptive time-stepping on all grids,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497:0,Adapt,Adaptive,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497,1,['Adapt'],['Adaptive']
Modifiability,Added adapt method for scalar and scalar biharmonic diffusvity + test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3401:6,adapt,adapt,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3401,1,['adapt'],['adapt']
Modifiability,"Adding this before I forget. It could be useful to have builtin support for getting wall clock time spent in key ""blocks"" of code during any; simulation. . For example knowing how long is spent in iterative solver, how long in I/O, how long in time stepping, how long in initialization, how long in dynamics computations, how long in tracer computations, how long in communication etc.. can be a useful check and help see what is requiring resources in different configurations.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1862:463,config,configurations,463,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862,1,['config'],['configurations']
Modifiability,Additionally can you help me understand why you are using `GradientBoundaryCondition` at all? I had thought that it's usually preferred to use `FluxBoundaryCondition` since this is often the preferred parameterization for large scale motions and basically we only use `ValueBoundaryCondition` for DNS (and `GradientBoundaryCondition` almost never). Curious to understand the class of problems that benefit from `GradientBoundaryCondition`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2207703968:201,parameteriz,parameterization,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2207703968,1,['parameteriz'],['parameterization']
Modifiability,Advection Refactor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2642:10,Refactor,Refactor,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2642,1,['Refactor'],['Refactor']
Modifiability,After #2522 me and @dhruvbhagtani will start working on the multi-layer. The plan is to extend the `ShallowWaterModel` to allow non-flat `z` dimensions with `Nz` the number of fluid layers. It would be good if we add a regression test for the single-layer `ShallowWaterModel` to ensure we don't break things in the process.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137948975:88,extend,extend,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137948975,2,"['extend', 'layers']","['extend', 'layers']"
Modifiability,"After talking a bit with @ali-ramadhan, I think we might have settled on the following solution:. * Introduce a new type called `PhysicalParameters` that holds `g` and `ρ0`; * Introduce a new abstract type called `Rotation` (or some such) that encodes information about the background rotation rate of the model --- `TangentPlane` with `f` and `β`, and possibly non-traditional Coriolis parameters, another type for the sphere, etc.; * Group viscous and diffusive transport coefficients into the upcoming `TurbulenceClosure` type, allowing for isotropic constant transport coefficients, anisotropic constant coefficients, or nonlinear closure schemes. These changes will also require us to compute buoyancy rather than a density perturbation, and may motivate us to simplify the code by defining variables in `pressures` as having units of the 'kinematic pressure', which is the ordinary pressure divided by `ρ0`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-494898546:796,variab,variables,796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-494898546,1,['variab'],['variables']
Modifiability,"Agreed. Useful and related comment. > I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR [vchuravy/GPUifyLoops.jl#18](https://github.com/vchuravy/GPUifyLoops.jl/pull/18).; > ; > The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in [#59 (comment)](https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181)) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs.; > ; > You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations.; > ; > Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.; >; >_Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/115#issuecomment-470782067_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910:101,sandbox,sandbox,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910,5,"['extend', 'rewrite', 'sandbox', 'variab']","['extended', 'rewrite', 'sandbox', 'variable']"
Modifiability,Ah I think you added `sandbox/vertically_stretched_plankton.jl` back in when we meant to keep it nuked but we can worry about it after this PR is merged.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652214:22,sandbox,sandbox,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1393#issuecomment-783652214,1,['sandbox'],['sandbox']
Modifiability,Ah it was just a try. `\bm` comes from the `bm` LaTeX package which I guess was available with KaTeX. For MathJax we might have to define the `\bm` command at the top of the pages that use it?. [Equation numbering still doesn't work](https://clima.github.io/OceananigansDocumentation/previews/PR1530/numerical_implementation/time_stepping/) but apparently it's because MathJax3 doesn't enable it by default: http://docs.mathjax.org/en/latest/input/tex/eqnumbers.html. Looks like we can configure it by passing a dict to the `MathJax3` constructor though: https://juliadocs.github.io/Documenter.jl/stable/lib/internals/writers/#Documenter.Writers.HTMLWriter.MathJax3,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-811481173:486,config,configure,486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1530#issuecomment-811481173,1,['config'],['configure']
Modifiability,"Ah ok I see why your original script didn't work now. When executing. ```julia; model = IncompressibleModel(grid=grid,; closure = closure,; boundary_conditions = (v=v_bcs); ); ```. this assigned `v_bcs` to the new variable `v` and passes it to the `IncompressibleModel` function. `v_bc` itself is a `NamedTuple` containing `x, y, z` properties so the `IncompressibleModel` constructor does not complain. Since the named tuple that is passed does not not have a `v` property, the velocities get the default boundary conditions (free slip and no normal flow). Then when you call `set!(model, v=-0.5)` it fills v to be -0.5 everywhere but then `update_state!(model)` is called to ensure that the velocity field is incompressible (divergence-free) by performing a pressure projection step. Since the default boundary condition enforces no-normal flow, the velocity cannot be -0.5 everywhere so the pressure field updates it to be zero to enforce incompressibility. This is a pretty subtle bug (related to #1204)... Since the proper named tuple can't be checked for in the constructor function signature, I wonder if it's worth adding a manual check to make sure a `NamedTuple{(:x,:y,:z)}` was not passed to the model constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930:214,variab,variable,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930,1,['variab'],['variable']
Modifiability,"Ah sorry about that! Happy to chat over Slack but don't wanna butcher @glwagner's suggestion. I guess having the `X, Y, Z` is important for `NetCDFOutputWriter` since it uses that information to know which dimensions to assign to each variable. They could be specified manually via the `dimensions` kwarg (there should be an example of this in the docstring) but ideally the dimensions should be detected automatically for an Oceananigans field. Maybe you just need to use `reduced_location` to determine the `X, Y, Z` for the `SpatialWindowAverage`? https://github.com/CliMA/Oceananigans.jl/blob/0ff8cd8e7d4565c8493ec7b81e531599277ab645/src/Fields/reduced_field.jl#L137. Maybe something like this could work?. ```julia; function SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()); X, Y, Z = reduced_location(location(field), dims=dims); return SpatialWindowAverage{X, Y, Z}(field.data, field.grid, field, field_slicer, dims); end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783553934:235,variab,variable,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783553934,1,['variab'],['variable']
Modifiability,Ah sorry for the slow reply. Docs build on `tartarus.mit.edu` through Buildkite which has GPUs but we disable the GPU through the Buildkite config. I think if we just remove this line we can build examples on the GPU!. https://github.com/CliMA/Oceananigans.jl/blob/81d9c0e061cae4aa5a0ec770ff8348be7517aa53/.buildkite/pipeline.yml#L324. Doesn't have to happen in this PR of course.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802307902:140,config,config,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1495#issuecomment-802307902,1,['config'],['config']
Modifiability,"Ah yes as noted here:. > This speed issue disappears either when ζ = ∂x(v) - ∂y(u) is replaced with ζ = Field(∂x(v) - ∂y(u)), or when ζ is the only variable in fields_slice. That's pretty bizarre. That makes me think it's some kind of weird interaction between `NCDatasets` and `Oceananigans`. I can say, with `ζ = Field(∂x(v) - ∂y(u))` the output type is different. It would seem more complex in fact, because it has one more layer of indirection (ie it's the window that refers to a 3D computed field, rather than a windowed computed field). So I don't know why that would compile faster. Honestly I don't think any of us has much experience optimizing compile time. Perhaps first reading this blog post:. https://julialang.org/blog/2020/08/invalidations/. and then the source code for `NetCDFOutputWriter` will lead to revelations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189:148,variab,variable,148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189,1,['variab'],['variable']
Modifiability,Ah yes! Seems like we were probably not doing it exactly right before... We could also add the environment variable `JULIA_DEBUG=Documenter` if people think it's helpful to get an idea of which example is currently being built (for when you build docs + examples locally).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1542#issuecomment-819466377:107,variab,variable,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1542#issuecomment-819466377,1,['variab'],['variable']
Modifiability,"Ah, I see the problem... all the `viscous_flux` are formulated in terms of velocities `U.u, U.v, U.w` which the shallow water model does not necessarily have. This will be slightly more involved to fix than just changing the signature of the function. . It depends how you want to formulate the viscous operator, as a diffusion of `u` or a diffusion of `uh`. If the former is _always_ the desired formulation, both in the vector invariant and the conservative equations, then it might be useful to add the velocities as a field of the shallow water model and pass them to the tendency kernel. . So indeed, we should open a PR to adapt the shallow water model to work with closures",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100:629,adapt,adapt,629,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152698100,1,['adapt'],['adapt']
Modifiability,"Ah, I see... ```; @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = δxᶠᵃᵃ(i, j, k, grid, Δy_qᶜᶠᶜ, v) - δyᵃᶠᵃ(i, j, k, grid, u, Δx_qᶠᶜᶜ, u); ```; that can also work... maybe more robust since differences are already extended for `Flat` grids. I agree",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054866428:201,extend,extended,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054866428,1,['extend'],['extended']
Modifiability,"Ah, I think suffice to say that in the context of the Craik-Leibovich equations, whenever the word ""Stokes drift"" is used, it's ""pseudomomentum"" that is really meant. . In particular the original context of ""Stokes drift"" is the specific situation in which surface waves forced from rest are associated with a mean Lagrangian current that causes particles and fluid to ""drift"". In the Craik-Leibovich equations, the Lagrangian-mean momentum is a prognostic variable and is not determined or _explicitly_ modified by the ""Stokes drift"" (it is only _implicitly_ modified through changes to the fluid physics). Thus rather than causing fluid to ""drift"", specifying the ""Stokes drift"" in the Craik-Leibovich equations (and in Oceananigans) instead acts to modify the underlying fluid dynamics by changing the relationship between momentum and vorticity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-779826789:457,variab,variable,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-779826789,1,['variab'],['variable']
Modifiability,"Ah, right! We have to extend the outer functions (`left_biased_interpolate`, `right_biased_interpolate`, and `symmetric_interpolate`) instead of the `inner` ones",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1276402805:22,extend,extend,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1276402805,1,['extend'],['extend']
Modifiability,"Ah, the only issue is there will be conflicts with #1575. It shouldn't be hard to refactor these changes to work with the code on that PR though I don't think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1593#issuecomment-820023429:82,refactor,refactor,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1593#issuecomment-820023429,1,['refactor'],['refactor']
Modifiability,All the arrays right now are of size `Nx*Ny*Nz` but technically there are `Nx` volumes in the _x_-direction and `Nx+1` faces so the output should match this and make sense. The easiest thing to do with the doubly periodic configuration we have right now is to have row `Nx+1` be a repeat of row `1` but writing out the fields at the very bottom (`k=Nz+1`) might require some extra computation?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/92:222,config,configuration,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/92,1,['config'],['configuration']
Modifiability,"Alright so as suggested I added a test for CFL calculation with a vertically stretched grid. Also refactored where the minΔx functinos go like @glwagner suggested, so if the tests pass I believe this should be good to go. @ali-ramadhan should I just call JuliaRegistrator to register this after it's merged?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799660063:98,refactor,refactored,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1467#issuecomment-799660063,1,['refactor'],['refactored']
Modifiability,Also apologies if this is PR feature scope but I found it easier to refactor if I de-cluttered the `ImmersedBoundaries.jl` module file. This ended up creating three new files:. * `immersed_boundary_grid.jl`; * `immersed_boundary_interface.jl`; * `immersed_boundary_nodes.jl`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459922652:68,refactor,refactor,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459922652,1,['refactor'],['refactor']
Modifiability,"Also one thing that is important to get right in multi-layer shallow water models is layer-wise conservation of mass and other properties (see _e.g._, https://aronnax.readthedocs.io/en/latest/verification.html and http://www.nordet.net/beom.html). > Topography that can interact more than one layer is complicated because then we need wetting and drying, but it won't need immersed boundaries. At least i don't think so. Wetting and drying usually requires a positive preserving advection scheme. We have first-order upwinding (which I don't think anyone has every used), that is positive preserving and could do this. But it's not a great scheme. A limiter would be better. There are a lot of methods out thatk, but not the first thing to worry about. This if much longer term, I would say. In addition to positive-preserving advection schemes, it seems one other way to deal with this is adding to the pressure gradients an extra term that prevents the thicknesses of outcropped/incropped layers from reaching zero following [Salmon (2002)](https://www.ingentaconnect.com/content/jmr/jmr/2002/00000060/00000004/art00004?token=005b148389c57630504c2a726e2d58464340592f713b672c57582a67232d45234a46246c6a4d2c3167732355e72). There is a deep discussion on the physics and practical implementation of this in different validation simulations in http://www.nordet.net/etc/doc_beom.pdf. Just wanted to put this out there, I don't have a good feel for which approach would be most desirable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194:991,layers,layers,991,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115738194,1,['layers'],['layers']
Modifiability,"Also this works:. ```julia; julia> import Base: minimum. julia> using OffsetArrays. julia> minimum(a::SubArray{<:Any, <:Any, <:OffsetArrays.OffsetVector}) = minimum(parent(parent(a))); minimum (generic function with 21 methods). julia> minimum(zspacings(grid, Center())); 1.0. julia> grid; 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0; ```. so it might have something to do with the `KernelFunctionOperation` that's used here?: https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Grids/grid_utils.jl#L407-L413",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490607038:527,variab,variably,527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490607038,1,['variab'],['variably']
Modifiability,"Also to be clear, declaring something as `const`, and then inserting that variable's value into another data structure does not guarantee that the value in the second data structure is fixed. `const` attaches to a name and does not ""propagate"" into other data structures like `ContinuousBoundaryFunction.parameters`. So things like the following are valid:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> const b = 2; 2. julia> t = Test(b); Test{Int64}(2). julia> t.a = 3; 3. julia> t; Test{Int64}(3); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691:74,variab,variable,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881686691,2,['variab'],['variable']
Modifiability,"Also what we'd call `filename` would be different than what is called file name in the docs for [`JLD2`](https://docs.juliahub.com/JLD2/O1EyT/0.4.22/internals/#JLD2.jldopen) and [`NCDatasets`](https://alexander-barth.github.io/NCDatasets.jl/stable/variables/#NCDatasets.NCDataset-Tuple{NCDatasets.CFVariable}), which might be a source of confusion in new users.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098254438:248,variab,variables,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2435#issuecomment-1098254438,1,['variab'],['variables']
Modifiability,"Also, `float_type` is part of the grid and all field defined on the grid could inherit that, right?; (perhaps this is already the case?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-875268386:79,inherit,inherit,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1825#issuecomment-875268386,1,['inherit'],['inherit']
Modifiability,"Although I prefer being explicit I'm a big fan of the macro you suggested as it collapses 20+ lines into a single elegant statement (and buries the ugly unpacking) whereas the `unpack_model` function still requires a comma separate list of 20+ variables. I think I'll go with the simple macro. If the unpacking variables have descriptive names, e.g. `grid`, `source_terms`, `velocities`, etc. then I think it'll still be understandable without being explicit.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/155#issuecomment-477595870:244,variab,variables,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/155#issuecomment-477595870,2,['variab'],['variables']
Modifiability,"An easier course of action would be to forget about performance at first and just fill halos every substep.; This will be quite inefficient but will allow us to test open boundary conditions for the hydrostatic model and validate them first. There is an implementation of a split explicit free surface solver that does not require special operators (specifically for a multi region grid) in #3596 ; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L130-L170. We could adapt this implementation for normal grids by implementing a keyword argument in the `SpliExplicitFreeSurface` constructor. Something like the `extended_halos` that is mentioned here; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L19-L28. For serial grids, `extended_halos` is not the correct argument, though, because we do not extend halos (we do that only on distributed and multi region grids), so maybe something like `use_boundary_aware_operators.` . Once the numerics have been settled we can adapt the open boundary condition implementation to the special operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268:566,adapt,adapt,566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268,3,"['adapt', 'extend']","['adapt', 'extend']"
Modifiability,"And just to clarify, when I say ""extend"" I'm referring to ""method extension"" --- in other words, defining new methods for a function that *dispatch* on the number or arguments and argument types.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761152934:33,extend,extend,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761152934,1,['extend'],['extend']
Modifiability,"Another application is for regularization in parameterizations, for example:; ```julia; Ri = ℑxyᶜᶜᵃ(i, j, k, grid, ℑxyᶠᶠᵃ, diffusivities.Ri) # Not boundary-aware . Ri = ℑxyᶜᶜᶜ(i, j, k, grid, ℑxyᶠᶠᶜ, diffusivities.Ri) # Boundary-aware ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3158#issuecomment-1610955565:45,parameteriz,parameterizations,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3158#issuecomment-1610955565,1,['parameteriz'],['parameterizations']
Modifiability,"Another benefit of removing the hydrostatic pressure is that we can improve the documentation and user interface too. For example, the hydrostatic pressure in the hydrostatic model is stored in something like. ```; model.pressure.pHY; ```. since for the nonhydrostatic model its. ```; model.pressures.pNHS; model.pressures.pHY; ```. With just one pressure field we should simply write `model.pressure` for both cases. It's a significant refactor to remove hydrostatic pressure --- I don't think we want to do the hacky thing that we did to set up that PR that just keeps the same structures but sets pressure to `nothing`, we want to do it properly and update the docs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281:437,refactor,refactor,437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518172281,2,['refactor'],['refactor']
Modifiability,"Another design we can consider is something like:; ```julia; grid = RegularCartesianGrid(size=(x=128, z=64), x=(-1, 1), z=(-1, 0), topology=(x=Periodic, z=Bounded)); ```; where since `y` has not been specified, it is assumed to be `Flat`. This makes the grid constructors more verbose but has the added benefit of being clearer and not having to specify flat dimensions, i.e. it's an xz-model so y should not even be mentioned. It would require a lot more refactoring though... but now's the time I guess.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581830270:456,refactor,refactoring,456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/614#issuecomment-581830270,1,['refactor'],['refactoring']
Modifiability,Another outstanding issue is the formulation of tracer evolution. At the moment we are evolving tracers but maybe we want to evolve thickness weighted tracers,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165844286:125,evolve,evolve,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165844286,1,['evolve'],['evolve']
Modifiability,Another possibility is that we refactor the code to generalize integer types. Which is not actually a horrible idea. There's some notion that we may also benefit from index types that are `Int32`. Adding an integer type for `Nx` would allow us to also automatically convert integers to `Int32` (eg we write something like `i = inttype(grid)`).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731452482:31,refactor,refactor,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731452482,1,['refactor'],['refactor']
Modifiability,"Apparently there are some averages that don't work when the grid is stretched:. ```julia; julia> grid = RectilinearGrid(size = (4, 4, 4), x = (0, 1), y=(0, 1), z=(k,) -> k); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [1.0, 5.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> field = Field{Face, Face, Face}(grid); 4×4×5 Field{Face, Face, Face} on RectilinearGrid on CPU; ├── grid: 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=Nothing, top=Nothing, immersed=ZeroFlux; └── data: 6×6×7 OffsetArray(::Array{Float64, 3}, 0:5, 0:5, 0:6) with eltype Float64 with indices 0:5×0:5×0:6; └── max=0.0, min=0.0, mean=0.0. julia> Average(field, dims=(1,2)); Reduction{typeof(Statistics.mean!), Field{Face, Face, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}, Tuple{Int64, Int64}}(Statistics.mean!, 4×4×5 Field{Face, Face, Face} on RectilinearGri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2189:403,variab,variably,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2189,1,['variab'],['variably']
Modifiability,"As HydrostaticFreeSurfaceModel is further developed we're going to have to restructure the docs significantly. In addition to that the docs have grown a bit stale and could probably use a refresh. I think it's a good time too to leverage the year or two of experience we've accumulated using Oceananigans to refactor the docs to make them more useful and practical. Here's the current structure:. 1. Home; 2. Installation instructions; 3. Using GPUs; 4. Examples; 5. Physics; 6. Numerical implementation; 7. Model setup; 8. Simulation tips; 9. Contributor's guide; 10. Gallery; 11. References; 12. Appendix. I propose refactoring this in a few ways:. * Adding a sort of ""quick start"" section (perhaps named just that) after ""Installation"". This will implement a similar simple example as `one_dimensional_diffusion.jl`, except with even more text, explaining basic important types and functions and providing links to other parts of the docs to obtain more information.; * ""Flattening"" the model setup section by bringing its sections out into the main list. I think this list should be refactored too according to what's important. For example, we don't need a whole section on `Clock`.; * Adding independent sections for each model type; * Moving ""Physics"" and ""Numerical implementation"" down in the docs to emphasize code documentation. The resulting structure might be something like. 1. What's Oceananigans?; 2. Installation; 3. Getting started; 4. Examples; 5. Grids; 6. Fields, BoundaryCondition, and AbstractOperations; 7. IncompressibleModel; 8. HydrostaticFreeSurfaceModel; 9. ShallowWaterModel; 10. Setting initial conditions; 11. Diffusion, viscosity, and TurbulenceClosures ; 12. Forcing functions; 13. Coriolis forces; 14. Buoyancy forces; 15. OutputWriters; 16. OutputReaders, post-processing, and plotting; 17. Using Graphics Processing Units (GPUs); 18. Useful tips and common pitfalls (from ""simulation tips""); 19. Contributor's guide; 20. Gallery (this should be way higher eventual",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852:308,refactor,refactor,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852,2,['refactor'],"['refactor', 'refactoring']"
Modifiability,"As a first step towards porting the Simulations infrastructure out of Oceananigans and into (ClimaEarth)[https://github.com/CliMA/ClimaEarth.jl], we should refactor the Simulations implementation so that it gets loaded _first_. Currently, it is loaded last:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Oceananigans.jl#L195-L229. This reorganization will help disentangle the current implementation from Oceananigans.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3088:156,refactor,refactor,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3088,1,['refactor'],['refactor']
Modifiability,"As a side note: I started working on a PR that adds tests to make sure we can write output from all grids, which would also help with #1429. But yeah, I don't think it'll be a quick PR since the grids all use different property names... Sounds like the variable names used in NetCDF might be an issue? I've had no problems with unicode variable names in NetCDF but I don't use IPython...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799818546:253,variab,variable,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799818546,2,['variab'],['variable']
Modifiability,"As a user, I prefer an internal ""settings"" dictionary over an environment variable. Actually, I think it would be better to define a function `Oceananigans.set_default_number_type(FT)` for users to access the ""setting"" dictionary. One reason is that an error will be thrown when the user makes a typo. Another option is to pass `FT=Float32` to the model and then let the constructor convert related components to `Float32` \(or `Float64` if `FT=Float64` is passed\). I feel it might be the most user-friendly interface. But obviously it will lots of efforts to implement.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644:74,variab,variable,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2389733644,2,['variab'],['variable']
Modifiability,"As discussed on #1153 we may start developing a `ShallowWaterModel` soon. To reuse as much code as possible, we may want to refactor the `TimeSteppers` and `Models` modules. Right now, `TimeSteppers` is included after `Models`:. https://github.com/CliMA/Oceananigans.jl/blob/4b972b580e7db9f49c314ab09280a2f99e5c1e32/src/Oceananigans.jl#L136-L137. However, with more than one model, we probably want to use dispatch to control the behavior of key functions in the time-steppers. For example, we'd have. ```julia; calculate_pressure_correction!(::ShallowWaterModel) = nothing; pressure_correct_velocities!(::ShallowWaterModel) = nothing; ```. Thus I think what we want to do is to include the `TimeSteppers` module first, with the definitions. ```julia; function calculate_pressure_correction! end; function pressure_correct_velocities! end; ```. and subsequently add methods in the `Models` submodule appropriate to the physics / formulation of each model.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165:124,refactor,refactor,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165,1,['refactor'],['refactor']
Modifiability,"As discussed with @jm-c, the organization of physical constants and parameters is somewhat confusing. Currently, constants are stored in three places:. 1. `PlanetaryConstants`, which stores a rotation rate, gravitational acceleration, and a Coriolis parameter used in an f-plane approximation; 2. `ModelConfiguration`, which stores anisotropic (potentially turbulent) viscosities and diffusivities; 3. `EquationOfState`, of which there is only one kind: `LinearEquationOfState`, which stores both parameters associated with the equation of state in addition to a reference density. I see a few problems:. * `f` is not a property of a planet.; * 'Model configuration' is an obscure name for turbulent or molecular transport coefficients.; * A reference density is not a parameter in an equation of state. I propose that we consolidate these three types into two, removing the reference density from `EquationOfState` and define a new type containing f, g, ρ0, ν, and κ. I'm not sure what to call the new type. One possibility is `FluidParameters` or `PhysicalParameters` or `PhysicalConstants`. I also propose that we cease support for anisotropic transport coefficients as parameters, defined generally, at least for the moment. We can support constant anisotropic transport coefficients as a type of LES closure in the future.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217:652,config,configuration,652,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217,1,['config'],['configuration']
Modifiability,"As for the `with_halo`, I am testing things out in REPL. Below you see that I have `with_halo` defined already but when I try the line you suggested it says that the function must be explicitly exported to be extended. Sorry that my function defining chops are not skilled enough to figure this out. ```; julia> methods(with_halo); # 2 methods for generic function ""with_halo"":; [1] with_halo(new_halo, old_grid::RegularRectilinearGrid) in Oceananigans.Grids at /home/fpoulin/software/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:218; [2] with_halo(new_halo, old_grid::VerticallyStretchedRectilinearGrid) in Oceananigans.Grids at /home/fpoulin/software/Oceananigans.jl/src/Grids/vertically_stretched_rectilinear_grid.jl:242. julia> with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ERROR: error in method definition: function Grids.with_halo must be explicitly imported to be extended; Stacktrace:; [1] top-level scope; @ none:0; [2] top-level scope; @ REPL[40]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844329017:209,extend,extended,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844329017,2,['extend'],['extended']
Modifiability,"As of PR #3783 the current config is to retry automatically once, but only if the exit status is 1. ```; retry:; automatic:; - exit_status: 1 ; limit: 1; ```. So I think this issue has been resolved. Thanks @glwagner!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3773#issuecomment-2397334483:27,config,config,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3773#issuecomment-2397334483,1,['config'],['config']
Modifiability,As part of the examples refactor I'm wondering whether we should we also change some of the examples to use a Makie variant for plotting?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064460506:24,refactor,refactor,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2326#issuecomment-1064460506,1,['refactor'],['refactor']
Modifiability,"As part of this PR it would probably make sense to refactor the interface between `Simulation` and output writers a bit. For example, `Callback` has a place to insert custom `initialize!` but output writers do not:. https://github.com/CliMA/Oceananigans.jl/blob/82503b811a305bd7a6c4f1d3650f2b25b535c8fa/src/Simulations/run.jl#L200-L214. The natural way to throw a warning would be during initialization, which should depend on both the output writer and the simulation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406:51,refactor,refactor,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3312#issuecomment-1749299406,1,['refactor'],['refactor']
Modifiability,"As soon as I put `fig[0, :] = Label(fig, title, textsize=24)` then the plot size gets all small and weird... Any ideas?. ```Julia; using GLMakie. filename = ""internal_wave"". fig = Figure(resolution = (800, 400)). ax = Axis(fig[1, 1];; xlabel = ""x"",; ylabel = ""z"",; limits = ((-π, π), (-π, π)),; aspect = AxisAspect(1)). iter = Observable(0). using JLD2. file = jldopen(filename * "".jld2""); grid = file[""serialized/grid""]. title = @lift(string(""ωt = "",; string(round(file[""timeseries/t/"" * string($iter)] * ω, digits=3)))). w = @lift(Array(file[""timeseries/w/"" * string($iter)][:, 1, :])). x, y, z = nodes((Center, Center, Center), grid). w_lim = 1e-8; w_levels = range(-w_lim, stop=w_lim, length=10). contourf!(ax, x, z, w; ; levels = w_levels,; colormap = :balance,; colorrange = (-w_lim, w_lim),; extendlow = :auto,; extendhigh = :auto). fig[0, :] = Label(fig, title, textsize=24). iterations = parse.(Int, keys(file[""timeseries/t""])). record(fig, filename * "".mp4"", iterations, framerate=8) do i; @info ""Plotting iteration $i of $(iterations[end])...""; iter[] = i; end; ```. https://user-images.githubusercontent.com/7112768/168449952-2ce68db5-1e21-4f04-8dc8-a29d2fba6c57.mp4. While with **everything same except** the line `fig[0, :] = Label(fig, title, textsize=24)` I get. https://user-images.githubusercontent.com/7112768/168450064-ab456174-06da-45e4-8674-55f0a3356091.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126821142:799,extend,extendlow,799,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2553#issuecomment-1126821142,2,['extend'],"['extendhigh', 'extendlow']"
Modifiability,"As we also discussed on slack, using threads (or tasks) won't work since to capture the output the global stdout variable is changed. You need `pmap` or launch new processes with `run`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576427498:113,variab,variable,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1576427498,1,['variab'],['variable']
Modifiability,"As well as more general decompositions, and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2536:563,config,configurations,563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536,1,['config'],['configurations']
Modifiability,"At the moment . `ΔF[i-1] = C[i] - C[i-1]` where `C` and `F` are the center and face coordinate, respectively. On the other hand, the derivative on the face `[i]` is calculated with `(c[i] - c[i-1]) / ΔF[i]` (where `c` is the value of the derived variable at the centers). therefore, it has to be that `ΔF[i] = C[i] - C[i-1]`. Because of how we test, this bug was miraculously eluding all testing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2150:246,variab,variable,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2150,1,['variab'],['variable']
Modifiability,"At the moment I'm playing with rectilinear and lon-lat grids, so those are the ones that I'm thinking about. However, I appreciate that we want these methods to work on all the grids that we support. . On these two grids, we could use the difference operators without any concern, for both the vertical component of vorticity and the horizontal component of divergence. No problem there. If you use Green's theorem to rewerite the integral of a vorticity as a circulation integral, then we should be able to rewrite the horizontal divergence using Gauss' divergence theorem as a line integral. Maybe that would generealize better to more exotic grids?. I will look at the paper you cited. Thanks for pointing this out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136345956:508,rewrite,rewrite,508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2575#issuecomment-1136345956,1,['rewrite'],['rewrite']
Modifiability,"At the moment the error throwing in the function `validate_index()` isn't working due to an undefined variable. For indices that aren't valid, the error ends up being not useful:. ```julia; caused by: UndefVarError: I not defined; Stacktrace:; [1] validate_index(idx::UnitRange{Int64}, loc::Type, topo::Type, N::Int64, H::Int64); @ Oceananigans.Fields /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:90; [2] validate_index; @ /glade/work/tomasc/.julia/packages/Oceananigans/7G5bN/src/Fields/field.jl:94 [inlined]; ```. This PR fixes that with a simpler error message.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2824:102,variab,variable,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2824,1,['variab'],['variable']
Modifiability,"At the moment this is possible:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = 1:1:10, y=1:1:10,; z = 1:1:10, ; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 5.0) variably spaced with min(Δx)=1.0, max(Δx)=1.0; ├── Periodic y ∈ [1.0, 5.0) variably spaced with min(Δy)=1.0, max(Δy)=1.0; └── Bounded z ∈ [1.0, 5.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> grid.Nz; 4. julia> length(grid.zᵃᵃᶜ); 10; ```; Meaning, you can pass a certain size to the constructor, say `Nx`, and also pass an array for that direction (to ""stretch it"") that has a different size than `Nx`. I haven't investigated the consequences of this, but this feels like it could cause problems. Should we throw a warning/error in these cases?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2548:284,variab,variably,284,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2548,3,['variab'],['variably']
Modifiability,"At the moment we hardcode the locations where output files in docs builds are so we can delete them before deploying the docs. See:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/docs/make.jl#L165-L169. We should find a way to automatically search for output files recursively in the `docs` directory and delete them before deploying the docs. I've asked in Julia slack how to do this and some ideas include:. ```Julia; julia> function recursive_find(dir, pattern); mapreduce(vcat, walkdir(dir)) do (root, dirs, files); joinpath.(root, filter(contains(pattern), files)); end; end; recursive_find (generic function with 1 method). julia> recursive_find(DEPOT_PATH[end], r""\.jl$""); 988-element Vector{String}:; ""/opt/julia/julia-1.9.0/share/julia/julia-config.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Base.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/Enums.jl""; ""/opt/julia/julia-1.9.0/share/julia/base/abstractarray.jl""; ⋮; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/llvmpasses.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/testhelpers/withlocales.jl""; ""/opt/julia/julia-1.9.0/share/julia/test/unicode/utf8.jl""; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3112:792,config,config,792,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3112,1,['config'],['config']
Modifiability,"At the moment, restarting from checkpoints does not allow to restart from data with different halo size.; In particular, I encountered this issue when I wanted to restart a simulation with a different advection order from already evolved data. We might want to support this feature since, when dealing with large complex simulations, a lot of trial and error has to be done in order to find the optimal parameters, which include order of advection (and sub-stepping size for the free surface, which involves halo size for distributed simulations). If there is interest in this feature, I can start implementing it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3206:230,evolve,evolved,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206,1,['evolve'],['evolved']
Modifiability,"At the moment, this PR allows slab decomposition in x and y, and pencil decomposition in x, y.; This PR implements these transposes:; ```julia; z -> y; y -> x; x -> y ; y -> z; ```; where the above letter stands for the ""free"" direction (the direction that is completely local). We always start from the `z` configuration because we do not want to support z-decompositions (because of possible vertical integrals and implicit vertical diffusion). ; The FFT based algorithm is ; ```julia; z_transform! ; z -> y; y_transform!; y -> x; x_transform!; division by λ; x_transform!; x -> y ; y_transform!; y -> z; z_transform!; ```; The whole procedure needs 4 transposes for pencil decomposition and 2 for slab decomposition.; I am still working on implementing the Fourier tridiagonal solver, which is very easily done naively by increasing the number of transposes:; ```julia; z -> y; y_transform!; y -> x; x_transform!; x -> y ; y -> z; tridiagonal_solve!; z -> y; y_transform!; y -> x; x_transform!; x -> y; y -> z; ```; This requires 8 transposes though, which would kill any possibility of scaling even if we completely fill the GPU memory.; I would like to ensure that we always do a maximum of 4 transposes (2 forward and 2 backward).; This means playing with memory in the background, I still have to do a little bit of thinking to ensure it, maybe I have to define other transposes like; ```julia; x -> z; z -> x; ```; which would remove two of them but it is slightly more complicated. This is because, in the previous transposes we switch partitioning between the in and out free direction while the third dimension remains untouched. On the other hand, z-configuration and x-configuration also have a differently partitioned y-direction which makes the transpose process between `x` and `z` non-trivial",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132:308,config,configuration,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1731333132,3,['config'],['configuration']
Modifiability,Awesome!. How big is `wet_cells_map`? Should we extend `ImmersedBoundaryGrid` so that users can opt in/opt out of this feature?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317226117:48,extend,extend,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2817#issuecomment-1317226117,1,['extend'],['extend']
Modifiability,"Bah, I realized this won't work because we have to call `compute!` on all leaves of an expression tree. For that it's important that `compute!(::AbstractOperation)` doesn't do anything. We can support this if we change that interface, eg if we add something `compute_leaf!`. Then we can adapt `compute!` for public use and update the private methods like `compute_leaf!` as needed. Might not be worth it, probably there's other stuff we also need to work on if we want totally beautiful REPLness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432:287,adapt,adapt,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1032963432,1,['adapt'],['adapt']
Modifiability,Baroclinic instability via spatially variable cooling flux,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/204:37,variab,variable,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/204,1,['variab'],['variable']
Modifiability,"Before this PR we couldn't create a ConformalCubedSphereGrid on the GPU due to some scalar operations that occur when we fill the metrics. After this PR:. ```Julia; julia> using Oceananigans. julia> grid = ConformalCubedSphereGrid(GPU(), panel_size = (3, 3, 1), z = (0, 1), radius = 1); ConformalCubedSphereGrid{Float64, FullyConnected, FullyConnected, Bounded} partitioned on GPU(): ; ├── grids: 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on GPU with 3×3×3 halo and with precomputed metrics ; ├── partitioning: CubedSpherePartition with (1 region in each panel) ; ├── connectivity: CubedSphereConnectivity ; └── devices: (CUDA.CuDevice(0), CUDA.CuDevice(0), CUDA.CuDevice(0), CUDA.CuDevice(0), CUDA.CuDevice(0), CUDA.CuDevice(0)). julia> grid[3]; 3×3×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on GPU with 3×3×3 halo and with precomputed metrics; ├── centered at: North Pole, (λ, φ) = (0.0, 90.0); ├── longitude: FullyConnected extent 90.0 degrees variably spaced with min(Δλ)=16.8962, max(Δλ)=29.6661; ├── latitude: FullyConnected extent 86.9617 degrees variably spaced with min(Δφ)=16.8962, max(Δφ)=29.6661; └── z: Bounded z ∈ [0.0, 1.0] regularly spaced with Δz=1.0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3575:1029,variab,variably,1029,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3575,2,['variab'],['variably']
Modifiability,"Before this PR, the following would *NOT* error:. ```Julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. After this PR:. ```Julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:109; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Vector{Float64}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Vector{Float64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[13]:1; ```. ```; julia> grid = LatitudeLongitudeGrid(size=(2, 2, 2), longitude=(-20, 20), latitude=(10, 20), z=[0, -0.5, -1], topology=(Bounded, Bounded, Bounded)). ERROR: ArgumentError: z=[0.0, -0.5, -1.0] should be a vector with increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Vector{Float64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/G",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319:276,variab,variably,276,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319,1,['variab'],['variably']
Modifiability,"Before this issue is resolved, one solution is to use callable objects:. ```julia; struct ParameterizedCallback{P}; parameters :: P; end. (cb::ParameterizedCallback)(simulation) = # function that depends on both `sim` and `cb.parameters`. cb = ParameterizedCallback(parameters) # builds the callable object, capturing `parameters`. simulation.callbacks[:callback] = Callback(cb, IterationInterval(10)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933:90,Parameteriz,ParameterizedCallback,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127#issuecomment-1001249933,3,['Parameteriz'],['ParameterizedCallback']
Modifiability,Better local variable name: `area` -> `grid_metric`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2289:13,variab,variable,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2289,1,['variab'],['variable']
Modifiability,"Biharmonic operator requires more halo cells than the classical Laplacian, so the `conditional_flux` method for the immersed boundary must be adapted to shut down fluxes from biharmonic diffusion up to 2 cells distance from an immersed boundary. Or maybe find a more sustainable solution, for example refactoring the biharmonic diffusivity to be calculated `∇²κ∇²` (which might require some work)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2209:142,adapt,adapted,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2209,2,"['adapt', 'refactor']","['adapted', 'refactoring']"
Modifiability,"Borrowing on previous code that a student and I wrote, I have created a julia code that will solve the linear stability problem for a Bickley Jet in the context fo the `ShallowWaterModel`. It doesn't actually use Oceananigans at all, yet, but produces the followin four figures. This is something that I plan to use to validate the growth rates in the nonlinear evolution of the Bickely jet in the `ShallowWaterModel`, but can easily be extended to other profiles and other models as well. Is there any interest in integrating this in Oceananigans?. **Velocity and free-surface height of the basic state:**. ![basic_state](https://user-images.githubusercontent.com/8239041/105401802-93844880-5bf4-11eb-8a7f-32878e09698c.png). **Growth rates of the two most unstable modes:**. ![growth_rates](https://user-images.githubusercontent.com/8239041/105401818-9717cf80-5bf4-11eb-9c12-79f755ce84ed.png). **Plots of the 1D spatial strucutre of the most unstable mode:**. ![modes_1D](https://user-images.githubusercontent.com/8239041/105401831-9bdc8380-5bf4-11eb-8226-c531129dc7ae.png). **Plots of the 2D spatial strucutre of the most unstable mode:**. ![modes_2d](https://user-images.githubusercontent.com/8239041/105401841-9da64700-5bf4-11eb-9cf6-c7efb9fce62e.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1310:437,extend,extended,437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1310,1,['extend'],['extended']
Modifiability,"Both `IncompressibleModel` and `ShallowWaterModel` use the more general `model_forcing` now, but I had to refactor `regularize_forcing` a bit as it needs the `model_field_names` when constructing `Relaxation` forcings and `ContinuousForcing`s with field dependencies. Tests passed on Tartarus but might be good if @glwagner had a quick look to make sure it's okay.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133:106,refactor,refactor,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1291#issuecomment-756838133,1,['refactor'],['refactor']
Modifiability,Boundary condition API kernels should use dynamic launch configuration,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/363:57,config,configuration,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/363,1,['config'],['configuration']
Modifiability,"BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}}},SpatialWindowAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos/Oceananigans.jl/sandbox/windowed_spatially_averaged.jl:111; ```; </details>. I've tried expanding the struct to include a grid parameter (based off of how `AveragedField` is programmed` and then defining `compute!` but I haven't been able to make it work. Any tips?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170:16548,sandbox,sandbox,16548,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783533170,2,['sandbox'],['sandbox']
Modifiability,"Btw, the problem is not related with bathymetry directly. It's related with the Heptadiagonal Matrix-based free surface solver. When there is an immersed boundary the default free-surface solver is the Heptadiagonal Matrix-based solver so that's why we get the error above. But an immersed boundary grid is not really required. ```julia; test_Oceananigans/ $ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.5 (2023-01-08); _/ |\__'_|_|_|\__'_| |; |__/ |. (@v1.8) pkg> activate .; Activating new project at `~/Research/test_OC`. (test_Oceananigans) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General.toml`; Resolving package versions...; Updating `~/Research/test_OC/Project.toml`; [9e8cae18] + Oceananigans v0.84.1; Updating `~/Research/test_OC/Manifest.toml`; [621f4979] + AbstractFFTs v1.4.0; [79e6a3ab] + Adapt v3.6.2; [4fba245c] + ArrayInterface v7.4.11; [a9b6321e] + Atomix v0.1.0; [ab4f0b2a] + BFloat16s v0.4.2; [fa961155] + CEnum v0.4.2; [179af706] + CFTime v0.1.2; [052768ef] + CUDA v4.4.0; [1af6417a] + CUDA_Runtime_Discovery v0.2.2; [d360d2e6] + ChainRulesCore v1.16.0; [9e997f8a] + ChangesOfVariables v0.1.8; [1fbeeb36] + CommonDataModel v0.2.4; [34da2185] + Compat v4.7.0; [a8cc5b0e] + Crayons v4.1.1; [7445602f] + CubedSphere v0.2.3; [9a962f9c] + DataAPI v1.15.0; [864edb3b] + DataStructures v0.18.14; [e2d170a0] + DataValueInterfaces v1.0.0; [ffbed154] + DocStringExtensions v0.9.3; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.9; [7a1cc6ca] + FFTW v1.7.1; [5789e2e9] + FileIO v1.16.1; [0c68f7d7] + GPUArrays v8.8.1; [46192b85] + GPUArraysCore v0.1.5; [61eb1bfa] + GPUCompiler v0.21.4; [c27321d9] + Glob v1.3.1; [615f187c] + IfElse v0.1.1; [40713840] + IncompleteLU v0.2.1; [3587e190] + InverseFunctions v0.1.11; [92d709cd] + IrrationalConstants v0.2.2; [42fd0dbc] + IterativeSolvers v0.9.2;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243:991,Adapt,Adapt,991,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3184#issuecomment-1636792243,1,['Adapt'],['Adapt']
Modifiability,But question: floats need adaptation?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2166702826:26,adapt,adaptation,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2166702826,1,['adapt'],['adaptation']
Modifiability,"CUDA v2.4.0 is out but we're blocked by OffsetArrays.jl now, which might remove the Adapt.jl dependency (https://github.com/JuliaArrays/OffsetArrays.jl/issues/174) so might not be worth waiting for all dependencies to support Adapt v3.0.0. If tests pass with CUDA v2.4.0 I say we merge this PR and close #1287.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372:84,Adapt,Adapt,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296#issuecomment-756802372,2,['Adapt'],['Adapt']
Modifiability,Calculation via $$\log_2(\vert \frac{progn}{tend} \vert)$$. with $progn$ being the prognostic variable (zonal velocity above) and $tend$ being the tendency taken as two consecutive time steps from the output. It's not exactly that obv because the AB2 time stepper works a bit differently but it's probably good enough! So this quantity is essentially the orders of magnitude (as power of 2) that the prognostic variables are larger than the tendencies. This is equivalent to the mantissa bits of precision lost in the addition of the two.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256:94,variab,variable,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3212#issuecomment-1672146256,2,['variab'],"['variable', 'variables']"
Modifiability,"Can we just compare 1) the topology and 2) all of the nodes? I think that would be sufficient to determine equality. I'm worried if we don't explicitly check the topology that we might run into some edge cases where the nodes / spacings are the same but the topologies are different (these would possibly be pathological with 0 halo in a periodic / flat direction, but still good to explicitly check I think...). When comparing numeric equality for nodes, we should add `@allowscalar` as needed there. I think we should add a test that equality works as expected, as well. We should also add a test for checkpointing on stretched grids. I think its ok if we don't support a numeric equality for other grids --- we can build them up one at a time. They are specific to each grid. The main downside here is that we need to refactor our grid implementation to have a single `RectilinearGrid` (there's no reason to have different rectilinear grid types, since we can dispatch on the case that certain directions have constant spacing easily). So this code will go away when we make that change. But I think it's a useful incremental improvement for now while we still have two rectilinear grids, so I'm fine to have it go in once it's cleaned up. Because of this:. ```julia; julia> using CUDA. julia> a = rand(2); 2-element Vector{Float64}:; 0.8207604162394306; 0.3815099688071648. julia> b = CuArray(a); 2-element CuArray{Float64, 1}:; 0.8207604162394306; 0.3815099688071648. julia> CUDA.@allowscalar a == b; true; ```. I think that this will work if the checkpointed grid is deserialized onto the CPU, even though `model.grid` is on the GPU. I think this is what we want, so that's fortunate the above works.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406:821,refactor,refactor,821,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2019#issuecomment-945919406,1,['refactor'],['refactor']
Modifiability,Can we rewrite the pressure equation and calculate each term in it?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3459:7,rewrite,rewrite,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459,1,['rewrite'],['rewrite']
Modifiability,"Can we start by refactoring this PR to implement this functionality in an example script? It could perhaps go in [`validation/biogeochemistry`](https://github.com/CliMA/Oceananigans.jl/tree/main/validation/biogeochemistry). Once we have that cleaned up, we might be able to see what parts of it belong in the source code versus left to users?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856:16,refactor,refactoring,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1252870856,1,['refactor'],['refactoring']
Modifiability,Can you write these possibilities for variable `ν` (eg `ν` must always appear inside the divergence)? These don't all have the same dimensions --- what's happening?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089417262:38,variab,variable,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089417262,1,['variab'],['variable']
Modifiability,"Can't reproduce the problem. On tartarus with Julia v1.8:. ```Julia; julia> grid = RectilinearGrid(GPU(), size=(16, 16, 16), x=(0,1), y=(0,1), z=0:16); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> minimum_zspacing(grid); 1.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1498623545:389,variab,variably,389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1498623545,1,['variab'],['variably']
Modifiability,"CenteredSecondOrder` advection and `ScalarDiffusivity` with constant coefficients; * Large eddy simulation with `SmagorinskyLilly` or `AnisotropicMinimumDissipation` turbulence closures; * Idealized problems (eg two-dimensional turbulence) in 1-3 dimensions that use Laplacian, biharmonic, or implicit numerical dissipation.; 2. `HydrostaticFreeSurfaceModel`, which solves the hydrostatic Boussinesq equations with linear free surface dynamics and a `z` coordinate. The hydrostatic model is useful for larger scale simulations, eg regional ocean modeling, and can be used with `RectilinearGrid` stretched in any or all directions as well as a `LatitudeLongitudeGrid`. We have a prototype closure for vertical mixing called `CATKEVerticalDiffusivity` (paper coming soon...) as well as a `RiBasedVerticalDiffusivity` and `ConvectiveAdjustment` that support implicit time discretization for vertical diffusion. We have a new high-order advection scheme specialized for geophysical turbulence / mesoscale turbulence problems that uses a vector invariant formulation. We can treat the free surface dynamics implicitly in time with various methods (FFT-based on rectilinear grids with flat bottoms, or preconditioned conjugate gradient based with various preconditioners in other situations). We also have a `SplitExplicitFreeSurface`. All models support complex domains / bathymetry via `ImmersedBoundaryGrid`, a variety of Coriolis forces (`FPlane`, `BetaPlane`, as well as some more exotic options), a wide variety of boundary conditions for any prognostic variable on any model boundary. Note however that the pressure solver for `NonhydrostaticModel` is only approximate on `ImmersedBoundaryGrid` (we are working on an exact pressure solver for immersed boundaries). We don't support simulations on the full sphere, or sea ice, yet, but we are working on both of those. Let me know if you have any specific questions about capabilities, I'm curious to hear what problems you're interested in tackling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3126#issuecomment-1572601030:2708,variab,variable,2708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3126#issuecomment-1572601030,1,['variab'],['variable']
Modifiability,Changed the title slightly as it is being adapted: https://github.com/CliMA/Oceananigans.jl/blob/bf767af3c40c049ebc9499b7553065a9ef350178/src/ImmersedBoundaries/partial_cell_bottom.jl#L72-L84,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269861562:42,adapt,adapted,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269861562,1,['adapt'],['adapted']
Modifiability,"Cherry picked some commits from PR #381 to fix the example test. One thing that's going to be annoying about testing example scripts is that they evaluate in global scope when including them, so it's going to be easy to get variable name conflicts... Not sure how to get around this as we agreed not to use functions for examples.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/424:224,variab,variable,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/424,1,['variab'],['variable']
Modifiability,Cleanup unused type variables,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2761:20,variab,variables,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2761,1,['variab'],['variables']
Modifiability,Closes #2507. . This PR attempts to extend shallow water system to multiple layers.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975:36,extend,extend,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975,2,"['extend', 'layers']","['extend', 'layers']"
Modifiability,"Closes https://github.com/CliMA/Oceananigans.jl/issues/1392. CC: @glwagner @ali-ramadhan . Sorry that the issue I create went so long! I was doing a bunch of wrong things but in the end it was pretty straightforward. At this point all I have is a working example of `WindowedSpatialAverage` in the sandbox and I'm creating this PR for two reasons:. - Getting feedback on possible edge cases, and maybe figuring out how the `NetCDFOutput` can infer the dimensions correctly; - Figuring out where to include this; - This isn't necessarily attached to an `OutputWriter`, so it feels odd to add it there; - Everywhere else in Oceananigans also feels inappropriate ; - Maybe add it to Oceanostics?; . Anyway, feedback is appreciated. . Also, big thanks to @ali-ramadhan for helping me out with this one.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397:298,sandbox,sandbox,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397,1,['sandbox'],['sandbox']
Modifiability,"Closes https://github.com/CliMA/Oceananigans.jl/issues/2548. Before this PR:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = (0,1), y=(0,1),; z = LinRange(0,1,20), ; halo=(3,3,3),; ); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 0.210526] variably spaced with min(Δz)=0.0526316, max(Δz)=0.0526316. julia> grid.zᵃᵃᶜ; 10-element OffsetArray(::Vector{Float64}, -2:7) with eltype Float64 with indices -2:7:; -0.13157894736842105; -0.07894736842105263; -0.02631578947368421; 0.02631578947368421; 0.07894736842105263; 0.13157894736842105; 0.18421052631578946; 0.23684210526315788; 0.2894736842105263; 0.3421052631578947. julia> collect(grid.xᶜᵃᵃ); 10-element Vector{Float64}:; -0.625; -0.375; -0.125; 0.125; 0.375; 0.625; 0.875; 1.125; 1.375; 1.625; ```. After this PR:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; [ Info: Oceananigans will use 6 threads. julia> grid = RectilinearGrid(size=(4, 4, 4),; x = (0,1), y=(0,1),; z = LinRange(0,1,20), ; halo=(3,3,3),; ); ERROR: ArgumentError: `length(z)` must be equal to size passed to `size` argument.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::LinRange{Float64}, dir::Symbol, size_dir::Int64, FT::Type); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:108; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Tuple{Int64, Int64}, y::Tuple{Int64, Int64}, z::LinRange{Float64}); @ Oceananigans.Grids ~/repos/Oceananigans.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Tuple{Int64, Int64, Int64}, FT::Type, extent::Nothing, x::Tuple{Int64, I",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2550:459,variab,variably,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2550,1,['variab'],['variably']
Modifiability,"Closes https://github.com/CliMA/Oceananigans.jl/issues/3795 by changing the default configuration of `NonhydrostaticModel` to `hydrostatic_pressure_anomaly = CenterField(grid)`. The spurious large-scale flow is developed due to numerical noise in the buoyancy field when the hydrostatic pressure anomaly is treated explicitly. When hydrostatic pressure anomaly is computed using the implicit integral of the buoyancy field, no spurious kinetic energy is introduced.; Here's the MWE as in https://github.com/CliMA/Oceananigans.jl/issues/3795:; ```julia; using Oceananigans; using Oceananigans.Units; using SeawaterPolynomials; using SeawaterPolynomials.TEOS10; using Printf. eos = TEOS10.TEOS10EquationOfState(). arch = CPU(); grid = RectilinearGrid(CPU(), Float64,; topology = (Bounded, Flat, Bounded),; size = (100, 100),; halo = (4, 4),; x = (0, 100),; z = (-100, 0)). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(),; advection = UpwindBiased(order=1),; timestepper = :RungeKutta3,; tracers = (:T, :S)). @inline T_initial(x, z) = 20; @inline S_initial(x, z) = 35; @inline w_initial(x, z) = rand() * 1e-6. set!(model, T=T_initial, S=S_initial, w=w_initial). u, v, w = model.velocities; T, S = model.tracers.T, model.tracers.S. KE = @at (Center, Center, Center) 0.5 * (u^2 + v^2 + w^2); KE_total = Field(Integral(KE)). simulation = Simulation(model, Δt=1e-3, stop_time=40days); wizard = TimeStepWizard(max_change=1.05, max_Δt=10minutes, cfl=0.6); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). wall_clock = [time_ns()]. function print_progress(sim); compute!(KE_total); @printf(""[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, max(T) %6.3e, max(S) %6.3e, Total KE %6.3e, next Δt: %s\n"",; 100 * (sim.model.clock.time / sim.stop_time),; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3796:84,config,configuration,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3796,1,['config'],['configuration']
Modifiability,Closure-specific temporary variables.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/94:27,variab,variables,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/94,1,['variab'],['variables']
Modifiability,"Co-authored-by: Francis J. Poulin <fpoulin@uwaterloo.ca>. I've added back the threaded benchmark written by @francispoulin in an older branch. I also added plots to it.; There is actually already a threaded benchmark script:; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading.jl; https://github.com/CliMA/Oceananigans.jl/blob/master/benchmark/benchmark_multithreading_single.jl; They differ in that the one I'm adding is essentially weak scaling shallow water model, while the one that's already there is strong scaling nonhydrostatic model.; If everyone thinks that it's appropriate, then I'll likely change the name of the extant benchmarking scripts to more accurately reflect their content. ; I would likely also do some more minor changes such as changing the default grid size down from 512^3, adding in plots, and configuring the output tables a bit more.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881:859,config,configuring,859,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881,1,['config'],['configuring']
Modifiability,"CompatHelper: bump compat for ""Adapt"" to ""3.0""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287:31,Adapt,Adapt,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287,1,['Adapt'],['Adapt']
Modifiability,"CompatHelper: bump compat for Adapt to 4, (keep existing compat)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3409:30,Adapt,Adapt,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3409,1,['Adapt'],['Adapt']
Modifiability,Conservatively adapt ReducedField for GPUs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1354:15,adapt,adapt,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1354,1,['adapt'],['adapt']
Modifiability,"CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}}}}); @ Oceananigans.Fields ~/Oceananigans.jl/src/Fields/averaged_field.jl:61; [16] top-level scope; @ REPL[55]:1; [17] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/initialization.jl:81; ```. # Environment. ```; julia> versioninfo(); Julia Version 1.6.1; Commit 6aaedecc44 (2021-04-23 05:59 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, cascadelake); ```. <details>; <summary>Manifest</summary>. ```; (Oceananigans) pkg> st -m; Project Oceananigans v0.58.1; Status `~/Oceananigans.jl/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v3.3.0; [4fba245c] ArrayInterface v3.1.14; [ab4f0b2a] BFloat16s v0.1.0; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v3.2.1; [72cfdca4] CUDAKernels v0.2.1; [7057c7e9] Cassette v0.3.6; [d360d2e6] ChainRulesCore v0.9.44; [34da2185] Compat v3.30.0; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.4; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.3; [7a1cc6ca] FFTW v1.4.1; [5789e2e9] FileIO v1.9.0; [0c68f7d7] GPUArrays v6.4.1; [61eb1bfa] GPUCompiler v0.11.5; [c27321d9] Glob v1.3.0; [615f187c] IfElse v0.1.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.6; [692b3bcd] JLLWrappers v1.3.0; [0f8b85d8] JSON3 v1.8.1; [63c18a36] KernelAbstractions v0.6.3; [929cbde3] LLVM v3.7.0; [2ab3a3ac] LogExpFunctions v0.2.4; [da04e1cc] MPI v0.17.2; [1914dd2f] MacroTools v0.5.6; [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1684:12175,Adapt,Adapt,12175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1684,1,['Adapt'],['Adapt']
Modifiability,"Copy pasting from @glwagner's fork. Adaptive time stepping with a `TimeStepWizard` that computes time steps for you. I just need to modify `time_step!` with a flag like `first_step_Euler=true` to take forward Euler steps at first iteration and when changing the time step, but with the ability to turn it off for tests where we actually don't want to do this. . I'll add some more docstrings and a couple of tests. cc @sandreza . Resolves #189",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/297:36,Adapt,Adaptive,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/297,1,['Adapt'],['Adaptive']
Modifiability,"Correct. Buildkite doesn't support any templating last I looked.The `codecov` variable is currently unused though, so you can leave that out.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063345075:78,variab,variable,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063345075,1,['variab'],['variable']
Modifiability,"Could lead to confusion, e.g. in #579. Thanks for helping locate this issue @masonrogers14. Easy PR but might involve refactoring some tests?. https://github.com/climate-machine/Oceananigans.jl/blob/588890004e69cfc7db10472b12a9840b8a9ad7b6/src/boundary_conditions.jl#L339",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/582:118,refactor,refactoring,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/582,1,['refactor'],['refactoring']
Modifiability,"Curious if @glwagner has any thoughts on `backend_kw` vs. `reader_kw`, but I'm thinking of renaming to `reader_kw` then potentially revising the naming in a future refactor of `OutputReaders` (probably as part of supporting NetCDF).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441901434:164,refactor,refactor,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441901434,1,['refactor'],['refactor']
Modifiability,"Current operators assume constant Δz which allow the model to use faster operators and use a tiny bit less space, so they'd have to be rewritten a tiny bit to account for a variable Δz when that gets implemented. We can either write new operators that get dispatched on `HorizontallyRegularCartesianGrid` structs (already possible), or maybe the performance gain is so tiny that we just make `RegularCartesianGrid` a subset of `HorizontallyRegularCartesianGrid` and only have one set of operators. `HorizontallyRegularCartesianGrid` might be a descriptive but pretty bad struct name.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/47:173,variab,variable,173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/47,1,['variab'],['variable']
Modifiability,"Currently an error during grid validation is actually not printed, instead you get; ```; ERROR: UndefVarError: N! not defined; ```; as string interpolation is expecting a variable called `N!` when the variable is `N`. This PR fixes this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2845:171,variab,variable,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2845,2,['variab'],['variable']
Modifiability,"Currently in my workflow, I define an environment variable that contains an string like `$init_$end.nc`, where `init` is the initial time and `end` is the `stop_time` of the simulation. In the first instantiation of the model for 60 days, this string will be appended to my output filename e.g.`vel_field_`, resulting on something like `vel_field_0_60.nc`. For the next pickup the filename will be changed to `vel_field_60_120.nc`. This works well when the files are not split, i.e. `file_splitting = NoFileSplitting()`. However when splitting the file, e.g. `file_splitting = TimeInterval(30days)`, the first instantiation will result in the following files:; ```; vel_fields_0_60_part1.nc vel_fields_0_60_part2.nc vel_fields_0_60_part3.nc; ```; then the next pickup will result in files: ; ```; vel_fields_60_120_part1.nc vel_fields_60_120_part3.nc vel_fields_60_120_part5.nc; vel_fields_60_120_part2.nc vel_fields_60_120_part4.nc; ```; of this files, the first 2 parts (`vel_fields_60_120_part1.nc` and `vel_fields_60_120_part2.nc`) are empty, and the `vel_fields_60_120_part3.nc` contains data from the day 61 until 91. This makes the loading of the data for post-processing a bit tricky, since some of they are empty and the disk storage will make more difficult chunking data. . If I don't change the name each time I pickup, with the `overwrite_existing=false` it crashes, and with `overwrite_existing=true` it rewrites all the files. . Another workflow will be to create a new folder for each pickup keeping the same filename, but splitting the files will result in the same issue of file duplication. . I hope this description of the workflow is clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301:50,variab,variable,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301,4,"['rewrite', 'variab']","['rewrites', 'variable']"
Modifiability,"Currently it is not generically possible to call. ```julia; fill_halo_regions!(field); ```. Part of this is trivial as noted in #969. But another part is that boundary conditions on fields can depend on other _other_ fields, to which `field` contains no reference. We allow field boundary conditions to depend on anything in `state(model)`, which includes the model velocity fields, tracer fields, pressure fields, and diffusivities. Because references to `state(model)` are required to fill halo regions in general, we are unable to fill halo regions prior to computing an `AveragedField` (for example). We may not _want_ to solve this problem because it require too-invasive changes. For example, we certainly want to support the concept of fields that are independent of other fields. General support for interdependent fields may be too difficult. Some possible solutions:. * an ""optional"" `state` property of `Field` which is set to `nothing` by default. We can ensure that `state` is properly determined in the constructor for `IncompressibleModel` for the model fields. * an ""optional"" `state` or `fields` property within each individual boundary condition (with a similar function as the optional property above). This property could be activated only for boundary conditions that need it (currently, only discrete form boundary conditions, though this could be extended to continuous form boundary conditions in the future via #897). Solving this will simplify time-stepping code a bit and permit simpler halo region filling via `fill_halo_regions!(field)` with no additional arguments.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/971:1370,extend,extended,1370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/971,1,['extend'],['extended']
Modifiability,"Currently open boundary conditions only work correctly for non-hydrostatic models. To work correctly with hydrostatic models with a free surface, the free surface needs to know about the open boundary conditions in order for the barotropic fluxes to be correct. Some refactoring needs to take place to support this as the split-explicit free surface has difference operators that need to be topologically-aware:. https://github.com/CliMA/Oceananigans.jl/blob/b3be950ef6a1f2139c2f65e083f20f1f7958ea55/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L35-L42. @simone-silvestri's suggestion in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312725203 was to move the topologically-aware operators to the `Operators` module and have them depend on boundary conditions. See PR #3268. But having operators depend on boundary conditions seems messy and breaks the chain of dependence Oceananigans has (architectures -> grids -> operators -> boundary conditions -> fields, etc.). So maybe this isn't the approach we want to take. After looking through https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl and some discussion with @tomchor we came to the conclusion that the need to impose boundary conditions in this way suggests that something needs to be a `Field`. I think that something is `η★` `U★`, and `V★`. If these became `Field`s and lived in `SplitExplicitState` then they could have their own boundary conditions and not we wouldn't need the topologically-aware operators?. And their boundary conditions could be inferred/computed from the boundary conditions on `u` and `v` using vertical integrals. For `η` I think it's prescribed. See https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353142608 and https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2353455930. **Note**: This issue is only for the split-explicit free surface. I thin",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828:267,refactor,refactoring,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828,1,['refactor'],['refactoring']
Modifiability,"Currently restoring a model from a checkpoint uses the function `restore_from_checkpoint`. However, this design can be difficult to use because, in general, restoring a model requires passing the forcing functions and boundary condition functions explicitly to `restore_from_checkpoint`. This means that part of the setup script needs to be replicated in the script that restores a model from the checkpoint. A different solution is possible that may require less work on the part of users to restore a model from a checkpoint: if we extend `run!` with the keyword argument `pickup`. . If `pickup=true` (and a checkpointer has been added to `simulation.output_writers`), then prior to executing the `run!` loop,. 1. The checkpointer file correpsonding to the most recent model iteration will be identified;; 2. Checkpointer data will be synced with `model.velocities`, `model.tracers`, `model.clock`, and, for `QuasiAdamsBashforth2` timesteppers, the tendency `model.timesteppers.Gⁿ`. For this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068:534,extend,extend,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068,1,['extend'],['extend']
Modifiability,"Currently, user-defined forcing functions (say, `F`) have the signature. ```julia; F(grid, U, Φ, i, j, k) = ...; ```. per. https://github.com/climate-machine/Oceananigans.jl/blob/3ab93222717271de194ade9e9b073c1c09f571e8/src/time_steppers.jl#L135. However, I think that we should reorganize this so that the most ""important"" arguments are first. I think perhaps a better ordering would be . ```julia; F(i, j, k, grid, time, velocities, tracers) = ...; ```. The idea is that `grid` is unlikely to be used without indices; however indices can be used without `grid`. This pattern also resembles the pattern we have developed for kernels (and thus could be used in the future to develop ""differentiated"" and ""interpolated"" user-defined forcing functions, for example). This also adds time as an argument, which I think is a good idea as this is needed for lots of elementary things like, eg, the tidal forcing functions desired by #212. Adding time as an argument will require some minor modifications to `calculate_interior_source_terms!`. We should also change over all of our kernel functions to having `(i, j, k, grid)` first, but we don't have to address that refactoring immediately. Note that changing the forcing function signature is a significant change as it affects the user API.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/390:1161,refactor,refactoring,1161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/390,1,['refactor'],['refactoring']
Modifiability,"Cut cells use piecewise linear representations of bathymetry (as opposed to full or partial cells which use piecewise constant ones). Here’s a tentative work plan for implementing cut cells:. 1. Develop the following test cases: . (a) Tracer advection with no momentum on a seamount ([Adcroft](https://journals.ametsoc.org/view/journals/mwre/125/9/1520-0493_1997_125_2293_rotbsc_2.0.co_2.xml) or [Schär](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml) configuration); ; (b) Internal wave or overflow with momentum;; ; Run these test cases for full and partial cells. As suggested by @jm-c, compare a simulation using low vertical resolution (~10 vertical layers) and partial cells with one using high vertical resolution (~500 vertical layers) and full cells at the same horizontal resolution (to verify the effectiveness of partial cells). To ensure that a stratified ocean remains at rest, implement the technique in [Lin](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs) for partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Cons",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123:504,config,configuration,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123,3,"['config', 'layers']","['configuration', 'layers']"
Modifiability,Cut down the examples. Moved stuff into a sandbox.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/230:42,sandbox,sandbox,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/230,1,['sandbox'],['sandbox']
Modifiability,"Dear Oceananigans team,. this looks like a really exciting and useful project. As an external user, how flexible is this package to add, e.g. , additional (passive) tracers to a model? I see that there is a generalised array of tracers, but temperature and salinity are hardcoded into the model initialiser. Would it be possible to add more tracers? I am asking because eventually it would be super cool to use a tool like this as the ocean circulation component in other Earth System Models. I am currently using [cGenie](https://github.com/derpycode/cgenie.muffin) which internally uses this ocean model : https://www.geosci-model-dev.net/4/957/2011/ ...; What is the general scope to do something like this? ; Sorry for asking user-level questions in the Issues, but I think you are still working on some more detailed documentation ... Many thanks! Heiko",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/369:104,flexible,flexible,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/369,1,['flexible'],['flexible']
Modifiability,Did some refactoring and CPU and GPU hydrostatic regression tests pass locally so I think this PR is ready for review!. @simone-silvestri Requesting a review from you on your own PR again lol but I won't approve unless you do.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2400089856:9,refactor,refactoring,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2400089856,1,['refactor'],['refactoring']
Modifiability,Differentiated and variable AMD model constants,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/622:19,variab,variable,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/622,1,['variab'],['variable']
Modifiability,Diffusivity refactor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2247:12,refactor,refactor,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247,1,['refactor'],['refactor']
Modifiability,Distributed IO is not supported yet and will require a lot of work and refactor so for the time being we have to do with the rank in the output writers,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895864384:71,refactor,refactor,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895864384,1,['refactor'],['refactor']
Modifiability,Distributed: extend MPI functions for `arch::Distributed`?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3318:13,extend,extend,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3318,1,['extend'],['extend']
Modifiability,"Do we currently have a function to retrieve spacings that considers whether a cell is ""wet"" or not? Meaning it considers whether a cell is part of the interior of the domain or is a halo/immersed solid cell when calculating `Δz`? Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. For example in the script below, I can retrieve `Δz` directly from `grid`, but the edges do not reflect the fact that the `z` direction is bounded. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25. julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; 5-element Vector{Float64}:; 0.25; 0.25; 0.25; 0.25; 0.25; ```. To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; ```julia ; julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; 5-element Vector{Float64}:; 0.125; 0.25; 0.25; 0.25; 0.125; ```; since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". I looked for ways to do this in that are already in the code but couldn't find anything. I wanted to ask before I started coding something from scratch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1182527618:812,variab,variably,812,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1182527618,1,['variab'],['variably']
Modifiability,"Do we think maybe just extending the existing pattern of input validation functions (`validate_coriolis`, `validate_advection`, etc) is a good route?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057:23,extend,extending,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796338057,1,['extend'],['extending']
Modifiability,"Do you want to add this here: https://github.com/CliMA/Oceananigans.jl/wiki/Installation-and-getting-started-with-Oceananigans ? . Let's phase these ""extended instructions"" out of the Documenter-based docs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2472#issuecomment-1109068285:150,extend,extended,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2472#issuecomment-1109068285,1,['extend'],['extended']
Modifiability,"Does anyone know how I can add Codecov coverage in our [buildkite pipeline](https://github.com/CliMA/Oceananigans.jl/blob/ncc/adds-codecov/.buildkite/pipeline.yml)?. From what I read at [`JuliaGPU/buildkite/README`](https://github.com/JuliaGPU/buildkite/blob/main/README.md) here, I get that I have to add:. ```Julia; plugins:; - JuliaCI/julia#v1:; version: ""1""; - JuliaCI/julia-test#v1: ~; - JuliaCI/julia-coverage#v1:; codecov: true; ```. in *every* step in our buildkite pipeline. Is this correct?. cc @maleadt, @vchuravy",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592:318,plugin,plugins,318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2329#issuecomment-1063309592,1,['plugin'],['plugins']
Modifiability,"Done!. ```Julia; julia> grid = RectilinearGrid(size=3, z= x->x^2, topology=(Flat, Flat, Bounded)); 1×1×3 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [1.0, 16.0] variably spaced with min(Δz)=3.0, max(Δz)=7.0. julia> grid = RectilinearGrid(size=3, z= x->-x^2, topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z should have increasing values.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::var""#41#42"", dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:126; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::var""#41#42""); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Function); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Function, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/Research/OC6.jl/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[22]:1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751328718:227,variab,variably,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3319#issuecomment-1751328718,1,['variab'],['variably']
Modifiability,"During the coefficients down to 1e-9 (!!) allows 3 stable time steps _when continents / bathymetry are removed_:. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 226.942 ms; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (288.084 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (1.446 seconds).; ┌ Info: Iteration: 1, time: 20 minutes, wall time: 1.452 seconds; │ ├── max(u): (1.32e-16, 5.40e-02, 6.44e-04) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 5.93e-01 m; ┌ Info: Iteration: 2, time: 40 minutes, wall time: 945.169 ms; │ ├── max(u): (1.39e-02, 1.06e-01, 1.05e-03) m s⁻¹; │ ├── extrema(T): (0.05, 30.00) ᵒC; └ └── max|η|: 1.33e+00 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 1 hour, wall time: 945.031 ms; │ ├── max(u): (3.55e-02, 1.52e-01, 1.37e-03) m s⁻¹; │ ├── extrema(T): (0.15, 30.00) ᵒC; └ └── max|η|: 2.08e+00 m; ```. But when they're put back, it still blows up (even with coefficients 1e-9):. ```julia; julia> include(""idealized_one_degree_simulation.jl""); grid = ImmersedBoundaryGrid on:; architecture: CPU(); grid: 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bound",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807:486,variab,variably,486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107311807,1,['variab'],['variably']
Modifiability,Dynamic launch config.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/270:15,config,config,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/270,1,['config'],['config']
Modifiability,"E.g. no need to calculate y-derivatives or y-averages, or even evolve v if the model is a 2D xz-slice. But this is low priority as it only affects the already fast 2D and 1D models.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/35:63,evolve,evolve,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/35,1,['evolve'],['evolve']
Modifiability,"Efficiently distributing a model (especially across GPUs) requires minimizing the number of messages. `update_state!(model)` looks like:. 1. Fill halos for the prognostic variables (requires message passing); 2. Computation of diagnostic variables; 3. Fill halos for diagnostic variables (requires message passing). We can thus minimize message passing by allocating two buffers: one for the prognostic fields, and one for the diagnostic fields. @simone-silvestri and I propose a new utility `field_tuple` for building tuples of fields to solve this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509:171,variab,variables,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509,3,['variab'],['variables']
Modifiability,Eliminate the previous rectilinear grids in favour of a general RectilinearGrid that is optionally stretched in any direction. Should be ready to merge.... Comments and to-do (in a future PR); - All grids except for `ConformalCubedSphereGrid` have an architecture field which means we should (a) include architecture in `ConformalCubedSphereGrid` and (b) remove architecture from all Models and Fields and let it be inferred by the grid (this might be a lot of work); - Nonhydrostatic Pressure solver is specified only for HRegRectilinearGrid (horizontally regular) and RegRectilinearGrid (fully regular). Specify pressure solver also for a non-regular grid? ; - Maybe: adapt the FFTTridiagonalSolver to grids with X and Z regular or Y and Z regular (might be useless because if a simulation requires a non-uniform direction that can just be set to be the z direction and would save us some coding),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2050:670,adapt,adapt,670,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2050,1,['adapt'],['adapt']
Modifiability,Employ new halo-filling functions to update halos of prognostic variables on the cubed sphere,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570:64,variab,variables,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570,1,['variab'],['variables']
Modifiability,Enhance Checkpointer + TendencyCallsite callback example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3461:0,Enhance,Enhance,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3461,1,['Enhance'],['Enhance']
Modifiability,Enhance Docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/753:0,Enhance,Enhance,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/753,1,['Enhance'],['Enhance']
Modifiability,Enhance `MultiregionGrid` with Conditional Halo Extensions and Debugging Capabilities,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3596:0,Enhance,Enhance,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3596,1,['Enhance'],['Enhance']
Modifiability,Enhance docstring for `Integral`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3446:0,Enhance,Enhance,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3446,1,['Enhance'],['Enhance']
Modifiability,Enhance docstrings + add models & modules in Docs/Appendix/Library,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2082:0,Enhance,Enhance,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2082,1,['Enhance'],['Enhance']
Modifiability,Enhance immersed boundary grid docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3505:0,Enhance,Enhance,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3505,1,['Enhance'],['Enhance']
Modifiability,Enhancement in the Eady turbulence example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1187:0,Enhance,Enhancement,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1187,1,['Enhance'],['Enhancement']
Modifiability,Enhancements to `RiBasedVerticalDiffusivity`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2423:0,Enhance,Enhancements,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2423,1,['Enhance'],['Enhancements']
Modifiability,Enhances docstring for the `ImplicitFreeSurface` constructor to include the available solver methods. Closes #2620,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2621:0,Enhance,Enhances,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2621,1,['Enhance'],['Enhances']
Modifiability,Enhances docstrings for timesteppers,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2322:0,Enhance,Enhances,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2322,1,['Enhance'],['Enhances']
Modifiability,"Everything useful that I have is probably in the draft PR #2275 and the associated branch! They aren't forcing functions, but we hard coded in some drag functions for the flux in the IB case that could be used, and the sandbox has the boundary condition versions of those same functions as a test. It wouldn't take much to turn them into divergences!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099515153:219,sandbox,sandbox,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1099515153,1,['sandbox'],['sandbox']
Modifiability,"Exactly what I am struggling with right now: figuring out how to quickly get x, y, z coordinates when loading an output file created previously (with JLD2 output writer}). So as far as I understand in that case the 'model' and 'grid' variables do not exist. ; `xc = file([""grid/xC""]) `; etc. works, but contains the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367:234,variab,variables,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367,1,['variab'],['variables']
Modifiability,Export `ParameterizedForcing` and fix docstring,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/739:8,Parameteriz,ParameterizedForcing,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/739,1,['Parameteriz'],['ParameterizedForcing']
Modifiability,Extend `BatchedTridiagonalSolver` to all directions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3117:0,Extend,Extend,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3117,1,['Extend'],['Extend']
Modifiability,Extend equation of state functionality,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/439:0,Extend,Extend,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/439,1,['Extend'],['Extend']
Modifiability,Extend operations for two `ZeroField`s,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3567:0,Extend,Extend,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3567,1,['Extend'],['Extend']
Modifiability,"Extended the print function so that ; string(::AdvectionScheme) = ""AdvectionScheme"". closes #2098",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099:0,Extend,Extended,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099,1,['Extend'],['Extended']
Modifiability,"Extended the type WENO5 to allow the execution of the WENO scheme on stretched and uniform grids alike. . In practice:. - `WENO5()` will default to the uniform 5th order coefficients (""uniform"" setting) in all directions with a JS-WENO formulation; - `WENO5(grid = grid)` will default to uniform interpolation coefficient if the direction is uniform (`typeof(Δc) <: Number`) and will precompute the ENO coefficients for reconstruction in the stretched directions (""stretched"" setting) (I have tested ""on the fly"" coefficient calculation for stretched directions and it is way too expensive! therefore, useless to keep as a possibility); - `WENO5(grid = grid, stretched_smoothness=true)` will compute coefficients for the smoothness indicators `β₀, β₁` and `β₂` to account for stretched grid; - `WENO5(zweno = true)` will implement a Z-WENO formulation for the weno weight calculation; - No support is given for `WENO5S(grid = grid)` for curvilinear grids for the moment (defaults to uniform setting). Comments:; Despite the fact that all methods have the same execution speed, `stretched_smoothness` requires more memory (and slightly more computation time) and is not much impactful. As such, most of the time it is better to use just the `WENO5(grid = grid)` keyword argument as it does not decrease accuracy but decreases memory utilization (and speed up slightly). (I haven't tried all types of grids, so maybe it is good to check before performing a large simulation on a weird stretched grid); On the other hand, a Z-WENO formulation is always beneficial (also in case of a uniform mesh) with no major decrease in performance. The same can be said for the stretched `WENO5(grid=grid)` formulation in case of stretched grids. `validation/advection/validate_weno_scheme.jl` compares all these methods in terms of time and accuracy on a simple 1D and 2D tracer advection simulations. Below some animations showing the performance of the three methods for a ""center coarsened"" grid type (`grid_str2`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060:0,Extend,Extended,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060,1,['Extend'],['Extended']
Modifiability,Extends FieldSlicer to support StepRange indices,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1526:0,Extend,Extends,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1526,1,['Extend'],['Extends']
Modifiability,Extends PrescribedVelocityField to support concrete Fields (not just functions),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1535:0,Extend,Extends,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1535,1,['Extend'],['Extends']
Modifiability,Extends `getindex` for `Nothing` locations to `AbstractField`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1649:0,Extend,Extends,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1649,1,['Extend'],['Extends']
Modifiability,Faster and more flexible NetCDF IO.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145:16,flexible,flexible,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145,1,['flexible'],['flexible']
Modifiability,Faster model with dynamic launch configuration by @maleadt,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/302:33,config,configuration,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302,1,['config'],['configuration']
Modifiability,"Feel free to refactor [`generated_vertically_stretched_grid`](https://github.com/CliMA/Oceananigans.jl/blob/6ff1f69e2bc5d66a0889fb3c62fb2a3b633ab535/src/Grids/vertically_stretched_rectilinear_grid.jl#L189) as part of #1532 and put it in a new file, so we can use it for grid stretching in non-z directions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1605#issuecomment-825730370:13,refactor,refactor,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1605#issuecomment-825730370,1,['refactor'],['refactor']
Modifiability,"Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:62; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Field{Center,Face,Center,OffsetArrays.OffsetArray{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:2635,sandbox,sandbox,2635,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449,1,['sandbox'],['sandbox']
Modifiability,"First of all, thank god this model runs on GPU. It is awesome how fast this is!!. I am trying to run the the model using the following function for `ScalarDiffusivity`:; ```; width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; ```; which returns the error below while running the model. ```; ┌ Warning: Cannot save Function property into closure/2/ν; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:22; ┌ Warning: Cannot save Function property into closure/2/κ/b; └ @ Oceananigans.OutputWriters /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/OutputWriters/output_writer_utils.jl:22; ┌ Info: Initializing simulation...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:168; ┌ Info: ... simulation initialization complete (27.506 ms); └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:203; ┌ Info: Executing initial time step...; └ @ Oceananigans.Simulations /home/isimoesdesousa/.julia/packages/Oceananigans/CuznF/src/Simulations/run.jl:113; InvalidIRError: compiling kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 4000, 50)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 16, 50)}, KernelAbstractions.NDIteration.StaticSize{(1, 256, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Bounded, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float64, 1}",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359:286,layers,layers,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359,1,['layers'],['layers']
Modifiability,Fix `_immered_cell` and adapt for `PartialCellBottom`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682:24,adapt,adapt,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682,1,['adapt'],['adapt']
Modifiability,Fix inconsistent variable definition in `ScalarDiffusivity` constructor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2288:17,variab,variable,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2288,1,['variab'],['variable']
Modifiability,"Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:88; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[1]:1; ```. I'm not really sure how to fix this one...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:14990,sandbox,sandbox,14990,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056,1,['sandbox'],['sandbox']
Modifiability,Following the warnings issued by julia `v1.8.2`; ```. WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LZ but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LY but does not use it.; WARNING: method definition for _multiary_operation at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/multiary_operations.jl:23 declares type variable LX but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LZ but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LY but does not use it.; WARNING: method definition for _derivative at /home/ssilvest/Oceananigans.jl/src/AbstractOperations/derivatives.jl:31 declares type variable LX but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable A but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable K but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Z but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable Y but does not use it.; WARNING: method definition for show at /home/ssilvest/Oceananigans.jl/src/OutputReaders/field_dataset.jl:52 declares type variable X but does not use it.; ```,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2761:202,variab,variable,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2761,11,['variab'],['variable']
Modifiability,"For a future PR (probably #2642):. * Use the _order_ (not buffer size) as a type parameter, so WENO(order=5) yields a type `WENO{5}`, for example; * Improve docstrings for advection schemes (but this is contingent on the larger advection refactor in #2642)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194587440:238,refactor,refactor,238,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1194587440,1,['refactor'],['refactor']
Modifiability,"For example for the tripolar grid it looks like this. ```julia; 2160×1080×60 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on GPU with 7×7×7 halo and with precomputed metrics; ├── centered at (λ, φ) = (75.0, 1.8005); ├── longitude: Periodic extent 360.167 degrees variably spaced with min(Δλ)=0.000208433, max(Δλ)=0.175625; ├── latitude: RightConnected extent 170.157 degrees variably spaced with min(Δφ)=0.000312453, max(Δφ)=0.157553; └── z: Bounded z ∈ [-6000.0, 0.0] variably spaced with min(Δz)=5.24961, max(Δz)=438.409; ```. This claims that whatever grid I've constructed is ""RightConnected"" in latitude. This doesn't really make sense to me... but let's set that aside (it's a separate issue with the tripolar grid). The bigger issue is that the y-topology is NOT the ""latitude topology"" --- on an orthogonal spherical shell grid, ""y"" and ""latitude"" are different (that's the whole point, when they do coincide we are on a LatitudeLongitudeGrid). We should design a good show method for this grid type. My impression is that the show method was copied from LatitudeLongitudeGrid. But we need to work a bit harder for OrthogonalSphericalShellGrid because it is more general. I think we should give information both about the coordinate system (lat, lon, z), and in addition to that and separately, give information about the logical arrangement of the grid (x, y, z), including the topology. The former is important for understanding the geography of the grid and the latter is important for understanding the discretization, and the two are distinct from one another. So the show method for this grid is going to be more involved than the others. I don't think we need to indicate whether the x, y directions are ""variably spaced"". That is useful for rectilinear and lat-lon grids, but not for general grids. . cc @navidcy @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3808:291,variab,variably,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3808,4,['variab'],['variably']
Modifiability,"For example, the grid below is perfectly regularly spaced in all dimensions but Oceananigans doesn't ""see"" it that way... ```Julia; julia> grid = RectilinearGrid(size = (4, 4, 2), x = (0, 1), y=[0, 1//4, 2//4, 3//4, 1], z=[0, 0.5, 1]); 4×4×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; ├── Periodic y ∈ [0.0, 1.0) variably spaced with min(Δy)=0.25, max(Δy)=0.25; └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.5, max(Δz)=0.5; ```. (This may be also relevant in a solution/warning to be shown to the user regarding #2191.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2192:407,variab,variably,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2192,2,['variab'],['variably']
Modifiability,"For future reference, instead of the second step above, we need to add an environment variable `DOCUMENTEY_KEY=path_to_long_private_key` to the file `/etc/buildkite-agent/hooks/environment` (which may not exist yet).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901384701:86,variab,variable,86,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901384701,1,['variab'],['variable']
Modifiability,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1342:619,Refactor,Refactor,619,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342,2,"['Refactor', 'parameteriz']","['Refactor', 'parameterizations']"
Modifiability,"For regular spacing:. ```julia; julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(2, 2, 2)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; x: [0.0, 2.0] regularly spaced with Δxᶜᵃᵃ = 2.0; y: [0.0, 2.0] regularly spaced with Δyᵃᶜᵃ = 2.0; z: [-2.0, 0.0] regularly spaced with Δzᵃᵃᶜ = 2.0; ```. for variable spacing:. ```julia; julia> σ = 1.1; # stretching factor. julia> Nz = 24; # vertical resolution. julia> Lz = 32; # depth (m). julia> hyperbolically_spaced_faces(k) = - Lz * (1 - tanh(σ * (k - 1) / Nz) / tanh(σ));. julia> grid = RectilinearGrid(size = (32, 32, Nz), x = (0, 64),; y = (0, 64), z = hyperbolically_spaced_faces); 32×32×24 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; x: [0.0, 64.0] regularly spaced with Δxᶜᵃᵃ = 2.0; y: [0.0, 64.0] regularly spaced with Δyᵃᶜᵃ = 2.0; z: [-32.0, -0.0] variably spaced with min(Δzᵃᵃᶜ) = 0.682695, max(Δzᵃᵃᶜ) = 1.830909; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017835511:338,variab,variable,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017835511,2,['variab'],"['variable', 'variably']"
Modifiability,For sure. The trick about the global environment is just Julia knowledge. But it is relevant to efficient workflows for testing so we can indeed put it there. Personally I don't test just one file unless I am debugging major refactors but perhaps others do it differently...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-2000034395:225,refactor,refactors,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-2000034395,1,['refactor'],['refactors']
Modifiability,"For the ""model setup"" section of the documentation where we'll describe how to use the `TimeStepWizard` to choose adaptive time steps, I was thinking it would be good to recommend some CFL values. I think with 2nd-order Adams Bashforth we're limited to CFL < 0.5, so I'm thinking of recommending to start with CFL = 0.3 then decrease if issues are encountered. I usually run with 0.15 < CFL < 0.3. @glwagner What do you usually run with?. @jm-c @christophernhill Any wisdom from MITgcm?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/353:114,adapt,adaptive,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/353,1,['adapt'],['adaptive']
Modifiability,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:263,config,configurations,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,1,['config'],['configurations']
Modifiability,"For the moment this works only with the `SplitExplicitFreeSurface` but I think it can be extended to work also with an implicit free surface following the above mentioned algorithm where $\text{barotropic-step}$ and $\text{barotropic-correction}$ are substituted with a solve of the linear system (starting from interpolated velocities) and a pressure correction step with interpolated eta, i.e.:. ***substep 1:***; - $u^{*, n+1/2} = u^{n} + \Delta t G(u^{n})$; - $\eta^{n+1/2} = \text{barotropic-solve}\left(\eta^n, \int_z u^{*, n+1/2} \right)$; - $u^{n+1/2} = \text{pressure-correction}\left(u^{*, n+1/2}, \eta^{n+1/2} \right)$. ***substep 2***; - $u^{*, n+1/3} = \frac{3}{4}u^{n} + \frac{1}{4}\left(u^{n+1/2} + \Delta t G(u^{n+1/2}) \right)$; - $\eta^* = \text{barotropic-solve}\left(\eta^{n+1/2}, \int_z u^{*, n+1/3} \right)$; - $\eta^{n+1/3} = \frac{3}{4}\eta^{n} + \frac{1}{4}\eta^*$; - $u^{n+1/3} = \text{pressure-correction}\left(u^{*, n+1/3}, \eta^{n+1/3} \right)$. ***substep 3***; - $u^{*, n+1} = \frac{1}{3}u^{n} + \frac{2}{3}\left(u^{n+1/3} + \Delta t G(u^{n+1/3})\right)$; - $\int_z u ^{n+1} = \frac{1}{6}\int_z u^{n} + \frac{1}{6}\int_z u^{n+1/2} + \frac{2}{3}\int_z u^{*, n+1}$; - $\eta^{n+1} = \text{barotropic-solve}\left(\eta^{n}, \int_z u ^{n+1} \right)$; - $u^{n+1} = \text{pressure-correction}\left(u^{*, n+1}, \eta^{n+1}\right)$",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441255636:89,extend,extended,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441255636,1,['extend'],['extended']
Modifiability,Forcing API refactor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/444:12,refactor,refactor,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/444,1,['refactor'],['refactor']
Modifiability,"Forgot to use dynamic launch configs for the `calculate_G*` kernels. But, hmmm, this actually slows things down a bit... ```; ─────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 247s / 29.9% 14.9GiB / 0.56% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 34.0s 46.1% 3.40s 292KiB 0.34% 29.2KiB; 256×256×256 (CPU, Float32) 10 30.5s 41.4% 3.05s 227KiB 0.26% 22.7KiB; 128×128×128 (CPU, Float64) 10 3.94s 5.35% 394ms 292KiB 0.34% 29.2KiB; 128×128×128 (CPU, Float32) 10 3.54s 4.80% 354ms 227KiB 0.26% 22.7KiB; 64× 64× 64 (CPU, Float64) 10 417ms 0.57% 41.7ms 292KiB 0.34% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 406ms 0.55% 40.6ms 227KiB 0.26% 22.7KiB; 256×256×256 (GPU, Float64) 10 337ms 0.46% 33.7ms 11.0MiB 13.0% 1.10MiB; 256×256×256 (GPU, Float32) 10 254ms 0.34% 25.4ms 9.62MiB 11.4% 0.96MiB; 32× 32× 32 (CPU, Float64) 10 52.6ms 0.07% 5.26ms 292KiB 0.34% 29.2KiB; 128×128×128 (GPU, Float64) 10 47.3ms 0.06% 4.73ms 11.0MiB 13.0% 1.10MiB; 32× 32× 32 (CPU, Float32) 10 46.9ms 0.06% 4.69ms 227KiB 0.26% 22.7KiB; 128×128×128 (GPU, Float32) 10 36.4ms 0.05% 3.64ms 9.62MiB 11.4% 0.96MiB; 32× 32× 32 (GPU, Float64) 10 26.6ms 0.04% 2.66ms 11.0MiB 13.0% 1.10MiB; 32× 32× 32 (GPU, Float32) 10 24.6ms 0.03% 2.46ms 9.61MiB 11.4% 0.96MiB; 64× 64× 64 (GPU, Float64) 10 24.6ms 0.03% 2.46ms 11.0MiB 13.0% 1.10MiB; 64× 64× 64 (GPU, Float32) 10 22.6ms 0.03% 2.26ms 9.62MiB 11.4% 0.96MiB; ─────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedup:; 32× 32× 32: 1.122; 64× 64× 64: 1.027; 128×128×128: 1.114; 256×256×256: 1.114. GPU Float64 -> Float32 speedup:; 32× 32× 32: 1.081; 64× 64× 64: 1.086; 128×128×128: 1.301; 256×256×256: 1.326. CPU -> GPU speedup:; 32× 32× 32 (Float32): 1.903; 32×",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/308:29,config,configs,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/308,1,['config'],['configs']
Modifiability,"From the stacktrace, it looks like it's complaining about `ω̄ ` and looking at the script: . https://github.com/CliMA/Oceananigans.jl/blob/master/examples/Bickley_jet_shallow_water.jl#L92. it looks like it's using a global variable `U` in the definition of `ω̄ ` which won't work in a GPU kernel. Probably the easiest solution is to just define `const U = 1.0` since `const` global variables can be referenced in GPU kernels. Not sure if there's a clean way of putting in `U` as a parameter (like with forcing functions) since you're using `ω̄ ` in an abstract operation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800175997:223,variab,variable,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1477#issuecomment-800175997,2,['variab'],"['variable', 'variables']"
Modifiability,"From the standpoint of `NonhydrostaticModel`, the only requirement (I think?) is a pressure solver that's valid on more grids. The `FourierTridiagonalPoissonSolver` combines FFTs with a tridiagonal solve in one direction to solve the Poisson equation. Thus, this method can be used if the grid is stretched in just one (1) direction. Right now, we only support grids that are stretched in `z`, the third direction / index. Presumably it's at most a matter of copy and paste and index permutation to support grids that are stretched in `x` (and regular in `y, z`) or stretched in `y` (and regular in `x, z`). Under the hood, the `FourierTridiagonalPoissonSolver` relies on the `BatchedTridiagonalSolver` to perform the tridiagonal solve:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L81-L82. The `BatchedTridiagonalSolver` launches a kernel over `xy` and performs a tridiagonal solve in `z`:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L79-L80. So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`. . This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward... Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation. I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620:1147,extend,extend,1147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620,1,['extend'],['extend']
Modifiability,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:281,variab,variables,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575,4,['variab'],"['variable', 'variables']"
Modifiability,"Future work:. 1) Make sure that the symmetric flux of buoyancy is very small, even on a stretched grid, etc; 2) Adapt the taper factor calculation to be boundary-friendly; 3) Also make sure the slope calculation is boundary-friendly. I don't really know how to do (3) so we need @jm-c help for that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2481#issuecomment-1111599631:112,Adapt,Adapt,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2481#issuecomment-1111599631,1,['Adapt'],['Adapt']
Modifiability,Gent-McWilliams mesoscale eddy flux parameterization,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1492:36,parameteriz,parameterization,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492,1,['parameteriz'],['parameterization']
Modifiability,"Getting at least area and volume in there would be helpful, but kind of stopping short of 'doing this right'. . Each time I look at the SGRID specs I think ""Its right there"" when I see the specifications of 'edges=length', 'faces=area', and 'volume'; <img width=""804"" alt=""image"" src=""https://user-images.githubusercontent.com/14314623/227060884-d28ff5d1-9e0a-4874-b9eb-093afd4607f9.png"">; But AFAIK there is no way to actually assign a coordinate/data variable to each of these positions? If we could somehow add that into the spec I think that would be much better than abusing `cell_thickness`. . In my mind, all that is needed to correctly parse a metric into xgcm is a flag (e.g. this is a metric) and information on the 'kind' of metric and its 'orientation', both of which I believe can be encoded in SGRID already? So really all that is needed is some metadata that implements the flag. I hope this makes sense to folks. . Maybe we get some of the sgrid folks into this discussion? Just to see if I misinterpret what is already possible and whether we could add something to SGRID that indicates that a variable/coordinate represents some physical metric (length, area, volume). cc @hrajagers @rsignell-usgs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480392005:453,variab,variable,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480392005,2,['variab'],['variable']
Modifiability,"Go for it! If you want to discuss an idea before writing code, let's discuss here. Here's my thoughts:. 1. We can add a color to an important `show` method like one / all of the models, or `Simulation`; 2. We can add a nice utility for logging progress that uses `Term.jl`, that users can configure and then add to `simulation.callbacks` (we could also consider making it default)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1077663914:289,config,configure,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2281#issuecomment-1077663914,1,['config'],['configure']
Modifiability,"Good idea! Does this mean tagging v0.94.0 (and one stop closer to v0.100) as it's a change to the public interface?. > Remove `OceananigansLogger`: rarely used. I use it in almost every script I write haha, but that's because I wrote it to my liking. There's a strong argument to be made that a logger configuration does not belong in Oceananigans.jl. I feel it's similar to Oceananigans' decision to not provide a default progress callback seeing as each user will probably want a different one. > Remove `StateChecker`: not used as far as I know. Yeah I think I used that to debug cubed sphere stuff. Could easily be defined in a validation script though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627:302,config,configuration,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872#issuecomment-2439726627,1,['config'],['configuration']
Modifiability,"Good idea. Maybe even suggest the user try `ShallowWaterModel`, as that is a better way to try this configuration? ;)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023127291:100,config,configuration,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023127291,1,['config'],['configuration']
Modifiability,"Got bitten by CuArray scalar operations while debugging some Europa runs so this PR adds an `__init__()` function to the Oceananigans module that disables CuArray scalar operations once the module has been loaded and only allows scalar ops via the `CUDA.@allowscalar` macro. Now when we accidentally perform scalar ops on CuArrays we should get an error, which is much better than having silent performance regressions which has happened multiple times in the past. Two remaining problems:; 1. `set!(u::Field, v::Number) = @. u.data = v` actually incurs scalar ops because `a::CuArray .= 1.5` does not but `a::OffsetArray{CuArray .= 1.5` does, so it's probably something we have to fix by adapting broadcasting over offsetarrays?; 2. For similar broadcasting reasons I think; ```julia; data = cpudata(output); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```; also incurs scalar ops during NetCDF output so I will try changing back to the old behavior where we used something like `	 ; ```julia; data = interiorparent(output); !isa(output, Array) && (data = Array(data)); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```. Resolves #276",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/851:689,adapt,adapting,689,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851,1,['adapt'],['adapting']
Modifiability,"Greg, Ali, and what if we began to consider more complex geometries etc -; hard to resist going in that direction..... we'd have to change the solvers; - more MITgcm-like, congrad etc - but what would the implications be for; boundary conditions? More food for thought. John. On Sat, Mar 28, 2020 at 10:22 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Mostly I am worried about scalability and sustainability in this design,; > or future designs.; >; > Currently our models are fairly simple, but its challenging to place; > bounds on potential future complexity. For example, models in the future; > may require additional fields associated with closures or; > parameterizations, such as (two-dimensional) boundary layer depth fields,; > plume quantities, mixing lengths and perhaps other auxiliary fields; > associated with various prognostic / diagnostic LES models. We probably; > can't plan to support setting boundary conditions on every possible field; > via the model constructor.; >; > With our current design we have essentially special-cased turbulent; > diffusivities because our focus is LES, turbulent diffusivities are; > relatively common, and it convenient for us. However doing this incurs some; > maintenance burden --- which will increase if we plan to hard-code; > validation and error checking.; >; > Food for thought.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605453798>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT642WME2EIX3DDSITRJYBYXANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060:675,parameteriz,parameterizations,675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060,1,['parameteriz'],['parameterizations']
Modifiability,"Having `classification` (previously called ""`BCType`"") as a property of `BoundaryCondition` will allow data to be stored there. A future PR will leverage this property to refactor `Communication` boundary conditions for models with multiple grids or distributed across multiple nodes. It was also realized that `NormalFlow` is a special case of an ""Open"" boundary condition, where halo regions are ""directly"" determined by an array or function. True support for Open boundary conditions will be the subject of a future PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1824:171,refactor,refactor,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1824,1,['refactor'],['refactor']
Modifiability,"Heh. I would never imply you can't take my code and adapt it to do nice things. You can of course do that. For example if you have `outputs` already assembled, you can do. ```julia; function create_subsampled_output(field); loc = location(field); subsampled_field = Field(loc, subsampled_grid); function output(model); interpolate!(subsampled_field, field); return subsampled_field; end; return output; end. subsampled_outputs = NamedTuple(name => create_subsampled_output(outputs[name]) for name in keys(outputs)); ```. And there's an infinity of other ways you can write your code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033084916:52,adapt,adapt,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2033084916,1,['adapt'],['adapt']
Modifiability,"Hello everyone, I have tested ```VerticallyStretchedRectilinearGrid( )``` and found a hard time in setting up the time step for a stable solution. ; I will going to post the whole issue but before that I just want to know weather is there any adaptive time stepping method like we did have ```TimeStepWizard``` . I have searched and failed may be I might have missed it that's why I first ask this question.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1741:243,adapt,adaptive,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1741,1,['adapt'],['adaptive']
Modifiability,"Hello everyone,. I'm trying to calculate the pressure terms shown in the following figure (Eq.(2.5) from [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)):. ![4031706602798_ pic](https://github.com/CliMA/Oceananigans.jl/assets/112752688/4672fa09-2fa1-4302-8c33-684cefe3612c). The equation in the above figure I think is another form of writing the pressure equation to maintain incompressibility, but different from the common way ($p = p_{HY'}+ p_{NHS}$), it may provide new insights into how different processes contribute to pressures and help to improve second-moment vertical mixing parameterizations, which is the motivation that I want to calculate them. What I'm trying to do is write the code that repeats the pressure solver algorithm for non-hydrostatic pressure (cause this is also an elliptic problem I think) to calculate the terms in the above equation, and re-run the pressure solver separately for each of these new terms. Lastly, I want to save these new pressure terms in a way that will not overwrite the original pressures. . I tried to start with the second term ($p_r'$) in the RHS of the equation. This term is the component that results from rapid distortion by the current shear. For this term, the vertical boundary condition is $\partial p_r' / \partial x_3 = 0$ (see more details about boundary conditions in Appendix A in [Pearson et al., 2019](https://www.cambridge.org/core/journals/journal-of-fluid-mechanics/article/pressurestrain-terms-in-langmuir-turbulence/C13A4550F408F770740F47C7CBDDEAED)). So the goal is to solve an equation $\nabla^2p_r' = -2\frac{\partial U_i}{\partial x_j}\frac{\partial u_j'}{\partial x_i}$ with applying the boundary condition $\partial p_r' / \partial x_3 = 0$. I have written a part of the code (I start from the calculation of $p_r'$ because there is no need to consider the boundary conditions, and the calc",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3459:715,parameteriz,parameterizations,715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3459,1,['parameteriz'],['parameterizations']
Modifiability,"Here's a few notes on a model with fetch dependence. ## Time-dependence of the spectral peak. Under persistent winds, the sea state continuously evolves. This is captured by the concept of _fetch_, which is more or less the distance over which the wind blows. The fetch dependence of the sea state is strikingly captured by this figure from [JONSWAP](https://pure.mpg.de/rest/items/item_3262854/component/file_3282032/content):. <img width=""671"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/156589227-c6f5f778-3cfd-4d4b-b199-34d4ad3756b1.png"">. which shows the _fetch dependence_ of the surface wave spectrum: as the fetch gets longer (as the winds blow for a longer period of time), the peak wavenumber decreases (the waves get longer) and the spectrum spreads out. [Lenain and Melville 2017](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2017_Lenain_Melville-Journal_of_Physical_Oceanography_vol_47-2.pdf) derive fetch relationships between peak frequency and non-dimensional fetch in their equations 11 and 12. Putting ourselves in a reference frame moving at the phase speed of the peak wavenumber, and rewriting these relationships in terms of peak wavenumber yields. ![image](https://user-images.githubusercontent.com/15271942/156588626-19b01ba3-5557-4f17-af1d-4d93b8c4fb9f.png). The above is a model for a time-dependent peak wavenumber for a given constant friction velocity. This is an alternative to a constant peak wavenumber scaling.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701:145,evolve,evolves,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1058124701,1,['evolve'],['evolves']
Modifiability,Here's how the `u` field from the code-snippet above looks like when evolved on a SingleRegion and MultiRegion grids:. ![u](https://github.com/CliMA/Oceananigans.jl/assets/7112768/cf256be5-7e94-45d6-9bc3-e5c7a6adc1fb),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3514#issuecomment-1999457836:69,evolve,evolved,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3514#issuecomment-1999457836,1,['evolve'],['evolved']
Modifiability,"Here's my latest work on setting up an OMIP simulation:. https://github.com/CliMA/ClimaOcean.jl/blob/glw-ss/ice-ocean-model/experiments/prototype_omip_simulation/omip_simulation.jl. which also includes an example of using `ImmersedBoundaryGrid` to implement bathymetry. Bathymetry is a little sad there; I ""diagnose"" it from the ECCO state rather than prescribing directly. We need initialization tools for reasonable ""in painting"" for cases where initial condition information and bathymetry are slightly different (ie filling in NaNs near boundaries, etc). All of this should evolve quite a bit in the next few months. PS I'm going to convert this to a Discussion so that we can continue the party without needing to make any source code changes.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809330687:578,evolve,evolve,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809330687,1,['evolve'],['evolve']
Modifiability,"Here's the julia docs on constants for reference:. https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Constants. This statement in the julia docs could maybe be clarified:. > It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. because its ambiguous what ""code involving global variables"" is. For Oceananigans, this almost always means ""functions that capture global variables in their scope"". So `f(x) = a * x` is going to be slow unless `a` is `const`; otherwise `f(x)` cannot be inlined properly because the type of `a` is uncertain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539:91,variab,variables-and-scoping,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539,4,['variab'],"['variables', 'variables-and-scoping']"
Modifiability,"Here's the specific error we got when we tried to get `Field`, including all its glorious boundary conditions, to compile on the GPU:. ```; Entry function 'ptxcall_calculate_Gu__66' uses too much parameter space (0x16c8 bytes, 0x1100 max); ```. dredged up from #746 . Some workarounds were suggested there, but I think our solution is actually better / simpler (adapt fields by unwrapping the underlying data and throwing away boundary conditions, rather than wrestling to get all the field info onto the poor GPU).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738767849:362,adapt,adapt,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738767849,1,['adapt'],['adapt']
Modifiability,"Here's what I got:. ![image](https://user-images.githubusercontent.com/15271942/156228448-7e02ebdb-4fa6-4e74-a495-0cd955927cb4.png). This seems sort of reasonable at moderate wind speeds. At low wind speeds it presumably doesn't make sense to have a peak period of 2.5s ... ? At the higher wind speeds peak periods of 25.5 s are maybe not impossible. It'd be nice to have a way of validating this. But maybe that's not easy short of actually running WW3. Notes... * The code to produce this is below; * Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux `τ`. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?); * If we want to re-parameterize this ""equilibrium Stokes drift"" in terms of momentum flux, we'll presumably have to run a sweep with WW3. ```julia; using SpecialFunctions; using GLMakie; using Printf. # Parameters; g = 9.81 # Gravitational acceleration for diagnostic wave property calculations; ρʷ = 1035 # Water density for toy bulk formula; ρᵃ = 1.225 # Air density for toy bulk formula; Cᵈ = 1e-3 # Drag coefficient for toy bulk formula; Ckᵖ = 0.167 # Peak wavenumber scaling parameter; Cuˢ = 0.016 # Scaling between wind stress and surface stokes drift; A_McWilliamsRestrepo = 5.1e-4 # parameter with units ""inverse acceleration""; # that relates wind stress to Stokes transport. # Peak wave number and surface Stokes drift calculation; U₁₀(τ) = sqrt(τ * ρʷ / (Cᵈ * ρᵃ)); surface_Stokes_drift(τ) = Cuˢ * U₁₀(τ); Stokes_transport(τ) = A_McWilliamsRestrepo * U₁₀(τ)^3. @inline function peak_wavenumber(τ); uˢ₀ = surface_Stokes_drift(τ); Vˢ = Stokes_transport(τ); return Ckᵖ * uˢ₀ / Vˢ; end. # Stokes drift profile calculation; T₁(k, z) = exp(2k * z); T₂(k, z) = sqrt(2π * k * abs(z)) * erfc(sqrt(2k * abs(z))). function Stokes_drift(τ, z); kᵖ = peak_waven",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685:712,parameteriz,parameterize,712,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1055741685,2,['parameteriz'],['parameterize']
Modifiability,"Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project. . My last attempt at improving the NetCDF solved many of the issues with the package https://github.com/JuliaGeo/NetCDF.jl/pull/61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite. . Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages. . I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype. . I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874:590,rewrite,rewrite,590,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874,1,['rewrite'],['rewrite']
Modifiability,"Hi @c42f thank you for chiming in! Will definitely ping you as we work on logging. I think we probably should have tackled logging much earlier. We still use `@printf` and vanilla `@info` for logging, which has been quite counter-productive haha. Definitely hoping we can reach a useful logger that can; * help developers by providing info and debug messages. Also nice in test logs.; * help users understand what the model is doing and provide a better and more responsive user experience by logging what the model is doing. This is where `@setup` and `@diagnostic` logging messages might be really nice. Although `@setup` and `@diagnostic` might be bad names as they don't imply logging? Not sure of the best solution but maybe your kwarg suggestion would help here, e.g. `@info source=""diagnostic"" msg`?. @arcavaliere seems to be developing a pretty general-purpose `ModelLogger` which hopefully we can adapt for all these uses! @arcavaliere I'm more than happy to help if you need anything. MicroLogging.jl looks pretty neat! I like that it puts the log level, file name, and line number on the right as putting them on the left causes messages not to align and makes logs harder to read. TensorBoardLogger looks pretty cool! Would be awesome to have something like that one day, but I guess you'd have to use something like ncusrses...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876:906,adapt,adapt,906,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-542677876,1,['adapt'],['adapt']
Modifiability,"Hi @iurt! Very nice that you are thinking to implement a new parametrization! . To start I would try to implement the additional prognostic equations, decoupled from the main solution. ; You can use the existing infrastructure for tracer evolution and modify the k or epsilon (or omega or whatever quantity you choose to evolve) ""specific"" dissipation terms in the TurbulenceClosures module. Once that is done and validated we can couple them to the momentum equations through the definition of a new ""eddy viscosity"" which uses values from the newly defined tracers",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554:321,evolve,evolve,321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051271554,1,['evolve'],['evolve']
Modifiability,"Hi all, I recently switched from using v0.30.0 to using the latest version of the master branch, and I am now unable to add the CuArrays package, as it seems to clash with some of the packages used by Oceananigans. Has anyone else experienced this? I was able to reproduce this issue on two computers. When reverting back to v0.30.0, I have no such problem and can add CuArrays without packages clashing. Thanks for letting me know if you get the same issue!. Full error message suggest that Adapt, GPUArrays, CUDA and NNlib are clashing with CuArrays but I am a beginner at Julia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:492,Adapt,Adapt,492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['Adapt'],['Adapt']
Modifiability,"Hi all,. I am having some weird patterns for buoyancy at the surface that blows up the model, even that I am not applying any forcing there. ## The context. I am currently trying to setup a front simulation to couple with the NP model being developed in #2385 .; The idea is to start with an unbalaced front that evolves in time until it reaches its balance. I expect that front will probably radiate some internal waves, but geostrophically adjust after some time. ## The initial conditions. I am starting the simulation with a single buoyant front that adds to an initial buoyancy profile. ![image](https://user-images.githubusercontent.com/5797727/161123119-976a92ef-0a7f-4bc9-823a-0da0b4852623.png). ```julia; const g = 9.82 # gravity; const ρₒ = 1026 # reference density. # background density profile based on Argo data; @inline bg(z) = 0.25*tanh(0.0027*(-653.3-z))-6.8*z/1e5+1027.56. # decay function for fronts; @inline decay(z) = (tanh((z+500)/300)+1)/2. @inline front(x, y, z, cy) = tanh((y-cy)/12kilometers); @inline D(x, y, z) = bg(z) + 0.8*decay(z)*front(x, y, z, 0)/4; @inline B(x, y, z) = -(g/ρₒ)*D(x, y, z). # setting the initial conditions; set!(model; b=B); ```. ## The problem. After 1 timestep it starts to present weird patters at the surface.; I am pretty sure I am messing up with something here, can you help me to figure this out?. ![image](https://user-images.githubusercontent.com/5797727/161127315-8230c1fb-9207-45ed-9fe8-f65b157a905a.png). ## Full code:; ```julia; using Oceananigans; using Oceananigans.Units. # define the size and max depth of the simulation; const Ny = 100; const Nz = 48 # number of points in z; const H = 1000 # maximum depth. # create the grid of the model; grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(-(Ny/2)kilometers, (Ny/2)kilometers),; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). # define the turbulence closure of the model; horizontal_closure = ScalarDiffusivity(ν=1, κ=1); vertical",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2405:313,evolve,evolves,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2405,1,['evolve'],['evolves']
Modifiability,"Hi all,. I'd be very keen to implement a multi-layer version of the shallow water model. For example, here's the 2-layer version:. <img width=""1002"" alt=""Screen Shot 2022-05-03 at 10 15 14 am"" src=""https://user-images.githubusercontent.com/29700296/166345681-77f90009-2f8b-4db5-8ddd-3808eca11c09.png"">. My ultimate ambition is to solve this set of equations that include a diapycnal term `S_int`:. <img width=""998"" alt=""Screen Shot 2022-05-03 at 10 17 48 am"" src=""https://user-images.githubusercontent.com/29700296/166345823-4ed83b3f-d160-4fea-93d4-2d29100452a8.png"">. where `Q_net` is a prescribed heat forcing at the surface. So, from what I understand and from what I discussed with @navidcy, if we have a multi-layer shallow water model like eqs. 56 above then I can implement the set of eqs with the diapycnal terms added forcing to each individual fluid layers. Does this sound right?. Is enhancing the `ShallowWaterModel` to have multiple layers feasible?. cc @francispoulin, @glwagner, @navidcy, @AndyHoggANU, @rmholmes",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507:860,layers,layers,860,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507,2,['layers'],['layers']
Modifiability,"Hmm yes, perhaps the output writers need to be re-initialized when picking up as well? That would require extending what we do when we pick up here:. https://github.com/CliMA/Oceananigans.jl/blob/3bb62a647a55a7dadf5f37331321bf0020a78c4d/src/Simulations/run.jl#L87-L90",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1997565752:106,extend,extending,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3485#issuecomment-1997565752,1,['extend'],['extending']
Modifiability,"Hmm, I think perhaps the mean buoyancy actually has to include an additional component that evolves (in addition to the static background component) which is independent of $x$ (upslope coordinate) but maybe varies in $z$ (slope-normal coordinate), right?. It sounds like what that example needs is to include a derivation of the equations we want to solve + boundary conditions, and then to impose intended boundary conditions (whatever those need to be) consistent with the boundary conditions that we'd like to impose on the total (non-decomposed) problem?. Edit: I noticed that you suggested modifying the boundary conditions in the tilted bottom boundary layer problem. My only suggestion is to also include a write up of the equations and a reference to the docs equations, that will make it clear the precise connection between the ""original"" equations and the perturbation equations that have to be solved by Oceananigans to achieve the desired goal.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083765467:92,evolve,evolves,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083765467,2,['evolve'],['evolves']
Modifiability,"Hmm, I think then `cell_advection_timescale` and `cell_diffusion_timescale` need to be extended for `ShallowWaterModel`, after which the `TimeStepWizard` will probably work. Perhaps change the name of this issue to ""Adapt cell_advection_timescale for ShallowWaterModel""?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599:87,extend,extended,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761148599,2,"['Adapt', 'extend']","['Adapt', 'extended']"
Modifiability,"Hmm, we need to take care because apparently only openmpi allows us to check this:. ```; help?> MPI.has_cuda; MPI.has_cuda(). Check if the MPI implementation is known to have CUDA support. Currently only Open MPI provides a mechanism to check, so it will return false with other implementations (unless overridden). For ""IBMSpectrumMPI"" it will; return true. This can be overridden by setting the JULIA_MPI_HAS_CUDA environment variable to true or false. │ Note; │; │ For OpenMPI or OpenMPI-based implementations you first need to call Init(). See also MPI.has_rocm for ROCm support.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3883#issuecomment-2445566465:428,variab,variable,428,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3883#issuecomment-2445566465,1,['variab'],['variable']
Modifiability,"Hmm... maybe something like. ```julia; s = 10 # stretching factor; h(k) = (1 - exp(s * (1 - k) / N)) / (1 - exp(-s)) # normalized, stretched height (goes from 0 at z=-Lz to 1 at z=0).; z_faces(k) = Lz * (h(k) - 1) # offsets normalized height and scales by Lz; ```. I get. ![image](https://user-images.githubusercontent.com/15271942/123190408-b7c2aa80-d45c-11eb-9eed-3c9aa1ed7c67.png). The stretched height function could be further parameterized by an exponent but it may not be necessary if changing `s` is sufficient for generating different grids.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867271377:432,parameteriz,parameterized,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867271377,1,['parameteriz'],['parameterized']
Modifiability,"Hmm... we don't support `Flat` z right now with `ExplicitFreeSurface` because we require two grid points in the vertical velocity (one grid point at the ""bottom"", one at the ""top"" coincident with the location of the free surface). I'm not sure about `ImplicitFreeSurface`. Can you check?. We might be able to refactor the algorithm to generally support hydrostatic free surface simulations with `Flat` z. Maybe we just need to generalize the free surface tendency for `ExplicitFreeSurface`?. On a regular `RectilinearGrid`, `NonhydrostaticModel` with `Flat` z is hydrostatic and has equivalent physics (because the free surface physics are linearized in `HydrostaticFreeSurfaceModel`). Before generalizing anything we could add an error message to the `HydrostaticFreeSurfaceModel` constructor to point this out (and maybe link to this issue). `ShallowWaterModel` has a nonlinear free surface and thus finite ""Mach number"" (ratio between gravity wave speed and flow speed). So I agree with @francispoulin ; that `ShallowWaterModel` is more general and might be a nice choice for some applications. I think it still lacks a diffusive flux implementation though?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537:309,refactor,refactor,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2198#issuecomment-1023327537,1,['refactor'],['refactor']
Modifiability,"Hmm... with a vanilla closure, the change is completely encapsulated in the addition of two layers of abstraction (we are just calling a simple diffusion operator). So, let's figure out how to make the abstractions fast. I think the slow down for vanilla closures should be `nil`. The 'abstraction slowdown' causes much larger problems with the complicated closures, so we need to solve that problem anyways. Edit: I see your post, so what I said above holds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496476529:92,layers,layers,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496476529,1,['layers'],['layers']
Modifiability,"Hmmm - I am skeptical about that from a computer point of view? In an implicit algorithm and/or radiative transfer alg the next step often depends on the result of the previous steps. . As every CCE graduate student learns, computers take many tens of cycles to evaluate an operation like a an add or multiply. The operation is sequential and carried out in a multi-stage pipeline in the heart of a CPU (or GPU). So unless the compiler has something else for the processor to do, the processor will have to wait for one step to make it through the pipeline before the next step? . I think the normal way to do this is to have some inner horiz blocking that is flexible (and can be 1,1) and then iterate over levels with some intermediate stores? The horiz block can be some fraction of inner cache or GPU local proc shared mem. The math doesn't quite look at this way because it assumes that a+b and/or a*b etc.. happen ""instantaneously"". It does not take into account that the awnser from a*b might take; 5-10 clock cycles to pass through the CPU floating point unit. . I think that is fairly generally true? Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different ; target arch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073:660,flexible,flexible,660,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073,1,['flexible'],['flexible']
Modifiability,Hmmm I thought this line would be enough. https://github.com/CliMA/Oceananigans.jl/blob/723ff2d69bb486a856c9748f84e56aef5e524c9e/docs/make.jl#L150. but you're right we used to use the `TRAVIS_REPO_SLUG` environment variable for this I think. Looks like the GitHub Actions equivalent is `GITHUB_REPOSITORY` like you linked to. But there doesn't seem to be one for Buildkite... https://github.com/JuliaDocs/Documenter.jl/blob/fa459cf315425d4fc5bdfbd6769f3b0e78f4a795/src/deployconfig.jl#L644-L666,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782346460:215,variab,variable,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1383#issuecomment-782346460,1,['variab'],['variable']
Modifiability,"Hmmm, do we know why we can't adapt the full `Field` to work inside GPU kernels? I think you said you've tried it but ran into some issues a while back?. The definition is; ```julia; struct Field{X, Y, Z, A, G, B} <: AbstractField{X, Y, Z, A, G}; data :: A; grid :: G; boundary_conditions :: B; ```; where the `grid` has been adapted, `data` is usually an offset array which has also been adapted, and I thought individual boundary conditions have been adapted as well so feels like it should be easy to adapt the full `Field`. Note: `boundary_conditions` is a named tuple of `FieldBoundaryConditions` so maybe we just need to adapt `FieldBoundaryConditions`, `CoordinateBoundaryConditions`? Hmmm but they're really named tuples so maybe they're already adapted. If we can't adapt `Field` then yeah the adapt rules you've suggested sound pretty good and would simplify the time stepping a lot. The kernels already deal with data tuples so not much would even have to change I think. If we can adapt `Field` though, then we should get all the benefits of simpler time stepping code without the confusion of a non-vanilla adapt rule. X-Ref: https://github.com/climate-machine/Oceananigans.jl/issues/298",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-605973535:30,adapt,adapt,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722#issuecomment-605973535,11,['adapt'],"['adapt', 'adapted']"
Modifiability,"Hmmm, should we be using [`CUDA.has_cuda_gpu`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda_gpu) instead of [`CUDA.has_cuda`](https://cuda.juliagpu.org/dev/api/essentials/#CUDA.has_cuda)?. Since Tartarus actually has GPUs (we just hide them via an environment variable in CI, e.g. https://github.com/CliMA/Oceananigans.jl/blob/main/.buildkite/pipeline.yml#L77) I can see `CUDA.has_cuda_gpu` returning false (which we want) while `CUDA.has_cuda` would return true (not what we want). This might fix the unit tests (`test_field.jl`) but there are other failures that might not be related to this. Confusingly I see no recent changes in CUDA.jl that would lead to a difference in behavior for `has_cuda` (see changes for `src/initialization.jl`) but there were a lot of changes between v3.3.6 and v3.5.0 that I wouldn't understand: https://github.com/JuliaGPU/CUDA.jl/compare/v3.3.6...v3.5.0",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682:275,variab,variable,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2005#issuecomment-942845682,1,['variab'],['variable']
Modifiability,"How about this @dhruvbhagtani?. ```Julia; julia> struct SingleLayer end. julia> struct MultiLayer end. julia> struct ShallowWaterModel{N, T}; number_of_layers :: Int; parameter :: T; ; function ShallowWaterModel(number_of_layers, parameter); if number_of_layers == 1; return new{SingleLayer, typeof(parameter)}(number_of_layers, parameter); else number_of_layers > 1; return new{MultiLayer, typeof(parameter)}(number_of_layers, parameter); end; end; end. julia> const SingleLayerShallowWaterModel{T} = ShallowWaterModel{SingleLayer, T}; SingleLayerShallowWaterModel (alias for ShallowWaterModel{SingleLayer}). julia> model1 = ShallowWaterModel(1, 2.0); SingleLayerShallowWaterModel{Float64}(1, 2.0). julia> model2 = ShallowWaterModel(2, 2.3); ShallowWaterModel{MultiLayer, Float64}(2, 2.3). julia> typeof(model1) <: ShallowWaterModel; true. julia> typeof(model1) <: SingleLayerShallowWaterModel; true. julia> typeof(model2) <: ShallowWaterModel; true. julia> typeof(model2) <: SingleLayerShallowWaterModel; false. julia> do_something(::SingleLayerShallowWaterModel) = ""I'll do something for single layer""; do_something (generic function with 1 method). julia> do_something(x) = ""I'll do something for multiple layers""; do_something (generic function with 2 methods). julia> do_something(model1); ""I'll do something for single layer"". julia> do_something(model2); ""I'll do something for multiple layers""; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1482001178:1210,layers,layers,1210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1482001178,2,['layers'],['layers']
Modifiability,How does this PR change `adapt`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2288911080:25,adapt,adapt,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2288911080,1,['adapt'],['adapt']
Modifiability,"Hydrostatic pressure is _supposed to be_ calculated by integrating downwards using a stencil in which pressure is located at `(Center, Center, Center)`. This requires interpolating buoyancy to `(Center, Center, Face)`. However, in the kernel of the integral, the buoyancy is multiplied by `Δzᵃᵃᶜ(i, j, k+1, grid)`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Models/IncompressibleModels/update_hydrostatic_pressure.jl#L15. This isn't the correct kernel if the integral corresponds to a discretization of the hydrostatic pressure term in the vertical momentum equation (omitting `i, j` for brevity) using a pressure field `p` located at (`Center, Center, Center`):. ```julia; (p[k] - p[k-1]) / Δzᵃᵃᶠ[k] = ℑzᵃᵃᶠ(k, b); ```. In other words, differencing a field at vertical `Center` requires dividing by `Δzᵃᵃᶠ`:. https://github.com/CliMA/Oceananigans.jl/blob/ade8ff03da722d1dd904022fc60997093d9e2e0f/src/Operators/derivative_operators.jl#L12. Another way to view the error is that we are multiplying a field located at `Center, Center, Face` by a grid metric located at `Center, Center, Center`. Possibly this error crept into the code due to a confusion about the superscript notation (there have been a few others of this nature). I'm not sure if it's easily caught; it probably depends on the importance of a horizontally-variable hydrostatic pressure.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1693:1371,variab,variable,1371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1693,1,['variab'],['variable']
Modifiability,"Hyperviscosity _is_ an LES closure. It's not just a great one because it requires tuning (ie you have to select the hyperviscosity, and the hyperviscosity doesn't change). You can use a scaling argument to find the hyperviscosity:. $$ \nu_4 = \Delta^4 / \tau $$. where $\Delta$ is a length scale (typically the grid spacing) and $\tau$ is the time-scale over which you'd like to damp grid scale motions. The longer the better. Perhaps you can estimate a time-scale in terms of the buoyancy frequency (eg to damp grid scale buoyancy oscillations) --- like $\tau = C / N$ where $N$ is the buoyancy frequency and $C$ is a constant (perhaps not O(1)). $C = 10$ could be a good starting point. If you need more dissipation then decrease $C$, if you need less increase $C$. Its not ""less correct"" than an LES closure. (Both are closures, not exact.) As for all LES or macroscale computational science in general the goal is to find solutions with statistics of interest that are indepednent of resolution. Note that upwinding can be thought of as adding hyperdissipation which scales with the velocity (similar to traditional LES closures in fact). WENO is adaptive-order hyperdissipation, from biharmonic on up. Personally I suspect that WENO produces more physical solutions than ""traditional"" LES closures.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1518010193:1151,adapt,adaptive-order,1151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3036#issuecomment-1518010193,1,['adapt'],['adaptive-order']
Modifiability,"I added some more but they definitely don't cover _all_ cases. Either I forgot or I am missing the point of `x/y/z/λ/φspacing` methods (the ones that give you a particular spacing). Like where would those be useful?. Btw, a periodic grid with faces at [0, 1, 11, 101] implying centers at [0.5, 6, 56] has the following spacings. It took me a while to confirm that the first spacing for Faces is actually correct. ```julia; julia> grid = RectilinearGrid(size=3, topology=(Periodic, Flat, Flat), x=[0, 1, 11, 101]); F = vcat(F₋, interiorF, F₊) = [-101.0, -100.0, -90.0, 0.0, 1.0, 11.0, 101.0, 102.0, 112.0, 202.0]; C = [(F[i + 1] + F[i]) / 2 for i = 1:TC] = [-100.5, -95.0, -45.0, 0.5, 6.0, 56.0, 101.5, 107.0, 157.0]; 3×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 3×0×0 halo; ├── Periodic x ∈ [0.0, 101.0) variably spaced with min(Δx)=1.0, max(Δx)=90.0; ├── Flat y; └── Flat z. julia> xspacings(grid, Center()); 3-element view(OffsetArray(::Vector{Float64}, -2:5), 1:3) with eltype Float64:; 1.0; 10.0; 90.0. julia> xspacings(grid, Face()); 3-element view(OffsetArray(::Vector{Float64}, -3:6), 1:3) with eltype Float64:; 45.5; 5.5; 50.0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3054#issuecomment-1605785678:824,variab,variably,824,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3054#issuecomment-1605785678,1,['variab'],['variably']
Modifiability,"I agree that it always returns a `Float32`. However, `@cuprintln` was clearly showing depths that were `Float64` inside the GPU kernels. Outside any kernel, I was not able to call `znode` and get back a `Float64`. . So I think your right that it might just be a GPU issue and maybe we just need to adapt `StepRangeLen` for the GPU to use `Float32`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445709565:298,adapt,adapt,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445709565,2,['adapt'],['adapt']
Modifiability,"I agree the current state of affairs puts a lot of responsibility on the user to ensure they pass `Float32` to every constructor that requires it, which is not very _friendly_ especially to new users who aren't familiar with the code. I also agree that having a way to specify the default number type in Julia is better than using an environment variable. Besides the limitation of strings, I feel like it would stray from Oceananigans.jl's script-based interface. If you share a script with someone now, you also need to inform them to run with specific environment variables. With enough environment variables you'll want a `.env` file. Agree with @Yixiao-Zhang that with `Oceananigans.set_default_number_type(FT)` we can do some checks and throw appropriate warnings compared with `Oceananigans.settings[:default_number_type] = Float32` (assuming it's a vanilla dictionary). > Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). Glad you brought this up! Definitely a use case for an expert/power user but I can think of a few use cases (e.g. nested simulations) that would be good to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817:346,variab,variable,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800#issuecomment-2396992817,3,['variab'],"['variable', 'variables']"
Modifiability,"I agree we can make the functions a little more verbose in that sense. ; We can change `calc_ κᶜᶜᶜ` to `calc_nonlinear_ κᶜᶜᶜ` and `calc_νᶜᶜᶜ` to `calc_nonlinear_νᶜᶜᶜ`. ; (`κᶜᶜᶜ` does not exist because diffusivity is needed at faces). For the variables we can make them verbose or agree to have a _concise_ naming convention (parallel to the verbose one) that is always consistent (i.e., `U` is `velocities`, `C` is `tracers`, `b` is `bouyancy` and so on)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1257255335:242,variab,variables,242,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1257255335,1,['variab'],['variables']
Modifiability,"I agree with @ali-ramadhan, keeping a `overwrite_existing` seems quite important to me too, potentially with a default value of `overwrite_existing = false`. . Another issue to add into this discussion is the fact of how to handle output (e.g. `file.nc`) with checkpoints and `file_splitting`. Currently, when a simulation is pickup from a checkpoint having the flag `overwrite_existing = true` rewrites to empty all the pre-existing files (i.e. file_part1.nc, file_partN.nc). With `overwrite_existing = false`, the simulation crashes because it doesn't find the file `file.nc`. I think it will be useful to handle automatic concatenation to splitted files, to allow a more flexible output particularly in the context of HPC computing with manageable file sizes, chunks, and wall times.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391714179:395,rewrite,rewrites,395,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2391714179,2,"['flexible', 'rewrite']","['flexible', 'rewrites']"
Modifiability,"I agree, let's just disable this test for now so we can merge outstanding PRs and rewrite the test",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430155087:82,rewrite,rewrite,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430155087,1,['rewrite'],['rewrite']
Modifiability,"I also find `with_halos` a bit messy, but in this case it might be neccessary to output grid metrics to disk if JLD2 or NetCDF are configured to output the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450863860:131,config,configured,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2450863860,1,['config'],['configured']
Modifiability,"I am just not extremely sure about the name `backend_kwargs`: at first glance, I thought it would be the keyword arguments of the `backend`, but it is just related to the reader of the underlying data (which for the moment, is only JLD2) and is not necessarily related to the backend (for the moment). ; I guess `jld2_kw` like in the `JLD2OutputWriter` does not work if we want to extend this to NETCDF. would something like `reader_kwargs` or `IO_kwargs` work you think?; Otherwise, if `backend_kwargs` is ok for the majority I can accept this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441804321:381,extend,extend,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2441804321,1,['extend'],['extend']
Modifiability,"I am thinking about it actually, for the moment I am dealing with bug fixing and improving stability and accuracy (which should be basically finished), when I have everything tested and verified I ll proceed with the refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1155362210:217,refactor,refactor,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1155362210,1,['refactor'],['refactor']
Modifiability,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655:1161,variab,variable,1161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655,1,['variab'],['variable']
Modifiability,"I am using Oceananigans v0.54.0 with Julia v1.6 on GPU. I tried setting an initial condition in salinity as follows:. ```; Stop = 29.5; Sbot = 32; ztop = -35; zbot = -70; dSdz = (Sbot-Stop)/ztop; S_func(x, y, z) = Stop + dSdz*(z > ztop)*z ; set!(model, S=S_func); ```. and got the error copied below. Note that this works fine in Julia v1.5.4. . ```; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/3q18R/deps/deps.jl:15; ERROR: LoadError: MethodError: no method matching set!(::Field{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, CuArray{Float64, 2}}}}}}, ::typeof(S_func)); Closest candidates are:; set!(::Oceananigans.Fields.AbstractField, !Matched::Number) at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:14; set!(::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G, !Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G) where {X, Y, Z, A} at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:16; set!(!Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where {X, Y, Z, A<:(OffsetArrays.OffsetArray{T, D, var""#s203""} where {T, D, var""#s203""<:Array}), G}, ::Function) at /home/guptam/.julia/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1555:489,Config,Configuration,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1555,1,['Config'],['Configuration']
Modifiability,"I am using the master branch for nutrient tracers with a 3rd DST advection scheme. I found that the halo points don't have the same values as the boundaries in a periodic domain. Below is the configuration I use and a slice of u velocity. Not sure it's a bug or you intended to do so... Also, the fancy logger disappeared after I updated to 0.36.0. ```julia; grid = RegularCartesianGrid(size=(32, 2, 32), extent=(2*32, 2*2, 2*32), halo = (2, 2, 2)). RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 66.0], y ∈ [0.0, 6.0], z ∈ [-64.0, 2.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 2, 32); halo size (Hx, Hy, Hz): (2, 2, 2); grid spacing (Δx, Δy, Δz): (2.0, 2.0, 2.0); ```; ```julia; T_bcs = TracerBoundaryConditions(Ogrid, top = BoundaryCondition(Flux, Qᵀ), ; bottom = BoundaryCondition(Gradient, ∂T∂z)). model = IncompressibleModel(; architecture = CPU(),; grid = grid,; coriolis = FPlane(f=f),; buoyancy = SeawaterBuoyancy(equation_of_state=LinearEquationOfState(α=α, β=β)),; closure = AnisotropicMinimumDissipation(),; boundary_conditions = (T=T_bcs,); ); ```; ```julia; model.velocities.u.data.parent[:,:,3]; 36×6 Array{Float64,2}:; -0.0085938 -0.00844015 -0.0085938 -0.00844015 -0.0085938 -0.00844015; -0.010009 -0.0104645 -0.010009 -0.0104645 -0.010009 -0.0104645; -0.00859588 -0.00912747 -0.00829848 -0.00823567 -0.00859588 -0.00912747; -0.00742535 -0.00655195 -0.00594664 -0.00595502 -0.00742535 -0.00655195; -0.00536066 -0.0038463 -0.00437428 -0.00422142 -0.00536066 -0.0038463; -0.00241687 -0.00325761 -0.00216266 -0.00211736 -0.00241687 -0.00325761; 0.00258328 0.00188971 0.00159199 0.00141804 0.00258328 0.00188971; 0.00289388 0.00378436 0.00257106 0.00259916 0.00289388 0.00378436; 0.00363445 0.00407903 0.00342151 0.00360496 0.00363445 0.00407903; 0.00575018 0.00480254 0.00481157 0.00447708 0.00575018 0.00480254; 0.00667745 0.00577658 0.00495125 0.00499728 0.00667745 0.00577658; 0.00464067 0.00487611 0.00543163 0.00506227 0.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/949:192,config,configuration,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/949,1,['config'],['configuration']
Modifiability,"I am very curious to hear what people think but do think it would make sense to have a tab called Models where we state briefly the model equations. This way the user knows exactly what their getting themselves into. We have that for `IncompressibleModel` in the `Physics` section, and feel the other two models should get a bit of converge. Even though the numerical methods will evolve, the governing equations will not change. Or if they do we'll be adding more into them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798799226:381,evolve,evolve,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1460#issuecomment-798799226,1,['evolve'],['evolve']
Modifiability,"I believe Oceananigans currently has the option to have curvilinear coordinates in the horizontal and a regular grid in the vertical. This has been used to solve the `HydrostaticFreeSurfaceModel` in spherical coordinates. Using what is currently available, it seems like one could adapt this to create a `HydrostaticFreeSurfaceModel` and maybe `IncompressibleModel` that allows for topography that varies in one-dimension. We could use a curvlinear grid in the `x-z` plane that is build on terrain following coordinates over smooth topography and then use a regular grid for the `y` direction. . I think this model would be interesting in it's own right but if nothing else it could be used for comparison with immersed boundary methods that include topography, which I presume is an idea people have? Immersed boundary could be more powerful in that it would allow for two-dimensional topography. **Questions**: . - If I define a `terrain-following` grid then what new code will need to adapted to do the above? ; - Would this be as easy to do for the nonhydrostatic model as for the hydrostatic one?; - If we define a `boundary-following` shallow water model to deal with smooth coastlines, could we modify the `ShallowWaterModel` to evolve in this geometry? This is actually purely horizontal so maybe it would be easier?. I have not done anything towards these goals and simply testing the waters (pun intended) as to how easy/difficult and interesting, and people think of this. @glwagner ?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1549:281,adapt,adapt,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1549,3,"['adapt', 'evolve']","['adapt', 'adapted', 'evolve']"
Modifiability,"I believe currently the pressure solved cannot work on GPU when grid has `topology = (Bounded, Bounded, Bounded)`. An enhancement so such topologies can run on GPUs would be great.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1007:118,enhance,enhancement,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1007,1,['enhance'],['enhancement']
Modifiability,"I can answer my own question:. Needs to put `const` before all parameters, as described in the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters). ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units; using Adapt. const Ny = 4000 # number of points in y; const Nz = 50 # number of points in z; const H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. const width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). const h = 50meters # mld; const Hv = 150meters # virtual h (stratification) ; const S = 2.8 # m/s; const c=2750kilometers # center of the storm; const l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008:192,variab,variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068625008,3,"['Adapt', 'layers', 'variab']","['Adapt', 'layers', 'variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters']"
Modifiability,"I can help with a few things:. 1. Moving the existing implementation of `set!` to `Models/IncompressibleModels`.; 2. Writing a new version of `set!` that works with `ShallowWaterModel`.; 3. Implementing a few simple tests that ensure `ShallowWaterModel` can be instantiated. @francispoulin let me know if you'd like to me to work on those three things. For 2. I need some clarification: `IncompressibleModel` has a tuple of fields called `model.velocities`, which always has fields `velocities.u, velocities.v, velocities.w`. For `ShallowWaterModel` I believe the three essential prognostic variables are `uh`, `vh`, and `h`. Then there can be additional tracers in `sw_model.tracers`. How do you want to organize the essential prognostic variables? I think you can come up with any name you want, or you can split them into multiple places...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729925232:591,variab,variables,591,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188#issuecomment-729925232,2,['variab'],['variables']
Modifiability,"I can use CUDA on sverdrup:. ```julia; julia> using CUDA. julia> CUDA.has_cuda(); true. julia> CuArray(rand(3)); 3-element CuArray{Float64, 1}:; 0.5230283963088462; 0.0396121811777137; 0.04373785020067866; ```. this is with CUDA v3.3.1:. ```julia; (v1.6) pkg> st; Status `/net/ocean/home/data44/data5/glwagner/.julia/environments/v1.6/Project.toml`; [052768ef] CUDA v3.3.1; ```. so this suggests that indeed the problem is with the buildkite setup. > Why is JULIA_CUDA_USE_BINARYBUILDER=""true"" needed?. This was needed briefly when an nvidia driver went out of date. It is no longer out of date, however, so this environment variable is not needed anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-872215666:625,variab,variable,625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-872215666,1,['variab'],['variable']
Modifiability,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3472:185,adapt,adapted,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472,7,['adapt'],"['adapt', 'adapted']"
Modifiability,"I can't run the MPI. I need to be directed to some instructions to setup my MPI. @simone-silvestri pointed at the [MPI docs](https://juliaparallel.org/MPI.jl/stable/configuration/#Configuration). Do I need MPIPreferences? I don't know... @glwagner did you have to use that? If not, why must I... we are using the same machine...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282501425:165,config,configuration,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2282501425,2,"['Config', 'config']","['Configuration', 'configuration']"
Modifiability,I changed the title if you want to focus on variable time-step but I think you should open another discussion or issue for the other stuff about the size of chi,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313366216:44,variab,variable,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313366216,1,['variab'],['variable']
Modifiability,"I continued refactoring and fixing tests now that `*spacings` use `KernelFunctionOperation`s to return `Field`s. All grid tests should pass now. And `*spacings` works on immersed grids fulfilling the original intent of this PR. Do we want an `include_halos` option or should the spacings be computed in the halos by default? I'm actually not sure how to make `KernelFunctionOperation` compute things in the halos. Will look into it. I'm also bumping v0.94.0 since this is a breaking change to the public interface. If people are happy with these changes, I can work on adding some more tests and docstrings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221:12,refactor,refactoring,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3143#issuecomment-2459913221,1,['refactor'],['refactoring']
Modifiability,"I decoupled the high-order reconstructions from the low-order interpolations. ; The reconstruction for advective fluxes are in `Advection/reconstruction_coefficients.jl`. You can probably extend all the instances of `symmetric_interpolate`, `left_biased_interpolate` and `right_biased_interpolate` in `flat_advective_fluxes`. Or maybe put a fallback for Flat grids in `topologically_conditional_interpolation.jl`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1263713946:188,extend,extend,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1263713946,1,['extend'],['extend']
Modifiability,"I didn't have a use-case in mind when suggesting this. It'll be rare for oceanography that two horizontal directions need to have different eddy diffusivities (though I'm sure that would be reasonable in some cases (balanced jet?)), but I think it's worth to implement that capability if we're trying to make Oceananigans a flexible, general-purpose-ish CFD package. Plus, given that parallelization capabilities are limited to only some directions, I can envision cases where users will rotate their domain in a way where the ""horizontal"" directions are actually `y`, `z`, and then `HorizontalDirections` won't work as intended. In any case, I personally will probably never use this feature, and it was only a suggestions for possible future uses. So feel free to ignore it if you think it's not worth it :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047165720:324,flexible,flexible,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2262#issuecomment-1047165720,1,['flexible'],['flexible']
Modifiability,"I didn't have the same problem! I think that means the issue could arise from some downstream package in your Manifest.toml in your global 1.5 environment (which is not present in mine, for some reason). What is the output of. ```julia; julia> pkg""st --manifest""; ```. ?. Mine is. ```julia; julia> pkg""st --manifest""; Status `~/.julia/environments/v1.5/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v2.4.0; [4fba245c] ArrayInterface v2.14.17; [56f22d72] Artifacts v1.3.0; [ab4f0b2a] BFloat16s v0.1.0; [6e4b80f9] BenchmarkTools v0.7.0; [6e34b625] Bzip2_jll v1.0.6+5; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v2.3.0; [83423d85] Cairo_jll v1.16.0+6; [7057c7e9] Cassette v0.3.4; [d360d2e6] ChainRulesCore v0.9.29; [944b1d66] CodecZlib v0.7.0; [35d6a980] ColorSchemes v3.10.2; [3da002f7] ColorTypes v0.10.9; [5ae59095] Colors v0.12.6; [34da2185] Compat v3.25.0; [e66e0078] CompilerSupportLibraries_jll v0.3.4+0; [d38c429a] Contour v0.5.7; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.3; [5ae413db] EarCut_jll v2.1.5+1; [b305315f] Elliptic v1.0.1; [2e619515] Expat_jll v2.2.7+6; [e2ba6199] ExprTools v0.1.3; [c87230d0] FFMPEG v0.4.0; [b22a6f82] FFMPEG_jll v4.3.1+4; [7a1cc6ca] FFTW v1.3.2; [f5851436] FFTW_jll v3.3.9+7; [53c48c17] FixedPointNumbers v0.8.4; [a3f928ae] Fontconfig_jll v2.13.1+14; [59287772] Formatting v0.4.2; [d7e528f0] FreeType2_jll v2.10.1+5; [559328eb] FriBidi_jll v1.0.5+6; [0656b61e] GLFW_jll v3.3.2+1; [0c68f7d7] GPUArrays v6.2.0; [61eb1bfa] GPUCompiler v0.8.3; [28b8d3ca] GR v0.53.0; [d2c73de3] GR_jll v0.53.0+0; [5c1252a2] GeometryBasics v0.3.9; [78b55507] Gettext_jll v0.20.1+7; [7746bdde] Glib_jll v2.59.0+4; [c27321d9] Glob v1.3.0; [42e2da0e] Grisu v1.0.0; [0234f1f7] HDF5_jll v1.12.0+1; [cd3eb016] HTTP v0.8.19; [83e8ac13] IniFile v0.5.0; [1d5cc7b8] Intel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189:412,Adapt,Adapt,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824043189,1,['Adapt'],['Adapt']
Modifiability,"I don't think so, we can refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2623#issuecomment-1480040680:25,refactor,refactor,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2623#issuecomment-1480040680,1,['refactor'],['refactor']
Modifiability,"I don't think there's a chicken and egg problem. Testing new features requires some initiative and also experience with / understanding of the relevant science applications. I think the ""egg"" is the validation test itself. A groomed, pedagogical docs example is the ""chicken"" that emerges from that egg. I also think that validation is not just about ensuring quantative accuracy, but about working out the user interface. We want the docs implementations to reflect relatively mature user interfaces, since the docs examples are relatively influential pieces of code. I believe immersed boundaries are still experimental, not least in light of #3142. What are the quantitative validation tests that use immersed boundaries? The only one that I know if is the one I worked on, which shows that a stratified ocean remains at rest:. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/immersed_boundaries/resting_stratified_bumpy_ocean.jl. We haven't documented those results well, though. The internal tide case could be adapted to validate immersed boundaries with the hydrostatic model, leveraging the vast literature on that subject. I don't think the example involves a comparison with theory or other published numerical results though. It wouldn't be that much work to turn that case into a validation test. As for `NonhydrostaticModel`, by all accounts it seems that it should be experimental until we have a validated pressure solver. It could be interesting to see if we can validate the nonhydrostatic model for certain LES cases, somehow. Otherwise, we do know that pressure solver is in general incorrect (either impenetrability across immersed boundaries is not satisfied, or the velocity field is divergent close to the immersed boundary).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874:1030,adapt,adapted,1030,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3148#issuecomment-1601130874,1,['adapt'],['adapted']
Modifiability,I don't think we use PencilArray for CuArray either in the source code or tests. My question is: does bumping PencilArrays and PencilFFTs mean that we can extend the distributed FFT algorithm (currently only implemented on CPU) to GPUs?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3121#issuecomment-1613498127:155,extend,extend,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3121#issuecomment-1613498127,1,['extend'],['extend']
Modifiability,"I don't think you can pass a field_dependency as symbols `(:v, :w)` because symbols cannot be passed into GPU kernels.; I'll check the proper syntax for `field_dependencies`. Correction: you should be able to because `field_dependencies` should not pass to the GPU when adapted, but now it is being passed internally somewhere...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2563#issuecomment-1130308748:270,adapt,adapted,270,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2563#issuecomment-1130308748,1,['adapt'],['adapted']
Modifiability,"I draft a repo on this matter [here](https://github.com/iuryt/Bioceananigans.jl).; I tried to summarize my ideas in the README:. > Most of the interelationships between biogeochemical tracers could be implemented using the **forcing functions** (see [Convecting Plankton](https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/) example from Oceananigans documentation), but commonly the light or light-limiting growth of the phytoplankton are **averaged over the mixed layer** in order to parameterized the effects of the mixing in the upper boundary layer. In other words, the mixing timescale is usually longer than photosynthesis, but shorter than cell-division time, which makes phytoplankton **see the average light or grow at the average light-limiting growth rate** while on the mixed layer. Other example of processes that are not easily implemented on Oceananigans include the **shading of phytoplankton** to deeper layers and the **sinking velocity**. The latter is currently being implemented on Oceananigans by this [Pull Request](https://github.com/CliMA/Oceananigans.jl/pull/2389) with a new forcing called `AdvectiveForcing`.; > ; > For now, this repository basically gives a set of modules that can be used to estimate the mixed-layer depth, estimate the phytoplankton shading and calculate the light-limiting growth, which is defined by the user as a function, and then the light (or the light-limiting growth) can be averaged over the mixed layer. So basically the repository can simply give all auxiliary functions that are needed for the biogeochemical models, but not the interelationship functions, which can be defined as forcing functions and added to a list of examples on the documentation. I don't mind giving up this repository and merging or adding it to the organization if this is somehow a good starting point.; I am also interested in seeing what the others think about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781:522,parameteriz,parameterized,522,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512#issuecomment-1116856781,4,"['layers', 'parameteriz']","['layers', 'parameterized']"
Modifiability,"I feel that labeling it ""weird"" is a harsh judgement. But I would say that using the word ""oceanic"" to describe software is ""quirky"". If folks prefer ""ocean-flavored"" (also quirky, just more characters), let's switch to that. Being ""flexible"" is probably one of our core philosophies as well so I agree with adding that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945819977:233,flexible,flexible,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-945819977,1,['flexible'],['flexible']
Modifiability,"I finished the first draft (of the topics I know about at least). I haven't written the very last subsection though, which is about viewing/using arrays in GPU runs because honestly I don't know enough to write about it. I know there's a function called `view()` that helps with slicing, and you can also use `adapt` to view CUDA Arrays in REPL for investigating, but I feel like I don't know enough of this aspect of the code to write this. There are two options here:. - Someone helps me out and writes that last section; - Or I can merge the PR without it for now (there are many other important things there for the user) and we worry about that last part in a future PR. Thoughts?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-814533032:310,adapt,adapt,310,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-814533032,1,['adapt'],['adapt']
Modifiability,I guess from a refactoring point of view it might also make sense to wait until we're closer to Oceananigans v1.0 before splitting off into multiple smaller packages. If we have to refactor code that involves deep changes (still likely) right now it might be easier to refactor 1 package rather than refactor across multiple packages + tag releases etc.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079:15,refactor,refactoring,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553#issuecomment-815049079,4,['refactor'],"['refactor', 'refactoring']"
Modifiability,I guess we could call it `grid_metric` instead of `area` and the iterator can be called `met` or `m` or `grid_term` instead... Probably also the comment above should be changed to something in the line of `operators of the form M * q where M is a grid metric and q is some variable`,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2285#issuecomment-1055034558:273,variab,variable,273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2285#issuecomment-1055034558,1,['variab'],['variable']
Modifiability,"I have a practical example that might demand a better interface for `calculate_diffusivities!` (or at least defining it for `ScalarDiffusivities`). I am now using quite complex formulations to calculate the viscosity for `ScalarBiharmonicDiffusivity`. Because of the staggering of the variables, the viscosity can only be calculated at `Center`s; I am using now `DiscreteDiffusionFunction`, which interpolates my formulation to the desired location in space.; This is very inefficient because I am recomputing the expensive viscosity multiple times in the same place.; It would be nice to have an option to have a precomputed diffusivity also in case of a `ScalarDiffusivity`, but provide the function to calculate the diffusivity as it is now done for `DiscreteDiffusionFunction`.; This would allow the code to be way more personalizable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342:285,variab,variables,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751#issuecomment-1260817342,1,['variab'],['variables']
Modifiability,"I have a start to this soon to be PR (I hope) but nothing working yet. . One issue that comes up is that `automatic_halo_sizing.jl` should not extend the halo if the topology is flat This is easy enough to set this up in principle, however, when I try telling it what `Flat` means using the following `using Oceananigans.Grids: Flat`, it fails. . How should I load `Flat` at this stage?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292:143,extend,extend,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292,1,['extend'],['extend']
Modifiability,"I have been thinking that we should expand a bit our Smagorinsky models.; Currently the only Smagorinsky-type model we have is the Smagorinsky-Lilly, which works well in some cases, notably the canonical horizontally-periodic turbulence, but has some downsides for more complex flows. For example when turbulence is not heterogeneous, or when there are persistent mean gradients in the flow. AMD is a good option in some cases, but often there are numerical artifacts in stratified, laminar regions in the flow (I don't think it's clear exactly what causes this, but it happens in many of my simulations, and I've herd similar things from others). So I think having at least one option to run a dynamic Smag would be good. One possibility is that, as a start, we allow for user-defined Smagorinsky coefficients that could depend on the velocities. Something like. ```julia; cₛ(i, j, k, grid, C::Function) = C(i, j, k, grid, u, v, w); ```; where `C(i, j, k, grid, u, v, w)` is provided by the user. That would allow the user a bit more control, and they could implement local dynamic Smag models, such as the [dynamic gradient Smagorinsky](https://journals.aps.org/prfluids/abstract/10.1103/PhysRevFluids.7.074604). Something similar is currently done for AMD, although I think it's a bit more restrictive than what I'm proposing. Soon, if there's interest, I'm planning on implementing a scale-independent Smagorinsky that's averaged in the symmetric flow directions (generally this is referred to as Planar-Averaged Scale-Independent Smag, but we wouldn't be limited to a planar average in our case). From then on, the extension to a Langrangian-Averaged Scale-Independent Smag would be straightforward. Eventually it would be nice to extend these to a Scale-_dependent_ model, but I think it's wise to start with the simpler cases. How do people feel about this?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637:1736,extend,extend,1736,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637,1,['extend'],['extend']
Modifiability,"I have created a new branch called ""ShallowWaterS1waveeqn"". S1 is for step 1. It doesn't do much right now but I'm trying to set up the skeleton so that we can actually do something intereting, like evolve the equation. At the moment I have the following:. 1. Created a ShallowWaterModels folder. 2. Created a ShallowWaterModels.jl module. It doesn't do much except include shallowwater_model.jl. 3. shallowwater_model.jl defines a mutable struct and a function. I couldn't get a lot of things to work but it does regularlize the boundary condtions, set up the velocities and a new variable called layer_depth. The name is not great and can go with depth or height, as people prefer. It will be in in the governing equations. 4. Created an example, in the same folder, called onedim_shallowwater.jl. Currently, this includes the module mentioned above, defines a grid (yes, a single point!), defines the initial conditions and sets the velocity. Questions:. 1. This is pretty bare bones so far but does this follow the philosophy of Oceananigans?. 2. I have tried to inititalze the layer_depth by adding an argument into the set! command but it failed. Below is the command that I thought would work and below is the error because layer_depth is not model.velocities or model.tracers. Can someone help me to see what silliness I am doing?. ```; set!(model, u = u, v = v, layer_deth = layer_depth); fails with ""ERROR: LoadError: ArgumentError: name layer_depth not found in model.velocities or model.tracers."". After I get the initial conditions defined I then need to specify the fluxes for the PDE. That should not be difficult but one issue is the nomenclature. The vector we have now is velocities, but we actually want, velocity transport. I should use and define hu and hv instead of u and v. That should be easy enough, I think.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1188:199,evolve,evolve,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188,2,"['evolve', 'variab']","['evolve', 'variable']"
Modifiability,"I have created a new validation script called `shallow_jet_topography.jl` that evolves the barotropically unstable jet (like in the shallow water example) but now over a shelflike topography. It can be found in `valiation/shallow_water`. . Some preliminary results are shown below. First, this is the case with a flat bottom and it does produce the same results as what we have in the example. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/3f8cc034-6764-4d3e-a7c1-510d7b55073d). Second, this is an example of prograde topography with the shallow water on the right of the propogating jet. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/d262c028-1ea3-41b8-8573-8ab4419ed891). Third, this is an example of retrograde topopgraphy with the shallow water on the right of the propogating jet. ![Geostrophic_State](https://github.com/CliMA/Oceananigans.jl/assets/8239041/064ebf34-b8bf-4cca-9000-a9edb1bdfd94). The growth rates differ but I want to update my linear stability code to compute the growth rates so that we can validate that the results are quantitatively close. But for this case here the prograde case is slightly more unstable with the rettrograde case, which is qualitatively correct.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973911400:79,evolve,evolves,79,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973911400,1,['evolve'],['evolves']
Modifiability,"I have introduced the option to iterate as well an option to use the formulation that assumes infinite iterations (`iterations = nothing`). If you want to give it a try for a simple configuration that would be nice!. example:; ```julia; grid = RectilinearGrid(size = (10, 10, 10), extent = (1, 1, 1)). advection = MPData(grid; iterations = 1) # equivalent to UpwindBiased(; order = 1); advection = MPData(grid; iterations = 3) # 3 corrective iterations; advection = MPData(grid; iterations = nothing) # ∞ iterations (a little more expensive); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1942023450:182,config,configuration,182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3434#issuecomment-1942023450,2,['config'],['configuration']
Modifiability,"I have put together an example for my own benefit (not to be merged into master unless people want it to be) that looks at the simulation of inertial instability in 2D. See [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/inertially_unstable_jet.jl) for the code. . I believe everything is working on a CPU but I am having two difficulties with GPUs. . 1. In line 39, where I define the background buoyancy of the jet, I can't use `coriolis.f` because CUDA seems to need a global variable and this doesn't cut it. I am presently using `f` instead and this works, but should this work? `ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!`; 2. When I make a simulation from a gpu calculation, I get that the buoyancy perturbation has perturbations at the top and bottom, which are not physical. Which is to say that it has different boundary conditions. I didn't actually specify the boundary conditions differently but just wanted a solid top and bottom. If I specify the boundary conditions explicitly, should this fix the problem? Maybe that's a fix but is this expected behaviour?. https://user-images.githubusercontent.com/8239041/113899192-8d851900-979a-11eb-97a7-b7f8085864b7.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554:525,variab,variable,525,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554,1,['variab'],['variable']
Modifiability,"I honesntly don't have a personal preference here. I'm just myself off of [Julia naming conventions](https://docs.julialang.org/en/v1/manual/variables/#Stylistic-Conventions) for variables and [general identified styles](https://en.wikipedia.org/wiki/Naming_convention_(programming)#Examples_of_multiple-word_identifier_formats). `ZFaces`, `z_faces` or `z_Faces` work for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814143240:141,variab,variables,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814143240,2,['variab'],['variables']
Modifiability,I just changed the Adapt.jl compat entry to make use of the new version with the `StepRangeLen` fix. The MWE from #3870 does not error with Adapt.jl v4.1.1 locally.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2447316135:19,Adapt,Adapt,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2447316135,2,['Adapt'],['Adapt']
Modifiability,"I just looked over the source code, and while I think this will be easy for the serial case, the code for distributed models is... fun... I have wanted to refactor the distributed stuff to make it understandable for a while anyways though. So I think we can come out on top.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388820708:155,refactor,refactor,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3810#issuecomment-2388820708,1,['refactor'],['refactor']
Modifiability,"I know `PartialCellBottom` is unexported and therefore experimental but just opening an issue that it doesn't currently work on GPUs with `HydrostaticFreeSurfaceModel`. I believe it's an Adapt issue. It works with `NonhydrostaticModel`. Might just be an issue with functions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBot",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:187,Adapt,Adapt,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['Adapt'],['Adapt']
Modifiability,"I left a few comments in the code. To guide the design of this feature, consider a few important use cases:. 1. Buoyant particles (eg particles that feel an ""additional"" advecting velocity, in addition to `model.velocities` and `model.background_fields.velocities`); 2. Chemical reactions taking place on particles; 3. ""Elastic"" particles that bounce of walls with a specified coefficient of restitution; 4. Particles that are nudged with random stochastic noise in addition to advection (this is a crucial feature that is necessary to approximate the effect of molecular / subfilter turbulent diffusion). I am not suggesting that we support all of these immediately or in the near future, but it'd be good to have a type-based infrastructure for particle dynamics that can be extended to include more features.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713689396:777,extend,extended,777,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-713689396,1,['extend'],['extended']
Modifiability,"I looked at both of those and they aren't very fast. That's why I coded up; my own in WaterLily. I have used CG preconditioners before with variable coefficient Poisson; equations and I agree they are a nice matrix free approach. Gabriel D Weymouth; _______________________________________________; ""Computers are useless. They can only give you answers."" Pablo Picasso. On Thu, Jun 17, 2021 at 2:54 AM Francis J. Poulin ***@***.***>; wrote:. > I have never used multigrid solvers in julia but did a quick look around; > and found there are at least a couple of libraries one can use. If someone; > decides they want to play with multigrid, I would suggest looking at these; > and other libraries as that would be very fast to get started.; >; > https://github.com/JuliaLinearAlgebra/AlgebraicMultigrid.jl; > https://github.com/JuliaInv/Multigrid.jl; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-862853210>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AADSKJ7IMJP5XPQFKUSYHGDTTFIUFANCNFSM457USDVQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-863021831:140,variab,variable,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1733#issuecomment-863021831,1,['variab'],['variable']
Modifiability,"I made one extra change which is that I don't call `N^2 / S^2` a Richardson number anymore. Since the denominator is a strain rate, not the _vertical_ shear, I think it's odd to call it `Ri`. Also that variable (whatever you call it) only appears 3 times briefly so there's no need to give it a name. It appears that our buoyancy modification doesn't really match Pressel's or Lilly's since we use an arbitrary `C_b` while they proposed to use `1/Pr_t`. @glwagner Is there any reference for that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889288420:202,variab,variable,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1908#issuecomment-889288420,1,['variab'],['variable']
Modifiability,I need to digest this suggestion! But in the meantime: does this work for changing `dt`? For idealized / strongly-time-dependent problems we often find it useful to continuously adapt the time-step according to a CFL criteria.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461:178,adapt,adapt,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2321#issuecomment-1512063461,1,['adapt'],['adapt']
Modifiability,I noticed it was a bit convoluted. I refactored the viscosity computation to hopefully be a bit more readable and understandable.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3102:37,refactor,refactored,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3102,1,['refactor'],['refactored']
Modifiability,"I noticed that `leith_enstrophy_diffusivity.jl` does a lot of floating point comparisons with zero when computing the components of the Redi tensor, e.g.; ```julia; @inline function Redi_tensor_xz_fcc(i, j, k, grid::AbstractGrid{FT}, buoyancy, C) where FT; bx = ∂x_b(i, j, k, grid, buoyancy, C); bz = ℑxzᶠᵃᶜ(i, j, k, grid, ∂z_b, buoyancy, C); return ifelse(bx == 0 && bz == 0, zero(FT), - bx / bz); end; ```. but if `bx` and `bz` are floats then might be a bad idea to check for `== 0` as they could be very small but not trigger the true branch. Even worse as we're dividing by `bz`. Not sure if this is an issue but noticed it while refactoring for PR #529.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/535:635,refactor,refactoring,635,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/535,1,['refactor'],['refactoring']
Modifiability,"I noticed that when I pass a `NamedTuple` to a `KernelFunctionOperation`, it'll generally give me an incorrect result if one of the variables used in the calculation is in the tuple and it's an operation. Here's a MWE where I'm creating a model with a constant `u=2`, setting up a simple KFO that returns `u` from `velocities`:. ```julia; using Oceananigans; using Oceananigans.AbstractOperations: KernelFunctionOperation; using Oceananigans.Fields: @compute. grid = RectilinearGrid(size = (1, 1, 4), extent = (1,1,1));. model = NonhydrostaticModel(; grid,); u₀ = 2;; set!(model, u=u₀). @inline ufunc(i, j, k, grid, velocities) = velocities.u[i, j, k]; ```. If I just pass `model.velocities` to it, it works fine and returns `u`. If I try to pass, for example, the perturbation `u - Average(u)`, then for some reason the KFO returns `u`:. ```julia; julia> velocities = (u = (model.velocities.u - Field(Average(model.velocities.u))),);. julia> @compute f1 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f1) # This should be all zero; 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 2.0. [:, :, 2] =; 2.0. [:, :, 3] =; 2.0. [:, :, 4] =; 2.0; ```. I expected the above to either work (i.e. produce the correct result) or throw an error, but returning `u` is unexpected. If, however, I define `velocities = (u = Field(model.velocities.u - Field(Average(model.velocities.u))),)` (i.e. wrap the operation in a `Field`) then the result is correct. Curiously, if I use `u₀` as the average in the snippet above (without wrapping the operation in `Field`), it appears to work:. ```julia; julia> velocities = (u = (model.velocities.u - u₀),);. julia> @compute f2 = Field(KernelFunctionOperation{Face, Center, Center}(ufunc, model.grid, velocities));. julia> interior(f2); 1×1×4 view(::Array{Float64, 3}, 4:4, 4:4, 4:7) with eltype Float64:; [:, :, 1] =; 0.0. [:, :, 2] =; 0.0. [:, :, 3] =; 0.0. [:, :, 4] =; 0.0; ```. Als",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455:132,variab,variables,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455,1,['variab'],['variables']
Modifiability,I opened a new issue for parameterized Callbacks --- check out #2127,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001249751:25,parameteriz,parameterized,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001249751,1,['parameteriz'],['parameterized']
Modifiability,"I propose that we adopt a policy that all tests contributed to `Oceananigans` must run on both the CPU and the GPU, because currently the GPU functionality is equal or more important than the CPU functionality. To resolve this issue and implement this policy moving forward, we need to adapt existing tests so that all tests run on the GPU.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/242:286,adapt,adapt,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/242,1,['adapt'],['adapt']
Modifiability,"I put a ton of effort into making it so that we could include one file and run the tests. So if its broken or wasn't a complete solution hopefully we can fix it, or make it work more generally. It's more annoying to have to include the filename as a global variable. I don't like that workflow as much. When we can include a file, we can rapidly iterate because we don't have to wait for things to recompile.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-1997573228:257,variab,variable,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3507#issuecomment-1997573228,1,['variab'],['variable']
Modifiability,"I put some work into the description, removing ""oceanic"" in favor of ""ocean-flavored"" and adding ""flexible"". Please reopen if there's still an issue!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-960167339:98,flexible,flexible,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2017#issuecomment-960167339,1,['flexible'],['flexible']
Modifiability,"I refactored the interface significantly. Now instead of using a model property `immersed_boundary`, I've introduced a new grid ""wrapper"" called `ImmersedBoundaryGrid`. This new grid wrapper replicates the behavior of the underlying or ""primary"" grid, except where functions are overridden. This allows functions like `diffusive_flux_x` to be extended without touching model time-stepping code. The main motivation for this change is to make it easy to implement more sophisticated immersed boundary methods such as partial cells and shaved cells. In those methods, the presence of the immersed boundary is felt at a fundamental level during the calculation of grid areas and volumes. The `internal_tide.jl` validation experiment has also been refactored and now reads:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary; using Plots. grid = RegularRectilinearGrid(size=(256, 256), x=(-10, 10), z=(0, 5), topology=(Periodic, Flat, Bounded)). # Gaussian bump of width ""1""; bump(x, y, z) = z < exp(-x^2). grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). # Tidal forcing; tidal_forcing(x, y, z, t) = 1e-4 * cos(t). model = HydrostaticFreeSurfaceModel(grid = grid_with_bump,; momentum_advection = CenteredSecondOrder(),; free_surface = ExplicitFreeSurface(gravitational_acceleration=4),; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; tracers = :b, ; buoyancy = BuoyancyTracer(),; coriolis = FPlane(f=sqrt(0.5)),; forcing = (u = tidal_forcing,)). # Linear stratification; set!(model, b = (x, y, z) -> 2 * z). progress(s) = @info ""Time = $(s.model.clock.time), max|w|: $(maximum(abs, model.velocities.w))""; ; simulation = Simulation(model, Δt = 1e-3, stop_time = 10, progress = progress, iteration_interval = 10) ; ; run!(simulation). xu, yu, zu = nodes(model.velocities.u); u = interior(model.velocities.u)[:, 1, :]. umax = maximum(abs, u); ulim = umax / 2 ; ulevels = vcat(-[umax], range(-ulim, stop=ulim, length=30), [u",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305:2,refactor,refactored,2,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1654#issuecomment-841751305,3,"['extend', 'refactor']","['extended', 'refactored']"
Modifiability,"I remember there is a problematic issue with initialisation and bathymetry. You need to be extra careful to put initial condition that is consistent with the bathymetry. We should actually fix that because it was so counterintuitive. That’s what I was trying to understand back in the day and fix but I lost steam. I couldn’t set up very simple things, let alone global configuration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973413973:370,config,configuration,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973413973,2,['config'],['configuration']
Modifiability,"I run https://github.com/CliMA/Oceananigans.jl/blob/master/examples/two_dimensional_turbulence.jl with success. but when trying to adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656:131,adapt,adapt,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656,1,['adapt'],['adapt']
Modifiability,"I say we emit a warning for now and I'll add a comment to `offset_windowed_data` that it could be extended to support windowing and offsetting for data that doesn't cover the whole grid. Here's some thoughts for the future:. - We want to compute index intersections using ""grid indices"" rather than ""parent indices"". So more lines in `offset_windowed_data` are needed; - the ""parent indices"" corresponding to particular grid indices depend on the span of the data. `parent_index_range` is only valid for ""full"" indices. Probably we should extend `parent_index_range` to take in some information about the parent data rather than assuming it spans the grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325:98,extend,extended,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1127157325,2,['extend'],"['extend', 'extended']"
Modifiability,"I set up my netcdf writer as follows:. `fields = Dict(""u"" => model.velocities.u,""v"" => model.velocities.v,""w"" => model.velocities.w,""T"" => model.tracers.T)`; `my_writer = NetCDFOutputWriter(model, fields, filename=""data/turb_box_test.nc"", time_interval=60)`; `simulation.output_writers[:field_writer] = my_writer`. and got the following error:. NetCDF error: Variable 'time' not found in file <unknown> (NetCDF error code: -33)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/862:359,Variab,Variable,359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/862,1,['Variab'],['Variable']
Modifiability,"I share here a double drake experiment that makes full use of this PR ; #### Grid setup; - latitude longitude grid from 75 S to 75 N; - 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); - 150 exponentially stretched vertical levels for a 3km deep ocean; - double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); #### Top BC: ; - temperature: restoring to reference profile (cosine shape); - salinity: prescribed latitudinally dependent surface flux; - zonal velocity: prescribed latitudinally dependent wind stress; #### Bottom BC:; - velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; #### Initial conditions; - zero velocities; - exponentially stratified temperature with SST equal to the reference temperature; - constant salinity; #### Model setup; - linear equation of state; - Richardson-based diffusivity for BL mixing ; - vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; - vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); - WENO for tracer advection (no horizontal diffusivity); - Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); #### Simulation setup; - time step of 10 minutes; - ran on 2 MPI processes with CUDA-aware MPI; - performs about 10 simulated years per day. On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). https://user-images.githubusercontent.com/33547697/219039209-e99ad100-2730-4805-bf57-c3b438f64537.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185:1508,evolve,evolved,1508,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431366185,1,['evolve'],['evolved']
Modifiability,"I should have addressed all the changes except the `Field{loc...}(grid)` to `Field(loc, grid)`. I will do another PR that will refactor all the instances of `Field(loc, grid)` to `Field{loc...}(grid)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1437178605:127,refactor,refactor,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1437178605,1,['refactor'],['refactor']
Modifiability,"I started tackling this issue in ClimaAtmos last week. I wrote a module, `OutputPathGenerator`, in a separate utilities package ([documentation](https://clima.github.io/ClimaUtilities.jl/dev/outputpathgenerator/)). This module defines an object, `OutputPathGenerator` that can be extended with different `OutputPathGeneratorStyle`s. ; The `OutputPathGenerator` is used in a `generate_output_path` function that takes the base output dir and the style.; The simplest of such styles is ""overwrite"". . The style that is currently being used in Atmos is `ActiveLinkStyle`. Citing from the docs:; > This style provides a more convenient and non-destructive approach. It manages a sequence of subfolders within the base directory specified by `output_path`. It also creates a symbolic link named `output_active` that points to the current active subfolder. This allows you to easily access the latest simulation results with a predictable path. > Example:; > Let's assume your output_path is set to data.; > If data doesn't exist, the module creates it and returns data/output_active. This link points to the newly created subfolder data/output_0000.; > If data exists and contains an output_active link pointing to data/output_0005, the module creates a new subfolder data/output_0006 and updates output_active to point to it.; > If data exists with or without an output_active link, the module checks for existing subfolders named data/output_XXXX (with XXXX a number). If none are found, it creates data/output_0000 and a link data/output_active pointing to it. Atmos uses `OutputPathGenerator` internally. My vision is that end users would be providing the base path and possibly choosing a `Style` if they don't want the default behavior (which is the ActiveLinkStyle). `Styles` are Julia objects and new ones can be defined in scripts by implementing a method for the function `generate_output_path`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662:280,extend,extended,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3543#issuecomment-2041168662,2,['extend'],['extended']
Modifiability,I suggest we convert the plankton example to use a vertically stretched grid. Then we can delete the `sandbox` directory from the repo. Also in the https://clima.github.io/OceananigansDocumentation/dev/model_setup/grids/ we should point the user to this example in the discussion (that doesn't exist yet?) about vertically stretched grid.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1394:102,sandbox,sandbox,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1394,1,['sandbox'],['sandbox']
Modifiability,I think I'm happy with the finite volume operators in this PR. Happy to make changes based on feedback so we have versatile and flexible operators. In the next PR I will fully integrate them with the code and make sure they are correct and performant. It will also show if I missed any operators.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773:128,flexible,flexible,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283#issuecomment-546648773,1,['flexible'],['flexible']
Modifiability,"I think [Coordinate system and notation](https://clima.github.io/OceananigansDocumentation/stable/physics/notation/) page in the docs needs to be updated. . First, we don't only use a Cartesian grid anymore (we don't even use the word Cartesian for the `RegularRectilinearGrid` anymore). I'm not sure how you guys wanna adapt this page and notation for the spherical coordinate grid though. Second, a part of the math isn't rendering and I'm not sure why.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1779:320,adapt,adapt,320,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1779,1,['adapt'],['adapt']
Modifiability,"I think all the closures we have contain diffusivity data (constants or functions or fields) that are not in `diffusivities`. The list is here:. https://github.com/CliMA/Oceananigans.jl/tree/master/src/TurbulenceClosures/turbulence_closure_implementations. Only a subset of the code is documented, so better to look to the source when considering refactoring I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883733159:347,refactor,refactoring,347,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883733159,1,['refactor'],['refactoring']
Modifiability,"I think broadcasting for same-field operators, e.g. `CellField .+ CellField` would be really useful and make the code more readable. The simplification here is fewer loops to look at which is a big plus I think. But cross-field broadcasting is a bit trickier so might be better to leave it unimplemented especially as it's not a very common operation, I only use it when adding `f .* v` to `Gu` or `f .* u` to `Gv`. Without it you would have to explicitly write `u .+ avgx(avgy(v))` so if you forget it then it might make finding the bug a bit harder. With it, you can just write `u .+ v` with the averaging happening behind the scenes, so you might apply it by mistake without realizing it. Another potentially difficult bug to find. I feel like everyone has a different opinion on this but in my mind, I'm thinking this would make the code easier to read and write (short-term), and ultimately easier to extend by users (long-term). I just sometimes use issues leave random TODO notes and ramble.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/12#issuecomment-445494799:906,extend,extend,906,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/12#issuecomment-445494799,1,['extend'],['extend']
Modifiability,I think extending `κᶠᶜᶜ` is simpler --- less code and less memory usage.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419777537:8,extend,extending,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419777537,2,['extend'],['extending']
Modifiability,"I think for Oceananigans it may not matter much, but it seems to matter a lot for the atmosphere so maybe it would be good to match up with the atmosphere so we can share operators. Here's @thabbott's argument for making z the fast index for an atmospheric LES model (taken from https://github.com/thabbott/JULES.jl/pull/16):; > I think that there are three strong argument to be made in favor of making ``z`` the fast index for this model:; >; > 1. Radiative transfer operates in columns; > 2. Rain falls downward relative to the air it's embedded in; > 3. Vertical momentum is solved implicitly within columns on the acoustic time step; > ; > This means that these three calculations can operate completely independently over different columns and (at least for calculations using a CPU) it's more efficient to store variables in the same column close to each other in memory. I don't think we have to change the function signatures relative to Oceananigans to make ``z`` the fast index, though---we just have to change the indexing order in ``differences.jl`` and ``interpolation.jl``. I think @vchuravy said that this might change with GPUs and/or shared memory, so maybe it's not super clear whether the change is worth making. Although for CPUs it will probably help a lot.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470:819,variab,variables,819,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470,1,['variab'],['variables']
Modifiability,"I think for idealized stuff the hydrostatic model is fairly well tested, but if one wants to do complex domains, problems requiring mixing parameterizations, etc, then our capability is still a little green I think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576:139,parameteriz,parameterizations,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107528576,1,['parameteriz'],['parameterizations']
Modifiability,I think here `return` and `return nothing` would have the same effect (probably also just avoiding the whole `return` statement but that will print the variable to screen if used in the REPL). . ```; julia> function test!(a); a[1] +=1; return; end; test! (generic function with 1 method). julia> function test_two!(a); a[1] +=1; return nothing; end; test_two! (generic function with 1 method). julia> a = [1]; 1-element Vector{Int64}:; 1. julia> test!(a). julia> a; 1-element Vector{Int64}:; 2. julia> test_two!(a). julia> a; 1-element Vector{Int64}:; 3. julia> function test_three!(a); a[1] +=1; end; test_three! (generic function with 1 method). julia> test_three!(a); 4. julia> a; 1-element Vector{Int64}:; 4; ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652:152,variab,variable,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2135#issuecomment-1005242652,1,['variab'],['variable']
Modifiability,I think it must be blocked by some dependency since CompatHelper updates the Manifest. I guess merging #1295 caused some conflicts so I might try bumping to Adapt v3.0.0 in a different PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881:157,Adapt,Adapt,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756771881,1,['Adapt'],['Adapt']
Modifiability,"I think it only depends on the combination of Boundary conditions you give to the GPU. Anyways, it's a weird error, I don't seem to be able to reproduce it; ```; ssilvest@tartarus:~/stable_oceananigans/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.0 (2022-08-17); _/ |\__'_|_|_|\__'_| | Official https://julialang.org/ release; |__/ |. julia> using Oceananigans, Statistics, Printf, Oceananigans.Units; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided. julia> grid = RectilinearGrid(GPU(), size=(1024, 1024), extent=(2π, 2π),; topology=(Bounded, Bounded, Flat)); 1024×1024×1 RectilinearGrid{Float64, Bounded, Bounded, Flat} on GPU with 3×3×0 halo; ├── Bounded x ∈ [4.64839e-19, 6.28319] regularly spaced with Δx=0.00613592; ├── Bounded y ∈ [4.64839e-19, 6.28319] regularly spaced with Δy=0.00613592; └── Flat z. julia> # forcing; u_forcing(x, y, z, t) = 0.01*cos(5*y); u_forcing (generic function with 1 method). julia> v_forcing(x, y, z, t) = -0.01*cos(5*x); v_forcing (generic function with 1 method). julia> # no-slip boundary conditions; u_bcs = FieldBoundaryConditions(south = ValueBoundaryCondition(0.0),; north = ValueBoundaryCondition(0.0));. julia> v_bcs = FieldBoundaryConditions(east = ValueBoundaryCondition(0.0),; west = ValueBoundaryCondition(0.0));. julia> model = NonhydrostaticModel(timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; boundary_conditions = (u=u_bcs, v=v_bcs),; forcing = (u=u_forcing, v=v_forcing),; buoyancy = nothing,; tracers = nothing,; closure = ScalarDiffusivity(ν=1e-5)); NonhydrostaticModel{GPU, RectilinearGrid}(time = 0 seconds, iteration = 0); ├── grid: 102",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873:623,variab,variable,623,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2530#issuecomment-1261415873,4,"['Config', 'config', 'variab']","['Config', 'config', 'variable']"
Modifiability,"I think it's a clue that . ```julia; vz_op = @at((Face, Center, Center), ∂x(b) / f); ```. is valid. My guess now is that if. ```julia; vz_op = @at (Face, Center, Center) - ∂x(b) / f; ```. is interpreted as. ```julia; loc = (Face, Center, Center); op = ∂x(b) / f; invalid_subtraction = -(loc, op) # not only does this not work, it's also just one `Expr`; vz_op = @at invalid_subtraction; ```. We can try to bandaid this by extending `@at` but I guess it's really just invalid syntax. `@at((Face, Center, Center), ∂x(b) / f)` is the right way to express this --- nice find @iuryt !",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1099101478:422,extend,extending,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415#issuecomment-1099101478,1,['extend'],['extending']
Modifiability,"I think it's ok that ""rigid lid"" is implicit. In fact all the sides are rigid and there's no special direction at all. In fact, it might make sense to omit ""free surface"" from the hydrostatic model description. We could soon have a rigid lid option there, and then it wouldn't really make sense to continue calling it a ""HydrostaticFreeSurfaceModel"". There's a few things I think should go in before 1.0:. * Abstraction for vectors. It's only for simple grids that we can really get away with referring to the velocity field component wise with `u, v, w`. Building an abstraction for vectors changes the API because we'll specify boundary conditions on the whole velocity field, not just each component separately. I don't think we should do 1.0 without this.; * Resolve #1825 (specifying `architecture` when building `grid`). Another major API change, not to mention a substantial internal refactor.; * Simplify grids. We really only need one `RectilinearGrid`, one `LatitudeLongitudeGrid`, and one ""arbitrary"" (not aligned with a coordinate system, like what's used for the cubed sphere). Another API change because we don't need `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Also simplifies the code a lot. It could also make sense to build some experience with immersed boundaries in case there are change motivated by that feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882075634:891,refactor,refactor,891,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-882075634,2,['refactor'],['refactor']
Modifiability,I think it's time to have something there. At lease a docs page that writes down the equations solved and the state variables... cc @francispoulin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1460:116,variab,variables,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1460,1,['variab'],['variables']
Modifiability,"I think so, the issue #3342 applies also to multi-region, so I think in a next PR we can extend this halo splitting to multi region boundary conditions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1764795630:89,extend,extend,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3338#issuecomment-1764795630,1,['extend'],['extend']
Modifiability,I think some stuff in `broadcast_abstract_field.jl` may need to be extended:. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl. specifically. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L18. which helps us identify when we're broadcasting between arrays and fields so that we hit . https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L42. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L46. Also. https://github.com/CliMA/Oceananigans.jl/blob/e4340a7f2ef10391b46e4b71bf3f74ffbd4bd945/src/Fields/broadcasting_abstract_fields.jl#L24-L28. where we take a shortcut for things like `u .= a` where `u isa Field` and a is some kind of array.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2540#issuecomment-1121030783:67,extend,extended,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2540#issuecomment-1121030783,1,['extend'],['extended']
Modifiability,"I think something that we haven't fully grasped in the past (and I am largely to blame) is how to properly display information to users in the REPL and log files (eg by extending existing methods so the interface for displaying `Oceanangians` types is the same as other julia types). There are a few functions available:. * `show`; * `print` (seems similar to `show`, except used where fancy formatting such as colors, etc may not be appropriate or available); * `summary`. We also want even more minimal representations than those produced by `summary`, like `string(typeof(obj).name.wrapper)`. There may also be a julia function for this, but I didn't find one after a cursory search. We have (unfortunately) introduced what appears to be a needless alternative to `summary` in the source code; we call this `short_show`. So we already have sizeable technical debt... I think it's helpful to follow convention as much as possible, especially if this package is used by other packages (eg it will be embedded in a climate model at some point in the future, which will be a separate package...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360:169,extend,extending,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2099#issuecomment-986795360,1,['extend'],['extending']
Modifiability,"I think that many of the functions and types at the top level, such as . https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Oceananigans.jl#L171-L188. indicate that code is included out of order, or that the notion of ""dependency"" (ie which parts of the code define an interface, vs which parts of the code implement an interface) is not well-established. In other words, we don't know what parts of the code are lower-level than other parts of the code. Therefore I think we should strive to reduce or eliminate those definitions if possible. This disorganization presents two problems. First it means that the code is harder to reason about, because its not logical (ie constructed ad-hoc rather than following clear rules). The more serious practical problem is that it will prevent us from splitting up the repo (ie separating core finite volume utilities such as grids, fields etc, from the physics / models, from simulations). It's possible that we will need to port out the ""simulations"" utilities fairly soon to facilitate coupled simulations (this would be required to avoid circular dependencies in the coupling software). The cause is mostly historical; the code was developed from the ground-up as-needed rather than following some preconceived design. We now understand that ""simulations"" should be incorporated before models; simulations should really _define_ the interface that a model needs to provide (mostly the function `time_step!`, but also a few auxiliary functions like `prognostic_fields`, `initialize!`, etc). I'm opening this issue because I think this concern should be written down somewhere so developers are aware and can strive to avoid worsening (ideally new development should work towards eliminating ""bad"" top-level definitions rather than adding new ones).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3048:1153,coupling,coupling,1153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3048,1,['coupling'],['coupling']
Modifiability,"I think that's a decent idea and also might help de-complexify some of the code associated with buoyancy models. We would have to refactor our equations of state a bit but that's not hard. The main question is what to do about `gravitational_acceleration`. Right now, `gravitational_acceleration` is a parameter of `SeawaterBuoyancy`:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/BuoyancyModels/seawater_buoyancy.jl#L10-L15. because if you're using `BuoyancyTracer()`, there's no gravitational acceleration parameter (since its absorbed into the definition of buoyancy). However, we could move `gravitational_acceleration` into `Buoyancy`, and then set it to `nothing` when we are using `BuoyancyTracer`. The downside of this approach is that people can then change this parameter when using `BuoyancyTracer`, even though such changes would have no dynamical effect on the model (we've tried to limit such possibility for confusion otherwise...). It could be reasonable to move `constant_temperature` and `constant_salinity` into `equation_of_state`. `SeawaterBuoyancy` is then a type union of buoyancies with either `LinearEquationOfState` or something else from `SeawaterPolynomials.jl`. PS the default values for coefficients here:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/BuoyancyModels/linear_equation_of_state.jl#L25. should probably be 0?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-951090677:130,refactor,refactor,130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2022#issuecomment-951090677,1,['refactor'],['refactor']
Modifiability,"I think the flux boundary condition implementation is correct: ; we ensure zero first and second order derivative across the boundary by mirroring the field, then we just add the flux later as a forcing. . The problem is in the `Open` boundary conditions. These just substitute the value at the interface without modifying halo nodes. This will not ensure a zero second order derivative on the face.; we have to extend the boundary condition to the halos to ensure 0 laplacian on the boundary. Two way that this can be done is either mirroring or linearly extrapolating. This will have an impact later if we support ""true"" open boundary conditions",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132:412,extend,extend,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2247#issuecomment-1040632132,1,['extend'],['extend']
Modifiability,"I think the main reason to use total height is that it generalizes to a ""stacked"" shallow water model (where there are N layers rather than just 1). But perhaps the choice depends on whether shallow water model is valuable mostly as a stand-alone model for physics problems or whether it's intent is more as a testbed for develping numerical methods, etc (with perhaps the eventual possibility of generalizing to N layers).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156776:121,layers,layers,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1115156776,2,['layers'],['layers']
Modifiability,"I think the next step is a fully-fledged implementation that supports `Flux` boundary conditions (and possibly others). We are almost there with the latest `TurbulenceClosures` refactor. If `correct_immersed_tendencies!` is copy/pasted for tracers then all tracers will be set to zero inside a boundary; this might not be exactly what users want. I think we also sometimes want free-slip rather than no-slip boundary conditions on momentum. The algorithm I am thinking of would have the following components:. 1. Implement a ""mask"" that replaces `correct_immersed_tendencies!` that forcibly overwrites immersed regions to specified values in `update_state!` (this is effectively what `correct_immersed_tendencies!` does now); 2. Extend `calculate_boundary_tendency_terms!` to adjust tendencies in cells adjacent to immersed boundaries. This involves a) subtracting out the ""spurious"" component associated with a diffusive flux across an immersed boundary and b) adding in the ""true"" boundary flux that's either specified by the user, or implied by a `Value` / `Gradient` boundary condition.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493:177,refactor,refactor,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1548#issuecomment-813819493,2,"['Extend', 'refactor']","['Extend', 'refactor']"
Modifiability,"I think there's still a use for `KernelComputedField`! It's more expensive to construct a calculation by nesting `ComputedField`s inside it. The difference is in the number of kernel launches: when expressing a calculation with a single kernel, the computation is computed with a single loop over all grid points. When expressing a calculation using intermediate `ComputedField`, then first we launch kernels to calculate the intermediate `ComputedField`s, and launch a final kernel to compute the quantity of interest. It can also be more memory intensive since the intermediate `ComputedField`s need to be stored. For some applications, the ""optimization"" of avoiding intermediate kernel launches / calculations may be unimportant (for example, if plenty of memory is available and computations are made very rarely). I think nesting `ComputedField`s is a nice solution that avoids having to hand-write kernels for those cases. But sometimes I do think that users want to optimize diagnostics calculations. There are also some other nice applications of `KernelComputedField`; for example I think it would be nice to make the LES eddy diffusivities into `KernelComputedField` (which are computed every tendency evaluation so performance is crucial), and perhaps some other auxiliary variables. I think it would be fun to try the compiler hack-around that I suggested in my comment above (defining multiple `identity` functions and using an internal counter to scroll through them during compilation). It's just a matter of finding the time to do it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600:1285,variab,variables,1285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786813600,1,['variab'],['variables']
Modifiability,"I think this PR is finally ready. Thanks to @simone-silvestri for the help!. Here a simple simulation (roughly adapted from the [ocean wind mixing example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/)) using stretched grids in the x, y, and z directions respectively:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/fba0fa71-92b0-4f7b-978e-7bb24f7060fb. https://github.com/CliMA/Oceananigans.jl/assets/13205162/dea0309f-3b2f-499a-81b2-f5de819dc992. https://github.com/CliMA/Oceananigans.jl/assets/13205162/17e2c3e1-71be-4d9a-9bbe-378bbb657150",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1597796977:111,adapt,adapted,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1597796977,2,['adapt'],['adapted']
Modifiability,"I think this is a a big step forward and happy to share my two cents worth. I agree that we should keep `gravitational_acceleration` the same as before. We will need to have a bunch of `g'`. Since we have a free surface, we assume that we have air above, then `g'` of the top layer is really just `g`. That's why I would suggest having n reduced gravities for n layers. We will need n interfaces and we could also store the n heights. Sometimes it's convenient to have one or the other. For efficiency we only need one, but for convenience we might want to have both. What are people's preferences?. The more layers we have, the thinner each layer tends to be. This means that it's more likely that layer depths can vanish. If this ever happens, then a numerical instability can happen. I remember discussing with @simone-silvestri using the positive preserving property of WENO to deal with this but I also remember that a preliminary test showed that it wasn't actually ensure to be positive. Sadly, I didn't follow up. Any idea if that was fixed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717:362,layers,layers,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1481952717,2,['layers'],['layers']
Modifiability,"I think we can impose a little more structure that eases biogeochemical model development. One route is to build out a layer on top of `AbstractBiogeochemistry` for models with a common form, something like. ```julia; struct TracerBasedBiogeochemistry; biogeochemical_tracers; drift_advection_schemes; drift_velocities; transitions; auxiliary_fields; end; ```. and perhaps more properties. This is similar to how `SeawaterBuoyancy` works, in that it provides a concrete structure with a slot `equation_of_state` whereby ""external"" packages like `SeawaterPolynomials` can insert custom behavior. Another possibility is to build out a new abstract type below `AbstractBiogeochemistry` with a function-based interface (somehow). I was also thinking it would be nice to supply a ""continuous form"" interface, so that model developers can implement functions that look something like. ```julia; biogeochemical_transition(x, y, z, t, N, P, Z, D, parameters); ```. rather than having to use the ""discrete form"". This sort of structure could also be provided by an external package. The advantage of including it here is that we get tighter coupling with Oceananigans development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310908285:1132,coupling,coupling,1132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310908285,1,['coupling'],['coupling']
Modifiability,I think we decided we would merge this in its current form and add tests for different topologies and Helmholtz equations in a future PR. In future PR(s) we should also refactor the interface to be more consistent with the other solvers and to use CuArrays in the solver itself. I think we don't intend to use the `PreconditionedConjugateGradientSolver` with `IncompressibleModel` so I removed it from the constructor. I presume a PCG solver will be created in the hydrostatic model constructor. Although a good regression test would be to run an `IncompressibleModel` with a PCG pressure solver and make sure it matches the regression data.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359:169,refactor,refactor,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1360#issuecomment-781637359,1,['refactor'],['refactor']
Modifiability,"I think we need a PR focused on cleaning up some of the legacy constructors out there before the code gets used by others. In particular I'd like to work on #413 (currently on the `grid-xyz` branch) which involves refactoring the `RegularCartesianGrid` constructor and I'd rather not leave behind three legacy constructors. Also, I'm not a fan of the `BasicModel` constructor. I understand it was introduced to avoid refactoring all the `Model` constructors, but would be nice to get rid of it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/429:214,refactor,refactoring,214,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/429,2,['refactor'],['refactoring']
Modifiability,"I think we should change the kwarg to `mode` with the two options from NCDatasets.jl: `""a""` (for append) and `""c""` (for clobber or create). Right now even with `clobber=false` `NetCDFOutputWriter` tries to define new dimensions and variables (which would fail due to conflict with existing dimensions/variables). cc @suyashbire1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/913:232,variab,variables,232,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/913,2,['variab'],['variables']
Modifiability,"I think we should delete the regression test and put a warning in the model constructor ""The ShallowWaterModel has not been validated"". It's a shame we've put so much time into the regression test as it is. I think the model likely has a few bugs to be ironed out. I'm also not convinced that we have all the numerical methods (ie vanishing layers, positive preserving advection) that would be needed to advertise the model as ""production-ready""). One could argue that the regression test is misleading in that it gives the false impression that the model is in a state that shouldn't change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3049#issuecomment-1496736100:341,layers,layers,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3049#issuecomment-1496736100,1,['layers'],['layers']
Modifiability,"I think we should do 1. and 2., keeping them separate. On Wed, Mar 17, 2021, 8:53 PM Ali Ramadhan ***@***.***> wrote:. > Some time ago @sandreza <https://github.com/sandreza> and @xiaozhour; > <https://github.com/xiaozhour> suggested it would be useful to add the; > GM-Redi parameterization to Oceananigans.jl since we may want to train; > mesoscale eddy parameterizations.; >; > I'm opening this issue to discuss on what exactly needs to be implemented.; > My main reference is; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html; >; > It seems that there are three different new closures that could; > potentially be added:; >; > 1. Redi (symmetric) tensor diffusivity.; > 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; > 3. GM-Redi combining the two.; >; > Note: @glwagner <https://github.com/glwagner> has already implemented; > parts of the Redi tensor and GM for TwoDimensionalLeith so GM-Redi might; > not need too much extra work:; > https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl; > Questions/proposal; >; > 1. Do we make the small-angle approximation? I would say yes.; >; > In Oceananigans.jl right now each component of the tensor diffusivity is; > calculated on-the-fly so the unapproximated tensor could end up being 2-4x; > more expensive to compute. We cannot compute the full tensor in one go; > (reusing the isopycnal slopes) and we may not want to since it takes up a; > lot of memory (9 extra field?). But maybe there's a good reason to not make; > the small-angle approximation? We could eventually support both; > (unapproximated and small-angle approximation).; >; > See; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion; > for a comparison of the two.; >; > 1. Is GM-Redi the main parameterization of interest? Would people use; > the fully symmetric or the fully anti-symmetric diffusivity tensor by; > themsel",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587:275,parameteriz,parameterization,275,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587,2,['parameteriz'],"['parameterization', 'parameterizations']"
Modifiability,"I think we should make it a rule that we don't write about experimental and transient features in the docs. I propose that instead we use Discussions and Issues for that. I prefer we make the docs ""slow moving"" and carefully curated --- like a textbook --- while using GitHub discussions to encapsulate ""living"", transient, and often more fine-grained knowledge about usage, experimental / rapidly changing features, and generally things that might require extended discussion and benefit from clarification questions. In part this means mostly avoiding tagging issues and pull requests in the documentation. The motivation for this approach has a few parts. First is to clarify ""what belongs in the docs"" versus what kinds of things will be documented elsewhere on the vast internet, so that people know where to look to get the answers they need. The second reason is to help control the development of docs by the community. As the code grows, the docs will have to necessarily grow to become very long. The docs are much shorter than they should be right now because the hydrostatic model in particular is still somewhat ""experimental"" (it's a multi-year effort to develop a fully functional GCM, and we are in the thick of it now). There will be so much more in the docs in the end --- a dozen or more parameterizations for ocean turbulence, sea ice, biogeochemistry, and on and on. As a result, it's going to become very important that the docs are as concise as possible (eg, the same constraint we face when writing a textbook). Thus in this process we'll have to carefully curate whatever goes into the docs as a community, and I think it will be helpful if the docs are only used for ""big"" things. A third reason is just that I think this is will reduce the effort required to maintain docs. For example, this change to the docs will become incorrect when we merge the multi-region PR (which hopefully will be soon). That means that we need to update the docs when we merge that PR. Maybe we",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498:457,extend,extended,457,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2464#issuecomment-1107180498,1,['extend'],['extended']
Modifiability,"I think we want `h` to be the layer thickness, so that these ideas generalize to ""n"" layers. Then the ""surface height"" is `H(x, y, t) = h(x, y, t) + b(x, y, t)`, where `b` is the height of the bathymetry. `eta` is defined relative to some reference height, eg `eta(x, y, t) = H(x, y, t) - H0`. I think with this definition, `b` comes into the pressure gradient but not momentum.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128972918:85,layers,layers,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128972918,1,['layers'],['layers']
Modifiability,I think we want to do this over a few PRs. The first task is to extend BatchedTridiagonalSolver,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1557433725:64,extend,extend,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3111#issuecomment-1557433725,1,['extend'],['extend']
Modifiability,"I think we're ready to merge this once we hammer out the details. Still TODO will be:. - refactoring the model setup pages to be more tutorial-like; - finishing the tutorials on reductions, simulations, and field time series / post-processing. @navidcy @simone-silvestri @rafferrari",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2274344831:89,refactor,refactoring,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3673#issuecomment-2274344831,1,['refactor'],['refactoring']
Modifiability,"I think what we want in terms of API is the ability to specify boundary conditions on the surface of an immersed boundary. One design would be to introduce a type called `ImmersedBoundary` that collects information about the location of the boundary and the boundary conditions for each field prescribed on it. This could be relatively simple to implement in the code, though it doesn't exactly conform to our current code design in which boundary conditions are embedded in `Field` objects. Another possibility that may better conform to our current boundary conditions / field design would be to embed `boundaries` in `grid` objects. With this design, `ImmersedBoundary` collects only information about its geometry and parameters related to its numerical implementation (eg regularization functions, interpolation methods, etc). We can then infer from `grid` the information needed to define boundary conditions for fields in both (`x` ,`y`, `z`), as well as on any `ImmersedBoundary`s. Grid constructors would then be something like. ```julia; grid = RegularCartesianGrid(; immersed_boundaries = ImmersedBoundary(geometry = # a function of (x, y, z, t); transfer_function = # parameters ; ); topology = # etc; ); ```; ; As for verification, I think we should use a quantitative test that verifies that boundary conditions are satisfied on the immersed boundary. Reproducing the Reynolds number correction to the drag coefficient on a sphere might be a good one, though it could be challenging because we'd have to use sponge layers to replicate an open boundary. We could also reproduce driven-cavity results in a triply periodic domain using rectangular immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/693#issuecomment-597087759:1529,layers,layers,1529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693#issuecomment-597087759,1,['layers'],['layers']
Modifiability,"I think what you have discovered is that simulations with `BackgroundField` can behave differently on the GPU than on the CPU for some reason. What do you mean when you say the `BackgroundField` is not consistent with the boundary condition? The boundary condition is applied only to the prognostic variable (the deviation) only. Indeed, one of the most important applications of `BackgroundField` is to run simulations in which the deviations are _periodic_ even though the `BackgroundField` is not. The Eady turbulence problem is an example of one such problem. In that case the background velocity and buoyancy fields are not periodic in the y-direction; but because they only vary _linearly_, deviations from that background state _can_ be idealized as periodic. There may indeed be some issue regarding `BackgroundField` and `Bounded` directions, but I believe this is a bug and not expected. Certainly there is a bug if different results occur on the CPU versus the GPU. Hopefully we can get to the bottom of it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815420587:299,variab,variable,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815420587,1,['variab'],['variable']
Modifiability,"I think you instantiate a model to do many things; one of them is time-stepping, but another may be analysis. Another is testing. Even now we can't actually solve poisson's equation without a `Model` easily, which seems like an unnecessary restriction of our non-modularity. I don't think we should make this problem worse. I think it makes sense `model` is a field of `Simulation`. Its simple to envision `Simulation` parameters that are identical, with a different underlying `model` (eg, changing the number of passive tracers)`. The way I envision a logical course for the development of complex software in general is that we start with the fundamental building blocks and make them as easy to use in their low-level form as possible. When we've decided we can proceed no farther, we add another layer of abstraction that fuses these underlying building blocks into a higher-order coherent object. And so on. I think its a better design strategy to add *layers* of abstraction, rather than *embedding* abstraction within already complex objects. The latter strategy would lead to unmanageable complexity.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542267410:959,layers,layers,959,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542267410,1,['layers'],['layers']
Modifiability,"I think η★ U★, and V★ (the intermediate variables at time step m+½ I think) are currently computed on-the-fly (mostly needed for AB3), which makes sense why imposing the topology and boundary conditions had to be baked into the operators. https://github.com/CliMA/Oceananigans.jl/blob/13bf409616af8c155b72d8869b7b8f97ae0e844b/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface_kernels.jl#L105-L120",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2397688960:40,variab,variables,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2397688960,1,['variab'],['variables']
Modifiability,"I thought I would also try freezing the velocity field, if possible. If this still weirdness at the boundary still happens when the velocity doesn't evolve, then it has nothing to do with the pressure solve. Could someone point me to an example that does this?; ________________________________; From: Francis Poulin ***@***.***>; Sent: Wednesday, April 7, 2021 7:43:11 PM; To: CliMA/Oceananigans.jl ***@***.***>; CliMA/Oceananigans.jl ***@***.***>; Cc: Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). Very good point. The background buoyancy does not satisfy the boundary conditions that are imposed. I will check it out later. If this is the case, then it is still mysterious why GPUs have a harder time with this than CPUs, but we will see and learn. Thanks for the suggestion. Francis; ________________________________; From: Gregory L. Wagner ***@***.***>; Sent: Wednesday, April 7, 2021 5:44:23 PM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Mention ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] strange results on gpus (#1554). The second time-step is when QuasiAdamsBashforth2 uses tendency information saved from the previous time-step. On the first time-step it's equivalent to a forward Euler scheme. I know the differences are small, 8th decimal place or so, but on such a coarse grid should we be expecting the same answers?. Hardware differences can produce results that differ by something like sqrt(eps(Float64)) I think. This is the tolerance we use for regression tests (but even those sometimes fail to pass on the GPU for some reason). Since the background buoyancy field has a linear gradient and your domain is bounded, can you try running the same simulation but explicitly resolving the background buoyancy field? (This could suggest that the issue has to do with BackgroundField...). -; You are receiving this because you were mentioned.; Reply to this email directly, view it on GitHub<https://gi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815368840:149,evolve,evolve,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815368840,2,['evolve'],['evolve']
Modifiability,"I want to merge this then use it to develop the user API for immersed boundary fluxes. Also, did anyone use this?. Partly I am wondering whether we may actually need shaved cells for accurate LES computations in complex domains with non-straight immersed boundaries) ... otherwise our boundaries will always have ""effective roughness"", and form drag may dominate. It is actually possible that form drag dominance is ok as a model for rough boundaries. But it'd be nice to have the possibility of ""smooth"" boundaries where fluxes can be controlled via parameterizations. It's also interesting that PALM, which uses an almost identical numerical method that we use, is primarily used for atmospheric LES in urban environments. So their boundaries _are mostly flat_ (the sides of buildings, etc...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100228717:551,parameteriz,parameterizations,551,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2402#issuecomment-1100228717,1,['parameteriz'],['parameterizations']
Modifiability,"I want to set the gradient boundary condition to east, west, south, north directions in u and v variables. However, for u variable, cannot specify east boundary condition using GradientBoundaryCondition at Face(). So, how should i solve this problem. . Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. Thanks.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3612:96,variab,variables,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612,3,['variab'],"['variable', 'variables']"
Modifiability,I wanted to add tests but the current test functionality is difficult to adjust to work for 2D arrays. . https://github.com/CliMA/Oceananigans.jl/blob/39e9b6f3e5c5f43845f21f8e10fdd629ced448fc/test/test_multi_region_cubed_sphere.jl#L9-L62. I'd like to rewrite those to use the connectivity property of the `ConformalCubedSphereGrid` rather than a series of if statements. Also address ##3242. But I wasn't planning to do this on this PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761:251,rewrite,rewrite,251,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3256#issuecomment-1712759761,1,['rewrite'],['rewrite']
Modifiability,"I wanted to extend the code to allow `NonhydrostaticModel`s with irregular grids in all directions, not just the `z` direction. As @glwagner mentioned, it would be good to discuss the approach here, although I started the draft PR https://github.com/CliMA/Oceananigans.jl/pull/3111 already extending `FourierTridiagonalPoissonSolver` to all directions. Apparently `BatchedTridiagonalSolver` needs to be generalized first, which I didn't anticipate/notice.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116:12,extend,extend,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116,2,['extend'],"['extend', 'extending']"
Modifiability,"I was actually expecting a different error. But this isn't a good one either. ```julia; julia> using Oceananigans. julia> using OrthogonalSphericalShellGrids. julia> grid = TripolarGrid(size=(4, 4, 4), z=(-1, 0)); 4×4×4 OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── centered at (λ, φ) = (0.0, -0.3201); ├── longitude: Periodic extent 360.112 degrees variably spaced with min(Δλ)=15.6283, max(Δλ)=95.2245; ├── latitude: RightConnected extent 212.5 degrees variably spaced with min(Δφ)=23.4259, max(Δφ)=56.6667; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.25. julia> free_surface = SplitExplicitFreeSurface(grid; cfl=0.7); SplitExplicitFreeSurface with Barotropic time step equal to 8.112 days. julia> model = HydrostaticFreeSurfaceModel(; grid, free_surface); ERROR: Centered{1, Float64, Nothing, Nothing, Nothing, Nothing} is not supported with Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, CPU}; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] validate_momentum_advection(momentum_advection::Centered{…}, grid::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{…}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_model.jl:227; [3] #construct_regionally#62; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:148 [inlined]; [4] construct_regionally; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:143 [inlined]; [5] macro expansion; @ ~/Projects/Oceananigans.jl/src/Utils/multi_region_transformation.jl:221 [inlined]; [6] HydrostaticFreeSurfaceModel(;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806:434,variab,variably,434,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806,2,['variab'],['variably']
Modifiability,"I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR https://github.com/vchuravy/GPUifyLoops.jl/pull/18. The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs. You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations. Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067:63,sandbox,sandbox,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115#issuecomment-470782067,5,"['extend', 'rewrite', 'sandbox', 'variab']","['extended', 'rewrite', 'sandbox', 'variable']"
Modifiability,I will move `MultiDimensionalScheme` and the advection refactor to two different PR,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1175058807:55,refactor,refactor,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1175058807,1,['refactor'],['refactor']
Modifiability,"I would also add a check that the fields are ""full"" fields, aka no `Windowed` fields (with particular indices different from the one we use to launch the kernel) and no `Reduced` fields with lower than 3 dimensions. We want to separate out those fields and treat them differently. ; We have an implementation like that for `fill_halo_regions!` here; https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Fields/field_tuples.jl#L54-L78. What I would probably do actually, instead of a new struct is to extend `compute!` for tuple fields as we do for `fill_halo_regions!` and use your newly implemented kernels for tuples of full fields. On the other hand, if defining a new type is useful for OutputWriters I am ok with it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694057688:538,extend,extend,538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1694057688,1,['extend'],['extend']
Modifiability,I would like to suggest the following checklist moving forward. - [ ] Decide whether we like the structure of the script `new_rates_of_convergence.jl`. How can we might improve it?; - [ ] Find where the bottleneck is in Oceanangans to make things globally single precision.; - [ ] Adapt this approach to the other validation cases that currently exist.; - [ ] Make `UpwindFirstOrderBiased()` advection scheme.; - [ ] Make `CenteredSixthOrder()` advection scheme.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313:281,Adapt,Adapt,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1276#issuecomment-750476313,1,['Adapt'],['Adapt']
Modifiability,"I would not incorporate those modifications but rather try to understand why that happens. The only difference there is the use of `getregion` instead of indexing with `[region]`. But `getregion` is intended to be basically just an indexing for the variables you have there, so it means that there is a problem with `getregion`, maybe a missing `@inline` somewhere?. In the end, with apply_regionally what happens under the hood is just this:. ```julia; for (r, dev) in enumerate(devs); switch_device!(dev); regional_func!((getregion(arg, r) for arg in args)...; (getregion(kwarg, r) for kwarg in kwargs)...); end; ```; In this case `regional_func!` is the launch! function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2100622115:249,variab,variables,249,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2100622115,1,['variab'],['variables']
Modifiability,I'd like to eliminate `Δx` from the code because this grid metric is only valid on regular horizontal grids. This is why I did not extend `Δx` for `ImmersedBoundaryGrid` when I extended all of the other grid metrics here:. https://github.com/CliMA/Oceananigans.jl/blob/master/src/ImmersedBoundaries/immersed_grid_metrics.jl. I was hoping that not including rogue metrics like `Δx` would facilitate in excising them from the code base. Where in `ShallowWaterModel` to you use `Δx`? I think in the stack trace for the error you received you should be able to locate where the problematic `Δx` is called.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-845306836:131,extend,extend,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-845306836,2,['extend'],"['extend', 'extended']"
Modifiability,I'm closing this. I'll open an issue to discuss an advection scheme refactor.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1104656459:68,refactor,refactor,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2388#issuecomment-1104656459,1,['refactor'],['refactor']
Modifiability,"I'm not 100% sure but I think doing reductions over non-contiguous data might be subject to variable timings that depend on how the data is organized in memory. In an ideal world, we would benchmark these things regularly...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233:92,variab,variable,92,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-960354233,1,['variab'],['variable']
Modifiability,"I'm not familiar with the Oceananigans code writing practice, but it looks like the parameter `number_of_layers` is redundant as it is already present in `grid.Nz`. Is the parameter added in a case where the user inputs the number of layers explicitly?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469180135:234,layers,layers,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469180135,1,['layers'],['layers']
Modifiability,"I'm not sure I follow then. Are you saying that you're not sure all the; versions in this range are bug-free? That being the case it's best to pin; it to a version we know is safe?. On Tue, Oct 5, 2021, 17:05 Gregory L. Wagner ***@***.***>; wrote:. > ***@***.**** commented on this pull request.; > ------------------------------; >; > In Project.toml; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>; > :; >; > > @@ -33,7 +33,7 @@ Tullio = ""bc48ee85-29a4-5162-ae0b-a64e1601d4bc""; >; > [compat]; > Adapt = ""^3""; > -CUDA = ""3""; > +CUDA = ""3.0.0 - 3.3.6""; >; > Note that Manifest.toml pins a specific version.; >; > Right, that's why I figured making it specific was the safest option.; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1997#discussion_r722703022>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/ADEX5KRJ3DYWCNI4IRO6RNTUFNSC3ANCNFSM5FKUICWQ>; > .; > Triage notifications on the go with GitHub Mobile for iOS; > <https://apps.apple.com/app/apple-store/id1477376905?ct=notification-email&mt=8&pt=524675>; > or Android; > <https://play.google.com/store/apps/details?id=com.github.android&referrer=utm_campaign%3Dnotification-email%26utm_medium%3Demail%26utm_source%3Dgithub>.; >; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603:527,Adapt,Adapt,527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1997#issuecomment-934858603,1,['Adapt'],['Adapt']
Modifiability,"I'm not sure if this is known (or even expected) or not, but with recent versions of Oceananigans I've noticed that we're allocating more and more memory on GPUs. Basically the scenario is that I've running simulations with a given script for the past 6 months or so. The simulation and model itself has stayed the same, I've been running on the same GPUs, and the only changes that I made were those forced by changes in Oceanigans. . When I started this setup, I could run up to ~105 million points. Then as the versions increased I had to decrease to size of simulations to 100 million and then to 95 million. Now with the change to Julia 1.8 (I had been using Julia 1.6 until version 0.77.5) there was a steep increase in memory use and my max size went from 95 to 80 million. Compared to my original size of ~105 million, that's a decrease of about 25% in the grid size. Has anyone else noticed this? Is this expected since we added more features/flexibility to the code lately?. A few notes:. - My simulation is pretty complex (it's got IBM, forcings for every variable, a tracer, LES closures and drag BCs), so I think for most other simulations the max size would be smaller; - I understand that part of the memory allocation depends on the package dependencies (and the Julia version itself), not being directly controlled by Oceananigans code; - It's also worth noting that since the cluster I use (Casper) hasn't installed Julia 1.8, I started trying the newest version from the pre-compiled binaries for Julia 1.8. I don't know if that can somehow affect the memory allocation since the binaries aren't optimized for that specific machine (I haven't yet tried compiling Julia 1.8 from source). CC @wenegrat @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794:1067,variab,variable,1067,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794,1,['variab'],['variable']
Modifiability,"I'm not sure. I'm not very familiar with the testing part of Oceananigans, so I'm not sure what would be a good test for this. Just testing that `min_Δz` works seems too specific, on the other hand, creating a whole simulation with a stretched grid and running it with an LES and adaptive time-stepping just to test that seems wasteful. I'm happy to just merge this for now and create a test for this in the future. Thoughts?. CC @glwagner @ali-ramadhan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866087165:280,adapt,adaptive,280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1751#issuecomment-866087165,1,['adapt'],['adaptive']
Modifiability,"I'm pretty sure this is trivial to support because `FunctionField` has the same interface as `AbstractOperation`, so we can simply extend these methods:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/AbstractOperations/computed_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122:131,extend,extend,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3226#issuecomment-1690265122,2,['extend'],['extend']
Modifiability,"I'm thinking about updating `benchmarks.md` with the new benchmark result tables and graphs. Should I do it now or wait until the docs get refactored?; It's only a single file in the appendix section, but I'm not too sure how me opening a PR on it now to update it will affect the grander refactoring plan.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401:139,refactor,refactored,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880741401,2,['refactor'],"['refactored', 'refactoring']"
Modifiability,"I'm trying to follow the [tutorial here](https://clima.github.io/OceananigansDocumentation/stable/generated/one_dimensional_diffusion/) using vscode (connected via remote-ssh to ubuntu machine). However, I consistently get errors below (and `@animate` step doesn't finish): ; ```; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. Aborted (core dumped); connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: eglfs, linuxfb, minimal, minimalegl, offscreen, vnc, xcb. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1281:430,plugin,plugin,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1281,12,['plugin'],"['plugin', 'plugins']"
Modifiability,"I'm trying to run a simulation that has both forcings and some auxiliary variables which get updated with every time-step. However, I found that just the existence of a variable in the `auxiliary_fields`, coupled with a forcing function where parameters are included, makes the simulation fail on the GPU. Here's a MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(), size=(4, 4, 4), extent = (1, 1, 1)). @inline forc_u(x, y, z, t, u) = x. model = NonhydrostaticModel(; grid, forcing = (; u=Forcing(forc_u, field_dependencies = :u)),; auxiliary_fields = (; a=0)); @show model.forcing model.auxiliary_fields; time_step!(model, 1); ```. the above runs fine on the CPU but fails on the GPU with:. ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gu!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(4, 4, 4)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 4)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}, Oceananigans.Fields.ZeroField{Int64, 3}}},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3025:73,variab,variables,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3025,2,['variab'],"['variable', 'variables']"
Modifiability,"I'm using v0.68.6, previously I was on v0.67.1 and saw the same error (not surprising). I was hoping to use a stretched x-grid with a stretched z-grid while I play around with some 2D internal wave simulations. I'm still new to Julia and Oceananigans so I've been trying to simulate the classic vertically oscillating sphere or cylinder as my source. I was playing around with refining the mesh near the oscillation to see if the wave beams were a little cleaner. I can make due with stretched z-grids for now!. --; Regarding the `MethodError`, and while I am new to Julia, but maybe in this case a `NotImplementedError` would work better? I find Julia's stacktraces a bit long winded because of multi-dispatch and I obviously didn't figure out that variable grid spacing is only implemented for the vertical coordinate for the pressure solver. But getting a `NotImplementedError` when I tried would have been painfully obvious even to me. :-)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023289047:750,variab,variable,750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1023289047,1,['variab'],['variable']
Modifiability,"I've also offered to help configure testing on our systems, if someone wants to provide what is needed to integrate with slurm.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328783023:26,config,configure,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-2328783023,1,['config'],['configure']
Modifiability,"I've had a go at implementing a proper NPZD model (rather than one I just made up on the fly) and have some thoughts on how we should modify the API:; - I think we need an `required_biogeochemical_auxiliary_fields` like `required_biogeochemical_tracers` because for most models we're going to want the user to at least specify a PAR field (I suppose we may want this to also check the shape of the field because some models may have a pre defined depth dependence of PAR so we might want the user to specify a 2D PAR field rather than doing it properly by integrating a 3D field); - Given what you said the other day about callbacks only being used for features that should be built into Oceananigans we might want to have a think about how a BGC model can specify the attenuation of PAR. You've mentioned that we could define some kind of integrated field?; - It might be helpful to have a simpler interface for advection in biogeochemical models. Although a user could just add another forcing, I think the only way for a model to automatically add an advective forcing is how I've implimented it in the below example. I Think this works quite well since a lot of BGC models write the sinking terms with the other forcing terms, but its a little cumbersome to write e.g. `sinking = div_Uc(i, j, k, grid, bgc.adv_scheme, bgc.u⃗ᵖ, fields.P)`, and model makers will need to do the setup stuff I've done to make the advective velocity fields. You can see my implementation [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/src/Models/AdvectedPopulations/NPZD.jl) and a script using it [here](https://github.com/OceanBioME/OceanBioME.jl/blob/Oceananigans-Update/examples/NPZD.jl) since I thought it was probably too complicated for the test (and will change that back to a 1 variable model later). Not finished making it work but yet but will be done soon.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242:1798,variab,variable,1798,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2802#issuecomment-1310609242,2,['variab'],['variable']
Modifiability,"I've long been unsatisfied with how we build output. It requires a lot of typing --- that is, [_boilerplate_](https://en.wikipedia.org/wiki/Boilerplate_text). I often feel a sense of dread when I have to go beyond ""visualizing the final iteration"" of a prototype to defining an output writer. _So much typing_. This PR is an attempt to make output easier and more fun. I use JLD2 as an example but if there is some consensus then I think this PR should extend the same to NetCDF. The main thrust of this PR is a new function called `output!`. It works like this:. ```julia; output!(simulation, outputs; schedule=TimeInterval(1), filename=""low_hanging_fruit""); ```. The default is `JLD2Format()`. For `NetCDF` users would write. ```julia; output!(simulation, outputs, NetCDFFormat(); kw...); ```. The function adds an output writer to `simulation`, choosing a ""generic name"" for the `simulation.output_writers` dictionary. Does this enable one line output writing?. I'd love to hear feedback about this design. I implemented it in the `two_dimensional_turbulence.jl` example for illustration:. https://github.com/CliMA/Oceananigans.jl/blob/6a6853ddf53c53c321c16393682b786e82ef5a8f/examples/two_dimensional_turbulence.jl#L109. There are two more things. First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Simulations are cheap, but life is short!. PS I also want to change `add_callback!` to just `callback!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793:453,extend,extend,453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793,1,['extend'],['extend']
Modifiability,"I've run a simulation with a timestep of $\Delta t = 1.066666...$ and it looks as though there's some kind of rounding bug which is resulting in multiple saves occasionally. I choose 'schedule = TimeInterval(t_end/num_saves)' and expect to get 'num_saves' (or possibly 'num_saves+1') points in the saved 'time' variable. However, I end up with about 30 extra saves. Examining 'time' in more detail reveals that most of the points are separated by 't_end/num_saves' but a few (around 30) are separated by a much smaller interval. My guess is that this is a rounding bug with when the code saves the field. Alternatively I could have messed something up. Matt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3614:311,variab,variable,311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3614,1,['variab'],['variable']
Modifiability,If `times` is a `Vector` then it needs to be converted to `arch_array` _and_ adapted when passed to GPU. We're doing a big overhaul on #3450 and this is one of the thing we fixed:. https://github.com/CliMA/Oceananigans.jl/blob/13dcd4ff9767c5a1e030bf4ce5765cc661b1175b/src/OutputReaders/field_time_series.jl#L235-L243,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3472#issuecomment-1942031002:77,adapt,adapted,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472#issuecomment-1942031002,1,['adapt'],['adapted']
Modifiability,If it was related to the rewrite of the terms then shouldn't been affecting CPU regression test as well?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1427118830:25,rewrite,rewrite,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1427118830,1,['rewrite'],['rewrite']
Modifiability,"If we want to allow for variable `nu`, which is a good idea, then the first two have the problem of not guaranteeing that viscosity reduces the kinetic energy,. The third form is the one to focus on, and is what would appear in the non-conservative of vector invariant forms. For the conservative form we need to mutliply the 3rd equation by `h`, and then `nu` has the correct dimensions: length^2/time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174:24,variab,variable,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1089638174,1,['variab'],['variable']
Modifiability,"If you didn't define new advection schemes but use the implemented ones they automatically lower the order near the boundaries. The implementation is in `topologically_conditional_interpolation.jl`. If you did not define new `symmetric_left_biased_interpolation_xᶠᵃᵃ` functions you should be ok. ; Otherwise you have to add your methods in the above mentioned file. If you are using an immersed boundary, the limiting is performed in the `conditional_fluxes.jl` file in the ImmersedBoundaries module. You can always use high order and fill more halos but then you are making an assumption on the field which you are trying to evolve",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182333702:626,evolve,evolve,626,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2650#issuecomment-1182333702,1,['evolve'],['evolve']
Modifiability,"If you want to adopt this PR, that would be great. I would leave the boundary conditions outside the operator for the moment, then we can look at the influence of those in performance in another PR. To test the performance we should push PR #3596 that implements split explicit with fill halos at every substep. Using that implementation for split-explicit will make boundary conditions for barotropic variables quite trivial to implement, but probably extremely slow. However, we can use it as a benchmark",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298:402,variab,variables,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353152298,1,['variab'],['variables']
Modifiability,Implement neural network parameterization of salty turbulent mixing in the upper ocean,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3819:25,parameteriz,parameterization,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3819,1,['parameteriz'],['parameterization']
Modifiability,Implementing AB2 for variable time-step size,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738:21,variab,variable,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738,1,['variab'],['variable']
Modifiability,"Implementing a vertically stretched grid (see PR #543) involves adding new Poisson solvers. This offers us a chance to:; 1. refactor the Poisson solvers into a more flexible API,; 2. support triply periodic and 3D box domains,; 3. unite some of the CPU and GPU Poisson solvers,; 4. reuse the Poisson solvers to implicitly time-step diffusion (vertically and possibly in 3D) in the future, and; 5. slide in (or dispatch on) a distributed pressure solve for distributed/MPI models without having to modify the time stepping code for regular models in the future. I am just throwing down some notes and ideas in this issue. This table summarizes the different boundary conditions and grids we may want to simulate, and the Poisson solver algorithm we would need. | Boundary conditions | Grid | Solver | Alternatives |; |----------------------|-----------------------|:-----------:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586:124,refactor,refactor,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586,2,"['flexible', 'refactor']","['flexible', 'refactor']"
Modifiability,Improve references/citations in docs + enhances 3D Stokes drift example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3430:39,enhance,enhances,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3430,1,['enhance'],['enhances']
Modifiability,"In `test_dynamics.jl` we test budgets for tracers and momentum variables:. https://github.com/CliMA/Oceananigans.jl/blob/0807552c94b87ec009564bf228ab85517e31dde0/test/test_dynamics.jl#L25-L41. However, the test is imperfect because 1) it does not test velocity components in non-periodic directions and 2) it uses a too-loose tolerance. ~~We can improve this test by tapering the initial condition for the field in question to zero for velocity fields in bounded directions.~~. EDIT: a little thought goes a long way: in `Bounded` directions, momentum is not conserved in general unless pressure at the boundaries is zero. Perhaps we should be happy just to test momentum conservation in periodic directions. This is still an important test that ensures the no flux condition is correctly implemented. Also, we can make the tolerance more strict. Finally, once this test works well, we can get rid of the `tracer_conserved_in_channel` test in `test_time_stepping.jl`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/942:63,variab,variables,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/942,1,['variab'],['variables']
Modifiability,"In a supposedly quiescent flow with constant temperature and salinity, seeded with tiny random noise in `w`, a large-scale flow develops and is maintained. Thus the flow gains kinetic energy in an otherwise unforced configuration, creating a ""perpetual machine"". Here is a MWE:; ```julia; using Oceananigans; using Oceananigans.Units; using SeawaterPolynomials; using SeawaterPolynomials.TEOS10; using Printf. eos = TEOS10.TEOS10EquationOfState(). arch = CPU(); grid = RectilinearGrid(CPU(), Float64,; topology = (Bounded, Flat, Bounded),; size = (100, 100),; halo = (4, 4),; x = (0, 100),; z = (-100, 0)). model = NonhydrostaticModel(; grid = grid,; buoyancy = SeawaterBuoyancy(),; advection = UpwindBiased(order=1),; timestepper = :RungeKutta3,; tracers = (:T, :S)). @inline T_initial(x, z) = 20; @inline S_initial(x, z) = 35; @inline w_initial(x, z) = rand() * 1e-6. set!(model, T=T_initial, S=S_initial, w=w_initial). u, v, w = model.velocities; T, S = model.tracers.T, model.tracers.S. KE = @at (Center, Center, Center) 0.5 * (u^2 + v^2 + w^2); KE_total = Field(Integral(KE)). simulation = Simulation(model, Δt=1e-3, stop_time=40days); wizard = TimeStepWizard(max_change=1.05, max_Δt=10minutes, cfl=0.6); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)). wall_clock = [time_ns()]. function print_progress(sim); compute!(KE_total); @printf(""[%05.2f%%] i: %d, t: %s, wall time: %s, max(u): (%6.3e, %6.3e, %6.3e) m/s, max(T) %6.3e, max(S) %6.3e, Total KE %6.3e, next Δt: %s\n"",; 100 * (sim.model.clock.time / sim.stop_time),; sim.model.clock.iteration,; prettytime(sim.model.clock.time),; prettytime(1e-9 * (time_ns() - wall_clock[1])),; maximum(abs, sim.model.velocities.u),; maximum(abs, sim.model.velocities.v),; maximum(abs, sim.model.velocities.w),; maximum(abs, sim.model.tracers.T),; maximum(abs, sim.model.tracers.S),; maximum(KE_total),; prettytime(sim.Δt)). wall_clock[1] = time_ns(). return nothing; end. simulation.callbacks[:print_progress] = Callback(print_progr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3795:216,config,configuration,216,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3795,1,['config'],['configuration']
Modifiability,"In all the scripts I found on distributed simulations, we seem to query the MPI state using `COMM_WORLD`, eg:. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L74. and. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/validation/distributed_simulations/mpi_nonhydrostatic_two_dimensional_turbulence.jl#L59-L60. But `Distributed` allows the `communicator` to be set, so `arch.communicator` can be something other than `COMM_WORLD`, eg. https://github.com/CliMA/Oceananigans.jl/blob/5dd96cf310e988fc5d3a2523c2dcc7197f18ff62/src/DistributedComputations/distributed_architectures.jl#L60-L66. Presumably we should never write scripts that make assumptions about the communicator (and we should strongly discourage users from doing so). So first of all the validation scripts must be changed. Secondly, I think something that could encouarge clean and good practices would be to extend functions like `Comm_rank` to `arch::Distributed` and possibly to the `grid` as well, so that we can call:. ```julia; rank = MPI.Comm_rank(arch); rank = MPI.Comm_rank(grid); Nranks = MPI.Comm_size(arch); ```. We'd have the option of throwing an error when non-distributed, or returning some sensible fallback like `Comm_rank(arch) = 0` and `Comm_size(arch) = 1`. Alternatively, we can develop our own API, since the MPI-based one is rather irregular and abbreviated, thus difficult for newbies to understand (I've been in this boat...). For example, perhaps simply `Base.size` and `rank` would suffice:. ```julia; Base.size(arch::Distributed) = MPI.Comm_size(arch.communicator); Base.size(arch::AbstractArchitecture) = 1; ```. ```julia; rank(arch::Distributed) = MPI.Comm_rank(arch.communicator); rank(arch::AbstractArchitecture) = 0; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3318:1034,extend,extend,1034,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3318,1,['extend'],['extend']
Modifiability,"In case people don't know, @hennyg888 ran all the benchmark scrips and I beileve he has posted the results here. Thank you Henry!. I think the scripts have evolved in that some of the outputs are formatted different than what currently appears. I'm not sure if people want to change everything to the current benchmark scripts that we have?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-877468836:156,evolve,evolved,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722#issuecomment-877468836,1,['evolve'],['evolved']
Modifiability,"In my attempt to study inertial instability I have two versions of the code. 1. Takes the solution to be a sum of the background and the perturbations, and **evolves the total** field. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/NoDecomposition/Bickley_Gaussian_jet_total.jl); 2. Stores the basic state in `BackgroundField` and **evolves the perturbation**, like the Eady problem. [code here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/Bickley_Gaussian_jet.jl). Actually, the first one uses `BackgroundField` for the background stratification, but not for the jet. Since evolving a solution that uses `BackgroundField` has three times as many advection terms, and in this 2D scenario advection is probably the most costly, I was expecting the slow down to be a factor of `3`. What I actually find is a slow down of `16`!?. Is this to be expected?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564:158,evolve,evolves,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564,2,['evolve'],['evolves']
Modifiability,"In shallow water models we don't usually talk about buoyancy but you could I suppose. Since density is what appears in the momentum equation, that's what's typically used. I believe Greg was saying buoyancy since that's the variable we typically use in the other models, but I could be wrong. Yes, you can have outcroppings at the surface. This can even happen in a one layer case. Imagine starting out with a one layer reduced gravity shallow water model that is in the shape of an inverted U. When perturbed, the interface will move and then you have to deal with height going to 0 and also becoming positive. . There are positive preserving schemes for WENO that we can code up and test with our current model to better understand how it works before moving to multiple layers. Again, very happy to talk about this too.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159:224,variab,variable,224,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1115559159,2,"['layers', 'variab']","['layers', 'variable']"
Modifiability,"In the equation of state for TEOS10 the function plugged in for depth has a different sign than what is assumed in the seawater polynomial package. https://github.com/CliMA/Oceananigans.jl/blob/main/src/BuoyancyModels/nonlinear_equation_of_state.jl#L27. In the SeawaterPolynomials package, the 'Z' variable must be positive. Thus one (or both) packages must be changed to have the right sign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2528:298,variab,variable,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2528,1,['variab'],['variable']
Modifiability,In the examples I have developed I have tried to always declare variables that are referenced globally in forcing functions or boundary conditions as `const`. Definitely open PRs to fix this if you find places where that isn't the case. I haven't stayed on top of every example that's been added.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881662284:64,variab,variables,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881662284,1,['variab'],['variables']
Modifiability,"In the spirit of getting closer to continuous delivery (see https://www.oxinabox.net/2019/09/28/Continuous-Delivery-For-Julia-Packages.html#what-if-i-dont-want-to-release-right-now--dev-versions) we should probably tag and release v0.43.0 soon since PRs #1070, #1057, and #1061 + couple of bug fix PRs would be useful to have. Release notes:. * Fixes a bug in `TwoDimensionalLeith` (PR #1073, issue #1034). Previously tests were being skipped due to extreme slowness. Now we run tests on GPU (but not CPU, where the closure is much slower to compile). * Rewrites the interface for ""scheduling"" output and diagnostics (PR #1070). Previously output and diagnostics were usually scheduled by specifying either `time_interval` or `iteration_interval` kwargs in the constrcutor for the object in question. Now, the relevant kwarg is called `schedule` and takes a callable `AbstractSchedule` object (or any user-defined function `func` that returns `true` or `false` depending on the single argument `func(model)`). This design is more flexible and extensible, and also simplifies underlying code. Four schedules are provided:. - `TimeInterval(interval)`; - `IterationInterval(interval)`; - `WallTimeInterval(interval)`; - `AveragedTimeInterval(interval; window=interval, stride=1)` (for time-averaging output). Breaking changes:. * Output writers and diagnostics no longer have the keyword arguments `time_interval` or `iteration_interval`. The most commonly-used features that are affected are `JLD2OutputWriter`, `NetCDFOutputWriter`, and `Checkpointer`. `JLD2OutputWriter` and `NetCDFOutputWriter` no longer have the kwargs `time_averaging_window` and `time_averaging_stride`. The specific syntax changes are:. * `time_interval=T` becomes `schedule=TimeInterval(T)`; * `iteration_interval=I` becomes `schedule=IterationInterval(I)`; * `time_interval=T, time_averaging_window=W` becomes `schedule=AveragedTimeInterval(T, window=W)`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1077:554,Rewrite,Rewrites,554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1077,2,"['Rewrite', 'flexible']","['Rewrites', 'flexible']"
Modifiability,"In this PR some structures are refractored such that; - all grids depend on the architecture; - the models takes only the grid as an input. To do so, the architecture is now a positional argument of the grid constructor (so it can be extended by `MultiArch`) as @glwagner suggested. The flow of the script will be something like this now:; ```; arch = ...; grid = Grid(arch, FT; kwargs...); model = NonhydrostaticModel(grid = grid, kwargs...); ```; Some comments on the `MultiArch` architecture...; - `MultiArch` has now a `child_architecture ` field specified on construction; - `MultiArch` still depends on a topology, so, a way to go about it it is to first define a topology and then ; `arch = MultiArch(CPU(), ranks=ranks, topology=topology); grid = (arch, topology=topology, kwargs...)` or to define an architecture without topology and then pass it to the grid. Take care that in this second case it is not guaranteed that `arch == grid.architecture` as the architecture in the grid is constructed from `topology(grid)`; - the grid constructed by `grid(arch::MultiArch; kwargs...)` will be a local grid. To reconstruct the global grid use `reconstruct_global_grid(grid)`. To do; - as of now a field, given `grid(arch::MultiArch; kwargs...)` as an argument, is constructed locally, which is no problem if you `set!` a field from a function but will create problems if you want to `set!` from a global array; - Explore new FFT options to allow more flexibility in the distributed NonhydrostaticModel; - allow GPU halo_passing to support `MultiArch(GPU(); kwargs...)`. Closes #2073 ; Closes #1825",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2078:234,extend,extended,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2078,1,['extend'],['extended']
Modifiability,"In this PR:; - Refactoring of advection to have three different reconstruction schemes: `Centered`, `UpwindBiased` and `WENO`; - advection schemes can be constructed with an `order` keyword argument which goes up to 12 for `Centered` and 11 for upwind schemes; - Reimplementation of boundary treatment: reconstruction method `_symmetric_`, `_left_biased_` and `_right_biased` have their own boundary treatment which entails checking the points for each method differently; - advection scheme have a `boundary_scheme` field which will is used to reconstruct values near the boundary. Boundary schemes use the same method as the _parent_ scheme but with a lower order:; For example, when using a WENO 9th order, closing in near the boundaries the order will be progressively decreased to 7th, 5th, 3rd and finally 1st. It also solves various bugs associated with advection and immersed boundary.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603:15,Refactor,Refactoring,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603,1,['Refactor'],['Refactoring']
Modifiability,"Indeed the pressure solver at the moment allows only a variable z-direction. This is because for a regular grid we can use a full FFT solve while with a singular stretched direction we can solve a tridiagonal system. . For more than one stretched direction we should use an iterative solver to solve the Poisson equation (the solvers are there but the infrastructure not quite yet). We should implement the iterative solver as a default for two or more stretched directions. And set up the FFT-tridiagonal solver as default when we have one stretched direction (either x, y or z). In the meantime, as a hotfix, If you only need one stretched direction I would suggest you to rotate your problem to stretch it in z-direction",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022674786:55,variab,variable,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191#issuecomment-1022674786,1,['variab'],['variable']
Modifiability,"Instructions to adapt the code to `MultiRegion` from a Slack conversation with @simone-silvestri:. If you want to adapt your script to multiregion you have to:; - define a multiregion grid with: `grid = MultiRegionGrid(grid, partition = XPartition(n_gpus_you_want_to_use), devices = n_gpus_you_want_to_use)` . The multiregion grid supersedes the immersed boundary grid, i.e. if you are using an immersed boundary grid then `grid = MultiRegionGrid(ibg; kwargs...)` , not the other way around.; - if you are using any array for forcing or boundary condition, you have to adapt it to the multiregion paradigm as follows: `using Oceananigans.MultiRegion: multi_region_object_from_array; my_adapted_array = multi_region_object_from_array(my_array, grid)`. MultiRegion works only on single node multi GPU, so all the GPUs should be accessible from a single process in the node. You can check the number of GPUs available by logging in a node and typing nvidia-smi , if you want to split your grid on specific devices (let’s say GPU 0 and 3), you can pass `devices = (0, 3)` to the `MultiRegionGrid` constructor. There is another thing that you have to take care of: the pressure solve is performed on one GPU only so both the storage and source term (a field of complex values of the size of the full grid) reside on 1 GPU only (usually the one corresponding to the last region). This means that if your grid is 100M points, 2.98 GB will have to be reserved for the solver’s auxiliary fields; ```julia; julia> sizeof(complex(zeros(Int(100e6)))) / 1024 / 1024 / 1024 * 2; 2.9802322387695312; ```; So make sure you have that space available. (When I have time I ll try to find a solution to run truly parallel pressure solvers, for both nonhydrostatic and hydrostatic models). In terms of outputs, we make use of `reconstruct_global_field` , a function used to reconstruct a global field from a `MultiRegionField` on the CPU. It is used by the output writers to spit out the full field. It is a slow procedure",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875:16,adapt,adapt,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1301096875,3,['adapt'],['adapt']
Modifiability,"Interesting! Good find. This not the only thing to worry about regarding the entrainment diffusivity. It's effect also seems to depend on vertical resolution, and it only seems useful at low resolutions. In general, I recommend switching to CATKEVerticalDiffusivity, where we have put a lot of effort into solving those problems. I'm going to suggest a different solution that setting some maximum capping diffusivity. I think setting a maximum diffusivity could work, but that there are better solutions that more directly address the underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:923,extend,extend,923,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718,2,['extend'],['extend']
Modifiability,Interface for closures (and other model terms) that introduce auxiliary prognostic variables,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2422:83,variab,variables,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2422,1,['variab'],['variables']
Modifiability,Is the PR on KA very crucial?. Would it be a lot of refactoring to have this merged atm with a tagged KA version? This way we don't need to wait for KA?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1610993664:52,refactor,refactoring,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-1610993664,1,['refactor'],['refactoring']
Modifiability,"Is this PR looking for an adopter? Happy to try to complete it since it seems like the first step towards open BCs for hydrostatic models. > > Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions.; > ; > Hopefully we don't have to pass boundary conditions 🥺; > ; > Not all complexity is justified by the performance gains... Ah I'm actually not sure where the performance gains would come from, but I thought that the operators need to be aware of the boundary condition in order to correctly implement open BCs (at least based on @simone-silvestri's comments in https://github.com/CliMA/Oceananigans.jl/issues/3628#issuecomment-2312725203).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617:288,refactor,refactor,288,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2350225617,1,['refactor'],['refactor']
Modifiability,Is this something we want to implement in the future? Would 3D implicit diffusion be useful or just vertically implicit?. I ask because if so it might influence some choices I make when refactoring the Poisson solvers. Vertically implicit diffusion can be implemented with just the `BatchedTridiagonalSolver`. For 3D implicit diffusion I believe we can do a Poisson solve similar to what we do for the pressure but I haven't worked out the math in 3D. It's probably not needed for boundary layer turbulence LES but maybe vertically implicit would be useful for mesoscale simulations?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/587:186,refactor,refactoring,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/587,1,['refactor'],['refactoring']
Modifiability,"It also bears mention that the curious behavior in the lat-lon results above (what looks like spurious boundary fluxes after around 20 days) apparently occurs whether we include the GM parameterization or not. So something else is wrong, perhaps with Bounded boundary conditions on lat-lon (but not sure).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1127186179:185,parameteriz,parameterization,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1127186179,1,['parameteriz'],['parameterization']
Modifiability,"It appears to be related to the size of the grid:. ```julia; julia> grid = RectilinearGrid(GPU(), size=(8, 8, 8), x=(0,1), y=(0,1), z=0:8); 8×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.125; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [0.0, 8.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> minimum_zspacing(grid); 1.0. julia> grid = RectilinearGrid(GPU(), size=(16, 16, 16), x=(0,1), y=(0,1), z=0:16); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.0625; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.0625; └── Bounded z ∈ [0.0, 16.0] variably spaced with min(Δz)=1.0, max(Δz)=1.0. julia> minimum_zspacing(grid); ERROR: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:89; [2] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/error.jl:97 [inlined]; [3] cuLaunchKernel(f::CUDA.CuFunction, gridDimX::UInt32, gridDimY::UInt32, gridDimZ::UInt32, blockDimX::UInt32, blockDimY::UInt32, blockDimZ::UInt32, sharedMemBytes::Int64, hStream::CUDA.CuStream, kernelParams::Vector{Ptr{Nothing}}, extra::Ptr{Nothing}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/utils/call.jl:26; [4] #39; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:69 [inlined]; [5] macro expansion; @ /glade/work/tomasc/.julia/packages/CUDA/BbliS/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#39#40""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3}, ::CUDA.KernelState, ::CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, ::Cartesian",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490603313:371,variab,variably,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3040#issuecomment-1490603313,2,['variab'],['variably']
Modifiability,"It looks like the Langmuir turbulence example is broken (the video generated in the documentation is blank and it does not run on my computer). I think it may be these two lines where the halo regions for each variable are manually removed, but Oceananigans seems to have already extracted those halo regions. This causes the variable and coordinate arrays to be different sizes, leading to a plotting error. https://github.com/CliMA/Oceananigans.jl/blob/24e9c2c3c85cc092913989d6c88d38046998aa07/examples/langmuir_turbulence.jl#L277-L278",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1004:210,variab,variable,210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1004,2,['variab'],['variable']
Modifiability,"It looks like there is a problem with GM. Taking 1 second time-steps without GM, `idealized_one_degree_simulation.jl` produces . ```julia; julia> include(""near_global_one_degree.jl""); underlying_grid = LatitudeLongitudeGrid(arch; size = (Nx, Ny, Nz), halo = (4, 4, 4), latitude, z, longitude = (-180, 180), precompute_metrics = true) = 360×150×48 LatitudeLongitudeGrid{Float64, Periodic, Bounded, Bounded} on CPU with 4×4×4 halo and with precomputed metrics; ├── longitude: Periodic λ ∈ [-180.0, 180.0) regularly spaced with Δλ=1.0; ├── latitude: Bounded φ ∈ [-75.0, 75.0] regularly spaced with Δφ=1.0; └── z: Bounded z ∈ [-5244.5, 0.0] variably spaced with min(Δz)=10.0, max(Δz)=410.5; ┌ Warning: WENO on a curvilinear stretched coordinate is not validated, use at your own risk!!; └ @ Oceananigans.Advection ~/Projects/dev/Oceananigans.jl/src/Advection/weno_fifth_order.jl:160; [ Info: Initializing simulation...; ┌ Info: Iteration: 0, time: 0 seconds, wall time: 5.177 seconds; │ ├── max(u): (0.00e+00, 0.00e+00, 0.00e+00) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 0.00e+00 m; [ Info: ... simulation initialization complete (388.072 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.553 seconds).; ┌ Info: Iteration: 1, time: 1 second, wall time: 28.596 seconds; │ ├── max(u): (1.94e-10, 4.57e-05, 1.03e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 1.03e-06 m; ┌ Info: Iteration: 2, time: 2 seconds, wall time: 1.632 seconds; │ ├── max(u): (9.46e-09, 9.13e-05, 2.06e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 3.09e-06 m; [ Info: Simulation is stopping. Model iteration 3 has hit or exceeded simulation stop iteration 3.; ┌ Info: Iteration: 3, time: 3 seconds, wall time: 843.428 ms; │ ├── max(u): (2.48e-08, 1.37e-04, 3.09e-06) m s⁻¹; │ ├── extrema(T): (0.31, 30.00) ᵒC; └ └── max|η|: 6.17e-06 m; ```. When `IsopycnalSkewSymmetricDiffusivity` is included, however, we find. ```julia; julia> include(""near_globa",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518:637,variab,variably,637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2463#issuecomment-1107298518,1,['variab'],['variably']
Modifiability,"It looks like this PR fixes some issues with complex AbstractOperations, but it does not allow us to use AveragedField on the GPU. I think a possible avenue to explore could maybe be to Adapt an AveragedField by wrapping the underlying, `Adapt`ed data in `Base.Broadcast.Broadcasted`, rather than attempting to adapt `AveragedField` (with its custom `getindex`, which it the crucial part) directly for the GPU. We know that broadcasting with singleton dimensions already works on the GPU and its possible we might borrow some of that machinery. The key function we might want to get a hold of is `_broadcast_getindex`:. https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827:186,Adapt,Adapt,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821774827,3,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"It makes sense that using `const` for variables referenced ""globally"" in functions increases CPU performance, see: https://docs.julialang.org/en/v1/manual/performance-tips/#Avoid-global-variables",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436:38,variab,variables,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800574436,2,['variab'],['variables']
Modifiability,"It seems like the behavior of `WindowedSpatialAverage` can now be achieved by using `Field(Average(field, dims=dims, condition=condition))`. It might be a bit slower, but it's more flexible, so I think we should get rid of `WindowedSpatialAverage`. Closes https://github.com/CliMA/Oceananigans.jl/issues/2185",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2193:181,flexible,flexible,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2193,1,['flexible'],['flexible']
Modifiability,"It seems to me that the use of `Forcing` as sponge/nudging layers that are only active in a small part of the domain is pretty common for code written with Oceananigans. I've done that in pretty much every doubly-periodic upper ocean LES that I've run. With open boundary conditions being implemented in https://github.com/CliMA/Oceananigans.jl/pull/3482, it looks like the use of these thin sponge layers will become even more common. Currently implementing these layers as `Forcing` means they'll be calculated at every point in the domain, regardless of them being useful only in a small region. I wonder if it's worth adding some mapping of active nodes so that we can save computational resources by only calculating `Forcing` where it's needed. If I understand correctly, `ImmersedBoundaryGrid` already has something like that?:. https://github.com/CliMA/Oceananigans.jl/blob/4367d422fd5780396da4ef660acd81a7fccce6df/src/ImmersedBoundaries/active_cells_map.jl#L91-L109. Although I do remember some discussion in the past about how it wasn't always worth passing a map, which is probably why this feature is optional. I'm curious about what people think of this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525:59,layers,layers,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525,3,['layers'],['layers']
Modifiability,It should be pretty easy to adapt `correct_incompressible_immersed_tendencies.jl` to create `correct_shallow_water_immersed_tendencies.jl` to this features to `ShallowWaterModel`. It may also make it easier to test the immersed boundary method as there is no need for a pressure solve in simulating the equations.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1458:28,adapt,adapt,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1458,1,['adapt'],['adapt']
Modifiability,"It would be nice to convert it into a discussion, but I think we want to correct the AB2 for variable time stepping quite soon, because it might be a large source of error.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313282962:93,variab,variable,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313282962,1,['variab'],['variable']
Modifiability,"It's currently defined _after_ these:. https://github.com/CliMA/Oceananigans.jl/blob/72e2197e640ddf308fd40aa4658e7686e596bccd/src/Oceananigans.jl#L194-L215. in addition, `ImmersedBoundaries` extends a bunch of functions that were defined in `Advection` and `TurbulenceClosures`. But this is backwards: `ImmersedBoundaries` should be regarded as a fundamental extension of `Grids`. Then `Advection` and `TurbulenceClosures` should provide functionality that is valid on regular and immersed grids. This is a necessary change to split the repo in the future: we want to regard ""advection"" and ""turbulence closures"" as part of the model/physics, and as immersed boundaries as ""physics-agnostic"", ie, more fundamental. More practically it's the cause of some pain. For example, we can't mask immersed fields within `TurbulenceClosures` without changing how we currently define `mask_immersed_field!`. And so on. Things are tangled. I think maybe immersed boundaries belong right after grids, then `Fields` should define `mask_immersed_field!`. So making this change would distribute a lot of the immersed boundary functionality throughout the code. This is probably a natural evolution, since we used to think that immersed boundaries were an experimental add-on. Now its not. @simone-silvestri curious about your opinion since you've worked on a lot of this.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3062:191,extend,extends,191,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3062,1,['extend'],['extends']
Modifiability,"It's easy to extend the existing simple test to a two-output case, so I did that on #1807. If #1807 passes, then there is some other aspect of the setup that's producing a failure. It's also possible that there is more than one problem / cause of woe.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947:13,extend,extend,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1517#issuecomment-873162947,2,['extend'],['extend']
Modifiability,"It's hard because even [wikipedia](https://en.wikipedia.org/wiki/Stokes_drift) is misleading on this subject and says. > For a pure wave motion in fluid dynamics, the Stokes drift velocity is the average velocity when following a specific fluid parcel as it travels with the fluid flow. Yet if a mean velocity exists, the motion is not a ""pure wave"" motion; it has a mean component and a wave component, each of which have dynamics that are independent in the limit of small amplitude waves. In other words, if particles and thus fluid undergo some net drift, then some external mean force must have imparted mean momentum to the fluid. So the first sentence of the Wikipedia article misleads. It's easy to get this wrong because in many systems the mean dynamics are ""trivial"" and do not evolve. But this is not always the case... The reason this subject is so tricky is because the physics of surface gravity waves _require_ a transfer of mean momentum from some external agent if they are excited (this is part of what it means for a wave field to have pseudomomentum). Thus the forced growth of waves is _also_ associated with a transfer of mean momentum (from the atmosphere to the ocean). But the mean momentum so transferred is not by any reasonable definition a ""wave property""; it undergoes an independent evolution and is easily divorced from wave fields that propagate rapidly away. In particular, if the system is rotating, the mean momentum excites a stationary inertial oscillation that has no net transport over long periods of time (while the wave field happily propagates ad infinitum)... Not that Wikipedia was always right before this on every topic --- but the view on Wikipedia is the same one that's taught in classrooms. I think users know _mathematically_ what is indicated by the keyword `stokes_drift`, especially if we well-document the fact that we solve for the Lagrangian-mean velocity. That's probably the most important thing. Buhler (2014) provides a good perspective ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611:789,evolve,evolve,789,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777919611,1,['evolve'],['evolve']
Modifiability,"It's just a suggestion... Perhaps it's not needed. But having it as a parameter of the type could be useful, even if the parameter is the same value as `grid.Nz` because if it's part of type you can write methods that do different things based on the number of layers your model has. E.g.,. ```Julia; function compute_this_and_that(model::ShallowWaterModel{1}); a = 1 # simple calculation for single-layer models; return a; end. function compute_this_and_that(model::ShallowWaterModel); number_of_layers = model.number_of_layers; a = sum(rand(number_of_layers)) # more complicated stuff only needed for multi-layer models; return a; end; ```. This way we don't use `if number_of_layers > 1; do this; else; do that` which reduces performance because the compiler has to compile all cases and check every time the value of layers and do this or the other....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127:261,layers,layers,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469188127,4,['layers'],['layers']
Modifiability,"It's mirroring Base julia, eg. ```julia; julia> a = rand(2, 3, 4); 2×3×4 Array{Float64, 3}:; [:, :, 1] =; 0.264469 0.977549 0.937297; 0.491955 0.710279 0.315507. [:, :, 2] =; 0.243796 0.783644 0.820073; 0.682626 0.351825 0.503396. [:, :, 3] =; 0.726912 0.287171 0.671998; 0.234873 0.993365 0.913062. [:, :, 4] =; 0.507489 0.568977 0.327032; 0.59475 0.547478 0.459589. julia> size(a, 3); 4; ```. We've extended `size` for fields, and `1, 2, 3` do currently correspond to the first, second, and third dimensions in that syntax. So I don't agree that it ""means nothing"", but perhaps we want something else for our API... I do agree that having named dimensions is a cool idea. I wonder if it'd be better to do this properly in the sense of #1700 or https://rafaqz.github.io/DimensionalData.jl/stable/course/#Dimensions-and-DimArrays rather than just providing functions like `size(c::AbstractField, :x)`...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-971713695:401,extend,extended,401,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2058#issuecomment-971713695,1,['extend'],['extended']
Modifiability,"It's needed when your computation is located on `Face`s. By default, `work_layout` returns a layout that extends from ""1 to `N`"". This default is used for time-stepping kernels. But for diagnostics you usually want that last grid point at `N+1`. It might make sense to change the default value, since users / people writing new kernels probably want `include_right_boundaries=true`, and its only a minority of rarely-changed kernels (for time-stepping) that want `include_right_boundaries=false`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1290#issuecomment-756170764:105,extend,extends,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1290#issuecomment-756170764,1,['extend'],['extends']
Modifiability,It's so nice that we have these tests. Seeing them pass makes me so confident that you did this matrix constructor refactor correctly @elise-palethorpe.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1180287052:115,refactor,refactor,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1180287052,1,['refactor'],['refactor']
Modifiability,"It's something to do with GPU, maybe GPU reductions?. ```; [2023/05/24 21:41:15.102] INFO Testing grid utils on variably spaced grid....; --;   | Grid initialization: Test Failed at /net/ocean/home/data44/data5/glwagner/.buildkite-agent/builds/sverdrup-4/clima/oceananigans/test/test_grids.jl:199;   | Expression: minimum_xspacing(grid) ≈ FT(π / 3);   | Evaluated: 0.0 ≈ 1.0471975511965976; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1564733331:112,variab,variably,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3100#issuecomment-1564733331,1,['variab'],['variably']
Modifiability,"It's true that global variables have to be defined as `const`, but it's also true that global variables are never ""required"" (they just may be more convenient than defining a callable struct)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458703878:22,variab,variables,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458703878,2,['variab'],['variables']
Modifiability,"It's very exciting! I was just remarking about ""we have to comment X out"". Extending a method that doesn't work on the cubed sphere is practically the same amount of work (in this case), and illustrates the proper workflow when developing a new feature (often methods will have to be extended, since they may make assumptions that are no longer valid). So I wanted to point that out in case people run into this in the future and use it as a template for their own development. Also if you are working with others, being clear about the development that's needed can help coordinate efforts.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432:75,Extend,Extending,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3204#issuecomment-1719386432,3,"['Extend', 'extend']","['Extending', 'extended']"
Modifiability,"Just a quick thought: mathematically it sometimes makes sense to use boundary conditions to reduce the size of the function space a variable can live in, i.e. considering a certain field to be in the space of functions that have zero value (or zero normal derivative) at a boundary. Physically, though, I'm not sure this is so useful, since many systems have non-trivial boundary conditions, including nonlinear conditions and conditions involving multiple fields. Then the notion of a certain BC even ""belonging"" to a certain field is a little less clear... you may just have a set of fields that need to collectively satisfy a set of conditions on the boundary. E.g. thermal radiation conditions (heat flux depends nonlinearly on temperature); E.g. nontrivial stress BCs (maybe where viscosity is temperature-dependent, like ice)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260:132,variab,variable,132,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/606#issuecomment-580349260,1,['variab'],['variable']
Modifiability,Just a small plea to make this implementation compatible with / moves us towards the refactor envisioned in #2454,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128350043:85,refactor,refactor,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128350043,1,['refactor'],['refactor']
Modifiability,"Just an update (mostly for my own benefit later), apparently the outputs are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArr",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:188,variab,variables,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,4,"['Variab', 'variab']","['Variable', 'variable', 'variables']"
Modifiability,"Just as an update --- we actually currently cannot do this verification experiment because of a problem with LES models (a theoretical problem, not an implementation problem) with specified buoyancy flux boundary conditions and zero stress boundary conditions. In short, we observe grid-scale oscillations in the near-surface buoyancy gradient when buoyancy fluxes are specified. The primary issue is associated with a too-small near-surface LES diffusivity. . I want to emphasize that this is not a numerical issue with boundary condition specification, or a bug in the LES implementation --- this is a fundamental, theoretical problem with LES formulation. Others have observed this issue before with a variety of LES formulations, so this issue is not particular to AMD, either. I'm working on a fix because this is an important, canonical problem. The easiest way to fix the problem is to allow the LES model constant (which we should view as a free parameter) to vary in space and in particular to increase near the wall. This is simple, yet completely empirical solution. . The level of empiricism / near-wall enhancement of the model constant needed for a smooth solution is mitigated somewhat if we can specify the gradient of buoyancy / temperature on the boundary. This second component of the fix can be done by introducing a wall model on top of the interior LES formulation that applies *on* boundaries. The wall model introduces a second free parameter in addition to the interior LES free parameter. Adjusting the wall model's free parameter allows us to ""effectively"" increase the near-wall value of the AMD diffusivity. An even better, more complete fix would also modify the interior LES model near the wall. But this is an open-ended science problem with no clear solution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/547#issuecomment-580299239:1116,enhance,enhancement,1116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/547#issuecomment-580299239,1,['enhance'],['enhancement']
Modifiability,"Just for completeness, what do we think about `pseudomomentum`?. The issue with Stokes ""drift"" is that it implies a ""drifting"" which is not quite the right way to think about how surface waves affect the motion of fluid beneath them. In reality, average momentum (and thus any ""drifting"" that might occur) is imparted by external forces (such as the atmosphere); the averaged effect of surface waves is rather more subtle and is associated with changes to the relationship between mean momentum and vorticity (eg, vorticity feels the effect of pseudomomentum, despite that momentum does not). These concepts are confused routinely in the literature, so our community doesn't have a solid conceptual foundation on which standardized terminology is easily built. But suffice to say that in practice most people say ""Stokes drift"" but mean ""pseudomomentum"". In the context of Oceanagnians of course the prognostic variable _is_ the mean momentum (the Lagrangian-mean velocity field), thus this keyword really does control psuedomomentum with no impact on ""drifting""...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818:911,variab,variable,911,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1331#issuecomment-777144818,1,['variab'],['variable']
Modifiability,"Just for reference, I created the MWE example below of a column model with a sheared `u` that evolves in time, where I write both the full `u` and an interpolated `u` to half the original resolution. What I'm doing here is creating a coarse grid, coarse model, and coarse field that takes the interpolated `u`. I use a `Callback` to keep interpolating `u` into `coarse_u` and then it's only a matter of setting up a coarse `NetCDFWriter` with `coarse_model`. ```julia; using Oceananigans. grid = RectilinearGrid(size = (1, 1, 8), extent = (1,1,1));; model = NonhydrostaticModel(; grid, closure = ScalarDiffusivity(ν=1e-2)). set!(model, u=(x, y, z,) -> z). simulation = Simulation(model,; Δt=0.5*maximum(zspacings(grid, Center())) / maximum(abs, model.velocities.u),; stop_time=20); # Create regular output; simulation.output_writers[:fullfields] = NetCDFOutputWriter(model, (; model.velocities.u),; filename = ""fullfields.nc"",; schedule = TimeInterval(5),; overwrite_existing = true,). # Create interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_model = NonhydrostaticModel(; grid=coarse_grid, closure = ScalarDiffusivity(ν=1e-2)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(coarse_model, (; coarse_u,),; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. This seems to be working. In the figure below the lines and triangles come from the full res output, while the cirlces come from the coarse (interpolated) output:. ![image](https://github.com/CliMA/Oceananigans.jl/assets/13205162/1a72237a-67ac-4804-9230-9d766e71b353). You can definitely take nicer/fancier a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2090846777:94,evolve,evolves,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3460#issuecomment-2090846777,2,['evolve'],['evolves']
Modifiability,Just merging this so I can work on cleaning up the examples. Couple of NetCDF related issues I hit:; * [NetCDF.jl](https://github.com/JuliaGeo/NetCDF.jl) seems to be missing some features and isn't really being maintained (See https://github.com/JuliaGeo/NetCDF.jl/issues/62 about saving time values and https://github.com/JuliaGeo/NetCDF.jl/issues/39). Maybe it's worth switching to [NCDatasets.jl](https://github.com/Alexander-Barth/NCDatasets.jl) which takes a more data frames approach to NetCDF and is actively maintained and grew out of bugs that weren't being fixed in NetCDF.jl. Unfortunately we're choosing between two relatively young packages. An alternative would be to use the much more mature [netcdf4-python](http://unidata.github.io/netcdf4-python/) but I'd rather not have to use PyCall...; * We might need to decide on some standard field/variable names. #91; * Output might need to take into account cell-centered and face-centered fields #92. Reopens #31,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/93:857,variab,variable,857,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/93,1,['variab'],['variable']
Modifiability,"Just moving an email thread to a GitHub issue:. > 1. Is it hydrostatic or non-hydrostatic? On GitHub it says 'It is designed to solve the rotating Boussinesq equations used in non-hydrostatic ocean modeling but can be used to solve for any incompressible flow.' so it implies it's non-hydrostatic?; > 2. Since currently only cartesian coordinate is supported, is it possible to set the Coriolis force with rotation axis at the center of the domain and specify the grids in the shape of a circle around this axis as if it's a rotating cylinder but not in cylindrical coordinate?; > 3. Is eddy parameterization supported, like the GM-Redi/Visbeck package in MITgcm?; > 4. for the boundary condition, is topographic feature supported?; I see in the online doc the UVelocityBoundaryConditions probably can be used to set non-slip boundary but features like topographic wall would still need extra setting right? Is it something related to gradient or no-penetration?; >; > _Originally posted over email_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/770:592,parameteriz,parameterization,592,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/770,1,['parameteriz'],['parameterization']
Modifiability,"Just to add a reference, [Kevlahan et al. 2015](http://doi.org/10.5194/gmd-8-3891-2015) doesn't discuss multiple layers, but seems to do a good job incorporating bathymetry and immersed-boundary continents that have proper wave reflection and don't increase wave speeds inside the continents. I'm trying this model out in Dedalus and maybe it's possible to extend this approach to multiple layers, but I'm not a shallow water expert.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116178998:113,layers,layers,113,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1116178998,3,"['extend', 'layers']","['extend', 'layers']"
Modifiability,"Just to be clear, the point of doing this is because you want to use dispatch to write flexible array operations that are agnostic to whether the array is a 'raw' array (like an `Array` or `CuArray`), or some kind of wrapper like an `OffsetArray`. By writing `parent(a)`, you ensure correct behavior on `a` in both cases; you don't need to write new high-level functions for wrappers versus arrays because dispatch is performed at the lower level, where it belongs. With `data` we can use the same logic --- this concept is deployed extensively in PR #463.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350:87,flexible,flexible,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/454#issuecomment-542269350,1,['flexible'],['flexible']
Modifiability,"Just to frame the discussion: this is probably most important in the context of new users or scientists trying to read examples, docs, and scripts that implement numerical experiments for scientific purposes. In that context I agree with @ali-ramadhan that `BoussinesqModel` is misleading for models with `tracers = nothing` and `buoyancy = nothing`. I think we've also discussed making this default, since its simple... As for the distinction between hydrostatic and non-hydrostatic models I agree that with currently supported configurations, `NonhydrostaticRigidLid` is better than `HydrostaticFreeSurfaceModel`. I'm only hesitant about this change because I wonder if we may want to combine these two models in the future. The motivation to develop `HydrostaticFreeSurfaceModel` separately is largely practical and caves to short term timeline pressures (it's easier to break things when nobody's using it, and we throw a warning right in the constructor so people know its experimental). In the long run it might make sense to have just a single interface to all incompressible models and support all combinations of hydrostatic, non-hydrostatic, free surface / rigid lid, etc through a single interface, similar to what MITgcm offers. The interfaces / model specific code is expensive to maintain, which motivates having just one interface. If this is our goal, it'd be premature to change the name of `IncompressibleModel`. If people feel they'd like to commit to maintaining two interfaces / model constructors / time-stepping code then I think changing the name to be clearer but less general is an option to consider. I personally would rather maintain as few `AbstractModel` as possible because I feel they are fairly expensive in terms of person-time to maintain. And we probably have a lot of improvements that need to be made (features like `model.auxiliary_fields`, `VectorField` for velocity field rather than baking in the coordinate system which fails on the cubed sphere), proper su",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772:529,config,configurations,529,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1620#issuecomment-827842772,2,['config'],['configurations']
Modifiability,"KE) * L_mix` with a mixing length `L_mix`, but also to energetically constrain the backscatter in the momentum equation. See this schematic, modified from Figure 1, Jansen et al. (2019):; ![MEKE_schematic](https://user-images.githubusercontent.com/23617395/167711268-23732094-80aa-476e-8f13-fd6cd8659e8c.png); So how about `PrognosticMEKEDiffusivity` and `PrognosticMEKEBackscatter`? Probably good to keep these 2 separated to be able to switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:1730,variab,variable,1730,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,1,['variab'],['variable']
Modifiability,KernelComputedField CubedSphere support plus internal CubedSpheres refactoring,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1603:67,refactor,refactoring,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1603,1,['refactor'],['refactoring']
Modifiability,"Kind of a leftover relic I forgot to cleanup, but boundary condition API kernels still use the old `Tx, Ty` and `Bx, By, Bz` values to launch kernels. We should switch them to use dynamic launch configuration like all the other time stepping kernels.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/363:195,config,configuration,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/363,1,['config'],['configuration']
Modifiability,"L.REPLBackend, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:180; │ [27] run_repl(::REPL.AbstractREPL, ::Any; backend_on_current_task::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:292; │ [28] run_repl(::REPL.AbstractREPL, ::Any) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/REPL/src/REPL.jl:288; │ [29] (::Base.var""#807#809""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:13",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:3825,variab,variable,3825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,1,['variab'],['variable']
Modifiability,"Let me try to reframe the problem and tell me if you agree. I think its a real issue that the output files are created when the output writers are instantiated. Because of this, we find ourselves having to write `overwrite_existing=false` when we pickup from a checkpoint, but `overwrite_existing=true` otherwise. This is a hack for sure. It's a failure of the checkpointer design --- the whole point of the design is to make checkpointing easy. We should be able to change just one line. I even think we should be able to pick up from a checkpoint with an environment variable so we don't have to change the run script at all. That would be more robust. What you're describing sounds like an additional problem of this deficiency. The fix seems straightforward. We just need to introduce the concept of output ""initialization"". Then we can delay creating the output file to `run!`. At that point we know if we are picking up from a checkpoint or not, obviously if we are picking from a checkpoint we don't want to delete any existing files. It seems like if we introduce initialization we can also handle file splitting. What do you think? If you want to help we can get started on it. I was putting it off myself because I don't have immediate needs for checkpointing but that will probably change pretty soon. Separately I don't like I also don't like `overwrite_existing` more broadly because I feel its boilerplate, which we are discussing a bit over on #3793 .",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391318167:569,variab,variable,569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391318167,1,['variab'],['variable']
Modifiability,Looks like a good interface to me. But is it on purpose that there is only support for background fields in the `NonhydrostaticModel` and not for the `HydrostaticFreeSurfaceModel`?. @liuchihl will test it in our configurations.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204239079:212,config,configurations,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2204239079,1,['config'],['configurations']
Modifiability,Looks like this PR only updates Adapt to v2.4.0 and not v3.0.0 so maybe it's being blocked by a dependency (which probably has a similar CompatHelper PR open right now). I think we should wait to check that all tests pass with Adapt v3.0.0 before merging.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548:32,Adapt,Adapt,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-754962548,2,['Adapt'],['Adapt']
Modifiability,"Looks like this happened after PR #1740 was merged as https://buildkite.com/clima/oceananigans/builds/2893 looks fine (GPU tests running on the commit before #1740 was merged) but the next commit/build on master is not fine https://buildkite.com/clima/oceananigans/builds/2895 (no GPU tests on the #1740 merge commit). Maybe this had something to do with CUDA.jl v3.3.0 or with the addition of the `JULIA_CUDA_USE_BINARYBUILDER=""true""` environment variable?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-871698977:448,variab,variable,448,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1794#issuecomment-871698977,1,['variab'],['variable']
Modifiability,"Lots of interesting discussion here. Nomenclature can be a pain as people use a lot of different words for the same things and sometimes use the same word for different things. I wonder whether finding a good review article and citing that would be a good way to establish our foundation? I imagine there is a lot to choose from out there but don't have a specific one in mind. Below are a few thoughts. 1) I would argue that molecular viscosity is real (resolved) physics, in these continuum models, is derived from physical principles and you should not change the coefficients based on the grid you are using. These are measured in experiments and are what the community to believe as true when doing lab experiments. 2) For large-scale flows, as many of us consider, molecular viscosity is insignificant and should probably be ignored as it has no real meaning on the large scales. That is why summing molecular and eddy viscosities does not seem like such a good idea to me. However, adding a very small number to a large number will nto make much of a difference for all intensive purposes. I would think that the user has the onous of responsibility of picking the viscosity that is appropriate for their problem. . 3) For large-scale flows where you need some parameterization, I think that using `eddy` or `sgs` are accepted by large groups in the community. Effective seems a little less desirable for me as it does not say where it comes from.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775339859:1268,parameteriz,parameterization,1268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1277#issuecomment-775339859,1,['parameteriz'],['parameterization']
Modifiability,"MWE:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10),; x = (0, 1),; z = (0, 1),; topology = (Periodic, Flat, Bounded)). mask = GaussianMask{:x}(center=1, width=0.1); sponge = Relaxation(rate=1; mask). model = HydrostaticFreeSurfaceModel(; grid, forcing = (; u=sponge)). simulation = Simulation(model; Δt=1, stop_iteration=1); run!(simulation); ```. The fix is a little involved because we can't distinguish between the arguments `(y, z)` and `(x, y)` by function arguments alone. Thus the mask itself needs to have grid information. This and other bug are the extended consequences of changing `node` to drop flat dimensions (#3355, with discussion on #3285). I still think the price was worth it for betting scripting, but it has come with a pretty significant trade-off in terms of under the hood code complexity...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3728:582,extend,extended,582,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3728,1,['extend'],['extended']
Modifiability,Major documentation refactoring for JOSS,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/570:20,refactor,refactoring,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570,1,['refactor'],['refactoring']
Modifiability,Major refactor of TurbulenceClosures module plus more tests for HydrostaticFreeSurfaceModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1449:6,refactor,refactor,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449,1,['refactor'],['refactor']
Modifiability,Major refactor of `FieldBoundaryConditions`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843:6,refactor,refactor,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843,1,['refactor'],['refactor']
Modifiability,"Making it easier to evolve tracers *only* after a certain time keeping them ""frozen"" until then",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154:20,evolve,evolve,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154,1,['evolve'],['evolve']
Modifiability,Making it easier to set up and configure scripts with checkpointing on clusters with time limits,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/779:31,config,configure,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779,1,['config'],['configure']
Modifiability,Maybe better to extend the `Checkpointer` constructor specifically for `ShallowWaterModel`?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2866#issuecomment-1384668956:16,extend,extend,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2866#issuecomment-1384668956,1,['extend'],['extend']
Modifiability,Maybe it did need some of the overwrite existing because it writes different configurations to the same file. Update: passes locally if I add them back,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1570636076:77,config,configurations,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3027#issuecomment-1570636076,1,['config'],['configurations']
Modifiability,"Might be cool to be able to dispatch on the order so the order could be specified as part of the model, e.g. ```julia; model = ShallowWaterModel(grid=grid, order=4); ```. and it would make it easier to use the operators in other models. We could define new types like. ```julia; struct SecondOrderCenteredDifference end # one option; struct CenteredDifference{N} end # another option; ```. then dispatch on `::SecondOrderCenteredDifference` or `::CenteredDifference{Val{4}}` or we could dispatch on numbers via `Val`. ```julia; julia> δ(i, A, ::Val{2}) = A[i] - A[i-1]; δ (generic function with 1 method). julia> δ(i, A, ::Val{4}) = (-2A[i+1] + 16A[i] - 16A[i-1] +2A[i-2]) / 12; δ (generic function with 2 methods). julia> δ(10, collect(1:20) .^ 2, Val(2)); 19. julia> δ(10, collect(1:20) .^ 2, Val(4)); 15.833333333333334; ```. but might have to be careful to [avoid performance regressions with `Val`](https://docs.julialang.org/en/v1/manual/performance-tips/#man-performance-value-type). That said it might take a non-trivial amount of refactoring to support and test dispatching on the operator order, at least for the incompressible model. Maybe it makes sense for `ShallowWaterModel` to add support for 4th-order operators first (with or without dispatch, probably easier without first) and from there we can investigate how to generalize?. If we go all out and start supporting lots of different operators I wonder if it's worth looking into [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl) or [FiniteDifferences.jl](https://github.com/JuliaDiff/FiniteDifferences.jl). Not sure what role these packages would play. From skimming the FiniteDifferences.jl README it seems that there are no higher-order non-allocating implementations between the two packages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155:1039,refactor,refactoring,1039,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1265#issuecomment-740952155,1,['refactor'],['refactoring']
Modifiability,"Might be good to add a test (or more than just one) for windowed fields. Even a simple one like. ```julia; windowed_field = CenterField(grid, indices=(:, :, 1:1)); @test view(windowed_field, :, :, 1:1) isa AbstractArray; ```. or something. @siddharthabishnu can you add that? Pretty basic test so probably belongs in `test_field.jl`:. https://github.com/CliMA/Oceananigans.jl/blob/sb/extend-parent-indices/test/test_field.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2088811397:384,extend,extend-parent-indices,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2088811397,2,['extend'],['extend-parent-indices']
Modifiability,Might be good to choose some standard names for the NetCDF variables (and output in general). Following the standard CMIP6 names might be one idea. Apparently some programs assume that NetCDF variables follow these conventions. See:; * https://www.earthsystemcog.org/projects/wip/CMIP6DataRequest; * http://clipc-services.ceda.ac.uk/dreq/index/standardname.html,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/91:59,variab,variables,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/91,2,['variab'],['variables']
Modifiability,"Might be interesting to give adaptive time-stepping a try. @christophernhill says it didn't work super well last time they tried it in the MITgcm but that might have been a long time ago. I suspect for most MITgcm runs, which act on large horizontal domains, the time step is severely limited by vertical motions which may not be true for all Oceananigans simulations. Not sure if this changes anything. I suspect you just calculate the time step using; ```julia; C = 1 # Maximum Courant number. Probably 1 for our explicit AB2 time-stepping scheme. Δt_x = C*Δx / maximum(abs.(u)); Δt_y = C*Δy / maximum(abs.(v)); Δt_z = C*Δz / maximum(abs.(w)). Δt = min(Δt_x, Δt_y, Δt_z); ```. Even if we don't use adaptive time-stepping, it might be a useful `CFLChecker` diagnostic that prints warnings when CFL is being violated.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/189:29,adapt,adaptive,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/189,2,['adapt'],['adaptive']
Modifiability,Might make sense to figure out how to `@assert` that the benchmark is configured correctly?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885658285:70,config,configured,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885658285,1,['config'],['configured']
Modifiability,Minor enhancement to ocean mixing example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2057:6,enhance,enhancement,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2057,1,['enhance'],['enhancement']
Modifiability,More / more flexible Smagorinsky models,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3637:12,flexible,flexible,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3637,1,['flexible'],['flexible']
Modifiability,"More of a general issue that #1118 made me think about is that we've been mixing data types and instantiated types. For example, we use data types when constructing grid topologies and specifying locations for abstract operations:. ```julia; topology = (Periodic, Bounded, Bounded); kinetic_energy @at (Cell, Cell, Cell) (u^2 + v^2) / 2; ```. but instantiated types when specifying which architecture and advection scheme to use. ```julia; model = IncompressibleModel(grid=grid, architecture=GPU(), advection=WENO5()); ```. It seems there's some element of memorization to know which one to use when. Maybe this will confuse future users (certainly it confused us in #1118). Changing this behavior would require a lot of refactoring but probably worth discussing whether changing makes sense or if we can make the user interface more robust and friendly to mismatches between data types and instantiated types?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1119:721,refactor,refactoring,721,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1119,1,['refactor'],['refactoring']
Modifiability,Most of the sandbox scripts are very stale and could be misleading so I'm nuking them. Simulation scripts should go in respective repositories at this point. Sandbox scripts that are worth making into examples can go into `examples/`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/367:12,sandbox,sandbox,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/367,2,"['Sandbox', 'sandbox']","['Sandbox', 'sandbox']"
Modifiability,"Mostly I am worried about scalability and sustainability in this design, or future designs. . Currently our models are fairly simple, but its challenging to place bounds on potential future complexity. For example, models in the future may require additional fields associated with closures or parameterizations, such as boundary layer depth fields, in-plume tracer concentrations and vertical momentum, precomputed mixing length fields, and perhaps other auxiliary fields associated with various prognostic / diagnostic LES models. We probably can't plan to support setting boundary conditions on every possible field via the model constructor. With our current design we have essentially special-cased turbulent diffusivities because our focus is LES, turbulent diffusivities are relatively common, and it convenient for us. However doing this incurs some maintenance burden --- which will increase if we plan to hard-code validation and error checking. Food for thought.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798:294,parameteriz,parameterizations,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605453798,1,['parameteriz'],['parameterizations']
Modifiability,"Navid here is the output-; ```; julia> using Pkg. julia> Pkg.activate("".""); Activating environment at `~/new_directory/Project.toml`. julia> print(read(""Manifest.toml"", String)); # This file is machine-generated - editing it directly is not advised. [[AbstractFFTs]]; deps = [""LinearAlgebra""]; git-tree-sha1 = ""485ee0867925449198280d4af84bdb46a2a404d0""; uuid = ""621f4979-c628-5d54-868e-fcf4e3e8185c""; version = ""1.0.1"". [[Adapt]]; deps = [""LinearAlgebra""]; git-tree-sha1 = ""f1b523983a58802c4695851926203b36e28f09db""; uuid = ""79e6a3ab-5dfb-504d-930d-738a2a938a0e""; version = ""3.3.0"". [[ArrayInterface]]; deps = [""IfElse"", ""LinearAlgebra"", ""Requires"", ""SparseArrays"", ""Static""]; git-tree-sha1 = ""2fbfa5f372352f92191b63976d070dc7195f47a4""; uuid = ""4fba245c-0d91-5ea0-9b3e-6abc04ee57a9""; version = ""3.1.7"". [[Artifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""c30985d8821e0cd73870b17b0ed0ce6dc44cb744""; uuid = ""56f22d72-fd6d-98f1-02f0-08ddc0907c33""; version = ""1.3.0"". [[BFloat16s]]; deps = [""LinearAlgebra"", ""Test""]; git-tree-sha1 = ""4af69e205efc343068dc8722b8dfec1ade89254a""; uuid = ""ab4f0b2a-ad5b-11e8-123f-65d77653426b""; version = ""0.1.0"". [[Base64]]; uuid = ""2a0f44e3-6c83-55bd-87e4-b1978d98bd5f"". [[CEnum]]; git-tree-sha1 = ""215a9aa4a1f23fbd05b92769fdd62559488d70e9""; uuid = ""fa961155-64e5-5f13-b03f-caf6b980ea82""; version = ""0.4.1"". [[CFTime]]; deps = [""Dates"", ""Printf""]; git-tree-sha1 = ""bca6cb6ee746e6485ca4535f6cc29cf3579a0f20""; uuid = ""179af706-886a-5703-950a-314cd64e0468""; version = ""0.1.1"". [[CUDA]]; deps = [""AbstractFFTs"", ""Adapt"", ""BFloat16s"", ""CEnum"", ""CompilerSupportLibraries_jll"", ""DataStructures"", ""ExprTools"", ""GPUArrays"", ""GPUCompiler"", ""LLVM"", ""Libdl"", ""LinearAlgebra"", ""Logging"", ""MacroTools"", ""NNlib"", ""Pkg"", ""Printf"", ""Random"", ""Reexport"", ""Requires"", ""SparseArrays"", ""Statistics"", ""TimerOutputs""]; git-tree-sha1 = ""e4b37e96b0ff53f46b13b49d7e9091b154757dc4""; uuid = ""052768ef-5323-5732-b1bb-66c8b64840ba""; version = ""2.4.3"". [[Cassette]]; git-tree-sha1 = ""742fbff99a2798f02bd37d250",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:422,Adapt,Adapt,422,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,Need to update `ParameterizedForcing` constructor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/785:16,Parameteriz,ParameterizedForcing,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/785,1,['Parameteriz'],['ParameterizedForcing']
Modifiability,Neutral boundary layers are not unstable,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1983:17,layers,layers,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1983,1,['layers'],['layers']
Modifiability,"New parameters for `RiBasedVerticalDiffusivity` in this PR as well @simone-silvestri . https://user-images.githubusercontent.com/15271942/227622141-c682b9d5-8848-4f3d-9734-aa258463b2f3.mp4. Note the TKE variable has no dynamics, just a passive tracer for ri-based.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3016#issuecomment-1483311126:203,variab,variable,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3016#issuecomment-1483311126,1,['variab'],['variable']
Modifiability,Nice adaptations. I agree with modifying the NaNchecker as a stop criteria (which outputs also the NaN location). No need to have simulations timestepping with NaNs,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2048#issuecomment-968916615:5,adapt,adaptations,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2048#issuecomment-968916615,1,['adapt'],['adaptations']
Modifiability,"Nice!. I was actually going to advocate for adding such a utility because I've found myself running a few tests where the time steps are likely to be diffusion limited:; 1. possibly stratified Couette flow sometimes,; 2. the Pearson vortex test from PR #336,; 3. more recently the [forced flow test](https://github.com/climate-machine/Oceananigans.jl/blob/5355044deae3120134b55cc20f6e38f637eea6a5/test/verification/forced_flow.jl) from (Brown, Cortez, & Minion, 2000) that I'm using to test whether our operator-splitting method is second-order accurate in both velocity and pressure. For geophysical flows, the time step will almost always be limited by advection, but there seem to be many other flows where the time step will be limited by diffusion. So if we want a package that is usable for not just geophysical flows, it would be nice to have adaptive time stepping that works with both advective and diffusive CFL.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/360#issuecomment-526919951:850,adapt,adaptive,850,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/360#issuecomment-526919951,1,['adapt'],['adaptive']
Modifiability,"No need to apologize! To extend a method, you can `import` it:. ```julia; import Oceananigans.Grids: with_halo. with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ```. Alternative syntax is. ```julia; using Oceanigans.Grids. Grids.with_halo(halo, ibg::ImmersedBoundaryGrid) = ImmersedBoundaryGrid(with_halo(halo, ibg.grid), ibg.immersed_boundary); ```. These are identical and the difference is just a matter of style. Syntax for namespace management is documented here: https://docs.julialang.org/en/v1/manual/modules/#using-and-import-with-specific-identifiers,-and-adding-methods",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844531769:25,extend,extend,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-844531769,1,['extend'],['extend']
Modifiability,"No worries about the late response! Here's a couple of comments, might have more later. > The current implementation I have going projects the velocity into tangential and normal directions (with respect to the immersed surface) before interpolating over the boundary. Since the boundary can be pretty variable in made more sense for us to take this approach. So the user would specify what they want the two tangential and 1 normal direction to be instead of (u,v,w) specifically. Right, this is what I mean by having an ""abstraction for vectors"" --- awesome! If the momentum equation is treated in vector form then the three components are coupled. User specification is then on the vector momentum equation; users will specify `VelocityBoundaryConditions` (rather than boundary conditions for each component, and `VectorForcing`, rather than forcing on each component. It may also make sense to coalesce the kernels that compute tendencies for each velocity component (but I'm less sure about that). Either way this is a major change to the API at the very least, but probably necessary and something we also need for complex domains for GCM simulations, like the cubed sphere. > the original idea was to infer Flux from Gradient. This makes sense for a continuous immersed boundary where it's not possible to _discretely_ specify fluxes. If we can't discretely specify fluxes, we have to rely on a diffusivity extracted from the specified turbulence closure. This is simple for closures that have isotropic diffusivities, but gets more complicated for closures with anisotropic / tensor diffusivities. Even worse is supporting flux boundary conditions for the case that a closure doesn't use a diffusivity at all... Note also that flux boundary conditions are used almost exclusively except for direct numerical simulation, so this is indeed an important consideration. > I know this is a little different than the fitted version, because it's a little harder to specify a normal direction in that",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517:302,variab,variable,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-850559517,2,['variab'],['variable']
Modifiability,None other than it requires typing the code and adding a test or two. Are you suggesting extending the capabilities of `FieldSlicer`? I think that's a nice idea if so!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-809903134:89,extend,extending,89,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1512#issuecomment-809903134,1,['extend'],['extending']
Modifiability,"Not _exactly_ sure why it was [1][3], but if `u_init` was an active variable at one point then we we would want to get its derivative which is there.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438773709:68,variab,variable,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2438773709,1,['variab'],['variable']
Modifiability,"Not really, it will call the fallback. But it's no cost to just have an adapt there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2178696246:72,adapt,adapt,72,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619#issuecomment-2178696246,1,['adapt'],['adapt']
Modifiability,"Not supposed to be concrete but just to lay out some goals for big new features and prioritize them based on our needs. Also in case I forgot about them. Most of these can be done independently so the version ordering is mostly for priority. * v0.6: Arbitrary LES closures (Smagorinsky and AMD implemented); * v0.7: Halo regions (PR #167); * v0.8: Reduce memory usage by storing fewer fields.; * v0.9: Machine precision mass conservation; * v0.10: channel and boxed/cubed models, i.e. multiple wall-bounded dimensions (PR #180); * v0.11: True finite volume operators; * v0.12: Variable Δz grid; * v0.13: Higher-order advection schemes (4th order, 3rd order DST, WENO?, Prather??); * v0.14: GPU performance optimization (GPU hackathon); * v0.15: Multi-GPU (and multi-CPU?) distributed parallelism (GPU hackathon); * v0.16: Fuller high-level and API documentation; * v0.17: Fast on-the-fly diagnostics framework (CPU and GPU friendly); * v1.0: Awesome LES model!; * v1.1: Hydrostatic mode; * v1.2: Spherical grid (pole problem)?; * v1.3: Cubed sphere grid?; * ...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/207:577,Variab,Variable,577,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/207,1,['Variab'],['Variable']
Modifiability,"Not working yet --- we have to be able to calculate the isopycnal slope inside the vertically-implicit diffusion solver, so need some refactoring.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2487#issuecomment-1112130751:134,refactor,refactoring,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2487#issuecomment-1112130751,1,['refactor'],['refactoring']
Modifiability,"Note, the `Checkpointer` currently does not save field location --- it only serializes the field data:. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L170. For a clean implementation of this feature, you'll need to extend the `Checkpointer` to also serialize the field location (and indices). Then you can use something like. ```julia; parent_data = file[""$name/data""]; loc = file[""$name/location""]; indices = file[""$name/indices""]; data = offset_data(parent_data, grid, loc, indices); model_field = model_fields[name]. if with_halos; copyto!(parent(model_field), parent_data); else; set!(model_field, data); end; ```. which extends these lines. https://github.com/CliMA/Oceananigans.jl/blob/f7acd8d0bd30dbe1ccb72854b6ea0ccab1eae0b5/src/OutputWriters/checkpointer.jl#L215-L217",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376:290,extend,extend,290,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3206#issuecomment-1659135376,2,['extend'],"['extend', 'extends']"
Modifiability,"Now that `ShallowWaterModel` is established I think it's important to make it more efficient. At the moment when we use `WENO5`, as I've been doing, we define 3 halo points in each direction. That means that our 1-layer model is really a 7-layer model, which is much more storage than we need. I very much want to remove this so that we can be much more efficient and have the code run faster. I know that #1024 tried to establish a flat dimension for `IncompressibleModel`. This is before my time and I heard multiple people tried doing this and it was a challenge. . I would like to do something independent of #1024, and force that any grid for `ShallowWaterModel` not define halo regions in the vertical and then not fill in those halo regions as it evolves. Below are a list of different things that I think should be done but am very curious to know what people suggest. I haven't tried this so I'm sure there are some details that I have not thought of and hoping to learn from others. - [ ] Maybe define the boundary conditions to be `flat` in the vertical and then try and get flat to work for this model?; - [ ] Maybe in `field_boundary_conditions.jl`, define `uhFluxBoundaryCondtions`, `vhFluxBoundaryCondtions`, `hBoundaryCondtions` that do not do anything to `top` and `bottom`?; - [ ] If we set the number of halos in the vertical to be 0, then we should still be able to use `new_data.jl` without having to modify it?; - [ ] Tell `fill_halo_regions.jl` to not do anything for `bottom` and `top`.; - [ ] If we remove the halos then I don't think we have to modify the tendencies at all so that might be fine.; - [ ] Other things that I've not considered?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499:754,evolve,evolves,754,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499,1,['evolve'],['evolves']
Modifiability,"Now that finally `MultiRegion` is merged we can implement the single node multi GPU paradigm also in the Nonhydrostatic model. cc @tomchor . The work can be divided in three tasks. - [x] Adapt the NonhydrostaticModel to accept a `MultiRegionGrid`. i.e., wrap local function calls in `@apply_regionally` and extend global methods in `multi_region_models.jl`. ; - [ ] Expose the parallelism in `RungeKutta3` timestepper and in the `update_state!` method. This is achieved by lumping together local function calls (all possible kernel calls such as calculate tendencies, rk substeps, etc) in outer functions and wrapping everything in `@apply_regionally`; - [ ] Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the `Distributed` module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). The first two tasks are quite trivial so I think the bulk of the work will be on implementing the pressure solver",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523:187,Adapt,Adapt,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523,2,"['Adapt', 'extend']","['Adapt', 'extend']"
Modifiability,Now that https://github.com/ali-ramadhan/DocumenterCitations.jl v0.1.0 has been tagged and is used as a Documenter.jl plugin we should switch to using it.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1096:118,plugin,plugin,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1096,1,['plugin'],['plugin']
Modifiability,Nuke sandbox,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/367:5,sandbox,sandbox,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/367,1,['sandbox'],['sandbox']
Modifiability,Nuke vertically stretched sandbox,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1395:26,sandbox,sandbox,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1395,1,['sandbox'],['sandbox']
Modifiability,"OK! I'll review this!. so in Oceananigans terms is the `e-ϵ` parameterization, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3605#issuecomment-2159268527:61,parameteriz,parameterization,61,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3605#issuecomment-2159268527,1,['parameteriz'],['parameterization']
Modifiability,"OK, I added some tests for variably spaced grids as well. @glwagner, what do you think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3054#issuecomment-1615844030:27,variab,variably,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3054#issuecomment-1615844030,1,['variab'],['variably']
Modifiability,"OK, let me put my 2 cents. If we have the validations in the docs just because of the animations then we should just put the animations on YouTube or somewhere and point people there. Having the non-working versions of, e.g., `lid_cavity.jl` script in the repo and in the docs has lead many new users in the rabbit hole of figure it out. Then users feel that scripts are not working, sometimes they post an issue or ask in Slack. But who know how many other users are simply discouraged. Personally, if I download a code that includes non-working pieces of code I am very discouraged. Thus, bottom-line: I see @glwagner's point that the functionality or pipeline for maintaining healthy validations scripts (even a subset of them) then *only those* should be included in the Docs. `Sandbox`: I'm so against a `sandbox` directory! It's like keeping your trash bin in your house for ever in case there is something useful there. I used to to it all the time: I'd keep commented out code in my scripts... But I think it's a bad practice. We need to let go. The repository and the tagged versions should not include half-bake scripts and what not. I'm happy with a sandbox repository `Oceananigans.jl-sandbox` where we keep things. Or a `sandbox` branch even. Regarding this PR and what's should be kept in the Docs: I vote we keep the convergence tests in the docs and nuke the validations. I agree with the git history size issue and probably the method of including the `.png` files that @ali-ramadhan suggests would work -- I've never done it though. (btw, @ali-ramadhan, I've noticed an increase in the repo's size recently... :()",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231:810,sandbox,sandbox,810,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872556231,9,"['Sandbox', 'sandbox']","['Sandbox', 'sandbox']"
Modifiability,"Oceananigans.jl supplies an interface for inserting user-defined functions into a model via `ContinuousForcing`, `DiscreteForcing`, `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction`. User functions are also permitted as input to some model terms: turbulence closures, Stokes drift, etc, and can be used in diagnostics and AbstractOperations. It's often necessary or convenient to formulate user functions in terms of global variables. For, example, a Gaussian surface cooling might be written as. ```julia; patch_width = 200meters; patch_amplitude = 1e-8 # m^3 s^-2; cooling_patch(x, y, t) = patch_amplitude * exp(-(x^2 + y^2) / 2patch_width^2). cooling_bc = FluxBoundaryCondition(cooling_patch); ```. Alas, this simple function will not compile on the GPU and is too slow on the CPU. To fix this, users need to declare `patch_width` and `patch_amplitude` as `const`:. ```julia; const patch_width = 200meters; const patch_amplitude = 1e-8 # m^3 s^-2; ```. For this problem, GPU scenario is a relatively happy one: `cooling_patch` will throw an error --- the ever-mysterious ""dynamic function invocation"" error --- but at least it will not run. On the CPU the situation is more insidious: the code will run, but slowly, leading to all sorts of issues: lost sleep, missed deadlines, wasted cluster credits, or abandonment of the Julia programming language. It'd be nice to recover the GPU situation on the CPU and throw an error (perhaps with the ability to opt-out) in this case --- or something. Here's a few possibilities (thanks @vchuravy!):. 1. Some utility in [JET.jl](https://github.com/aviatesk/JET.jl), [JETTest.jl](https://github.com/aviatesk/JETTest.jl), or perhaps [GPUCompiler.jl](https://github.com/JuliaGPU/GPUCompiler.jl) (?!). 2. `Test.@inferred`:. ```julia; julia> using Test: @inferred. julia> a = 2; f(x) = a * x # non-const'd global --- bad!; f (generic function with 1 method). julia> const b = 2; g(x) = b * x # oh good, there's const; g (generic function with 1 method)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:434,variab,variables,434,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,1,['variab'],['variables']
Modifiability,"Oh yeah right... Well, I don't know any ""good reference"". I've seen some people use an ad-hoc ""boundary layer depth"" of few tenth's of meters. In isopycnal coordinates (e.g. mom6) one uses the depth of the bottom layer, or an average of the fluid layers within e.g. 10 meters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445:247,layers,layers,247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1974#issuecomment-917622445,1,['layers'],['layers']
Modifiability,"Oh yeah that should work. I'll wait and see what your implementation looks like then. I agree that something like `set_surface_temperature!(model, 300)` looks much more user-friendly and portable!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/5#issuecomment-439149399:187,portab,portable,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/5#issuecomment-439149399,1,['portab'],['portable']
Modifiability,"Ok @navidcy I've updated the parameters. For the sake of documentation: these parameters were obtained by calibrating CATKE against 5 LES from LESbrary's ""4 day suite"" at 8m resolution. The defaults are now the ""best"" parameters at the end of that calibration. The last iteration of the calibration produced these plots:. <img width=""687"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155354710-33778efc-b52a-4fdb-a54d-e9ba97c4bda1.png"">. The blue line is the forward solution produced by a column model with CATKE using the best parameters. The TKE is a bit off, and the velocity profiles aren't ""perfect"" (still very good); but the buoyancy profiles are near perfect. I have some ideas for improving CATKE further, but it's going to take a bit of time. I think moving forward the right approach is to always use CATKE's default configuration for experiments. Then, whenever we update CATKE we'll take a new version. That way we can figure out what CATKE flavor we used by referencing the Oceananigans version. Also for documentation, here's a screenshot of the parameter values from the end of the calibration:. <img width=""1549"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/155355188-089d306f-32ae-46ed-a5e1-f70d3b16f4df.png"">. The defaults were copied from that screenshot. @navidcy I think @rafferrari is referring to any time-step constraints that CATKE might impose. You should be prepared to take short time-steps between 10s and 1 minute during the initial stages of the simulation (while the TKE profile is rapidly adjusting to the initial condition + forcing). Hopefully we can take longer time-steps later on.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824:852,config,configuration,852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2273#issuecomment-1048925824,1,['config'],['configuration']
Modifiability,Ok great then I think this is close. I'll just add a `Project.toml` to the new validation directory (hopefully eventually we will transition all validation directories to this more maintainable state).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940:181,maintainab,maintainable,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3384#issuecomment-1837207940,1,['maintainab'],['maintainable']
Modifiability,"Ok here's a little more insight into the problem. The issue is actually with `view`, which doesn't work when called on windowed field. `view` can only _create_ a windowed field from a full field, right now. In other words, `view` cannot act on a `view`. Haha. I'm extending `view` to work correctly when the argument itself is already windowed. This is probably the issue with outputting the free surface too. I can't remember exactly what went wrong there though. The output issue could also hint that things are more convoluted than they should be. Still though, we should be able to create views into fields that are already views. It should be fine.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2090900577:264,extend,extending,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2090900577,1,['extend'],['extending']
Modifiability,"Ok if its just for a quick test rather than extended work, that makes sense",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3555#issuecomment-2069564427:44,extend,extended,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555#issuecomment-2069564427,1,['extend'],['extended']
Modifiability,"Ok, I'll open a PR that refactors the interface for file splitting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000127066:24,refactor,refactors,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967#issuecomment-2000127066,1,['refactor'],['refactors']
Modifiability,"Ok, this change doesn't work because we actually pass the `closure` and `buoyancy` to `apply_flux_bcs!`, right now:. https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl#L42-L43. This is for models like CATKE that have boundary conditions which depend on the closure... which extend `getbc`... https://github.com/CliMA/Oceananigans.jl/blob/7f2d512ceaa2ce3fec3132cf0b08ab39344270d9/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/tke_top_boundary_condition.jl#L19-L20. So I think to make this change we also need to generalize the implementation of `DiscreteBoundaryFunction`. We would need to have a type that indicates whether or not we should somehow truncate the `args` that are passed to `fill_halo_regions!` (in that generalization, the pattern on `main` would be the special case that all the args after the first 2 are discarded). ## Nota bene. A different solution one might invent would _copy_ `model.closure` and `model.buoyancy` into CATKE's `TKETopBoundaryConditionParameters`. The reason this doesn't work is that we support _changing_ the parameters of `model.closure` after creating the model. (This is a nifty feature that makes calibration a lot more efficient.) This means that we always need to get the closure parameters from `model.closure` to be consistent.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780:397,extend,extend,397,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3630#issuecomment-2189717780,1,['extend'],['extend']
Modifiability,"Okay finally tests passed!. @navidcy I tried restarting the tests over and over (honestly more than 10 times over the past few days) and they always failed. I could only make them pass this morning when I restarted them one at a time. That is, starting one, and only restarting the next failed test when the previous one had fully run. So maybe the variability we see in tests has to do with different processes trying to access the same resources... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223676543:349,variab,variability,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223676543,1,['variab'],['variability']
Modifiability,"Okay so this MWE reproduces the error:. ```julia; using NCDatasets. a = reshape([1.], 1, 1, 1); b = dropdims(a, dims=(1, 2, 3)). ds = NCDataset(""/tmp/test.nc"",""c""); time = defDim(ds,""time"",Inf); v = defVar(ds,""temp"",Float32,(""time"",)); ds[""temp""][1] = b. close(ds); ```. However, if I create a variable without an unbouded dimension (i.e. without time) and do the same thing, it works properly:. ```julia; using NCDatasets. a = reshape([1.], 1, 1, 1); b = dropdims(a, dims=(1, 2, 3)). ds = NCDataset(""/tmp/test.nc"",""c""); v = defVar(ds,""temp"",Float32,()); ds[""temp""][] = b. close(ds); ```. So I think this is an edge case that NCDatasets doesn't yet handle well. I'm gonna create an issue there and see what they say.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857#issuecomment-1362066454:294,variab,variable,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857#issuecomment-1362066454,1,['variab'],['variable']
Modifiability,"Okay, so I'm just gonna throw this out there: is it advantageous to migrate the Poisson solvers to a separate package (PoissonSolvers.jl)? It would be akin to the relationship between PencilFFTs.jl and PencilArrays.jl. I've been thinking about it for the past few days and I can see some pros:. - Separating the code can make Oceananigans easier to maintain:; - fewer things to test in every PR (the tests are becoming larger and larger and apparently we're starting to have backlogs on buildkite); - fewer lines/modules in general can make it easier to make sense of the code, especially for beginner users/contributors (in general the smaller the code base, the easier it is to attract contributors). Also having (brief) docs just for the solvers would be a very useful reference in general imho.; - Efficient Poisson solvers are hard to write and it's an art of their own since different BCs generally require different algorithms. With that said, having a separate package just for that might not only benefit the community (a quick google search for something like ""poisson solver julia"" shows that there's interest) but also it might make it easier for someone who needs a specific algorithm that we don't yet have to make a contribution that might help us. That said, I've never touched the Poisson solvers in Oceananigans so I don't know how ""portable"" they are, or if there are significant disadvantages. So some feedback here would be helpful. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1553:1351,portab,portable,1351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1553,1,['portab'],['portable']
Modifiability,"Okkkk round 2. Let's see if this makes more sense. ```julia; # Two-parameter stretching:; h★ = 0.5 # controls spacing near surface (higher means finer spaced); Δh = 0.25 # normalized height where stretching becomes significant (here, 1/4 of domain height). h₀(k) = h★ + (1 - h★) * (k - 1) / (Nz + 1) # linear normalized height; h(k) = h₀(k) * tanh((k - 1) / (Δh * Nz)) / tanh(1 / Δh) # bottom-stretched normalized height. z_faces(k) = Lz * (h(k) - 1); ```. Hopefully that produces something more sensible. EDIT: ~~I guess this parameterization only works for small values of `Δh` (otherwise the grid is invalid). I'll keep thinking --- I think we can just replace the bottom-stretching function (the tanh) with something better behaved.~~ Fixed that in the above. Another issue is that spacing is linear near the bottom for large `Δh` so only the middle is stretched. So we could try a three-parameter function instead (maybe not worth it for this PR...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867783861:527,parameteriz,parameterization,527,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867783861,1,['parameteriz'],['parameterization']
Modifiability,"On a refactoring note, currently `ZDirection` is defined here https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L6. Which is after `Coriolis/coriolis.jl` is compiled. I think it makes more sense to move this definition to `Grids`. Everyone okay with that? That way any other module can use it (and I can use in Coriolis). I also think would be useful to use something like `validate_vertical_unit_vector()` to validate the rotation axis: https://github.com/CliMA/Oceananigans.jl/blob/fafdf3c7caa6aa1431b9d6437036794ec5dcb8fc/src/BuoyancyModels/buoyancy.jl#L37. So I was thinking of moving this to `Utils` (or maybe even `Grids`?) and renaming it to `validate_unit_vector()`. Since this would be refactoring code, I'll wait for some feedback before doing these modifications.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464:5,refactor,refactoring,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-886097464,4,['refactor'],['refactoring']
Modifiability,"On the user interface side, @simone-silvestri discussed a refactor that would implement something like:. ```julia; # To fix the number of substeps at 200; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(200)). # To fix the number of substeps according to CFL criteria, given the time-step passed to simulation; free_surface = SplitExplicitFreeSurface(time_step=FixedNumber(simulation_Δt=2minutes, cfl=0.7)). # Fixed time-step (variable number of substeps); free_surface = SplitExplicitFreeSurface(time_step=FixedSize(cfl=0.7)); ```. Do you have any feedback on that? Partly, this was motivated by my own confusion with the API. (Note, we also discussed some internal changes like getting rid of `settings`.) One detail is that we shouldn't have to pass `grid` because the free surface already must be ""materialized"" on the model grid in order to allocate memory for fields. My opinion is that we _either_ should pass `grid` and cut out the materialization, or we should not pass `grid` and materialize under the hood. But not both because that's the worst of both words (less convenient for users, complicated under the hood). We're waiting for #3125 to do this since there are some changes introduced there",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342:58,refactor,refactor,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695593342,4,"['refactor', 'variab']","['refactor', 'variable']"
Modifiability,"One idea to avoid a huge amount of refactoring could be to define something like. ```julia; default_float_type = Ref(Float64); ```. Then to change to float32 we'd write. ```julia; Oceananigans.default_float_type[] = Float32; ```. Next, everywhere we've written `FT=Float64` we change to `FT=default_float_type[]`. Basically that adds a global variable that users can modulate at the top of a script. We'd also have to introduce type parameters here and there wherever `Float64` was hardcoded (eg `TimeInterval`). Note this is also a reason not to do clock updates with some kind of higher precision it would seem (which we have discussed a bit to solve some rounding errors)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898:35,refactor,refactoring,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1732204898,2,"['refactor', 'variab']","['refactoring', 'variable']"
Modifiability,"One solution for compiling kernels with fields as arguments is to define. ```julia; Adapt.adapt_structure(to, field::AbstractField) = data(field); ```. and. ```julia; Adapt.adapt_structure(to, fields::NamedTuple{S, NTuple{N, <:AbstractField}}) where {S, N} =; datatuple(fields); ```. This approach will automatically unwrap fields when they are passed to GPU kernels (I think). . The disadvantage of this approach is that the code is a little bit harder to interpret, because if you miss the definition of this function, you might be confused why `field.boundary_conditions` and `field.grid` were not accessible from inside GPU kernels. On the other hand, this only affects the lowest-level kernels, and GPU programmers probably know that an `adapt_structure` method must be defined somewhere for an exotic object like `Field` to be passed into a kernel. If we document what we are doing clearly, we may solve this problem. Doing this means we would no longer have to unwrap fields manually prior to passing them to GPU kernels. Are there any other issues that I'm not seeing?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/722:84,Adapt,Adapt,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/722,2,['Adapt'],['Adapt']
Modifiability,"One thing that might be easier to ask for help with his, I wanted to print out the norm of the perturbation buoyancy in both cases. When we evolve the perturbation this is easy, but when we evolve the total field, I couldn't figure out how to do it. Do you have a recommendation? . This would be helpful to determine how the norm changes with resolution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708512691:140,evolve,evolve,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251#issuecomment-1708512691,2,['evolve'],['evolve']
Modifiability,"Opening this request as per the Slack conversation. Sometimes file sizes become very big (and thus are not easy to transfer, etc.), and so quite often it would probably be good to split data files according to time intervals. So something with API like; ```; split_file = Filesize(10Mb). split_file = TimeInterval(10days); ```. Is there any specific things that should be noted if we are to extend the `start_next_file()` functionality to NetCDF as well instead of just JLD2? Like any flags or things that I should note.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2967:391,extend,extend,391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2967,1,['extend'],['extend']
Modifiability,Or maybe to adapt the default based on the incoming grid?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2399820164:12,adapt,adapt,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3806#issuecomment-2399820164,1,['adapt'],['adapt']
Modifiability,"Out of curiousity, how much work is it to implement RK3 for `HydrostaticFreeSurfaceModel`?. Seems like fixing AB2 for variable time steps isn't too difficult if it's just changing how $G^{n+1}$ is computed though. > Why don't we answer this once and for all, there are not two answers to this question. I thought this was answered quite clearly, albeit for a very idealized case, here: https://github.com/CliMA/Oceananigans.jl/pull/945#issuecomment-692706814 Is AB2 still technically only first-order accurate?. I know it's quite difficult to extrapolate from the convergence test to global simulations, but my experience has been that RK3 beats out AB2 for non-hydrostatic simulations. That said, it's probably still good to have AB2 especially if it can support variable time steps.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418029947:118,variab,variable,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418029947,4,['variab'],['variable']
Modifiability,"Overlapping MPI communication and computation in the HydrostaticFreeSurfaceModel and the NonhydrostaticModel. In particular, this PR introduces two keyword arguments for the `fill_halo_regions!` function, active **only** in case of distributed halo passing boundary conditions:; - the`async::Bool` keyword argument that allows launching MPI operations without waiting for the communication to complete.; - the `only_local_halos::Bool` keyword argument, which fills only the halo in case of a local (i.e., Flux, Value, Gradient, Periodic, and, temporarily, MultiRegionCommunication) boundary condition. This is required for having explicit boundary conditions (like Value or Flux) for turbulent diffusivities (we directly calculate diffusivities in the halos in the case of distributed BC). This PR allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an interior kernel that calculates tendencies between, e.g., `i = Hx` and `i = Nx - Hx`, and a boundary kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries.; Before computing tendencies near the boundaries, boundary-adjacent auxiliary diagnostic variables are recalculated (hydrostatic pressure, vertical velocity and diffusivities for the hydrostatic model, hydrostatic pressure and diffusivities for the non-hydrostatic model). Also, this PR introduces ; - 8-way halo passing for distributed grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/ke",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125:848,variab,variables,848,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125,2,['variab'],['variables']
Modifiability,"Overlapping MPI communication and computation in the `HydrostaticFreeSurfaceModel`. In particular, this PR introduces the `async` keyword argument to `fill_halo_regions!` that allows launching MPI operations without waiting for the communication to complete. ; This allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an _interior_ kernel that calculates tendencies between `H` and `N-H`, and a _boundary_ kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries. This PR is contingent on #2924 . Closes #615; Closes #1882",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2953:316,variab,variables,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2953,2,['variab'],['variables']
Modifiability,"PJ Tuckman (@qwert2266) recently wrote a pretty sweet Julia script for doing automated parameter exploration with Slurm on Satori (see https://github.com/ali-ramadhan/JuicyMoons.jl/pull/14). The script itself can be found at: https://github.com/ali-ramadhan/JuicyMoons.jl/blob/pjt/enceladus-slurm/slurm/20201031ScriptCreator.jl (needs some refactoring and might have bugs). The automation was complicated by the fact that Satori only allows you 1 Slurm job (through which you can request 4 GPUs and cram 4 GPU simulations on one node) and there's a 12 hour time limit on all jobs. So the idea/hack we came up with was for the simulation scripts to touch a file to indicate they have checkpointed themselves and to touch another file to indicate they have reached steady state. The Julia script keeps creating and submitting Slurm scripts until all simulations have reached steady state (""checkpointed"" simulations are queued/scheduled again while simulation that have reached ""steady state"" are not queued/scheduled any more). The point of this issue is to discuss whether it makes sense to add an example/tutorial of automating parameter exploration with Slurm? The specific workflow discussed above is specific to Satori so it might not make sense to include it in the docs (might be more of an internal resource). We looked at ClusterManagers.jl but don't think it's super useful since we're working around only have 1 job, and we don't know what the next job will be until the 4 simulations crammed into the first job are done running. X-Ref: #1045 proposes adding example Slurm scripts would is definitely a good idea. cc @sandreza @suyashbire1 might be interested.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1137:340,refactor,refactoring,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1137,1,['refactor'],['refactoring']
Modifiability,"PS from the docstring for `adapt`:. ```julia; help?> Adapt.adapt; adapt(to, x). Adapt a value x according to to. If no specific adaptions have been registered for to, this call will be a no-op. To alter the behavior, implement methods of adapt_structure and adapt_storage to respectively define how to adapt structures, and the leaves of those structures. For example, defining an adaptor for an environment where we can't have integers, and adding a method to adapt_storage to appropriately convert those to floating-point numbers:. julia> struct IntegerLessAdaptor end. julia> Adapt.adapt_storage(::IntegerLessAdaptor, x::Int64) = Float64(x). julia> adapt(IntegerLessAdaptor(), 42); 42.0. This will automatically work on known types too:. julia> adapt(IntegerLessAdaptor(), tuple(1,2,3)); (1.0, 2.0, 3.0). If we want this to work with custom structures, we need to extend adapt_structure:. julia> struct MyStructure; x; end. julia> Adapt.adapt_structure(to, obj::MyStructure) = MyStructure(adapt(to, obj.x)). julia> adapt(IntegerLessAdaptor(), MyStructure(42)); MyStructure(42.0). ──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. adapt(to). Create a function that adapts its argument according to to. If no specific adaptions have been registered for to, the returned function will be equivalent to identity.; ```. The ""1-argument"" version of `adapt` actually returns a `Fix1`, I think. That's why we are getting errors about calling `Fix1`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851:27,adapt,adapt,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867020851,19,"['Adapt', 'adapt', 'extend']","['Adapt', 'adapt', 'adaptions', 'adaptor', 'adapts', 'extend']"
Modifiability,Parameterized abstractions that work on CPU and GPU architectures.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147:0,Parameteriz,Parameterized,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147,1,['Parameteriz'],['Parameterized']
Modifiability,"Perhaps a more concise and extendable implementation would be. ```julia; compute!(collection::Union{Tuple, NamedTuple}) = map(compute!, collection); ```. inspired by [Adapt](https://github.com/JuliaGPU/Adapt.jl/blob/ff4419424b6b48b4440c5235f5a4070880fcdf79/src/base.jl#L3)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1928751483:27,extend,extendable,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3455#issuecomment-1928751483,3,"['Adapt', 'extend']","['Adapt', 'extendable']"
Modifiability,"Perhaps start a git repo and post a link to it? It's best to include the julia environment you're using with the file (otherwise it will go stale as Oceananigans evolves). If you want to just post the file then you can use a [gist](https://gist.github.com), or copy/paste the code here if its short.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1296014219:162,evolve,evolves,162,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1296014219,1,['evolve'],['evolves']
Modifiability,"Perhaps we rename all variables to `closures` when they are tuples of 2 elements or more? Just a suggestion, feel free to ignore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2551#issuecomment-1126166730:22,variab,variables,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2551#issuecomment-1126166730,1,['variab'],['variables']
Modifiability,"Perhaps worth stating here that I think RK3 is vastly superior to AB2 not only because of the faster time-to-solution but also because it is ""self-starting"" (does not depend on tendencies from previous time-steps), checkpointing is cheaper and simplified, and the chance of bugs (which cost us nearly 6 months during parameterization development in the past) wherein ""restarted"" simulations can fail when the prior tendencies have NaN _even_ if we attempt to start with an Euler time-step. So RK3 is both faster _and_ simpler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679:317,parameteriz,parameterization,317,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3874#issuecomment-2441607679,2,['parameteriz'],['parameterization']
Modifiability,"Perhaps, there is no need for an environment variable that modify the filename, instead this is something that could be done if the user is using a checkpoint. But rather than using this convoluted workflow that will require renaming and deleting files, I thought the optimal implementation is to append to the previous existing file when using checkpoints. If the filename is `vel_fields.nc`, the expected files after the second pickup should be:; ```; vel_fields_part1.nc vel_fields_part3.nc vel_fields_part5.nc ; vel_fields_part2.nc vel_fields_part4.nc ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391960027:45,variab,variable,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391960027,1,['variab'],['variable']
Modifiability,"Playing around with an internal wave test case I think we actually need todo something more like the adaptive boundary described in section 4.1 of this paper https://doi.org/10.1016/S1463-5003(00)00013-5 as I have come across two problems: when the flow is directed out of the domain on a prescribed interface (e.g. u = cos(pi/h(z+h)) then information can't get out, and on the ""Orlanski"" side where information is travelling into the domain I am getting instability as it is just keeping the boundary value constant which by default is zero. This might present some more user interface issues as it is going to require us to set a ""known"" value on every open boundary unless we're confident that the flow will only be leaving.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155:101,adapt,adaptive,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1971287155,1,['adapt'],['adaptive']
Modifiability,"Plots were added for the following benchmarking scripts, so as to present the most important data found in the original output tables in a visual format that is easier to analyze:; ```; benchmark_shallow_water_model.jl; benchmark_incompressible_model.jl; strong_scaling_shallow_water_model.jl; weak_scaling_shallow_water_model.jl; strong_scaling_incompressible_model.jl; ```; The plotting requires the Plots and PyPlot packages. Additional fixes were also made. Three manual calls to the garbage collection function, `GC()` was added in `src/Benchmarks.jl` which enabled `benchmark_shallow_water_model.jl` and `benchmark_incompressible_model.jl` to run multiple benchmarking cases with large grids without running out of memory. One such call is `GC( true)` which triggers a ""full"" garbage collection that is able to remove younger unreferenced objects. For the _single files of the scaling benchmarking scripts, the `@benchmark` portion was adjusted to have `evals=1` on top of the original configuration of `samples=10`. This allowed larger ranks of CPUs to be benchmarked. Originally, without the configuration limiting evaluations to 1, as the number of CPUs increased and the time per evaluation decreased, the number of times the benchmarked bit of code was run became too great and caused deadlocks between the MPI processes.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1746:992,config,configuration,992,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1746,2,['config'],['configuration']
Modifiability,Poisson solver that allows for variable vertical grid spacing.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/46:31,variab,variable,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/46,1,['variab'],['variable']
Modifiability,Portable random number generator for testing.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/176:0,Portab,Portable,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/176,1,['Portab'],['Portable']
Modifiability,PreconditionedConjugateGradientSolver and ImplicitFreeSurface refactor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1575:62,refactor,refactor,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1575,1,['refactor'],['refactor']
Modifiability,Prescribed variable diffusivities and viscosities,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/781:11,variab,variable,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/781,1,['variab'],['variable']
Modifiability,Preserve locations when adapting Field to GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1906:24,adapt,adapting,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1906,1,['adapt'],['adapting']
Modifiability,"Pressure is different from other variables because it doesn't have a dedicated `compute!` function. I do actually think it would be nice to ""regularize"" the code in this way by making the pressure (and eddy diffusivities) into `KernelComputedField`s (or other kinds of special fields) so that `compute!` works on them in the same way it works on other `ComputedField`s. The reason it is different is because while we have always had pressure auxiliary variables, `ComputedField`s are only a relatively recent addition to the code. In fact, it hadn't even occurred to me that it would be nice if we could use `compute!(hydrostatic_pressure)` until recently. More on the top of this issue, there is a small difference between the two kernels: in one the reference density (which is otherwise arbitrary?) appears to be `1027` and in the other its `1024`. But otherwise I don't see why it wouldn't work and I am a bit stumped.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786242341:33,variab,variables,33,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786242341,2,['variab'],['variables']
Modifiability,Pretty sure what I wrote will work. May need `adapt` as well.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2402599146:46,adapt,adapt,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3840#issuecomment-2402599146,1,['adapt'],['adapt']
Modifiability,"Previously, `getindex` for `Nothing` locations was specified to `AbstractReducedField`. This PR extends these functions to apply to `AbstractDataField`. The effect of this is limited because `Field`s are still entirely ""unwrapped"" within kernels, meaning that we lose their location data. If/when we are able to preserve location data for `Field` when adapting to the `GPU`, we may not need `ReducedField` or `AbstractReducedField` any longer -- we can instead use `Nothing` locations to indicate that a field is reduced along a particular direction.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1649:96,extend,extends,96,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1649,2,"['adapt', 'extend']","['adapting', 'extends']"
Modifiability,"Probably not the best use of time to try to get `reverse` to work. But if someone is interested in looking further, we can see that `reverse` starts by building a new object with `copymutable`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L59-L60. `copymutable` works correctly because it relies on 1) `similar` and 2) `copyto!`, both of which we define for `Field`. So that's nice, showing the power of extending those functions. The error that @siddharthabishnu finds occurs because we haven't defined `view` for `CartesianIndices`. This is used by `_reverse`:. https://github.com/JuliaLang/julia/blob/d7dc9a8cc8f2aebf04d5cecc8625be250169644b/base/arraymath.jl#L95. The fix is pretty easy I think. We simply need to extend `reverse!`:. ```julia; Base.reverse!(f::Field; dims=:) = reverse!(parent(f); dims); ```. This seems to work as expected:. ```julia; julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.14945052605940137; -0.25420686637327716; 0.36399517922432356; -0.03994475992128757; 0.018968176930285508; -0.5607261175546058. julia> reverse!(parent(c)); interior(c)[:]; 6-element Vector{Float64}:; -0.5607261175546058; 0.018968176930285508; -0.03994475992128757; 0.36399517922432356; -0.25420686637327716; -0.14945052605940137; ```. But again I don't know why we want reverse for `Field`. Do we?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965:459,extend,extending,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2035345965,4,['extend'],"['extend', 'extending']"
Modifiability,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006:595,parameteriz,parameterization,595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006,1,['parameteriz'],['parameterization']
Modifiability,"Probably related:. I saw the new `Simulation` API and the new `Callback` idea. This brought a change: the old way of building a Simulation included a `parameters` arguments. This `parameters` was accesible from the `progress` function. With the new way, we build callbacks and then register them, but there is no way to pass additional parameters to it. . In one of my usages I was hacking a progress function https://github.com/aramirezreyes/RamirezReyes_ShallowWaterInFPlane/blob/c1971c0cb3fc99fbb2dbf3303a8fd60b17a59d5a/scripts/run_oceananigans_example_cpu.jl#L101 to update some arrays on a parameterization. Unfortunately, this depended on the `parameters` argument. The more generalized idea of the `callbacks` is very elegant and works nice, but it loses some power from the lack of ability to add additional parameters to the callback function. Is there a way to recover this ability? (there are other ways of getting it to work but having it in the design would be nice). _Originally posted by @aramirezreyes in https://github.com/CliMA/Oceananigans.jl/issues/1895#issuecomment-1001102006_",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2127:595,parameteriz,parameterization,595,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2127,1,['parameteriz'],['parameterization']
Modifiability,Proposed enhancements/changes in Docs,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2448:9,enhance,enhancements,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2448,1,['enhance'],['enhancements']
Modifiability,"Protoyping how we might dynamically append arbitrary forcing functions. This could provide a really powerful and concise API for configuring the model. Adding a sponge layer can be done in ~5 lines. I highly doubt this will be performant as is, especially as I'm appending closures with an arbitrary number of arguments. I'm not even sure if it's even possible to make this run fast and work on a GPU... We might have to compile something every time a new forcing function is created to move it away from `Main` and make it inline-able?. Initially the forcing is zero so Julia sees `Oceananigans.zero_func` which it presumably knows how to optimize away. But after adding an `add_ones(args...) = 1.0` forcing function it sees `(::getfield(Main, Symbol(""#new_Fu#3"")){typeof(add_ones),typeof(Oceananigans.zero_func)})` which lives in `Main`...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/294:129,config,configuring,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/294,1,['config'],['configuring']
Modifiability,Quick test tells me everything works with latest CUDA packages which just got released but will have to refactor a bit to make use of GPUifyLoop's new `@launch` functionality (and remove the `@setup` calls).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/153:104,refactor,refactor,104,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/153,1,['refactor'],['refactor']
Modifiability,"Re solving the problem with the user interface (eg the `immersed` boundary condition that we currently have) --- @simone-silvestri and I discussed how to implement this, and our tentative plan is to add a new term to the tendency kernels:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_tendency_kernel_functions.jl. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Models/NonhydrostaticModels/velocity_and_tracer_tendencies.jl. The reason for this approach is to avoid entangling the immersed boundary condition calculations with the existing closure kernel functions. We're not totally sure what the immersed boundary condition stuff will entail and we think this approach will be easier to maintain and extend in the near future. Hopefully we can adapt some of the ideas and code in this PR to that eventual implementation. I think this implementation will prove useful for users who just want to use the hard-coded boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675:781,extend,extend,781,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1050094675,2,"['adapt', 'extend']","['adapt', 'extend']"
Modifiability,"Ready to be reviewed. I could not make the oceanic les regression test work for the moment, but we still have to build a bit on this PR so this is a good starting point to not blow up this PR too much. Next steps should be; - include an example (to be ran on the distributed pipeline); - include a tridiagonal solve; - relax the constraints on the divisibility of the grid size by the ranks, this will require a bit of experimenting but it can be easily done by modifying the buffers in `TransposableField` to be of variable size",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2183310740:516,variab,variable,516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2183310740,1,['variab'],['variable']
Modifiability,Refactor SavedFields struct into a FieldWriter and FieldMemoryWriter.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/29:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/29,1,['Refactor'],['Refactor']
Modifiability,Refactor `Fields.interpolate` to make sense for `Nothing` locations and `Flat` directions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3368:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3368,1,['Refactor'],['Refactor']
Modifiability,Refactor `Fields.interpolate` to make sense for `Nothing` locations and `Flat` directions - take 2,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3395:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3395,1,['Refactor'],['Refactor']
Modifiability,Refactor `Simulations` + simulations infrastructure to be loaded first,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3088:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3088,1,['Refactor'],['Refactor']
Modifiability,Refactor `SplitExplicitFreeSurface`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3894:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3894,1,['Refactor'],['Refactor']
Modifiability,Refactor `regrid!` so that it works with non-flat `x` and `y` dimensions?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2067:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2067,1,['Refactor'],['Refactor']
Modifiability,Refactor boundary conditions container,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405,1,['Refactor'],['Refactor']
Modifiability,Refactor diagnostics framework?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/43:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/43,1,['Refactor'],['Refactor']
Modifiability,Refactor examples to use FieldTimeSeries,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1871:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1871,1,['Refactor'],['Refactor']
Modifiability,Refactor exported names,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872,1,['Refactor'],['Refactor']
Modifiability,Refactor interpolate to work for `Nothing` locations and to make sense for `Flat` topologies,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3358:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3358,1,['Refactor'],['Refactor']
Modifiability,Refactor of some stretched rectilinear grid tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2917:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2917,1,['Refactor'],['Refactor']
Modifiability,Refactor vector invariant advection,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2820:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2820,1,['Refactor'],['Refactor']
Modifiability,Refactor vertical vorticity to return operation rather than Field,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3340:0,Refactor,Refactor,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3340,1,['Refactor'],['Refactor']
Modifiability,Refactoring Coriolis implementation and semantics,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1904:0,Refactor,Refactoring,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1904,1,['Refactor'],['Refactoring']
Modifiability,Refactoring for `ImmersedBoundaries` to take precedence over `Solvers`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3847:0,Refactor,Refactoring,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3847,1,['Refactor'],['Refactoring']
Modifiability,Refactors Poisson solver interfaces and new implicit free surface solver,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1869:0,Refactor,Refactors,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869,1,['Refactor'],['Refactors']
Modifiability,Regarding vanishing layers: what MOM6 does (I think) is that layers never vanish but they are restricted to have height of 1e-10.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117964473:20,layers,layers,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1117964473,2,['layers'],['layers']
Modifiability,Regriding enhancements,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1991:10,enhance,enhancements,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1991,1,['enhance'],['enhancements']
Modifiability,Remove Immersed map from `Adapt`ing the `ImmersedBoundaryGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3690:26,Adapt,Adapt,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3690,1,['Adapt'],['Adapt']
Modifiability,"Remove `GKSwstype: ""100""` from buildkite environment variables",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3604:53,variab,variables,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3604,1,['variab'],['variables']
Modifiability,"Reopening a PR based on #261 and #263 which I reverted as it broke some of the examples we usually run, e.g. free convection. Before merging we should probably either refactor the examples to use the new boundary conditions API or come up with this `BoundaryConditionsWizard` that does everything for us.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/282:167,refactor,refactor,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/282,1,['refactor'],['refactor']
Modifiability,Resolves #1794 . We should also come up with a more permanent solution (perhaps another environment variable to toggle GPU-CI) that throws an error if GPU tests can't run on the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1799:100,variab,variable,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1799,1,['variab'],['variable']
Modifiability,"Revert ""Cut down the examples. Moved stuff into a sandbox.""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/231:50,sandbox,sandbox,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/231,1,['sandbox'],['sandbox']
Modifiability,"Revert ""Revert ""Cut down the examples. Moved stuff into a sandbox.""""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/232:58,sandbox,sandbox,58,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/232,1,['sandbox'],['sandbox']
Modifiability,Rework CI to use buildkite plugin,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3042:27,plugin,plugin,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3042,1,['plugin'],['plugin']
Modifiability,Rewrite regression tests,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/665:0,Rewrite,Rewrite,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/665,1,['Rewrite'],['Rewrite']
Modifiability,"Right `InMemory` is more like a `nothing` backend, there's nothing back there. . On ClimaOcean there's an example how we extended this infrastructure to a particular kind of NetCDF backend: https://github.com/CliMA/ClimaOcean.jl/blob/dd9148a8f702699ddf2947d3a1a094adddbd9bb1/src/DataWrangling/JRA55.jl#L218. The implementation in this PR seems simple enough though. @ali-ramadhan maybe can you provide a little syntax example how you expect this to be used? @navidcy take a look and see what you think",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2314147354:121,extend,extended,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2314147354,2,['extend'],['extended']
Modifiability,"Right now `SpecifiedTimes` is acting in a way different from its documentation. In addition to triggering a callback in the specified times, according to the docs, it's also triggering the callback in initialization. For example, the following MWE. ```julia; using Oceananigans. grid = RectilinearGrid(size=(4, 4, 4), extent=(1, 1, 1)); model = NonhydrostaticModel(; grid); simulation = Simulation(model, Δt=1, stop_iteration=10). callback_func(sim) = @warn ""Function called in iteration $(sim.model.clock.iteration)""; simulation.callbacks[:cfl_changer] = Callback(callback_func, SpecifiedTimes([5, 10])). run!(simulation); ```. produces the following output. ```julia; [ Info: Initializing simulation...; ┌ Warning: Function called in iteration 0; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: ... simulation initialization complete (262.483 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (28.766 seconds).; ┌ Warning: Function called in iteration 5; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; [ Info: Simulation is stopping. Model iteration 10 has hit or exceeded simulation stop iteration 10.; ┌ Warning: Function called in iteration 10; └ @ Main ~/repos/Oceananigans.jl/sandbox/test_specified_times.jl:7; ```. Is this by design? If so the docs for `SpecifiedTimes` must be changed to account for that since they currently read:. ```; Return a callable TimeInterval that ""actuates"" (schedules output or callback execution) whenever the model's clock equals the specified values in times. For example,. • SpecifiedTimes([1, 15.3]) actuates when model.clock.time is 1 and 15.3.; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2719:782,sandbox,sandbox,782,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2719,3,['sandbox'],['sandbox']
Modifiability,"Right now the `NetCDFOutputWriter` saves some useful metadata (date, Julia version, Oceananigans version, schedule metadata) but this could be extended to saving model and simulation parameters (advection scheme, coriolis parameters, boundary condition parameters when possible, equation of state parameters, etc.). This would be generally useful and reduce the burden to do this in other packages, e.g. LESbrary.jl. This saving of metadata can easily be extended to work with `JLD2OutputWriter` as well.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1313:143,extend,extended,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1313,2,['extend'],['extended']
Modifiability,"Right now the element-wise operators are all written for the constant _Δx_, _Δy_, _Δz_ case. As we transition to supporting variable grid spacings, the operators should be written as finite volume operators that take into account the variable areas and volumes. We should be able to figure out a way to write the operators such that they work efficiently for all Cartesian grids. Would be good to do this before #47 is implemented. This may require #59 to be resolved first.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/115:124,variab,variable,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/115,2,['variab'],['variable']
Modifiability,"Right now we have monstrosities like (this one is a bit extreme); ```julia; Nx, Ny, Nz = model.grid.Nx, model.grid.Ny, model.grid.Nz; Lx, Ly, Lz = model.grid.Lx, model.grid.Ly, model.grid.Lz; Δx, Δy, Δz = model.grid.Δx, model.grid.Δy, model.grid.Δz. grid = model.grid; cfg = model.configuration; bcs = model.boundary_conditions; clock = model.clock. G = model.G; Gp = model.Gp; constants = model.constants; eos = model.eos; U = model.velocities; tr = model.tracers; pr = model.pressures; forcing = model.forcing; poisson_solver = model.poisson_solver. δρ = model.stepper_tmp.fC1; RHS = model.stepper_tmp.fCC1; ϕ = model.stepper_tmp.fCC2. gΔz = model.constants.g * model.grid.Δz; fCor = model.constants.f. uvw = U.u.data, U.v.data, U.w.data; TS = tr.T.data, tr.S.data; Guvw = G.Gu.data, G.Gv.data, G.Gw.data. # Source terms at current (Gⁿ) and previous (G⁻) time steps.; Gⁿ = G.Gu.data, G.Gv.data, G.Gw.data, G.GT.data, G.GS.data; G⁻ = Gp.Gu.data, Gp.Gv.data, Gp.Gw.data, Gp.GT.data, Gp.GS.data; ```. Would be nice to prettify or abstract away this unpacking. @charleskawczynski I noticed you used some @unpack macros in the code you showed on Monday, is it up on GitHub by any chance?. I think [Parameters.jl](https://github.com/mauro3/Parameters.jl) implements an @unpack macro, might be good to look at.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/155:281,config,configuration,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/155,1,['config'],['configuration']
Modifiability,"Right, and we are essentially looking for a keyword that the user can use to specify they want to use layers. This keyword can be anything we want, right? . I was advocating for something that seemed intuitive to me but any layered shallow water model is a plus for me.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343:102,layers,layers,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1155740343,2,['layers'],['layers']
Modifiability,"Right, another reason to allow the user to specify the time attribute when using `NetCDFOutputWriter`. The default `IncompressibleModel` uses seconds so that could be an argument for ""seconds"" being the default for `NetCDFOutputWriter`. But right now it's not configurable by the user so I'll keep this issue open until this is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791012283:260,config,configurable,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1421#issuecomment-791012283,1,['config'],['configurable']
Modifiability,"Right. It serves the same purpose as the `OutputWriter` abstract type. It's dispatched on for functions like `run_diagnostic` and `time_to_run` in PR #352. https://github.com/climate-machine/Oceananigans.jl/blob/908ae4d23ce3e472d03fd69766edc457301df681/src/diagnostics.jl#L6. We did agree to refactor the diagnostics abstraction anyways, so maybe the need for an abstract `Diagnostics` type will disappear. I might hold off on this issue until it's clearer what `diagnostics.jl` will look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/361#issuecomment-523429721:292,refactor,refactor,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/361#issuecomment-523429721,1,['refactor'],['refactor']
Modifiability,"Run with implicit vertical diffusion and implicit free-surface, 20 minutes time step, 2.8 degree resolution and 18 vertical layers (constant spacing), ""realistic"" bathymetry, 30 years in about 2 hrs. https://user-images.githubusercontent.com/33547697/149965680-be56233d-3a08-4d2b-8115-cdb14edfd1af.mp4",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1015517597:124,layers,layers,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1015517597,1,['layers'],['layers']
Modifiability,"Running a simulation with `FT=Float32` is fairly onerous because the number type has to be passed to a huge number of model components individually. Eg we need to write. ```julia; using Oceananigans; using SeawaterPolynomials: TEOS10EquationOfState. FT = Float32; grid = RectilinearGrid(FT, size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(FT, f=1); equation_of_state = TEOS10EquationOfState(FT); buoyancy = SeawaterBuoyancy(FT; equation_of_state); ```. Here are two ideas to make this easier:. ## Use an environment variable. For this we introduce an environment variable, say `OCEANANIGANS_NUMBER_TYPE`. Then we can write a small utility:. ```julia; function global_number_type(default=Float64); user_number_type = get(""OCEANANIGANS_NUMBER_TYPE"", ENV, nothing). if isnothing(user_number_type); FT = default; else; try; FT = eval(Symbol(user_number_type)); catch; error(""The environment variable OCEANANIGANS_NUMBER_TYPE=$user_number_type is not supported!""); end; end. return FT; end; ```. This also permits a script-based approach because users can write. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the num",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800:521,variab,variable,521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800,3,['variab'],['variable']
Modifiability,"Running the example to t = 100 rather than t=150 would yield a quick 2/3. I think we can also decrease the resolution and increase the time-step. The resolution also is not isotropic, which essentially wastes grid points. The x dimension is 2pi but y is width 20. So if we use Ny = 128 then we might as well use something like Nx = 64 or 48. Further decreasing the resolution would also help a lot, because the time steps could be increased. And I think the movie doesn't need to plot so many frames. I think the writing and notation can also be improved. It's confusing to use `L_z` to refer to the reference depth. The `ShallowWaterModel` calls this variable `h`, and it's easy to confuse with the vertical extent of a 3D grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3169#issuecomment-1630755758:652,variab,variable,652,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3169#issuecomment-1630755758,1,['variab'],['variable']
Modifiability,Sandbox scripts for Large eddy simulation,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315:0,Sandbox,Sandbox,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315,1,['Sandbox'],['Sandbox']
Modifiability,"Scalar diffusivity fails on GPU if you use fields for the viscosity/diffusivity since there is no adapt method. . I've added them in this PR along with a test, feel free to remove the test if its too much.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3401:98,adapt,adapt,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3401,1,['adapt'],['adapt']
Modifiability,"Seems maybe that we want to output to a single file for every MultiRegionGrid, but in some special way by extending stuff in. https://github.com/CliMA/Oceananigans.jl/blob/main/src/OutputWriters/fetch_output.jl. Whatever we do there can then be interpretable by `FieldTimeSeries` to make sense of things. ""reconstructing"" output writers can probably be implemented with function output right now. indices seem like a challenge for the cubed sphere. For simpler stuff I guess we can partition the indices. That'd be just amazing if cuFFTxt works out of the box eh?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059:106,extend,extending,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116865059,2,['extend'],['extending']
Modifiability,"Shall we extend the `ShallowWaterModel` type to incorporate single- and multi-layer configs? What other properties does a multilayer shallow water type need? The reduced gravities that correspond to each interface is an obvious one... any other?. The number of layers could be a parameter of the type so we can dispatch on it in various methods. E.g.,. ```julia; mutable struct ShallowWaterModel{N, G, A<:AbstractArchitecture, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} <: AbstractModel{TS}; number_of_layers :: Int # Number of fluid layers; grid :: G # Grid of physical points on which `Model` is solved; architecture :: A # Computer `Architecture` on which `Model` is run; clock :: Clock{T} # Tracks iteration number and simulation time of `Model`; gravitational_acceleration :: GR # Gravitational acceleration; reduced_gravitational_acceleration :: RG # Reduced gravitational acceleration between for fluid interfaces; advection :: V # Advection scheme for velocities, mass and tracers; velocities :: U # Velocities in the shallow water model; coriolis :: R # Set of parameters for the background rotation rate of `Model`; forcing :: F # Container for forcing functions defined by the user; closure :: E # Diffusive 'turbulence closure' for all model fields; bathymetry :: B # Bathymetry/Topography for the model; solution :: Q # Container for transports `uh`, `vh`, and height `h`; tracers :: C # Container for tracer fields; diffusivity_fields :: K # Container for turbulent diffusivities; timestepper :: TS # Object containing timestepper fields and parameters; formulation :: FR # Either conservative or vector-invariant. function ShallowWaterModel(number_of_layers, grid, all_other_things...); arch = architecture(grid); return new{number_of_layers, typeof(G), typeof(arch), the_rest_of_parameters...}(number_of_layers, grid, arch, all_other_things...); end; end. const SingleLayerShallowWaterModel{N, G, A, T, GR, RG, V, U, R, F, E, B, Q, C, K, TS, FR} = ShallowWaterModel{1, G, A, T, GR, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910:9,extend,extend,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2975#issuecomment-1469071910,4,"['config', 'extend', 'layers']","['configs', 'extend', 'layers']"
Modifiability,"Should be ready to go when all tests pass. We can wait for PR #2121 to finish and then merge this in. Update. Actually need to finish adapting the solver for the `NonHydrostaticModel` (i.e., the `z_face_solver`)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087:134,adapt,adapting,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2097#issuecomment-1013367087,1,['adapt'],['adapting']
Modifiability,Should we extend `mask_immersed_field` for `BinaryOperation`? And for `MultiaryOperation`? This might be useful also for post-processing,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269855711:10,extend,extend,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3676#issuecomment-2269855711,1,['extend'],['extend']
Modifiability,"SingleColumn enhancements and ""ensemble of columns"" abstraction",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1924:13,enhance,enhancements,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924,1,['enhance'],['enhancements']
Modifiability,So I removed `~/.julia` and ran the instantiate before and I got the following output; ```; [45606] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:25; Allocations: 2907 (Pool: 2898; Big: 9); GC: 0; Installing known registries into `~/.julia`; ┌ Warning: The active manifest file has dependencies that were resolved with a different julia version (1.9.2). Unexpected behavior may occur.; └ @ /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/Manifest.toml:0; Installed GPUArraysCore ─────────────── v0.1.6; Installed Crayons ───────────────────── v4.1.1; Installed Adapt ─────────────────────── v4.0.4; Installed TableTraits ───────────────── v1.0.1; Installed ColorTypes ────────────────── v0.11.5; Installed Scratch ───────────────────── v1.2.1; Installed Preferences ───────────────── v1.4.3; Installed PrettyTables ──────────────── v2.3.2; Installed SentinelArrays ────────────── v1.4.5; Installed CUDA_Driver_jll ───────────── v0.9.1+1; Installed DataAPI ───────────────────── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed Tables ────────────────────── v1.12.0; Installed FixedPointNumbers ─────────── v0.8.5; Installed GPUCompiler ───────────────── v0.26.7; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArraysCore ──────────── v1.4.3; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed StaticArrays ──────────────── v1.9.7; Installed TimerOutputs ──────────────── v0.5.24; Installed AbstractFFTs ──────────────── v1.5.0; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed OrderedCollections ────────── v1.6.3; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed LLVMExtra_jll ─────────────── v0.0.30+0; Installed UnsafeAtomicsLLVM ─────────── v0.1.5; Installed LaT,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472:642,Adapt,Adapt,642,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2245919472,1,['Adapt'],['Adapt']
Modifiability,"So [this section of the docs](https://clima.github.io/OceananigansDocumentation/stable/simulation_tips/#Global-variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters) is misleading (or maybe just plain wrong), no?. We should probably rewrite that with an example using a callable. I think the MWE here would suffice.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458492186:111,variab,variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters,111,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2960#issuecomment-1458492186,2,"['rewrite', 'variab']","['rewrite', 'variables-that-need-to-be-used-in-GPU-computations-need-to-be-defined-as-constants-or-passed-as-parameters']"
Modifiability,So here a local variable `area` is defined but `area` could be `Δx`. This is confusing... right?. https://github.com/CliMA/Oceananigans.jl/blob/4f1fe0fa7edd9489ba20875be64b69daa0a77b95/src/Operators/products_between_fields_and_grid_metrics.jl#L8. @simone-silvestri,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2285:16,variab,variable,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2285,1,['variab'],['variable']
Modifiability,"So in summary, a future effort should take these steps:. 1. Write a function like `substepped_tracers(bgc::AbstractBiogeochemistry)` that can be extended by a hypothetical substepping BGC implementation.; 2. Prototype this concept by implementing a new (hopefully simple, one tracer) BGC model, and prototype the time-stepping algorithm that substeps the tracer forward during `update_biogeocemical_state!`. This should be easy to merge since it only requires defining the one new function `substepped_tracers` for skipping the tracer update. Furthermore, the prototype will demonstrate that the substepping is useful for a stiff problem, and will also develop a substepping scheme. Next, we can consider building an interface for doing the substepping itself, much like we have an interface for doing ordinary time-stepping. That will require a bit more design, but I think the initial prototype will give us a lot of information about the best way to go about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251:145,extend,extended,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455678251,2,['extend'],['extended']
Modifiability,"So initially me and @djlikesdjs were trying to use the `SplitExplicitFreeSurface` with the adaptive barotropic step based on CFL. This:. ```Julia; using Oceananigans. grid = RectilinearGrid(size = (10, 10), x = (-100, 100), z = (-100, 0), topology = (Periodic, Flat, Bounded)). free_surface = SplitExplicitFreeSurface(; grid, cfl = 0.7); ```. errors. ```Julia; ERROR: ArgumentError: either specify a cfl or a number of substeps; Stacktrace:; [1] Oceananigans.Models.HydrostaticFreeSurfaceModels.SplitExplicitSettings(FT::DataType; substeps::Int64, cfl::Float64, grid::RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, fixed_Δt::Nothing, gravitational_acceleration::Float64, averaging_kernel::Function, timestepper::Oceananigans.Models.HydrostaticFreeSurfaceModels.ForwardBackwardScheme); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/Oceananigans/pbNSE/src/Models/HydrostaticFreeSurfaceModels/split_explicit_free_surface.jl:306; [2] SplitExplicitFreeSurface(FT::DataType; gravitational_acceleration::Float64, kwargs::Base.Pairs{Symbol, Any, Tuple{Symbol, Symbol}, NamedTuple{(:grid, :cfl), Tuple{RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64}}}); @ Oceananigans.Models.HydrostaticFreeSurfaceModels ~/.julia/packages/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238:91,adapt,adaptive,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238,1,['adapt'],['adaptive']
Modifiability,"So then should we simply use `SlipVelocity` for the sake of the generality and leave the user to define a function for that velocity that could depend on field variables.; Should we also leave for users to define the way it will diverge at the boundary?; What do you think it could be the simplest example we could use for this validation, @johnryantaylor ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830:160,variab,variables,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2389#issuecomment-1082494830,2,['variab'],['variables']
Modifiability,"So, I also tried upgrading my whole project without upgrading Julia (so still using Julia 1.5.2) and the error persists. . To be clear, before the upgrade below everything was working normally and after the upgrade the checkpointer stopped being created. Here's the upgrade:. ```; Updating registry at `~/.julia/registries/General`; ######################################################################## 100.0%; Installed Showoff ───── v1.0.2; Installed StructTypes ─ v1.6.0; Installed Tables ────── v1.4.2; Installed Plots ─────── v1.11.2; Installed ArgParse ──── v1.1.4; Installed GR ────────── v0.57.3; Updating `/glade/scratch/tomasc/ISI_jet/Project.toml`; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; Updating `/glade/scratch/tomasc/ISI_jet/Manifest.toml`; [79e6a3ab] ↑ Adapt v3.2.0 ⇒ v3.3.0; [c7e460c6] ↑ ArgParse v1.1.2 ⇒ v1.1.4; [4fba245c] ↑ ArrayInterface v3.1.6 ⇒ v3.1.7; [052768ef] ↑ CUDA v2.4.1 ⇒ v2.4.3; [d360d2e6] ↑ ChainRulesCore v0.9.34 ⇒ v0.9.37; [35d6a980] ↑ ColorSchemes v3.10.2 ⇒ v3.11.0; [5ae59095] ↑ Colors v0.12.6 ⇒ v0.12.7; [34da2185] ↑ Compat v3.25.0 ⇒ v3.27.0; [0c68f7d7] ↑ GPUArrays v6.2.0 ⇒ v6.2.2; [28b8d3ca] ↑ GR v0.55.0 ⇒ v0.57.3; [d2c73de3] ↑ GR_jll v0.56.1+0 ⇒ v0.57.2+0; [63c18a36] ↑ KernelAbstractions v0.5.4 ⇒ v0.5.5; [da04e1cc] ↑ MPI v0.17.1 ⇒ v0.17.2; [872c559c] ↑ NNlib v0.7.17 ⇒ v0.7.18; [9e8cae18] ↑ Oceananigans v0.53.2 ⇒ v0.54.0; [91a5bcdd] ↑ Plots v1.11.0 ⇒ v1.11.2; [ea2cea3b] + Qt5Base_jll v5.15.2+0; [ede63266] - Qt_jll v5.15.2+3; [01d81517] ↑ RecipesPipeline v0.3.1 ⇒ v0.3.2; [992d4aef] ↑ Showoff v0.3.2 ⇒ v1.0.2; [2913bbd2] ↑ StatsBase v0.33.4 ⇒ v0.33.5; [09ab397b] ↑ StructArrays v0.5.0 ⇒ v0.5.1; [856f2bd8] ↑ StructTypes v1.5.0 ⇒ v1.6.0; [3783bdb8] ↑ TableTraits v1.0.0 ⇒ v1.0.1; [bd369af6] ↑ Tables v1.4.1 ⇒ v1.4.2; [6aa5eb33] ↑ TaylorSeries v0.10.11 ⇒ v0.10.12; [0796e94c] ↑ Tokenize v0.5.15 ⇒ v0.5.16; ```. I was able t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260:903,Adapt,Adapt,903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1547#issuecomment-818960260,1,['Adapt'],['Adapt']
Modifiability,"So, I've been running some simulations with a bunch of diagnostics, which make the simulation slower. I think some of the diagnostics that I'm calculating are already being calculated by Oceananigans (like derivatives). If I understand correctly, in each of those cases Oceananigans calculates that variable once to get the tendencies and then does the same calculation again when for my diagnostics, which seems wasteful. Is it possible (or desirable) to create a way for the code not to do the calculation twice if the user wants that diagnostic specifically? Maybe pass options when creating the model like:. ```julia; model = IncompressibleModel(grid, computed_fields=(:dudz, :dvdz,)); ```; so that those fields get stored just like the velocity and the tracers do?. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483:299,variab,variable,299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483,1,['variab'],['variable']
Modifiability,Some docstring fixes/enhancements + Code cleanup,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2872:21,enhance,enhancements,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2872,2,['enhance'],['enhancements']
Modifiability,Some further enhancements for the KH example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1144:13,enhance,enhancements,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1144,1,['enhance'],['enhancements']
Modifiability,"Some of the points that could be in the Goals/Mission section:. - Easy to install, understand and use; - Versatile: model is made in blocks that could be combined and easily configured across scales; - Modern: this might be no independent from the others.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059785806:174,config,configured,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308#issuecomment-1059785806,1,['config'],['configured']
Modifiability,"Some of the validations are failing...?. What previously gave. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); ERROR: ArgumentError: Must supply extent or x keyword when x-direction is Periodic; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Nothing, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:70; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/input_validation.jl:98; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Tuple{Int64, Int64, Int64}, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Tuple{Int64, Int64, Int64}, x::Nothing, y::Nothing, z::Tuple{Float64, Irrational{:π}}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/Research/OC8.jl/src/Grids/rectilinear_grid.jl:268; [5] top-level scope; @ REPL[3]:1; ```. now it goes through:. ```Julia; julia> RectilinearGrid(CPU(), Float64, size=(16, 16, 16), z=(-π, π)); 16×16×16 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [1.0, 1.0) variably spaced with min(Δx)=0.0, max(Δx)=0.0; ├── Periodic y ∈ [1.0, 1.0) variably spaced with min(Δy)=0.0, max(Δy)=0.0; └── Bounded z ∈ [-3.14159, 3.14159] regularly spaced with Δz=0.392699; ```. Note that it creates an x and y coord `[1.0, 1.0)`!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777:1509,variab,variably,1509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3333#issuecomment-1762074777,2,['variab'],['variably']
Modifiability,Some phrasal enhancements in the docs/physics section. The page `physics/boundary_conditions.md` wasn't included in the `make.jl`? Is this markdown file deprecated and we should delete it altogether?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2599:13,enhance,enhancements,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2599,1,['enhance'],['enhancements']
Modifiability,"Some pretty promising Lagrangian particle tracking benchmarks!. Couple of takeaways (all assuming a model with 128^3 grid points and QAB2 time stepping):; 1. **Low overhead**: You can advect up to ~100,000 particles on the CPU and up to ~10,000,000 particles on a (Titan V) GPU before the model slows down by more than 30%.; 2. **Great on GPUs**: Seems that the GPU is great for advecting millions of particles. You can advect ~100,000,000 particles and your model only slows down by a factor of 4x. In this scenario, the GPU is ~620x faster than a single CPU core.; 3. Calculated using `(t_100000000 - t_0) / 100000000`, advecting a single particle on the CPU takes ~110 ns while on the GPU it only takes ~0.127 ns. This seems a little too good to be true but I'll double check this. I'll start refactoring this PR using @glwagner's and @zhenwu0728's feedback, but I think it would be really great if we can keep this performance. # Benchmarks. ```; Oceananigans v0.44.1; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. ```; Lagrangian particle tracking benchmarks; ┌───────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ N_particles │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 0 │ 361.749 ms │ 364.041 ms │ 364.293 ms │ 368.854 ms │ 293.44 KiB │ 1876 │; │ CPU │ 1 │ 375.030 ms │ 376.591 ms │ 377.959 ms │ 385.248 ms │ 297.16 KiB │ 1906 │; │ CPU │ 10 │ 377.251 ms │ 380.792 ms │ 387.560 ms │ 443.325 ms │ 297.16 KiB │ 1906 │; │ CPU │ 100 │ 378.867 ms │ 381.194 ms │ 381.328 ms │ 383.461 ms │ 297.16 KiB │ 1906 │; │ CPU │ 1000 │ 378.076 ms │ 384.114 ms │ 383.611 ms │ 388.507 ms │ 297.16 KiB │ 1906 │; │",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975:796,refactor,refactoring,796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975,1,['refactor'],['refactoring']
Modifiability,"Some recent improvements in `CUDA.jl`:. https://juliagpu.org/post/2022-01-28-cuda_3.5_3.8/#preserving_array_indices. attempt to avoid promoting index types from 32-bit to 64-bit integers (64-bit integers are Julia's default). Throughout `Oceananigans` we use 64-bit integers by using the constant `1` for index calculations:. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Operators/difference_operators.jl#L7. According to that blog post, changing the above line. ```julia; @inline δxᶜᵃᵃ(i, j, k, grid, u) = @inbounds u[i+0x1, j, k] - u[i, j, k] ; ```. may decrease register pressure (perhaps dramatically, especially for wide stencils with lots of indices). `0x1` is the integer 1 with type `UInt8`:. ```julia; julia> i = 0x1; 0x01. julia> typeof(i); UInt8. julia> i == 1; true. julia> i === 1; false; ```. The amount of code that generates our stencils is not all that large. We find stencil calculations in. * `Operators`; * `Advection`; * `ImmersedBoundaries`. I also found a few stray index manipulations in random places like. https://github.com/CliMA/Oceananigans.jl/blob/9f6d841393094b123c99287fab7157a65db4d513/src/Models/HydrostaticFreeSurfaceModels/pcg_implicit_free_surface_solver.jl#L211. I think this issue also implies that we should strive to minimize the number of places where we do index calculations, to minimize the chances that we accidentally convert to `Int64`. We might also want to do some profiling to see the specific effect moving to `UInt8` indices might have. Perhaps we should benchmark two fully-loaded models, a `NonhydrostaticModel` LES with high-order advection, and a global-configuration of `HydrostaticFreeSurfaceModel` with an immersed boundary / continents, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2202:1657,config,configuration,1657,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202,1,['config'],['configuration']
Modifiability,Some refactoring of `time_step!` to unify `HydrostaticFreeSurfaceModel` and `NonhydrostaticModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3895:5,refactor,refactoring,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3895,1,['refactor'],['refactoring']
Modifiability,Some sandbox stuff might've been added by accident,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863619586:5,sandbox,sandbox,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863619586,1,['sandbox'],['sandbox']
Modifiability,"Some stuff later in the docstring is also weird. For example it says. > To use `TimeStepWizard`, adapt in a [`Callback`](@ref) and add it to a `Simulation`:. I don't know what it means to ""adapt"" a function in a callback. There's no adaptation, `TimeStepWizard` was _born_ for `Callback`!! Better to say that we ""wrap"" or ""insert it"" into `Callback`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514:97,adapt,adapt,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3248#issuecomment-1701916514,3,['adapt'],"['adapt', 'adaptation']"
Modifiability,Some test pass and it makes no sense. Is it just random test failure past of the test natural variability?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216:94,variab,variability,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1864#issuecomment-881956216,1,['variab'],['variability']
Modifiability,"Some time ago @sandreza and @xiaozhour suggested it would be useful to add the GM-Redi parameterization to Oceananigans.jl since we may want to train mesoscale eddy parameterizations. I'm opening this issue to discuss on what exactly needs to be implemented. My main reference is https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html. It seems that there are three different new closures that could potentially be added:; 1. Redi (symmetric) tensor diffusivity.; 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; 3. GM-Redi combining the two. Note: @glwagner has already implemented parts of the Redi tensor and GM for `TwoDimensionalLeith` so GM-Redi might not need too much extra work: https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl. # Questions/proposal. 1. Do we make the small-angle approximation? I would say yes. In Oceananigans.jl right now each component of the tensor diffusivity is calculated on-the-fly so the unapproximated tensor could end up being 2-4x more expensive to compute. We cannot compute the full tensor in one go (reusing the isopycnal slopes) and we may not want to since it takes up a lot of memory (9 extra field?). But maybe there's a good reason to not make the small-angle approximation? We could eventually support both (unapproximated and small-angle approximation). See https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion for a comparison of the two. 2. Is GM-Redi the main parameterization of interest? Would people use the fully symmetric or the fully anti-symmetric diffusivity tensor by themselves?. If not then maybe we can save some time by just implementing one new closure, `GMRedi` or `GentMcWilliamsRedi`. If we take the isopycnal diffusivity to be the same for both the symmetric and anti-symmetric tensor then we the resulting tensor is quite cheap to compute (only 3 components) if performance is impo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1492:87,parameteriz,parameterization,87,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492,2,['parameteriz'],"['parameterization', 'parameterizations']"
Modifiability,"Something a little puzzling to me is that we clearly succeed at type inference when running on the GPU. Do we have a better chance of succeeding there because of `adapt`? We do make some critical simplifications via `adapt`, most notably. https://github.com/CliMA/Oceananigans.jl/blob/f70d0949f7688df89a7f8a9e7d44177cde27091a/src/Fields/field.jl#L400",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480467620:163,adapt,adapt,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480467620,4,['adapt'],['adapt']
Modifiability,"Something else I tried was deleting the `Project.toml` and `Manifest.toml` file as well as `~/.julia`, and after running the following:; ```; using Pkg; Pkg.activate("".""); Pkg.add(""CUDA""); Pkg.instantiate(); using CUDA; ```; I got:; ```; [57577] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA_Runtime_jll/YgJCI/.pkg/platform_augmentation.jl:210; Allocations: 2907 (Pool: 2898; Big: 9); GC: 0; Activating new project at `/glade/derecho/scratch/knudsenl/BottomBoundaryLayer`; Installing known registries into `~/.julia`; Updating registry at `~/.julia/registries/General.toml`; Resolving package versions...; Installed GPUArraysCore ─────────────── v0.1.6; Installed Crayons ───────────────────── v4.1.1; Installed TableTraits ───────────────── v1.0.1; Installed ColorTypes ────────────────── v0.11.5; Installed Adapt ─────────────────────── v4.0.4; Installed Scratch ───────────────────── v1.2.1; Installed Preferences ───────────────── v1.4.3; Installed PrettyTables ──────────────── v2.3.2; Installed CUDA_Driver_jll ───────────── v0.9.1+1; Installed SentinelArrays ────────────── v1.4.5; Installed DataAPI ───────────────────── v1.16.0; Installed PooledArrays ──────────────── v1.4.3; Installed FixedPointNumbers ─────────── v0.8.5; Installed Tables ────────────────────── v1.12.0; Installed LLVMLoopInfo ──────────────── v1.0.0; Installed GPUCompiler ───────────────── v0.26.7; Installed StaticArraysCore ──────────── v1.4.3; Installed TimerOutputs ──────────────── v0.5.24; Installed JLLWrappers ───────────────── v1.5.0; Installed InlineStrings ─────────────── v1.4.2; Installed AbstractFFTs ──────────────── v1.5.0; Installed IteratorInterfaceExtensions ─ v1.0.0; Installed StaticArrays ──────────────── v1.9.7; Installed PrecompileTools ───────────── v1.2.1; Installed DataValueInterfaces ───────── v1.0.0; Installed CUDA_Runtime_Discovery ────── v0.3.4; Installed NVTX_jll ──────────────────── v3.1.0+2; Installed LLVMExtra_jll ───────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900:868,Adapt,Adapt,868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2246012900,1,['Adapt'],['Adapt']
Modifiability,"Something fishy is happening. The error is. ```julia; Reason: unsupported dynamic function invocation (call to Base.Fix1{typeof(Adapt.adapt), Float64}); ```. This means we created a partially-applied function via `Fix1(adapt, x)`. . This looks like a bug that has to do with some package update, maybe to `Adapt`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041:128,Adapt,Adapt,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3406#issuecomment-1867011041,4,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"Sorry about the GPU errors, they're much scarier than they look! Looks like a pretty involved setup so I'll let @glwagner comment on the setup. In this case it looks like Julia is complaining about an `unsupported dynamic function invocation (call to overdub)` in `Fxn_scale` at line 93. ```julia; @inline Fxn_scale(t) = spl_scale(t); ```. which itself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:974,variab,variable,974,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,3,"['Adapt', 'variab']","['Adapt', 'variable']"
Modifiability,"Sorry for the slow replies, I am currently away. I will put together a MWE when I am back. More out of interest, is there a benefit to passing variables explicitly?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1236299727:143,variab,variables,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2700#issuecomment-1236299727,1,['variab'],['variables']
Modifiability,"Sorry if I'm missing something obvious (still new with the working of Oceananigans/Julia), but I was trying to test this feature and expand it to `BuoyancyTracer` over the weekend and I wonder if this implementation can be made more general. . The way I understand @ali-ramadhan created some functions `g_x` to extract the gravity components in each direction and then used them in the `x_dot_g_b` functions to calculate each component of the gravity acceleration. The thing is that gravity can only be a vector using `SeawaterBuoyancy`. When trying to apply this to `BuoyancyTracer` I found that I'd need to replicate the same feature but with a different name (since, as @glwagner pointed out, `gravitational_acceleration` would be a confusing name when working directly with buoyancy). Also, if you also think issue https://github.com/CliMA/Oceananigans.jl/issues/1372 is relevant, it might be nice to have one unified word/approach for the tilting of the domain. So what do you guys think if this tilting is implement at the `AbstractBuoyancy` level? If I understand correctly all buoyancy types inherit that, right? That way we'd have a keyword for the tilt (maybe `tilt`, `gravitational_direction` or `gravity_projection`) that would default to `(0, 0, 1)` and a similar option could be given to `FPlane`, avoiding confusion.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312:1100,inherit,inherit,1100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-782900312,1,['inherit'],['inherit']
Modifiability,Sorry meant to delete the sandbox before merging PR #1348.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1395:26,sandbox,sandbox,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1395,1,['sandbox'],['sandbox']
Modifiability,Stochastic CI variability? I restarted them...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2222364915:14,variab,variability,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2222364915,1,['variab'],['variability']
Modifiability,Stop adapting `OffsetArray` in Oceananigans,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1141:5,adapt,adapting,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1141,1,['adapt'],['adapting']
Modifiability,Store model metadata as parameterized types in the Model struct.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/133:24,parameteriz,parameterized,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/133,1,['parameteriz'],['parameterized']
Modifiability,"Strange that we don't have this already but this PR refactors the operators to be truly finite volume. By using multiple dispatch we only have one operator rather than having a different operator for each grid. The beautiful ϊ (`\iota\ddot`) now denotes interpolation. Thanks @sandreza!. Need to switch to using the `caa`, `afa`, etc. notation and introduce some composite operators from `closure_operators.jl`. Just opening this PR early so people can see what the new operators look like, get some feedback, etc. Once this PR is merged, implementing a vertically stretched grid will be easy, and implementing wall bounded directions should be as simple as defining something like; ```julia; Ay(i, j, k, grid) = ifelse(j == 0, 0, Δx(i, j, k, grid) * Δz(i, j, k, grid)); ```; but still thinking about the best way to dispatch on e.g. `DoublyPeriodicDomain`, `ChannelDomain`, `TriplyPeriodicDomain`, etc. I will also release v0.7.0 once this PR is merged. Resolves #115; Resolves #146 ; Resolves #469",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/283:52,refactor,refactors,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/283,1,['refactor'],['refactors']
Modifiability,"StreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:407",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:11614,adapt,adapt,11614,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['adapt'],['adapt']
Modifiability,"StreamGetCaptureInfo; @ ~/.julia/packages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.jul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2072,adapt,adapt,2072,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,1,['adapt'],['adapt']
Modifiability,"Stuck with this error:. ```; julia> include(""test_enzyme.jl""); MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.22; MPIPreferences.jl: 0.1.11; MPICH_jll: 4.2.3+0. Library information:; libmpi: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; libmpi dlpath: /Users/gregorywagner/.julia/artifacts/5b62c899cf8329a8d07e8fe6eda96039010046c7/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version:; MPICH Version: 4.2.3; MPICH Release date: Wed Oct 2 09:35:21 AM CDT 2024; MPICH ABI: 16:3:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --disable-doc --enable-fast=all,O3 --enable-static=no --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features:. Enzyme with CATKEVerticalDiffusivity: Error During Test at /Users/gregorywagner/Projects/Oceananigans.jl/test/test_enzyme.jl:264; Got exception outside of a @test; MethodError: no method matching getindex(::Base.RefValue{Tuple{Base.RefValue{Float64}, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, Nothing, Nothing, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Field{Center, Face, Center",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596:602,config,configure,602,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3837#issuecomment-2400785596,1,['config'],['configure']
Modifiability,"Suggestions are definitely welcome for streamlining everything!. Note: in dedalus, this problem is handled by allowing users to accumulate parameters into something like `model.parameters` (in dedalus, this is essentially a dict whose keys are accessible by their names to any function/equation defined with a string expression). Having a ""global-like"" variable (like `model.parameters`) is pretty convenient, but also leads to more complicated code. The more democratic callable object strategy is a bit simpler and more modular, but may involve a slightly more complicated API (though I'm not 100% sure about that --- users must decide!)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595948214:353,variab,variable,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682#issuecomment-595948214,1,['variab'],['variable']
Modifiability,"Supercedes #3090, introducing a more comprehensive refactoring of the CATKE formulation. Closes https://github.com/CliMA/Oceananigans.jl/issues/3064; Closes https://github.com/CliMA/Oceananigans.jl/issues/3047",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3122:51,refactor,refactoring,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3122,1,['refactor'],['refactoring']
Modifiability,"Sure!. ```; (Oceananigans) pkg> status; Project Oceananigans v0.53.0; Status `~/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/Project.toml`; [79e6a3ab] Adapt v3.2.0; [052768ef] CUDA v2.4.1; [a8cc5b0e] Crayons v4.0.4; [7a1cc6ca] FFTW v1.3.2; [e9467ef8] GLMakie v0.1.30; [c27321d9] Glob v1.3.0; [033835bb] JLD2 v0.4.3; [63c18a36] KernelAbstractions v0.5.4; [da04e1cc] MPI v0.16.1; [442fdcdd] Measures v0.3.1; [85f8d34a] NCDatasets v0.11.3; [6fe1bfb0] OffsetArrays v1.6.2; [bac558e1] OrderedCollections v1.4.0; [4a48f351] PencilFFTs v0.12.2; [d330b81b] PyPlot v2.9.0; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.0; [09ab397b] StructArrays v0.5.0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [10745b16] Statistics; ```. ```; ERROR: LoadError: ArgumentError: length(size) must be 2.; Stacktrace:; [1] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64; greater_than::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [2] validate_tupled_argument(::Tuple{Int64,Int64,Int64}, ::Type{T} where T, ::String, ::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:24; [3] validate_size(::Type{T} where T, ::Type{T} where T, ::Type{T} where T, ::Tuple{Int64,Int64,Int64}) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/input_validation.jl:48; [4] RegularRectilinearGrid(::Type{T} where T; size::Tuple{Int64,Int64,Int64}, x::Tuple{Int64,Int64}, y::Tuple{Int64,Int64}, z::Tuple{Int64,Int64}, extent::Nothing, topology::Tuple{DataType,DataType,DataType}, halo::Nothing) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/src/Grids/regular_rectilinear_grid.jl:161; [5] simulate_lid_driven_cavity(; Re::Int64, N::Int64, end_time::Int64) at /home/meck/Documents/Bachelor Arbeit/Repos/Oceananigans.jl/validation/lid_d",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928:154,Adapt,Adapt,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1507#issuecomment-807380928,1,['Adapt'],['Adapt']
Modifiability,"SurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1666,adapt,adapt,1666,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['adapt'],['adapt']
Modifiability,"Tar`; [8dfed614] Test `@stdlib/Test`; [cf7118a7] UUIDs `@stdlib/UUIDs`; [4ec0a83e] Unicode `@stdlib/Unicode`; [e66e0078] CompilerSupportLibraries_jll `@stdlib/CompilerSupportLibraries_jll`; [deac9b47] LibCURL_jll `@stdlib/LibCURL_jll`; [29816b5a] LibSSH2_jll `@stdlib/LibSSH2_jll`; [c8ffd9c3] MbedTLS_jll `@stdlib/MbedTLS_jll`; [14a3606d] MozillaCACerts_jll `@stdlib/MozillaCACerts_jll`; [05823500] OpenLibm_jll `@stdlib/OpenLibm_jll`; [efcefdf7] PCRE2_jll `@stdlib/PCRE2_jll`; [83775a58] Zlib_jll `@stdlib/Zlib_jll`; [8e850ede] nghttp2_jll `@stdlib/nghttp2_jll`; [3f19e933] p7zip_jll `@stdlib/p7zip_jll`; Precompiling project...; ✗ RecipesPipeline; ✗ Plots; 0 dependencies successfully precompiled in 7 seconds (205 already precompiled); 2 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages; Testing Running tests...; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads; [2023/02/21 06:36:13.652] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.673] WARN allowscalar([true]) is deprecated, use `allowscalar() do end` or `@allowscalar` to denote exactly which operations can use scalar operations. -@-> /g/data/v45/nc3020/OC.jl/test/dependencies_for_runtests.jl:71; [2023/02/21 06:36:18.728] WARN Over-writing registration of the datadep -@-> /g/data/v45/nc3020/.julia/packages/DataDeps/ae6dT/src/registration.jl:15; [2023/02/21 06:36:18.729] WARN Over-writing registration of the datadep -@-> /g/data/v45/nc3020/.julia/packages/DataDeps/ae6dT/src/registration.jl:15; [2023/02/21 06:36:19.136] INFO Running shallow wat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:10688,Config,Configuration,10688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Config'],['Configuration']
Modifiability,"Tests fail on v0.76.5 on GPU... weird... ```Julia; nc3020@gadi-gpu-v100-0100:/g/data/v45/nc3020/OC.jl$ julia-1.6 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.6.7 (2022-07-19); _/ |\__'_|_|_|\__'_| |; |__/ |. (Oceananigans) pkg> test; Testing Oceananigans; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Project.toml`; [79e6a3ab] Adapt v3.3.3; [6e4b80f9] BenchmarkTools v1.3.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [124859b0] DataDeps v0.7.10; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [91a5bcdd] Plots v1.36.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates `@stdlib/Dates`; [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`; [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`; [56ddb016] Logging `@stdlib/Logging`; [44cfe95a] Pkg `@stdlib/Pkg`; [de0858da] Printf `@stdlib/Printf`; [9a3f8284] Random `@stdlib/Random`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [8dfed614] Test `@stdlib/Test`; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Manifest.toml`; [621f4979] AbstractFFTs v1.1.0; [79e6a3ab] Adapt v3.3.3; [4fba245c] ArrayInterface v6.0.1; [30b0a656] ArrayInterfaceCore v0.1.2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:477,Adapt,Adapt,477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Modifiability,"Thank you for all your comments. I will try those lines; Just one question. Is the sintax of. `ΞT = randn(size(T)...) *. shape`. correct? I am getting this error message:. > Warning: No xauth data; using fake authentication data for X11 forwarding.; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: syntax: invalid identifier name "".""; Stacktrace:; [1] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197; in expression starting at /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case09/c16_128_128m.jl:197. Line 197 corresponds to the line above. I removed the `*.shape` and the simulations are now running. Is that ok?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962:290,variab,variable,290,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268557962,5,"['Config', 'config', 'variab']","['Config', 'Configuration', 'config', 'variable']"
Modifiability,"Thank you for reply, @glwagner!. > Can you clarify --- is the simulation on the right with the FFT-based _direct_ solver, or is it with a preconditioned conjugate gradient solver that use an FFT as a preconditioner?. On the left is FFT-based direct solver. On the right is the PCG solver with the FFT-based solver as a preconditioner. > My suggestion is to use a preconditioned conjugate gradient solver, with the FFT-based solver as a _preconditioner_ (not as the direct solver). It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the `HeptadiagonalIterativeSolver`. > As for blow up I think the problem happens for very small time-steps? Perhaps try it without adaptive time-stepping for now and also cap the `max_iterations` as a small number. I am doing more testing on this. It is a different issue though. I will open a new issue if I can find a simple way to reproduce the blow up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297:825,adapt,adaptive,825,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071006297,2,['adapt'],['adaptive']
Modifiability,"Thank you for the links !. The Oceananigans src code is very clearly written so the reading is relatively OK (I could use some explanations on your closure usage). If it was up to me I would prefer an extended documentation of GPUifyLoops ;) I only understand how it works by reading what you do with it. . The GPU shared memory is basically a programmable cache while the cache of CPU can't be (easily) controlled. In both cases there is cache so, if you compute multiple partial derivatives of a given (set of) field(s) (d/dx,d/dy, d2/dx2,...) once a block has been fetched in the cache then the memory operations are cheap. Cache is also useful for performing tiny transpositions enabling fast access and vectorized (SIMD) CPU or GPU ops in both X,Y or Z directions. . I hope that obtaining an efficient code for both (multicore SIMD) CPUs and GPUs maybe possible adjusting the (recursive?) block sizes (i.e. controlling the data layout and adapt it to the computing target). I will try to use part of your code to rewrite the toy 2D CFD solver I have translated from Matlab (https://discourse.julialang.org/t/asynchronous-makie/27127/9?u=laurentplagne). Kudos again to your team for this inspiring package. Laurent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592:201,extend,extended,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/333#issuecomment-518372592,3,"['adapt', 'extend', 'rewrite']","['adapt', 'extended', 'rewrite']"
Modifiability,"Thank you for the written explanation! Here are my comments:. > to split the bgc tendencies from the rest I needed a way to turn them off in the normal tendency computation, I did this by passing a keyword all the way through to biogeochemical_transitions - when I did it this way the intention was to touch as little of the existing code as possible, but it might not be the cleanest/most maintainable. I don't think we need to change anything in the existing kernels code. Instead, we can design an interface that allows biogeochemical models (like the models implemented in OceanBioME) to ""opt-in"" to a substepping scheme. In this design, there's no need to change the existing ""slow"" kernels I don't think. However, we could consider changing the name of them. For example, all that's needed is for the _implementation_ to know when to return a slow source term vs fast source term. > this is where I had to make some more changes to the existing code (and probably the messiest part of what I did), because the code often expects the tendencies to live at timestepper.G / $G^-$, so I made functions that dispatched on the timestepper and usually returned that, but for the new timestepepr returned timestepper.physics.G etc. I'm not sure that new tendencies are needed for substepping. The substepping scheme for CATKE manages to avoid allocating any additional tendencies by preserving the ""slow"" source term:. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/TurbulenceClosures/turbulence_closure_implementations/TKEBasedVerticalDiffusivities/time_step_catke_equation.jl#L167-L171. The only change that is needed within Oceananigans (in principle) --- as far as I can tell --- is to skip the tracer update for certain tracers (like we do for CATKE and TKEDissipation):. https://github.com/CliMA/Oceananigans.jl/blob/6c40d7e225c2127051b2703b9c62a8b18260e3a5/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L78-L85. Then the ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851:390,maintainab,maintainable,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3888#issuecomment-2455670851,2,['maintainab'],['maintainable']
Modifiability,"Thank you for your feedback @maleadt! What is CUDAnative compilation? If you mean the precompilation phase when CUDAnative is first loaded, then it's not that as I start timing after all packages are loaded. I thought 6-7 minutes was normal/expected as @vchuravy et al. reported similar GPU compilation times for their shallow water model: https://github.com/JuliaLabs/ShallowWaterBench. I haven't done any rigorous benchmarking yet but out of those 6 minutes, ~1.5 minutes are spent on compiling code that creates CuFFT plans (the first plan takes 1.5 minutes then the others take <1 second). From watching the log I'm guessing the other 4.5 minutes are evenly split between setting up the model (creating CuArrays, initializing them, etc.) and the first time step (where the kernels are getting compiled presumably). I don't think we have that many kernels (just 5 bigger ones) but one of them; https://github.com/ali-ramadhan/Oceananigans.jl/blob/2b64d584c79ece0429f2421335ddb6bc0c6c6663/src/time_steppers.jl#L213; has several layers of inlining (it's inlining the majority of the functions in [operators/ops_regular_cartesian_grid_elementwise.jl](https://github.com/ali-ramadhan/Oceananigans.jl/blob/master/src/operators/ops_regular_cartesian_grid_elementwise.jl)) after which it probably balloons up to be a pretty big kernel. They also have tons of arguments crammed in as the structs I was passing weren't `isbitstype` (working on this #59). I should come back and update this issue once we do some proper benchmarking (note to self: nvprof seems like it's being deprecated in favor of Nsight). Caching kernels between sessions sounds tough but will definitely look into timing compilations in CUDAnative, might provide some insight on how to speed things up.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-466847765:1030,layers,layers,1030,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/66#issuecomment-466847765,1,['layers'],['layers']
Modifiability,"Thanks @ali-ramadhan. I agree and confirmed that where the derivative is computed on faces and centres, the following line and the line below. This should extend to higher orders of course. https://github.com/CliMA/Oceananigans.jl/blob/ebd7858000c78f7b1754112a68c587e6195e620b/src/Operators/derivative_operators.jl#L18",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741927886:155,extend,extend,155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1266#issuecomment-741927886,1,['extend'],['extend']
Modifiability,"Thanks @glwagner and @ali-ramadhan for your suggestions. They all sound very interesting and gives me a lot to think about. Here are my initial reactions. Given that I don't know the numerics of Oceananigans, yet, but know the physics, I can imagine myself contributing to the following pretty quickly:. 1. Shallow Water model (and maybe even a Green-Naghdi version) with several layers for fun.; 2. Layered and stratified Quasi-Geostrophic Model; 3. Hydrostatic Boussinesq Model (rigid lid first and then a free-surface). Something that I can imagine giving to good undergraduate research students would be. 4. Verticall-Implicit time-stepping for diffusion. ; 5. Profiling parallelism. If I had keen student in computer science then maybe . 6. Distributed parallelism with MPI. . I have never used GPU's before but given the efficiency of GPU's vs CPU's that you have in the docs, I am definitely going to learn. Initial thougths on 1 and 2:; I know that FourierFlows has both QG and SW, which are spectrally based. I gather that Oceananigans is Finite Volume based. If I wanted to start with either of these would you suggest I start wtih FourierFlows or ignore that?. I kind of like the idea of having a QG code that can either be FV or Spectral, depending on the users whims, but that might be difficult, depending on how compatable these two libraries are. I suppose I should start in reading the code in detail and planning out what I think needs to be done. Any suggestions are welcome!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151:380,layers,layers,380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724274151,1,['layers'],['layers']
Modifiability,"Thanks @glwagner and I agree, at the last time I definitely see more smaller scale features. Also, I agree that since velocity is always smoother than vorticity, that is perhaps a better field to use. Clever idea!. In the paper you mentioned, equation 33 is the at the core where the nonlinear Coriolis term is rewritten using WENO schemes to rewrite `\omega U_\perp` using WENO. Is this what is the part that is done differently where the velocity is used?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081927354:343,rewrite,rewrite,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1081927354,1,['rewrite'],['rewrite']
Modifiability,"Thanks @glwagner for the help. Much appreciated. I tried to adapt it and the good news is that I don't get an error. The bad news is that I don't think the boundary conditions are being set correctly. . Below are a few ideas of things I think I need to do. Maybe you can confirm whether I understand this correctly?. - You had it set up for the sponge to depend on x but if I want the inflow and outflow to be in the south and north, respectively, then it should depend on `y`, right?; - `smoothed_step_mask` is currently only acting on the south. I pressume I need to add a similar function for the north?; - Do I need to have a sponge on `h` as well? I thought imposing this on `vh` might be enough in the case when the flow doesn't vary in the zonal direction. I imagine if I want inflow from the west only, which I do want, and the meridonal velocity depends on the zonal coordiante, then I should pick the sponge to relax to a geostrophically balanced state.; - Even though I am trying to set the inflow/outflow boundary conditions to `vh -> h` so that `v -> 1`, when I look at the final matrix, I have that `vh` is zero everywhere. This tells me that the boundary conditions are not being set. It does seem to say that `vh` does have `NormalFlow` boundary conditions so that seems like something is right. ```; using Oceananigans; using Oceananigans.Grids; using Oceananigans.Models; using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBoundary. using Oceananigans.BoundaryConditions: NormalFlow. grid = RegularRectilinearGrid(size=(64, 64),; x=(-10, 10), y=(0, 5),; topology=(Periodic, Bounded, Flat)). bump(x, y, z) = y < exp(-x^2); grid_with_bump = ImmersedBoundaryGrid(grid, GridFittedBoundary(bump)). damping_rate = 1/100 # relax fields on a 100 second time-scale; const y0 = 0 # center point of sponge; const dy = 1.0 # sponge width; smoothed_step_mask(x, y, z) = 1/2 * (1 + tanh((y - y0) / dy)). vh_sponge = Relaxation(rate=damping_rate, mask=smoothed_step_mask, target",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935:60,adapt,adapt,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1730#issuecomment-852653935,1,['adapt'],['adapt']
Modifiability,"Thanks @glwagner! We haven't been using background velocities in our setups, so won't have as much to say on that yet. But we'll continue testing the background tracer fluxes. @samlewin, are you using background shear in addition to background tracer fields in your configurations, or is the shear just in your initial conditions? This PR might be relevant.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2276121204:266,config,configurations,266,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2276121204,1,['config'],['configurations']
Modifiability,Thanks @simone-silvestri for adding a GPU test for `FieldTimeSeries`! I've adapted it correctly now and tests pass locally so I think this PR is ready for review. Actually I should add a test that uses the new kwargs. Would do a test where multiple threads open the same `FieldTimeSeries` but don't think we have multi-threaded tests.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2397361158:75,adapt,adapted,75,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3739#issuecomment-2397361158,1,['adapt'],['adapted']
Modifiability,"Thanks @tomchor for your feedback. It is greatly apprecaited. For the first point, I completely appreciate that we need to be clear. This can be done in the docstrings but it is certainly nice to pick variable names that are intuitive and make the code easier to read. I think Oceananigans does this very well and I very much want to continue in this direction. . I wonder if something like `zF_stretch` might do the trick? The `zF` suggests the result will be at faces and `stretch` suggests that this is a stretching of some kind. Or maybe `z_Faces_stretched`?. I am sorry if I mispoke. I did not mean to say that users do not care about what kind of stretched grid we use. This is clearly not the case. What I wanted to say is that a beginning user probably would be more concerned about having a stretched grid and probably not so much of the details. Some users would of course care a great deal about the kind of grid, and we definitely want to help both kinds of users. I agree with @glwagner 's suggestion of us supply a few basic examples for people to use, as a starting point. Users should certainly be able to take these examples, build on them, and build whatever kind of stretched grid they want. This is currently available and this should always be the case. When defining our examples we should not only define the region (or regions where we want it stretched, as it shouldn't only have to be one spot), but also the degree to which it decays. I don't necessarily have the language to describe this accurately now, but when putting together a sample function/array, I think a lot of this will beome clearer (to me at least).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145:201,variab,variable,201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-813565145,2,['variab'],['variable']
Modifiability,"Thanks for all the context! . Good points about the time step being more restricted by Coriolis for coarse global simulations and error being dominated by spatial discretization. I'd also be very interested how AB2 compares against RK3 for time-to-solution. I guess this could be readily tested with the non-hydrostatic model simulating turbulence. I'd be curious if RK3 is always faster, or if it's case-dependent. Although it is risky to be on the edge of stability CFL-wise. > It may be a research project to adapt the split-explicit free surface. . Ah I didn't realize that RK3 was not really used for global ocean models, especially with a split-explicit free surface :(. > However, also in this form, successive tendencies do not cancel out. Is this neccessary or is this why Quasi AB2 is technically only first-order accurate? I guess right now with Euler steps the tendency terms do cancel out when an AB2 time step is taken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640:512,adapt,adapt,512,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2418146640,1,['adapt'],['adapt']
Modifiability,"Thanks for bringing these up! This stuff certainly needs some work, and we should probably make it clear what's e.g. a free parameter. > I see a few problems:; > * `f` is not a property of a planet. Agreed. Perhaps now that we're also thinking of channel models on a _β_-plane, we should also build a ""rotation"" abstraction to choose between _f_-plane, _β_-plane, and Coriolis force (possible with cosine term). > * 'Model configuration' is an obscure name for turbulent or molecular transport coefficients. Yes. This should be addressed by incorporating a `TurbulentDiffusivity` struct like the one you proposed in #120. I agree with John that when we do this, isotropic and anisotropic diffusion should be options. > * A reference density is not a parameter in an equation of state.; Hmmm, but if ρ₀ is needed to calculate ρ then isn't it a parameter of the EOS?. Sounds like this issue is worth discussing and strategizing about. We could maybe get some ideas and inspiration from how CliMA.jl is handling parameters?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491642405:423,config,configuration,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/217#issuecomment-491642405,1,['config'],['configuration']
Modifiability,"Thanks for confirming!. So the two outstanding issues are:. - [ ] Do we want to divide by volumes instead of areas to be more general? (Cosmetic but maybe worth fixing); - [ ] Figure out how the height field should be included to achieve higher accuracy, which neither formulation is able to do.; - [ ] Do we evolve the tracer or thickness weighted tracers?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165836785:309,evolve,evolve,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1165836785,1,['evolve'],['evolve']
Modifiability,"Thanks for embarking on this @glwagner!. > It's a bit of a work in progress. Before merging we need:; > * tests (simple 1D test with temperature to see if budgets are correct?). Just added ""WIP"" (work in progress) to the PR title. We can work on the tests together. For testing, we should be able to extend the 1D column model example: https://github.com/climate-machine/Oceananigans.jl/blob/master/examples/column_model.jl. > Also looks like Travis is failing; not sure why that is. Looks like it's just the one test in the time stepping section that's failing. Maybe something to do with how the boundary conditions are called during the time stepping? The Model test passes so it's not erroring during model initialization/construction. > I propose changing the struct `BoundaryConditions` to `ModelBoundaryConditions` for clarity. I'll always vote for clarity!. Just one initial question: I might be misunderstanding the purpose of `bc.calc` but why not `bc.impose(args...)` instead of `bc.calc(args...)` as we usually say that we _impose_ boundary conditions?. Have to run out but will have a more detailed look later today. Otherwise, looks really neat! On a more practical note, might end up being easier to discuss this PR in person.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-471182606:300,extend,extend,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118#issuecomment-471182606,1,['extend'],['extend']
Modifiability,"Thanks for looking through the time stepping code, this is great feedback!. I agree it would be nice to dispatch on the array type (or even the architecture, another reason to use types instead of symbols). No reason why `xC, xF, yC, ...` have no assigned type in `RegularCartesianGrid`, just oversight on my part. There will probably be a major refactor of the code's design soon-ish to get all this little stuff right. I remember fields initially had the array type be a parameter, e.g. `CellField{T}` then `data::T` but I hit some performance issues with that I think. I may have just been encountering the [Avoid fields with abstract containers](https://docs.julialang.org/en/v1/manual/performance-tips/index.html#Avoid-fields-with-abstract-containers-1) Julia performance tip, but I think making the parameter an `AbstractArray` as you're suggesting shouldn't sacrifice performance. And yes, the solver is not spectral. Will probably generically call it `PoissonSolver` when the next refactor happens (and the documentation would make it clear what it actually does).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462783213:346,refactor,refactor,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/45#issuecomment-462783213,2,['refactor'],['refactor']
Modifiability,"Thanks for the additional changes and it seems to be doing much better! Still three tests that fail. I looked ath the initialize environments and saw what I copied below. It seems to have probelms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.Pk",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:926,variab,variable,926,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,2,"['config', 'variab']","['config', 'variable']"
Modifiability,"Thanks for the feedback! We were also thinking that if the ocean and atmosphere shared the same vertical indexing then maybe using some shared parameterizations would be easy but as pointed out, vertical indexing isn't necessarily a rigid thing in DG. Also sounds like the ocean and atmosphere don't need to agree as they're arbitrary decisions anyways. Interesting point about setting the vertical index to be the fastest running index to help speed up vertical integrals. We only have one vertical integral in the time stepping core so not sure if it'll make a big difference on the ocean side but something to think about! Might be relevant to #21. We decided to switch our convention and use _k=1_ at the bottom. I'll submit a PR soon with this change.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/90#issuecomment-469654068:143,parameteriz,parameterizations,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/90#issuecomment-469654068,1,['parameteriz'],['parameterizations']
Modifiability,"Thanks for the questions @simone-silvestri . I'll answer them here as it's probably easier for the discussion. **Q1**: You can certainly solve the equations in the non-conservative form and the method should work. But it does't have any advantages compared to other methods: i.e. doesn't help with conserving anything and does not easily extend to other geometries. **Q2**: The pressure term in the momentum equation is ` 1/\rho_0 \nabla p`. In the case of a rigid lid we have that `p` is the surface pressure. I thought that redefining pressure with ` p/\rho_p -> p` might be easier, to get rid of the constant, but it's easy enough to include the coefficent. We should continue to do whatever Oceananigans is currently doing, and I thought it was absorving the constant density, but I could be wrong. **Q3**: In the shallow water model with a free-surface the pressure is always hydrostatic, `p = p_0 + g \rho_0 (h - z)`, where `h` is the total depth. The case of a rigid lid is a bit different since we just have the surface pressure `p`. You are correct that the free-surface shallow water model is very similar to the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `Vec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:338,extend,extend,338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,2,['extend'],['extend']
Modifiability,Thanks for the suggestions @simone-silvestri! And I noticed you started doing some refactoring in PR #3847 so I'll close this in favor of your PR.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3830#issuecomment-2412498850:83,refactor,refactoring,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3830#issuecomment-2412498850,1,['refactor'],['refactoring']
Modifiability,"Thanks to @vchuravy's work, a two-year old PR was finally merged! https://github.com/JuliaArrays/OffsetArrays.jl/pull/57. So OffsetArrays v1.4.0 now adapts OffsetArrays. This means we can should rid of this file: https://github.com/CliMA/Oceananigans.jl/blob/a48f284ca7341193254ddb3fc44daa9f5e9f318d/src/Utils/adapt_structure.jl. because right now we get a method redefinition warning:. ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition adapt_structure(Any, OffsetArrays.OffsetArray{T, N, AA} where AA<:AbstractArray{T, N} where N where T) in module OffsetArrays at /home/alir/.julia/packages/OffsetArrays/ExQCD/src/OffsetArrays.jl:486 overwritten in module Utils at /home/alir/Oceananigans.jl/src/Utils/adapt_structure.jl:5.; ** incremental compilation may be fatally broken for this module **; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1141:149,adapt,adapts,149,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1141,1,['adapt'],['adapts']
Modifiability,"Thanks, that's helpful @jagoosw. Just one more thought... I realized after I did the testing for my previous post that the hang occurs at ""Initializing simulation..."". This implies that the problem isn't with any constructors (eg the `Field` constructor above) but rather the actual computations, probably. A big change from 0.85 (which [occurred in 0.88](https://github.com/CliMA/Oceananigans.jl/releases/tag/v0.88.0)) is the [introduction of the `KernelParameters` abstraction](https://github.com/CliMA/Oceananigans.jl/pull/3125) for offsetting indices within kernels, used here:. https://github.com/CliMA/Oceananigans.jl/blob/70536571523ad2eb71fd9a2200121eca63998ac4/src/AbstractOperations/computed_field.jl#L78. and I think other places, which @simone-silvestri can advise. `KernelParameters` extends some `KernelAbstractions` functionality in a non-trivial way I think. Maybe there are some things we can improve there:. https://github.com/CliMA/Oceananigans.jl/blob/main/src/Utils/kernel_launching.jl. Even if the issue is fixed on 1.10, I think we still ought to understand this problem better since it might come back in the future (things like this often do...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808580651:797,extend,extends,797,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1808580651,1,['extend'],['extends']
Modifiability,"That could work --- though I'd point out that listing the model components that can be inconsistent with one another might be more explicit. I would advocate for a ""blacklisting"" method whereby blacklisted combinations of components are listed local to the implementation of the component. For example, in `beta_plane.jl` we could add. ```julia; validate_coriolis(::BetaPlane, ::AbstractGrid{FT, TX, <:Periodic}) where {FT, TX} = # error; ```. we also need, in `hydrostatic_spherical_coriolis.jl`,. ```julia; validate_coriolis(::HydrostaticSphericalCoriolis, ::AbstractRectilinearGrid) = # error; ```. I think a warning is better than an error for `WENO5` on a curvilinear grid. That'd be a fun scheme to experiment with and we don't know ""how wrong"" it is. If the curvilinear grid is almost regular, we have reason to think it might work. In cases like these where we aren't completely, rock-solid positive that a certain model configuration is invalid I think we should also err conservative and allow such models to be constructed. . We do need to strike a balance between being helicopter parents to users, and catching common mistakes. I don't think we should get in the business of curating science --- we should just provide useful software. Specialty applications can just avoid the kwarg-based constructor so I'm not sure we should worry much about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847:929,config,configuration,929,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796814847,1,['config'],['configuration']
Modifiability,That was just an example. There's a lot of erroneous usage. This might help:. ```; (base) gregorywagner:src/ (glw/fix-adapt) $ grep -r unroll ./* [11:11:55]; ./Advection/Advection.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./Advection/stretched_weno_smoothness.jl: @unroll for j = 1:3; ./BoundaryConditions/fill_halo_regions_open.jl:# and need to unroll a loop over the boundary normal direction.; ./BoundaryConditions/fill_halo_regions.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for i = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for j = 1:H; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for n = 1:M; ./BoundaryConditions/fill_halo_regions_periodic.jl: @unroll for k = 1:H; ./BoundaryConditions/fill_halo_regions_flux.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl:using KernelAbstractions.Extras.LoopInfo: @unroll; ./Fields/regridding_fields.jl: @inbounds @unroll for k = 1:target_grid.Nz; ./Fields/regridding_fields.jl: @unroll for k_src = k₋_src:k₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for j = 1:target_grid.Ny; ./Fields/regridding_fields.jl: @unroll for j_src = j₋_src:j₊_src-1; ./Fields/regridding_fields.jl: @inbounds @unroll for i = 1:target_grid.Nx; ./Fields/regridding_fields.jl: @unroll for i_src = i₋_src:i₊_src-1; ./Fields/field_boundary_buffers.jl:using KernelAbstractions.Extras.Lo,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155:118,adapt,adapt,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3374#issuecomment-1874436155,1,['adapt'],['adapt']
Modifiability,"That was the main issue we discussed in #2740 with locating the free surface at `grid.Nz+1`. . (from #2740); > Well the issue is that if we want to save the output at the surface `(:, :, grid.Nz)` we cannot include the free surface if this is defined at `grid.Nz+1` (it would not exist at `grid.Nz`). ... `grid.Nz+1` won against `grid.Nz` so, for the moment, you should define two different `OutptWriters`, one for grid-sized variables and one for the free surface.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267430238:426,variab,variables,426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2770#issuecomment-1267430238,1,['variab'],['variables']
Modifiability,"That was used for smoothness indicators on variable grids (the previous `stretched_smoothness` in `WENO5(grid = grid, stretched_smoothness=true)`). I temporarily removed that keyword because it assumed that WENO was order 5. (also we weren't using it because it made everything quite slow). I had the plan to reintroduce it with the upcoming advection refactor",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2747#issuecomment-1256262527:43,variab,variable,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2747#issuecomment-1256262527,2,"['refactor', 'variab']","['refactor', 'variable']"
Modifiability,"That's great news @ali-ramadhan . I guess by looking at your code I can learn how to adapt it to `ShallowWaterModel`. Maybe I will start by doing some tests for the two-dimensional turbulence example, or has someone done that already? By that I mean checking scalabiilty.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921:85,adapt,adapt,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-786696921,1,['adapt'],['adapt']
Modifiability,"That's great that you want to do this @apaloczy ! I am also happy to help if I can. I think that @glwagner explained it very well. One question I will raise is, do we prefer to have to have height as a variable, or the free surface, which is more consistent with the hydrostatic model?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1114360766:202,variab,variable,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1712#issuecomment-1114360766,1,['variab'],['variable']
Modifiability,"The Adams-Bashforth time stepper relies on an approximate time-integral to calculate the tendencies. ; This time integral, when using a constant time step, is simply approximated as; ```math; G^{n+1} = \left(\frac{3}{2} + \chi \right) G^n - \left( \frac{1}{2} +\chi \right) G^{n-1}; ```; The $\chi$ term should be a small deviation from the time integral, added to reduce the noise generated by non-linear terms. ; I wanted to open a bit of a discussion about the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have adde",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738:531,variab,variable,531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738,1,['variab'],['variable']
Modifiability,"The Julia docs go into a lot of detail and have a useful summary (https://docs.julialang.org/en/v1.5/manual/modules/#Summary-of-module-usage-1) but I think `import` is used with the intention of extending a method via multiple dispatch. So you would `import Flux: σ` if you wanted to define a new method for `σ`, e.g. if you wanted to define a custom `σ(x::Complex)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1285#issuecomment-755264366:195,extend,extending,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1285#issuecomment-755264366,1,['extend'],['extending']
Modifiability,"The MIT grid seems to just copy the metrics from the first cell... ```; julia> grid = ConformalCubedSphereGrid(cs32_filepath, CPU(), Nz=1, z=(-1, 0));; ┌ Warning: ConformalCubedSphereGrid is experimental: use with caution!; └ @ Oceananigans.CubedSpheres ~/Research/OC.jl/src/CubedSpheres/conformal_cubed_sphere_grid.jl:163. julia> fgrid = grid.faces[1]; 32×32×1 OrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded} on CPU with 1×1×1 halo and with precomputed metrics; ├── longitude: FullyConnected λ ∈ [-45.0, 44.0312) variably spaced with min(Δλ)=80152.3, max(Δλ)=3.23804e5; ├── latitude: FullyConnected φ ∈ [-45.0, 42.2888) variably spaced with min(Δφ)=80152.3, max(Δφ)=3.23804e5; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> fgrid.Δxᶠᶠᵃ[0:3, 0:3]; 4×4 Matrix{Float64}:; 80152.3 80152.3 1.36265e5 170108.0; 80152.3 80152.3 1.36265e5 170108.0; 1.33313e5 1.33313e5 1.51133e5 1.76175e5; 1.69174e5 1.69174e5 1.75781e5 1.90232e5; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384647750:545,variab,variably,545,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2836#issuecomment-1384647750,2,['variab'],['variably']
Modifiability,The `GITHUB_REPOSITORY` environment variable is used by GitHub actions. We deploy from Travis so the right environment variable is `TRAVIS_REPO_SLUG`.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/804:36,variab,variable,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/804,2,['variab'],['variable']
Modifiability,The `SplitExplicitFreeSurfaces` module is only temporary here for easier manipulation and refactoring of the code. We can remove it if we decide we don't want the free surface in a module,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3894#issuecomment-2451588537:90,refactor,refactoring,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3894#issuecomment-2451588537,1,['refactor'],['refactoring']
Modifiability,"The advection-like Coriolis scheme was a non-sequitur because `f` is a very regular field, so upwinding it was just decreasing performance without a significative increase in quality of the simulation. On the other hand, upwinding `u` is very much discouraged because the energy builds up rapidly (by upwinding the velocity the divergence of the reconstructed tangential velocity is not a direct interpolation of the divergence of the original velocity, which is a necessary condition to maintain the algorithm stable). The only thing I can think to increase the order of velocity interpolation in the Coriolis force is to use a centered high-order scheme to interpolate velocity, but that would not help with the noise since a centered scheme is dispersive in nature. . I converted this PR to implement a `WetPointCoriolisScheme` (described in [Numerical boundary layers and spurious residual flows](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/JC091iC09p10621)). ; This is just a simple addition to an enstrophy conserving scheme where edge (""dry"") points are neglected in the interpolation of the velocity in the tangential direction. A comparison of the output of this scheme in a global 1 degree setup will follow",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272:865,layers,layers,865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2729#issuecomment-1252445272,2,['layers'],['layers']
Modifiability,"The buoyancy is actually a buoyancy perturbation, showing the growth of diffusive boundary layers + waves. But the viscosity and diffusivity help dissipate the grid scale waves so that larger scale waves dominate later on.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442594450:91,layers,layers,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2935#issuecomment-1442594450,1,['layers'],['layers']
Modifiability,"The climate machine shallow water model used DG numerics. I agree with Greg; that it would be nice to do a side-by-side comparison of two; numerical approaches to the same underlying equations. Not sure it used a; Bernoulli formulation.; john; ps Francis - great that you are involved with oceananigans!. On Fri, Nov 13, 2020 at 11:53 AM Gregory L. Wagner <notifications@github.com>; wrote:. > 2. Climate Machine also has a shallow water model; > <https://github.com/CliMA/ClimateMachine.jl/blob/master/src/Ocean/ShallowWater/ShallowWaterModel.jl>.; > I don't know the details of what this does but I should probably learn how; > the two models will differ.; >; > I'm not 100% sure how its implemented but I think at the end it'd be great; > if both ClimateMachine and Oceananigans shallow water models used the same; > equation set, since we can then compare the numerics. We don't have the; > bandwidth to develop the ClimateMachine shallow water model, but possibly; > at the time the Oceananigans has a nice one we'll be motivated to flesh out; > ClimateMachine's model.; >; > I'm not sure about immersed boundaries --- does the method generalize in a; > simple way? I'm not sure whether a special treatment is required for the; > height field, compared to an ordinary velocity variable, or tracer.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726873787>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQWKUQJEBFEYXSOVQO3SPVQABANCNFSM4TQVNFEA>; > .; >. -- ; ==========================================; John Marshall; Earth, Atmospheric and Planetary Sciences, MIT; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726894931:1282,variab,variable,1282,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1165#issuecomment-726894931,1,['variab'],['variable']
Modifiability,"The connectivity creates a ""cartesian grid"" of ranks which informs us which ranks are spatial neighbours. ; The more general way to arrange this grid, in absence of any other information is to wrap around the ranks as if the cartesian rank grid was `Periodic`. This is enough information for parsing the rank configuration, but not enough to perform fill halo regions. ; For this, we need a grid! Only with a grid, we will know if some directions are Bounded or Periodic, so, leveraging this information we can correctly assess which boundaries need communicating or not. Philosophically speaking, architecture provides the general rank layout while the grid concretizes this information ; leveraging the topology to decide whether to perform halo passing or not. Practically speaking the implementation leverages an `inject_halo_communication_boundary_conditions` implemented here:; https://github.com/CliMA/Oceananigans.jl/blob/34a3b930e0ace7df7dc7660f9c74f52315f41da7/src/DistributedComputations/halo_communication_bcs.jl#L14; previously only the connectivity was passed to this function, while this function should require also grid information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187:309,config,configuration,309,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328#issuecomment-1758117187,1,['config'],['configuration']
Modifiability,"The construction `Field(Average(op; dims))` allocates memory only for the result, and not for intermediate variables. So volume averages should not allocate much memory if constructed this way. Also note that you usually want to give abstract operations to output writers directly rather than `Field(abstract_op)`, because this will reduce memory allocation when you request sliced output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803:107,variab,variables,107,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301497803,1,['variab'],['variables']
Modifiability,"The convention we use for the other variables stored on faces is that our ""interior"" data spans from `i=1` to `i=N`. Thus we call the `i=N+1` a ""halo point"" for fields on faces, even though it really is not (its on the boundary, see #455). . In addition, we use a convention that face indices are ""left"" of cell indices. Thus `iFace=1` corresponds to the ""left"" boundary of the domain. `iCell=N` is the rightmost cell in the domain; and `iFace=N+1` corresponds to the rightmost boundary. Why do you want ""direct"" access to the surface at `k=Nz`? Can you explain why you want this? This is confusing to me and I don't see why we would want to have an odd and surprising convention for the vertical coordinate. The fact is simply that the face at `i=N` is a very concrete and real place. It lies in the interior of the domain, to the left of the cell point `i=N`. This is a fact of our grid and must be internalized by anyone who wants to work with the discrete data and index fields directly by raw index. If/when we use named axis conventions for `fields` (see #457), we would be able to access the surface via `u[Z(At(0))]` (or some syntax like that. We can also create an alias `Surface() = Z(At(0))`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542223106:36,variab,variables,36,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/462#issuecomment-542223106,1,['variab'],['variables']
Modifiability,The conversation around metrics is still unsettled. AFAICT there's no way to put those in the SGRID variable. There are [CF conventions](http://cfconventions.org/Data/cf-conventions/cf-conventions-1.8/cf-conventions.html#cell-measures) for `cell_measures`: specifically `area` and `volume` but we would also need length. There is a `cell_thickness` standard_name that could be used for this. cc @jbusecke,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480009990:100,variab,variable,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1334#issuecomment-1480009990,1,['variab'],['variable']
Modifiability,"The deep convection golden master fails intermittently even if the random number generator is seeded with the same value. Some randomness is added to the initial surface temperature. For now the 5 tests affected by this are skipped with `@test_skip` and will show up as ""Broken"". @christophernhill suggested using a portable random number generator: http://mitgcm.org/download/daily_snapshot/MITgcm/model/src/port_rand.F",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/176:316,portab,portable,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/176,1,['portab'],['portable']
Modifiability,The difference between this parameterization and the currently implemented `TwoDimensionalLeith` parameterization is that the diffusivities are user-provided rather than being a 3D field that's computed from the vorticity and divergence. That's why this parameterization is actually a simplification of `TwoDimensionalLeith`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470:28,parameteriz,parameterization,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1972#issuecomment-916410470,6,['parameteriz'],['parameterization']
Modifiability,"The docs include a ""Model setup"" section which includes references and info about `Simulation`. I think we should have a separate section on `Simulation`, which includes an explanation of diagnostics, output writers, adaptive timestepping, and `run!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/946:217,adapt,adaptive,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/946,1,['adapt'],['adaptive']
Modifiability,"The easiest way to add additional fields into a forcing is to create them before the forcing, eg. ```julia; eddy_diffusivity = CenterField(grid); ```. Such a field can be passed into a forcing function as a parameter, for example. (It can also be captured inside a function as a global variable). To use this, you'll have to use the ""discrete form"" forcing. More on that in the docs: https://clima.github.io/OceananigansDocumentation/stable/model_setup/forcing_functions/. To compute this field, write a callback,. ```julia; function compute_eddy_diffusivity(sim); νₑ = sim.model.diffusivity_fields.νₑ; Pr = sim.model.closure.Pr; parent(eddy_diffusivity) .= parent(νₑ) ./ Pr; return nothing; end; ```. Next add the callback to the simulation,. ```julia; add_callback!(simulation, compute_eddy_diffusivity); ```. By default the callback is called every time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095186354:286,variab,variable,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095186354,1,['variab'],['variable']
Modifiability,"The equations of motion for most or all major ocean modeling software are implemented using a ""Generalized Vertical Coordinate"" (GVC). Generalized vertical coordinates contain a ""fixed z"" coordinate as a limiting case, but generalize to vertical coordinates that. * Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a re",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:664,adapt,adaptive,664,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['adapt'],['adaptive']
Modifiability,"The first step is to install the `buildkite-agent` utility on the local machine:. https://buildkite.com/organizations/clima/agents. Then a tag needs to be added to the `buildkite-agent.cfg` file (for example, when buildkite is installed with a system package manager the default configuration file is located at `/etc/buildkite-agent.cfg`). We use two tags (for example):. ```; tags=""queue=Oceananigans,architecture=GPU""; ```. Note that you may not be able to use a space after the comma between two tags. We also set the number of agents via the `spawn` keyword. To start the buildkite agent as a system process, type. ```; sudo systemctl start buildkite-agent; ```. To stop a buildkite agent running as a system process, type. ```; sudo systemctl stop buildkite-agent; ```. Alternatively, `buildkite-agent` can be run in the background via `tmux` or `screen`. When `buildkite-agent` is run as a system process, their status is viewed by typing. ```; sudo systemctl status buildkite-agent; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1046:279,config,configuration,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1046,1,['config'],['configuration']
Modifiability,"The intention of this PR is to extend the capability of `FieldTimesSeries` such that it can be used in time-dependent boundary conditions and forcing. This PR develops over 2 main points, but it is still a work in progress so suggestions are welcome. 1) Allow writing down files with `set!`ing the `OnDisk` flavor of a field time series so that it aligns with the format of our jld2 output writer. In this way, it is possible to easily format BC from different file types (such as binary or text) to be used with Oceananigans. ; An example of this is:; ```julia; grid = LatitudeLongitudeGrid(size = (16, 16, 10), latitude = (-60, -40), longitude = (-10, 10), z = (0, 1)); u = XFaceField(grid); fts = FieldTimeSeries{location(u)...}(grid, 1:100, backend = OnDisk(), path = ""testfile.jld2"", name = ""u""); for i in 1:length(fts.times); set!(u, 2i); set!(fts, u, i); end; ```; This will generate a file called `testfile.jld2` with the following structure; ```; julia> f = jldopen(""testfile.jld2""); JLDFile /Users/simonesilvestri/development/Oceananigans.jl/testfile.jld2 (read-only); ├─📂 serialized; │ └─🔢 grid; └─📂 timeseries; ├─📂 u; │ ├─🔢 1; │ ├─📂 serialized; │ │ ├─🔢 location; │ │ └─ ⋯ (2 more entries); │ └─ ⋯ (99 more entries); └─📂 t (100 entries); ```; which can be easily read by the other field time series types. 2) To do linear interpolation we need at least 2 fields in memory, so `OnDisk` will not do. On the other hand, we might not want _all_ fields in memory as if we are dealing with forcings that might overwhelm the memory (especially on the GPU). So the proposal is to implement a `Chunked` abstraction that only keeps in memory a ""chunk"" of the data. The details of this implementation are still open do be decided, especially if we want an automatic update of the chunk if we index into an index not existing in memory or if we want the user to be responsible in updating the data in memory through something like a callback; ```julia; julia> fts3 = FieldTimeSeries(""testfile.jld2"", ""u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3233:31,extend,extend,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3233,1,['extend'],['extend']
Modifiability,"The issues with the `HydrostaticFreeSurfaceModel` are the tendency kernels. The difference with the non-hydrostatic model is that we do not know a priori which RHS function to call (for example CATKE has an `:e` tracer that requires a different RHS function and the same goes with a 1 equation parameterization of mesoscales that evolves an additional tracer equation for the mesoscale energy `:K`). Our solution now is to infer the RHS function and pass it as an argument to the kernel. Apparently, this prevents compilation. I ll come up with a solution today",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485231926:294,parameteriz,parameterization,294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485231926,2,"['evolve', 'parameteriz']","['evolves', 'parameterization']"
Modifiability,"The main advantage of having `DiskTimeSeries` in `Oceananigans` would be to use it in examples without depending on another package. I think the implementation of `DiskTimeSeries` is light. It also _requires_ certain features (for example, location metadata must be saved by `JLD2OutputWriter` for `DiskTimeSeries` to work). This tight coupling between `DiskTimeSeries` and `OutputWriters` could motivate including `DiskTimeSeries` in `Oceananigans.jl`. Other aspects of analyzing Oceananigans data might be more appropriate in another package. I'm not exactly sure what specific features are up for debate in this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405:336,coupling,coupling,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1493#issuecomment-809902405,1,['coupling'],['coupling']
Modifiability,"The main contribution of this pull request is a refactor of the function `time_step!` and related functions to reduce code duplication and improve readability. There is now a function called `time_step_kernel!` that dispatches on the value of its first argument (provided by `model.metadata`) to execute on the CPU or GPU. A `Model` constructor is now provided in which all important information can be input via keyword arguments. I favor this kind of design for fluids codes because I believe it improves the understand-ability of scripts, as it encourages explicit naming of parameters passed into the `Model` constructor. The output writing functionality has also been refactored slightly. However, many more changes will be made in the future so this is not consequential. I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). A few more notes:. * We need tests for output writers, and the output writing functionality needs to be revamped; * The model constructor needs work; * The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain; * We should get rid of model metadata and simply include the 'architecture' as a type parameter of `Model`; * and so much more... Lots of work to do!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97:48,refactor,refactor,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97,2,['refactor'],"['refactor', 'refactored']"
Modifiability,The main point of upgrading is to get rid of CUDA errors on the CPU and use `CUDAapi.has_cuda()` which replaces the `HAVE_CUDA` variable we've been using. This was originally in PR https://github.com/climate-machine/Oceananigans.jl/pull/378 (this PR is mostly cherry picked commits) but when it was merged @glwagner reported issues with forcing functions on the GPU. So now I've added a test that makes sure that forcing functions don't crash when used in a CPU or GPU model (one with and one without `const`).,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/388:128,variab,variable,128,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/388,1,['variab'],['variable']
Modifiability,"The more I think about it, the more I like the idea of an environment variable to have a ""pickup mode"". Let's see what others think.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120302022:70,variab,variable,70,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535#issuecomment-1120302022,1,['variab'],['variable']
Modifiability,"The next one I ran into is https://github.com/CliMA/Oceananigans.jl/blob/00f028bb37f13692e24921588aeb8a9150f6dd55/src/Advection/reconstruction_coefficients.jl#L215. So one alternative is to use named tuples instead of variables. ```; @inline function compute_reconstruction_coefficients(grid, FT, scheme; order). method = scheme == :Centered ? 1 : scheme == :Upwind ? 2 : 3. rect_metrics = (:xᶠᵃᵃ, :xᶜᵃᵃ, :yᵃᶠᵃ, :yᵃᶜᵃ, :zᵃᵃᶠ, :zᵃᵃᶜ). if grid isa Nothing; coeffs = (; (m => nothing for m in rect_metrics)...); else; metrics = coordinates(grid); dirsize = (:Nx, :Nx, :Ny, :Ny, :Nz, :Nz). arch = architecture(grid); Hx, Hy, Hz = halo_size(grid); new_grid = with_halo((Hx+1, Hy+1, Hz+1), grid); coeffs = (; (rect_metric => calc_reconstruction_coefficients(; FT, getfield(new_grid, metric), arch, getfield(new_grid, dir), Val(method); order = order); for (dir, metric, rect_metric) in zip(dirsize, metrics, rect_metrics))...); end. return tuple(coeffs...) # actually return named tuple to be order invariant; end; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3556#issuecomment-2064446102:218,variab,variables,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3556#issuecomment-2064446102,1,['variab'],['variables']
Modifiability,"The objective of this PR is to more clearly and quickly advertise the setting up of Oceananigans models in more than one configuration. We currently have one ""quickstart"", which sets up `NonhydrostaticModel` to do decaying turbulence. I propose that we add two more for `HydrostaticFreeSurfaceModel`: a rectangular configuration (say baroclinic adjustment) and a spherical configuration, maybe with bathymetry. I think we should also change defaults to grease the wheels a bit. So this PR will change the free surface to split explicit. I also think we should use WENO advection schemes and increase the default halo size to (4, 4, 4) so that 5th order WENO works on immersed boundary grid. Basically, I think the default should be useful: second-order advection with nothing closure is not useful. . I'd also like to add the quick start setups to the docs, in addition to the README. A few more miscellaneous ideas:. - A bulleted list of the examples with a short description of what each example demonstrates (so that one does not have to wade through all of them to find what they are looking for); - A new page in the docs that summarizes the ""major capabilities"" of each model. More docs refactoring is ultimately needed but I think this is a good start. Closes #3289",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3308:121,config,configuration,121,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3308,4,"['config', 'refactor']","['configuration', 'refactoring']"
Modifiability,"The only distinction is that in the `VectorInvariantFormulation` (that evolves $u$ and $v$) you want to compute; $h^{-1} \nabla \nu h \nabla t$,; while in the `ConservativeFormulation` (that evolves $uh$ and $vh$) ; $\nabla \nu h \nabla t$",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2941#issuecomment-1443856384:71,evolve,evolves,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2941#issuecomment-1443856384,2,['evolve'],['evolves']
Modifiability,"The reason that the advection term is the only term account for is because this is typically what one wants. If you want diffusion to act on the entire temperature profile (not just the perturbation), then perhaps you shouldn't use a background field at all. Instead you should initialize the temperature to `T(z) = N^2 * z + T'(z)` where `T'(z)` is the perturbation and evolve the entire temperature field. This is more correct anyways... Background fields are useful when one wants to consider either some kind of (implicit) forcing that maintains the background field, preventing it from evolving. If we include a diffusion term associated with the background field, then we defeat much of the purpose of having a background field feature in the first place. The same is true for boundary conditions. One important use case for background fields is when we can set up a problem where the perturbation is periodic even though the background is not. In that scenario the total field is not periodic, and we could not use a periodic domain. Enter `BackgroundFields`: decomposing the solution into background + perturbation allows us to model the perturbation in a periodic domain with periodic boundary conditions. If the periodic boundary condition were defined as a boundary condition on the total (background + perturbation), then we wouldn't be able to achieve this important case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2081949716:371,evolve,evolve,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2081949716,1,['evolve'],['evolve']
Modifiability,"The recent diffusivity refactor #2247 changed `ExplicitTimeDiscretization` -> `Explicit`. https://github.com/CliMA/Oceananigans.jl/blob/b3ddbc84c8f35aaf5b93fbbfdb4cffcada5c6533/src/TurbulenceClosures/implicit_explicit_time_discretization.jl#L8-L27. We are importing these in http://github.com/CliMA/OceanTurbulenceParameterEstimation.jl and it seems a bit vague to import. ```Julia; using Oceananigans.TurbulenceClosures: Explicit; ```. Should we go back to bit more verbose names?. cc: @simone-silvestri, @glwagner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2264:23,refactor,refactor,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2264,1,['refactor'],['refactor']
Modifiability,"The signature used to extend `FFTImplicitFreeSurfaceSolver` was not used by `build_implicit_free_surface_solver`; thus, slice ensemble models had incorrect free surface solvers. This PR fixes it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2220:22,extend,extend,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2220,1,['extend'],['extend']
Modifiability,"The way I implemented it, the matrix ""constructors"" are saved in the solver without the variable diagonal term. Basically the constructors include all the terms except for the term that varies with the time step which is saved in `solver.diagonal`. ; i.e. the `Dᵢⱼₖ` in; ```; Axᵢ₊₁ ηᵢ₊₁ + Axᵢ ηᵢ₋₁ + Ayⱼ₊₁ ηⱼ₊₁ + Ayⱼ ηⱼ₋₁ + Azₖ₊₁ ηₖ₊₁ + Azₖ ηⱼ₋₁ ; - 2 ( Axᵢ₊₁ + Axᵢ + Ayⱼ₊₁ + Ayⱼ + Azₖ₊₁ + Azₖ ) ηᵢⱼₖ ; + ( Cᵢⱼₖ + Dᵢⱼₖ/Δt^2 ) ηᵢⱼₖ = b; ```. Every time that the time step changes this is the operation that is performed:; ```; constructors = deepcopy(solver.matrix_constructors); M = prod(solver.problem_size); update_diag!(constructors, arch, M, M, solver.diagonal, Δt, 0); solver.matrix = arch_sparse_matrix(arch, constructors) ; ```. So the matrix is constructed from a copy of the updated constructors. In this way there is no need to subtract anything to the diagonal because `solver.matrix_constructors` does not include the diagonal term. . `update_diag!` adds `Dᵢⱼₖ/Δt^2` to the diagonal elements. . If you want to do the something analogous with the linear operation, remove the time dependent term from it. Then add it separately with `update_diag!` every time the time step changes. Of course you want to make sure that you have elements in your diagonal, non trivial if `Cᵢⱼₖ` because a sparse matrix removes 0 elements. check out this function ; `ensure_diagonal_elements_are_present!(sparse_matrix)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403:88,variab,variable,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1179415403,1,['variab'],['variable']
Modifiability,"The wizard uses `new_time_step`, which is correctly extended within `MultiRegion` ; https://github.com/CliMA/Oceananigans.jl/blob/40ac9d0efff7a0c877df652e3f9114fe53693bc2/src/MultiRegion/multi_region_models.jl#L63-L66.; I haven't extended `cell_advection_timescale` yet. Also, I haven't yet extended `interior`, because data can live on different GPUs, so `interior` should not be used if not after `reconstruct_global_field`.; Maybe I can add `cell_advection_timescale` to multi region, but then I have to extend also `cell_diffusion_timescale` and the extension of `new_time_step` has to be deleted. I ll think about the pros and the cons. ; For every function that does not work in `MultiRegion`, in the meantime, you can wrap it with `@apply_regionally` and you'll get a `MultiRegionObject` containing the local equivalent. In this case; ```; @apply_regionally new_Δt = wizard.cell_advection_timescale(model); new_Δt = minimum(new_Δt.regions); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304946176:52,extend,extended,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304946176,4,['extend'],"['extend', 'extended']"
Modifiability,"Then you can just load in your ""bottom"" from the `ImmersedBoundaryGrid` and set that to; ```; bottom[ bottom .>0 ] .= NaN; bottom[ bottom .<0 ] .= 0.0; ```; then when you lift the variable; ```; ζ′ = @lift file[""timestepper/ζ′/ *string($iter][:, 1:end-1, 1] .+ bottom; ```; (it is not going to be in the exact same position since `ζ′` is at faces and bottom is at centers, but on a 1/4 degree resolution I don't think makes much of a change)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128082953:180,variab,variable,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128082953,1,['variab'],['variable']
Modifiability,"There are a few gotchas when setting up GPU simulations so it's not always as simple as just changing `CPU` to `GPU`, mainly related to things the GPU compiler does not like. A common one that produces a very non-obvious error is using global variables in forcing functions or any function that will get used in a GPU kernel (e.g. https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733435704 and https://github.com/CliMA/Oceananigans.jl/issues/1477). Might be helpful for users if we add a section or page to the docs that describes these issues.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478:243,variab,variables,243,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478,1,['variab'],['variables']
Modifiability,"There are a lot of new instances of `@allowscalar`, but rather than adding new instances we should be refactoring the tests so they don't appear. When we find that we have to use `@allowscalar`, it often indicates that our `Field` infrastructure is somehow deficient / doesn't support necessary operations, which causes us to resort to indexing and other syntax that requires `@allowscalar`. @navidcy @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411314641:102,refactor,refactoring,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2865#issuecomment-1411314641,1,['refactor'],['refactoring']
Modifiability,"There are two things at play here. First, there is a refactoring of the equation set to allow for a generalized vertical coordinate. This actually involves rewriting the equations. To merge that generalization, I think we would also like to see the new equations that are being solved written up in the docs. When the equations are generalized, this would also involve implementing a new abstraction for the vertical coordinate, along with a `vertical_coordinate = ZVerticalCoordinate()` default, which preserves existing behavior. The second PR should then implement a `ZStarVerticalCoordinate()` (other better names are fine too). So to me this feels like we need two PRs, one with docs update and API design, and then a second with z* implementation.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1867969677:53,refactor,refactoring,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1867969677,1,['refactor'],['refactoring']
Modifiability,"There is a choice we need to make about the third variable: the total depth (what we usually denote as `h`) or the free-surface (what we usually denote with `\eta`). In the equations you have above, the first set of equations is using `h` as the total depth, but the second uses it as a free-surface. I am fine with either but if we are using the variable `h`, I would vote for the layer depth.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128987220:50,variab,variable,50,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1128987220,2,['variab'],['variable']
Modifiability,"There is a mismatch between what the docstring of the `RectilinearGrid` claims for what the metrics (e.g., `Δxᶜᵃᵃ` or `Δxᶠᵃᵃ`) are and what the metrics actually correspond to. The docstring says that, e.g., `Δxᶜᵃᵃ` is the distances between cell centers. I think this is wrong. First of all, this is not uniquely defined as, e.g., the distance between a cell center and the adjacent cell centers may be different on each side of the cell. I believe that `Δxᶜᵃᵃ` is, instead, the length of the corresponding cell that is centered at `caa`, _or equivalently_, is the distances between the adjacent faces of each cell's center. Note that for a regularly-spaced grid what I claim to be correct and what the docstring mentions are equivalent (and possibly this is what lead to the current docstring?). However, for a variably-spaced grid they are not equivalent. Here's an example:. ```julia; julia> Nx = 3; grid = RectilinearGrid(size = Nx, topology = (Bounded, Flat, Flat), x = [0, 1, 2, 10]); 3×1×1 RectilinearGrid{Float64, Bounded, Flat, Flat} on CPU with 3×0×0 halo; ├── Bounded x ∈ [0.0, 10.0] variably spaced with min(Δx)=1.0, max(Δx)=8.0; ├── Flat y; └── Flat z. julia> grid.xᶜᵃᵃ[1:Nx]; 3-element Vector{Float64}:; 0.5; 1.5; 6.0. julia> grid.xᶠᵃᵃ[1:Nx+1]; 4-element Vector{Float64}:; 0.0; 1.0; 2.0; 10.0. julia> grid.Δxᶜᵃᵃ[1:Nx]; 3-element Vector{Float64}:; 1.0; 1.0; 8.0. julia> grid.Δxᶠᵃᵃ[1:Nx+1]; 4-element Vector{Float64}:; 1.0; 1.0; 4.5; 8.0; ```. A schematic of the cell faces and centers together with the corresponding values for `Δx` is below:. ```julia; F C F C F C F. xᶠᵃᵃ 0 1 2 10; xᶜᵃᵃ 0.5 1.5 6.0. Δxᶠᵃᵃ 1 1 4.5 8; Δxᶜᵃᵃ 1 1 8; ```. I am pretty sure that what we want is what the code actually does. In this case, what's left to be done is simply to fix the docstring. Am I right?. (P.S.: I stumbled upon this while trying to fill the halos properly for #3239.)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3252:811,variab,variably-spaced,811,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3252,2,['variab'],"['variably', 'variably-spaced']"
Modifiability,"There is a nonlocal contribution in the vertical. The pressure gradient at fluid layer $j$ depends on all fluid thicknesses of that layer and **all** layers above that. Does this impose any constraint on the technical design (in terms of whether we write 3D kernels or `Nz` 2D kernels, where `Nz` the number of fluid layers...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457:150,layers,layers,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600#issuecomment-1147075457,2,['layers'],['layers']
Modifiability,There is no adapt method for the model. I don't know how it would play to send the whole model to the GPU. We might have some parameter space issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517:12,adapt,adapt,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1258425517,1,['adapt'],['adapt']
Modifiability,"There is still a problem. This time with the vector size:. > ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] No Gpu available; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [ Info: Oceananigans will use 16 threads; ERROR: LoadError: DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 129 and 128""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs (repeats 3 times); @ ./broadcast.jl:495 [inlined]; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] instantiate; @ ./broadcast.jl:266 [inlined]; [6] materialize(bc::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3}, Nothing, typeof(*), Tuple{Array{Float64, 3}, Array{Float64, 3}}}); @ Base.Broadcast ./broadcast.jl:883; [7] top-level scope; @ /lustre/scratch5/.mdt0/fspereira/OCEANANIGANS/test/case13/c16_128_128m.jl:200. Also, shouldn't we set v (last line below, I added the commented v's):. `Random.seed!(1414). T = model.tracers.T; u, v, w = model.velocities. x, y, z = nodes(T, reshape=true); Lz = model.grid.Lz. shape = @. z / Lz * (1 + z / Lz); ΞT = randn(size(T)...) .* shape; Ξu = randn(size(u)...) .* shape; #Ξv = randn(size(v)...) .* shape; Ξw = randn(size(w)...) .* shape. Tᵢ = @. 20 + dTdz * z + dTdz * Lz * 1e-6 * ΞT; uᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξu; #vᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξv; wᵢ = @. sqrt(abs(Qᵘ)) * 1e-3 * Ξw. #set!(model, u=uᵢ, v=vᵢ, w=wᵢ, T=Tᵢ, S=35); set!(model, u=uᵢ, w=wᵢ, T=Tᵢ, S=35)`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743:199,Config,Configuration,199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2766#issuecomment-1268613743,5,"['Config', 'config', 'variab']","['Config', 'Configuration', 'config', 'variable']"
Modifiability,There must be a simple bug to fix. I remember the simulation was quite stable. I think it has to do with how bathymetry is defined in the code. A simple configuration might snoop out the issue,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973873627:153,config,configuration,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1973873627,2,['config'],['configuration']
Modifiability,"There seems to be a problem with calculating fluxes in a `Flat` direction. . The `Horizontal` formulation It is trying to calculate the viscous flux in the horizontal direction using the vertical vorticity which requires at least 2 points in each horizontal direction. . (specifically these two lines); ```; @inline viscous_flux_vx(i, j, k, grid, closure::AHD, clock, U, args...) = - ν_ζᶠᶠᶜ(i, j, k, grid, clock, closure.ν, U.u, U.v); @inline viscous_flux_uy(i, j, k, grid, closure::AHD, clock, U, args...) = + ν_ζᶠᶠᶜ(i, j, k, grid, clock, closure.ν, U.u, U.v) ; ```. because this calls the circulation operator `Γᶠᶠᶜ`; which is calculated as. ```; @inline Γᶠᶠᶜ(i, j, k, grid, u, v) = Δy_qᶜᶠᶜ(i, j, k, grid, v) - Δy_qᶜᶠᶜ(i-1, j, k, grid, v) - Δx_qᶠᶜᶜ(i, j, k, grid, u) + Δx_qᶠᶜᶜ(i, j-1, k, grid, u); ```. requiring `i-1` which we do not have if `x` is `Flat`. ; I wonder how it was even working before? Maybe a workaround we can implement is to extend the circulation operator for `Flat` directions. ```; @inline Γᶠᶠᶜ(i, j, k, grid::AbstractGrid{<:Any, Flat}, u, v) = - Δx_qᶠᶜᶜ(i, j, k, grid, u) + Δx_qᶠᶜᶜ(i, j-1, k, grid, u); @inline Γᶠᶠᶜ(i, j, k, grid::AbstractGrid{<:Any, <:Any, Flat}, u, v) = Δy_qᶜᶠᶜ(i, j, k, grid, v) - Δy_qᶜᶠᶜ(i-1, j, k, grid, v); ```. Or maybe just put it to zero since it actually is zero",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054853703:945,extend,extend,945,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2284#issuecomment-1054853703,1,['extend'],['extend']
Modifiability,"There's a number of changes we should make to `TKEBasedVerticalDiffusivity` that might make parameter estimation easier:. * Pull out a single “bulk” scaling parameter from the diffusivity scalings rather than using two independent scales for Ri -> -infty and Ri -> + infty; * Identify one diffusivity as “primary” (eg tracer diffusivities), and formulate the other diffusivities in terms of the ratio between the primary diffusivity (eg, using Prandtl numbers rather than raw diffusivities); * Parameterize the diffusivity scaling functions in terms of a “-” and “delta” rather than “-” and “+” value. Eventually we want to embed a convective adjustment ""submodel"" in `TKEBasedVerticalDiffusivity`; in this we want to write the convective adjustment diffusivity as a “correction” to the ""primary"" diffusivity. cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1695:494,Parameteriz,Parameterize,494,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1695,1,['Parameteriz'],['Parameterize']
Modifiability,"There's no need for a new kernel because the diffusivities are `νₑ / Pr` so they can be calculated on the fly. We need to extend `κᶠᶜᶜ` and `κᶜᶠᶜ` and `κᶜᶜᶠ`. ```julia; @inline κᶠᶜᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑxᶠᵃᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; @inline κᶜᶠᶜ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑyᵃᶠᵃ(i, j, k, grid, K.νₑ) / closure.Pr[id]; @inline κᶜᶜᶠ(i, j, k, grid, closure::SmagorinskyLilly, K, ::Val{id}, args...) = ℑzᵃᵃᶠ(i, j, k, grid, K.νₑ) / closure.Pr[id]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419238472:122,extend,extend,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2904#issuecomment-1419238472,1,['extend'],['extend']
Modifiability,"There's two challenges. One is refactoring `Reduction` to be more general. `cumsum!` has a diffeerent pattern, the dimensionality is not reduced for the output and it has a slightly different syntax. But I figured that stuff out here:. https://github.com/CliMA/Oceananigans.jl/pull/3590. The next challenge is to figure out how to integrate downwards rather than up; this is a little trickier I think because we may need an abstraction that reverses indices or something. There is also the metric part but that's kind of trivial, its the same thing as with `Integral` or `Average`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956:31,refactor,refactoring,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2098993956,1,['refactor'],['refactoring']
Modifiability,"These are just functions which retrieve `Ax`, `Ay`, `Az` and `V` on the location of interest. On the other hand, they conflict with the same variables exported from `AbstractOperations`. I think they should be exported only by the latter because as `AbstractOperations` they have a unique functionality whereas from `Operators` they are just a renaming of `Axᵃᵃᵃ`, `Ayᵃᵃᵃ`, `Azᵃᵃᵃ`and `Vᵃᵃᵃ`",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2158:141,variab,variables,141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2158,1,['variab'],['variables']
Modifiability,"These kernels:. https://github.com/CliMA/Oceananigans.jl/blob/1dbe86c49e1d4e013c5ea595f837b4c226b1561e/src/BoundaryConditions/fill_halo_regions.jl#L51-L66. use broadcasting and are thus executed on the default CUDA stream. We should rewrite these kernels using the `KernelAbstractions.jl` kernel language so that we can control when they are executed. In particular, kernel filling for periodic directions must be filled after non-periodic directions to ensure that corner points are set properly. We can potentially solve this problem by asking *only* the west, east halo-filling routines to fill corner points. This ensures the corner points will be filled if _at least_ one direction is periodic. In the case that no directions are periodic, the corner points do not need to be filled.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/811:233,rewrite,rewrite,233,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/811,1,['rewrite'],['rewrite']
Modifiability,"Thinking about this more, I think it would make sense to make an even more radical change. I think we should add `diagnostics`, `output_writers`, and `clock` to `Simulation`. . The `time_step!` function then performs a single time-step, whereas to run a simulation one should write `run!(simulation)`, which handles diagnostics, output writing, adaptive time-stepping, and logging in an integrated way. This orthogonalizes the design a bit: `diagnostics` and `output_writers` are not really aspects of a ""model"", if we use a narrow interpretation of a model as a discrete representation of a physical system. A single physical system might conceivably be associated with a wide range of disparate diagnostics and output, depending on what kind of science is being done. I think scripts become clearer. The user writes. ```julia; model = Model(; model_parameters...). simulation = Simulation(model; simulation_parameters...). simulation.diagnostics[:diag] = # something. run!(simulation); ```. As an example to illustrate why `Simulation` is orthogonal to `Model`, here's a possible clear and coherent usage of this separation:. ```julia; model = Model(; model_parameters...). set!(model; first_interesting_initial_condition...). first_simulation = Simulation(model, first_simulation_parameters...); first_simulation[:diag] = diag_specific_to_first_simulation; run!(first_simulation). set!(model; second_interesting_initial_condition...) # same physical model, but different starting initial condition... no new memory allocated, no recompilation --- fast. second_simulation = Simulation(model, second_simulation_parameters...); second_simulation[:diag] = diag_specific_to_second_simulation; run!(second_simulation); ```. We can use `run!(simulation, time_steps=nsteps)` to allow hand-coded user loops that achieve a functionality similar to what we have now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442:345,adapt,adaptive,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/447#issuecomment-542294442,1,['adapt'],['adaptive']
Modifiability,"Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2327849488:145,refactor,refactor,145,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2327849488,1,['refactor'],['refactor']
Modifiability,"This ""PR"" adapts one of the CPU Poisson solver tests to the GPU. The test fails. . Hopefully there is a bug in the test. If so, it should be fixed so that we have a valid test for the GPU Poisson solver. I suggest we use just one solver for both the CPU and the GPU --- unifying those could be in the scope of this PR. It'll also be nice to have one function that returns the (real) solution to the Poisson equation, given complex input. . Our algorithm (for Periodic-Periodic-Neumann --- this would not be the case for Periodic-Periodic-Periodic) requires one temporary storage variable (which stores a permuted, complex version of the solution) that should be part of the `PPNPoissonSolver` struct (see what I did there?)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/238:10,adapt,adapts,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/238,2,"['adapt', 'variab']","['adapts', 'variable']"
Modifiability,"This PR ""enhances"" `JLD2OutputWriter` so it first _checks_ whether an iteration number exists in the file it's about to save to. If the iteration number does exist, it emits warning, but does not fail. Previously, it would fail. This helps when restoring a simulation from a checkpoint when output is saved at higher frequency than the simulation is checkpointed. TODO: probably test makes sense.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2537:9,enhance,enhances,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2537,1,['enhance'],['enhances']
Modifiability,"This PR **finally** adds proper citations that link to a references page all generated from an `oceananigans.bib` file. This is now possible thanks to the new Bibliography.jl package which I've used to hack in a Documenter.jl ""plugin"" at https://github.com/ali-ramadhan/DocumenterBibliographyTest.jl. This is currently the last action item for the JOSS submission. The code that handles citations and bibliography expansion is a little messy and will hopefully evolve into a proper Documenter.jl plugin but for now I've copy pasted the code into Oceananigans.jl until the plugin has stabilized in some form. The `@cite` and `@bibliography` syntax should remain the same though.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/794:227,plugin,plugin,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/794,4,"['evolve', 'plugin']","['evolve', 'plugin']"
Modifiability,"This PR _finally_ revives the half-baked `VerticallyStretchedCartesianGrid` implementation that's been living in Oceananigans.jl for over a year. It also formalizes the `FourierTridiagonalPoissonSolver` that's been living in `test_solvers.jl` for a while as well. I re-ran the regression tests using a `VerticallyStretchedCartesianGrid` with constant spacing as a sanity check and they pass on the CPU which is good and helped uncover some functions that needed generalization. There's still quite a bit to do and test so maybe we should merge this PR after a bit of polish and continue developing and testing the `VerticallyStretchedCartesianGrid` in subsequent smaller PRs?. TODO off the top of my head:; 1. Adapt `VerticallyStretchedCartesianGrid` to work in GPU kernels. It has some offset arrays.; 2. Test the `FourierTridiagonalPoissonSolver` for other/all topologies.; 3. Add some dynamics tests?; 4. Validation experiment: Stratified Couette flow (Vreugdenhil & Taylor, 2018).; 5. Benchmarks! The xy FFT + z Tridiagonal solver might be faster than xyz FFT. Resolves #471. And of course, no PR is complete without eye candy (had to use matplotlib for irregular heatmaps):. https://user-images.githubusercontent.com/20099589/107367287-1fc7b400-6aad-11eb-945f-1fb2694392b2.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1348:710,Adapt,Adapt,710,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1348,1,['Adapt'],['Adapt']
Modifiability,"This PR adapts the analytical pressure solver test to an explicit test for second-order convergence of the pressure solver in all configurations. The triply periodic solver currently throws an error if we try to construct it, so I'm skipping that test.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/704:8,adapt,adapts,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/704,2,"['adapt', 'config']","['adapts', 'configurations']"
Modifiability,This PR adapts the hydrostatic regression tests to be run in distributed mode. an important step in this direction is to allow array partitioning under the hood in `set!` if the array size coincides with the global size of the field (implemented here). a more important step is to remove the topology from the `Distributed` architecture (it should not know anything about topology which is a grid property),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3328:8,adapt,adapts,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3328,1,['adapt'],['adapts']
Modifiability,"This PR adds Lagrangian particle tracking for incompressible models. You construct `LagrangianParticles` by passing in a bunch of x, y, z coordinates as 1D arrays (`xs`, `ys`, `zs`) when constructing an incompressible model:. ```julia; model = IncompressibleModel(grid = grid, ..., particles = LagrangianParticles(x=xs, y=ys, z=zs)); ```. then the particles are advected with the flow at every time step (i.e. online particle advection). If arrays are used for `x`, `y`, `z` then I think you should be able to add/remove/birth/kill/breed/split/combine/beach/teleport/etc. particles at any time since arrays are mutable and the type signature of the `LagrangianParticles` won't change. In a futue PR we might want to add `LagrangianParticles` parameters, forcing functions (?), and callafters so that particle properties can be tracked, evolved, and interacted with tracers to model biogeochemistry (https://github.com/JuliaOcean/PlanktonIndividuals.jl) or play ecological games (https://github.com/ali-ramadhan/lagrangian-microbes). Right now I suppose it only advects particles using forward Euler. Using the model's RK3 for particle advection would double (or triple?) the memory usage of the particle tracker as we would have to store previous tendencies (velocities). I wonder if the accuracy of forward Euler is acceptable for Lagrangian particle tracking. I'm also wondering whether it makes sense to support both forward Euler and RK3 in case you want to advect a huge number of particles and memory is limiting the amount of particles you can track? I guess you can do RK3 or RK4 inside the `advect_particles!` kernel but it would assume that the velocity field is constant between stages. Perhaps a convergence test is needed to answer these questions. I think there are a lot of things that can be done at boundaries (see e.g. https://github.com/OceanParcels/parcels/issues/37, https://github.com/OceanParcels/parcels/issues/47, https://github.com/OceanParcels/parcels/issues/61) so I think ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091:836,evolve,evolved,836,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091,1,['evolve'],['evolved']
Modifiability,"This PR adds a GPU-enabled `CompressibleModel`, developed with @thabbott and @RaphaelRR in a separate repository (https://github.com/ali-ramadhan/Atmosfoolery.jl). This is a large PR and I'm not even sure if it makes sense to merge it into Oceananigans.jl. The main purpose of opening this PR is to document progress made and ultimately decide on what to do with this feature. I don't think I can continue working on it. # Description. The compressible model implements the conservative Scheme by Satoh (2003), suitable for compressible non-hydrostatic models with moist processes, and is valid in the limit of a condensable gas/atmosphere with multiple moist species. Two choices of prognostic thermodynamic variables are available, internal energy and entropy, although in the Oceananigans spirit adding new thermodynamic variables is pretty easy!. @thabbott implemented the Satoh (2003) equation set. I initially implemented the Klemp et al. (2007) equation set which is only valid in the limit of a dry atmosphere with trace amounts of moist species. An RK3 time-stepper is used that is apparently 3rd-order accurate for linear terms but only 2nd-order accurate for non-linear terms. This is because it's developed to allow for acoustic time stepping between RK stages. This split-explicit time-stepping scheme is described by Wicker & Skamarock (2002), Klemp et al. (2007), and Satoh (2003). It's essentially the same one used by the NCAR WRF model (Skamarock et al., 2019). No acoustic time stepper is implemented yet. Explicit acoustic time stepping could make sense for regular Cartesian grids while a vertically implicit acoustic time stepper would make sense for vertically stretched grids (possible with `Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advect",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:709,variab,variables,709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,2,['variab'],['variables']
Modifiability,"This PR adds a benchmarking script that times how long a single time step takes on the CPU and GPU using `Float32` and `Float64` for various model resolutions. It uses TimerOutputs.jl to nicely format the benchmarks. It also prints out CPU->GPU speedups and Float64->Float32 ""speedups"". It only executes the GPU benchmarks if executed on a CUDA-enabled machine. We can later extend it to time model initialization, different parts of the time stepping, etc. Right now it only benchmarks a simple ""static ocean"" configuration so no fancy forcing functions are used, but we can extend the number of scenarios/experiments we benchmark. The time stepping and Poisson solver still takes the same amount of time whether the ocean is static or active. Resolves #67. Well, kind of. It's not clear to me how to easily incorperate this with CI in a way that doesn't involve one of us eyeballing the text output. For now we should at least run this script every time we make a change that might potentially impact performance. Example output; ```; ──────────────────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl benchmarks Time Allocations; ────────────────────── ───────────────────────; Tot / % measured: 718s / 46.6% 17.2GiB / 0.02%. Section ncalls time %tot avg alloc %tot avg; ──────────────────────────────────────────────────────────────────────────────────────────────────; 256x256x256 static ocean (CPU, Float32) 10 168s 50.2% 16.8s 20.3KiB 0.73% 2.03KiB; 256x256x256 static ocean (CPU, Float64) 10 141s 42.3% 14.1s 20.3KiB 0.73% 2.03KiB; 128x128x128 static ocean (CPU, Float32) 10 12.4s 3.72% 1.24s 14.5KiB 0.52% 1.45KiB; 128x128x128 static ocean (CPU, Float64) 10 9.00s 2.69% 900ms 14.8KiB 0.54% 1.48KiB; 64x 64x 64 static ocean (CPU, Float32) 10 1.03s 0.31% 103ms 14.2KiB 0.51% 1.42KiB; 256x256x256 static ocean (GPU, Float64) 10 891ms 0.27% 89.1ms 333KiB 12.0% 33.3KiB; 256x256x256 static ocean (GPU, Float32) 10 859ms 0.26% 85.9ms 329KiB 11.9% 32",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:375,extend,extend,375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,3,"['config', 'extend']","['configuration', 'extend']"
Modifiability,"This PR adds a new example called ""Microbial rock paper scissors"" in which an idealized diurnal cycle is simulated with an agent-based model of marine microbes as Lagrangian particles playing rock paper scissors. This example is loosely based off of https://github.com/ali-ramadhan/lagrangian-microbes and can be extended to to study competition between marine microbes in an idealized setting. The purposes of this example are to show users how to:; 1. use Lagrangian particle tracking.; 2. define their own custom particle types.; 3. implement interacting particle pairs using KD trees.; 4. write fields and particles to NetCDF.; 5. easily read, analyze, and plot data from NetCDF using GeoData.jl. This example has aided me in figuring out which abstractions are needed for particle tracking in #1091 and are helping me figure out which plotting recipes would be good to implement as part of https://github.com/rafaqz/GeoData.jl/pull/106. This PR in a work-in-progress and depends on #1091. I still need to make it Literate. The example also produces a neat animation of particles being advected (too big to include as a gif) and I'm hoping to expand the data analysis a bit. ![image](https://user-images.githubusercontent.com/20099589/101072675-614b5880-356c-11eb-8537-44e21fa3e8ff.png). ![species_count](https://user-images.githubusercontent.com/20099589/101072466-14678200-356c-11eb-9c36-8c0eda8c3c36.png). # Plotting with GeoData.jl. I think reading data with JLD2 and plotting it can be cumbersome (and makes the examples more complicated than they should be in my opinion). I think once GeoData.jl is a bit more mature I think we should encourage users to use it as it simplifies data analysis and plotting greatly. For example, plotting w and b looks something like (could still be improved of course, contourf might be better). ```julia; anim = @animate for n in 1:Nt; @info ""Plotting idealized diurnal cycle frame $n/$Nt..."". w_plot = plot(w[Ti=n, xC=32], color=:balance, clims=(-0.02, 0.0",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1244:313,extend,extended,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244,1,['extend'],['extended']
Modifiability,"This PR adds a new function `accurate_cell_advection_timescale` that is used to compute CFL at every grid point then reduced to find the maximum (which is the correct way as discussed in #1201). It will allow us to use the `TimeStepWizard` for adaptive time-stepping on all grids. I'll also extend it to `ShallowWaterModel` before merging. So it works great and scales well on the CPU but not so well on the GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497:244,adapt,adaptive,244,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497,4,"['adapt', 'extend']","['adaptive', 'extend']"
Modifiability,This PR adds a new submodule `Oceananigans.CubedSpheres` that implements new grid and field types for running `HydrostaticFreeSurfaceModel` with a fully connected cubed sphere (should eventually also be flexible enough to just use 1 < n < 6 faces but I'm just testing 6 faces for now). This PR is still a work-in-progress and is quite messy with some pretty horrible code (please don't judge :sob:). I'll be adding to it and refactoring it over the next few days. Compile times have increased significantly with `grid::ConformalCubedSphereGrid` which has slowed down development but should be pretty close to being able to time step. EDIT: This might only be on Julia 1.6...,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1522:203,flexible,flexible,203,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1522,2,"['flexible', 'refactor']","['flexible', 'refactoring']"
Modifiability,"This PR adds a property to `IncompressibleModel` called `background_fields`. `background_fields.velocities` contains background velocity fields; `background_fields.tracers` contains background tracer fields. Background fields are specified with a `NamedTuple` similar to forcing functions and boundary conditions:. ```julia; background_u(x, y, z, t) = z * sin(t). model = IncompressibleModel(grid=grid, background_fields=(u,), ...); ```. Background fields are neglected in all tendency terms _except_ the advection terms. This restricts their use, but greatly simplifies their implementation. Todo:. - [x] update physics docs to include background fields in model equations; - [x] update model setup docs; - [x] tests; - [x] update `eady_turbulence.jl` and `internal_wave.jl` example to use `background_fields`; - [x] extend implementation of `FunctionField` to take parameters and add a special constructor for background `FunctionFields`. Resolves #960",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1014:818,extend,extend,818,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1014,1,['extend'],['extend']
Modifiability,"This PR adds a validation experiment as suggested by @christophernhill and @jm-c to add a very small Gaussian sea surface height η perturbation in the northern hemisphere of the cubed sphere face and watch it evolve. There is no rotation/Coriolis and no diffusivity right now to test the simplest model possible (so η just splashes around as expected). Next step would be to turn on rotation, diffusivity, and the implicit free surface. Might have to generalize some things, e.g. Coriolis, to non-regular curvilinear grids like `ConformalCubedSphereFaceGrid`. So I guess the main purpose of this PR is to make sure the cubed sphere face works, so maybe the validation experiment won't make it into the final version of this PR. https://user-images.githubusercontent.com/20099589/111330144-139fbb00-8646-11eb-9598-a0e18e88280b.mp4. This PR depends on PR #1433. Will `git rebase main` once it's merged.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1480:209,evolve,evolve,209,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1480,1,['evolve'],['evolve']
Modifiability,"This PR adds an `IsopycnalSkewSymmetricDiffusivity` turbulence closure. This is otherwise knows as Gent-McWilliams parametrization but here we chose the more descriptive name. Also plans include to possibly extend this closure for turbulent viscosity. joint work with @glwagner . Resolves #1492, resolves #1972. This PR further enhances `FieldTimeSeries` to allow building `FieldTimeSeries` for data without halos.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994:207,extend,extend,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994,2,"['enhance', 'extend']","['enhances', 'extend']"
Modifiability,"This PR adds an `architecture` property to the `RegularRectilinearGrid` and `VerticallyStretchedRectilinearGrid`. Eventually, this PR will remove the `architecture` property from all models and fields. The new API will require `architecture` to be specified once when building the grid and never thereafter. This major change to the API is crucial for supporting a clean, simple API for grid metrics stored in arrays (all cases except the edge case of a fully regular grid). In the new API, both the architecture and floating point type are exclusive properties of `grid`. In addition this change will simplify the construction of models on distributed architectures and will eliminate the need for special model constructors for that case. Ultimately, we hope to go beyond this change to support just three grids:. 1. `RectilinearGrid`; 2. `LatitudeLongitudeGrid`; 3. `OrthogonalSphericalShellGrid`. In the first two cases, ""regularity"" is established if the grid metrics are numbers (rather than arrays or functions). This is another major change to the API (and a major internal refactor) that will hopefully reduce, simplify, and generalize grid constructors and applications. Closes #1825.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1998:1082,refactor,refactor,1082,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1998,1,['refactor'],['refactor']
Modifiability,This PR adds an example that computes the linear instability of a vertically shear mean flow profile U(z) accompanied with a sheared buoyancy profile B(z) and then evolves the unstable eigenmode to its nonlinear equilibration. [preview of the docs](https://clima.github.io/OceananigansDocumentation/previews/PR1125/generated/kelvin_helmholtz_instability/),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125:164,evolve,evolves,164,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125,1,['evolve'],['evolves']
Modifiability,"This PR adds areas, volumes, and a few product operators needed to evaluate correct Coriolis terms on curvilinear grids, following. https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8. Before merging we should discuss:. - Should I update all the Coriolis terms? (`beta_plane.jl, non_traditional_f_plane.jl`, etc?); - Are we ok using three-letter codes, even though we only plan to support horizontally-curvilinear grids (rather than vertically curvilinear grids) in the near future?; - Should we add more regression tests / evaluate existing regression tests before changing terms that are not covered?; - It's not feasible to adapt the _entire_ codebase to work on curvilinear grids right now. How should we handle throwing errors for cases that are not supported? Adding `RegularCartesianGrid` annotations in key places seems like the easiest strategy, but we should be careful not to miss any. We can perhaps add annotations to _all_ operators, and then support curvilinearity in as parsimonious fashion as possible to be conservative.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1371:644,adapt,adapt,644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1371,1,['adapt'],['adapt']
Modifiability,"This PR adds experimental support for rotating/tilting the gravity vector. I'm not even sure if it works properly but I'm opening a draft PR as it might be ready to be experimented with? I don't think we can have a non-zero gravity component along a periodic direction as the fluid just free falls along that dimension and the model blows up. But here's a thermal bubble rising with gravity tilted at 45 degrees. ![tilted_gravity_plume](https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif). This is an experimental feature since it needs more rigorous testing and because full support for tilted gravity may require more work, e.g.; 1. Should AMD use `z_dot_g_b` now?; 2. Should `∂x_b` return a vector or should it be split up into `x_dot_∂x_b`, etc.? The Leith closure uses `∂x_b`.; 3. We may want to clean up and refactor the implementation, taking some suggestions from #1151. cc @tomchor . Resolves #1151",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242:865,refactor,refactor,865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242,1,['refactor'],['refactor']
Modifiability,"This PR adds grid topologies: `Periodic`, `Bounded`, and `Singleton`. We should finalize our choice of named before merging. As `topology` is now a required kwarg of all grid constructors tons of refactoring was needed. It also does a bit of cleanup: `AbstractGrid` is now defined in the Grids submodule, and grids no longer have the `Tx, Ty, Tz` property (total number of grid points). Documentation should be updated before this PR is merged. Resolves #446 ; Resolves #459; Resolves #489",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/614:196,refactor,refactoring,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/614,1,['refactor'],['refactoring']
Modifiability,"This PR adds model setup documentation describing all the possible options the user has when setting up a model. Right now it's still a mega-page work-in-progress but the more useful parts will describe how to set up different kinds of boundary conditions with several examples, how diagnostics work and how flexible they are, and also output writers including finally a little guide on how to checkpoint and restore from a checkpoint. I think this PR is the last piece of work we agreed is needed before a JOSS submission.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/534:308,flexible,flexible,308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/534,1,['flexible'],['flexible']
Modifiability,"This PR adds one main feature and one bug fix. 1) Zonal and Volume Averages have been added to diagnostics; 2) Some checkpointing fixes have been added to allow for more flexible: specifically, CPU to GPU (visa versa is now possible) restarts are now possible and velocity / tracer fields are still checkpointed if they use function boundary conditions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/783:170,flexible,flexible,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/783,1,['flexible'],['flexible']
Modifiability,"This PR adds regridding in x (and there was previously untested regridding in y). Regridding is only supported for tracer fields (though it's not a huge amount of work to extend the schemes for any field). I believe the regridding is conservative for `RectilinearGrid`, and also conservative for `LatitudeLongitudeGrid` when the grids are aligned (ie when all grid lines of the coarser of the two grids is shared with the finer grid). In the case of partial overlaps on curvilinear grids, the volumes of the overlaps are approximated and thus the regridding is not perfectly conservative. It could make sense to emit a warning in this case. In principle, this should allow regridding in 3D by forming intermediate regridding in x, y, and z. We leave multi-dimensional regridding to the user for now. This PR also adds a `minimum_turbulent_kinetic_energy` and `negative_turbulent_kinetic_energy_damping_timescale` to `CATKEVerticalDiffusivity`, either of which can help stabilize 2D or 3D simulations with CATKE (where due to advection TKE may go negative).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2881:171,extend,extend,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2881,1,['extend'],['extend']
Modifiability,"This PR adds support for variable ""closure constants"" in `SmagorinskyLilly`, and refactors the `AnisotropicMinimumDissipation` to share it. It discontinues support for `Function` closure constants in AMD. As an example, the ""Van Driest"" damping function (discussed in #3369) would be implemented in a simple channel simulation as follows:. ```julia; # Vertically-bounded resolved LES; #; # This script builds a simulation of freely-decaying turbulence in; # a vertically-bounded domain, where turbulence far from the wall is modeled using; # the SmagorinskyLilly eddy diffusivity closure, but the dynamics close to the wall; # is fully resolved. The Van Driest damping function is used to modify the SmagorinkyLilly; # model constant close to the wall to ensure that the dynamics is relatively unaffected; # by the eddy diffusivity. using Oceananigans; using Oceananigans.Grids: zspacing; using Oceananigans.Fields: FunctionField; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization. grid = RectilinearGrid(size=(64, 64, 256), x=(0, 1), y=(0, 1), z=(0, 1),; topology = (Periodic, Periodic, Bounded)). vitd = VerticallyImplicitTimeDiscretization(); molecular_diffusivity = ScalarDiffusivity(vitd, ν=1.05e-6). """"""; van_driest_damping_function(x, y, z, p). Return the model constant for SmagorinskyLilly which decreases to zero; at the center of the first grid cell away from the wall.; """"""; @inline function van_driest_damping_function(x, y, z, p); # Position of first grid cell; z₀ = p.Δz₀ / 2; z₁ = 1 - p.Δz₁ / 2. # Distances to the wall; d⁺₀ = (z - z₀) / p.δ⁺; d⁺₁ = (z₁ - z) / p.δ⁺; d⁺ = min(d⁺₀, d⁺₁). # Model constants; A⁺ = p.A⁺; C = p.C. return C * (1 - exp(d⁺ / A⁺)); end. # Find grid spacing at top and bottom, assuming rectilinearity; Nz = size(grid, 3); Δz₀ = zspacing(1, 1, 1, grid, Center(), Center(), Center()); Δz₁ = zspacing(1, 1, Nz, grid, Center(), Center(), Center()). parameters = (C = 0.16,; A⁺ = 26, # :-D; Δz₀ = Δz₀, # vertical grid spacing at the bottom;",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3370:25,variab,variable,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3370,2,"['refactor', 'variab']","['refactors', 'variable']"
Modifiability,"This PR adds tests for `RegularLatitudeLongitudeGrid` which uncovered a couple of stupid bugs in the process. Sorry everyone. I guess we shouldn't be approving important PRs without tests in the future. I've somehow convinced myself that we need `Nλ + 2Hλ + 1` grid points in longitude even when it's periodic (tests don't pass otherwise), but not sure why so maybe let's hold off on merging just yet. This PR should fix things in PR #1404. Also, I didn't like `test_grids.jl` so I refactored it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1415:482,refactor,refactored,482,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1415,1,['refactor'],['refactored']
Modifiability,"This PR adds the keyword arguments `time_averaging_window` and `time_averaging_stride` to the constructors for `JLD2OutputWriter` and `NetCDFOutputWriter`. A non-`nothing` `time_averaging_window` transforms all the specified output to a `WindowedTimeAverage`. I have implemented this feature for `JLD2OutputWriter` only so far. ~~@ali-ramadhan, can you confirm that the pattern applied to `JLD2OutputWriter` will work for `NetCDFOutputWriter`? I'm not 100% sure how it would work with the ""slice"" functionality of the `NetCDFOutputWriter`.~~. Todo:. - ~~[ ] Implement convenience kwargs for `NetCDFOutputWriter`~~; - [ ] Tests for `JLD2OutputWriter`; - ~~[ ] Tests for `NetCDFOutputWriter`~~. Edit: I think we should just get this working for the `JLD2OutputWriter` for now. The `NetCDFOutputWriter` needs a bit of work anyways. We can extend `NetCDFOutputWriter` to averaged output once that preliminary work is complete.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/887:836,extend,extend,836,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/887,1,['extend'],['extend']
Modifiability,"This PR aims to create a single `FieldBoundaryConditions` function to replace `HorizontallyPeriodicBCs` and `ChannelBCs`. This paves the way for boundary conditions to become a `Field` property (#606). It's a pretty big breaking change so would be good to agree on the design and API before refactoring. Side note: Ideally we would set `default_bc(::Flat) = nothing` but until we elide operations and halo filling along `Flat` dimensions, I think we should use `default_bc(::Flat) = PeriodicBC()`. @glwagner Let me know if this looks like what we discussed. If so, I'll go ahead and change all the tests and examples to use it instead of `HorizontallyPeriodicBCs` and `ChannelBCs`. Reminder to self: Documentation, especially model setup, will have to be revised as part of this PR.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/620:291,refactor,refactoring,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/620,1,['refactor'],['refactoring']
Modifiability,"This PR aims to incorporate trained neural networks that represent the entrainment process due to turbulent convection in the upper ocean into Oceananigans.jl. This parameterization is designed to work using the TEOS-10 nonlinear equation of state, hence it works only in typical oceanographic conditions on Earth.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3819:165,parameteriz,parameterization,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3819,1,['parameteriz'],['parameterization']
Modifiability,This PR builds off #664 and rewrites the regression tests to match changes made in #664 to the time-stepping algorithm. It also does some minor refactoring and cleanup of the regression test scripts.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/665:28,rewrite,rewrites,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/665,2,"['refactor', 'rewrite']","['refactoring', 'rewrites']"
Modifiability,"This PR bumps the patch version in order to deploy docs, now that the `DOCUMENTER_KEY` environment variable should be correctly set for the tartarus buildkite agent. Resolves #1909",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1940:99,variab,variable,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1940,1,['variab'],['variable']
Modifiability,"This PR changes `NonhydrostaticModel` to use a single pressure variable. Prior to this PR, pressure is decomposed into a ""hydrostatic anomaly"" and a ""non-hydrostatic"" component. The vertical momentum equation in `NonhydrostaticModel` is. $$ \partial_t w = - \partial_z p + b + G_w' $$. where $G_w'$ collects the contributions to the vertical momentum tendency other than pressure gradient and buoyancy. Prior to this PR, the kinematic pressure $p$ is decomposed into (note that in this Boussinesq formulation, a hydrostatic component has already been removed from $p$) . $$ p = p_h' + p_n $$. with the hydrostatic anomaly $p_h'$ defined by. $$ p_h' = - \int^0_z b \mathrm{d} z $$. Using the hydrostatic pressure anomaly eliminates buoyancy from the vertical momentum equation, such that. $$ \partial_t w = - \partial_z p_n + G_w' $$. Buoyancy forces enter the dynamics via horizontal gradients of the hydrostatic pressure anomaly. For example, x-gradient of the kinematic pressure becomes. $$ \partial_x p = \partial_x p_h' + \partial_x p_n $$. This decomposition is advantageous for two reasons. First, in a hydrostatic model the vertical momentum equation reduces to the equation for $p_h'$. This means that switching from a hydrostatic to non-hydrostatic model is particularly simple given this decomposition. Second --- and this must be evaluated --- it's possible to carefully control the evaluation of the hydrostatic integral so that a resting stratified fluid remains at rest, even in the presence of complex bathymetry. When we use the ""MITgcm algorithm"" we achieve this perfectly, even with partial cell bathymetry. This PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:63,variab,variable,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['variab'],['variable']
Modifiability,"This PR changes ~two things~ about the BBL example:. - The variable `κ` was used for both the von Karman constant and for the eddy diffusivity. Now it's just used for the von Karman constant; - ~When calling `NonhydrostaticModel` we were using ordered arguments, which could make a new user interpret that they should know the order of the arguments when calling `NonhydrostaticModel`. Now this call is made in a more usual way with keyword arguments, where the order doesn't matter.~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2934:59,variab,variable,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2934,1,['variab'],['variable']
Modifiability,"This PR checks whether two grids are only different in the vertical dimension using runtime information, rather then relying on both fields being `SingleColumnGrid`. It also extends `total_length` for directions that are `Flat`, but have non-zero grid points (for simulations representing ensembles of simulations). Closes #2067",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2174:174,extend,extends,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2174,1,['extend'],['extends']
Modifiability,"This PR copies `schedule::AveragedTimeInterval` for each time-averaged output object when wrapping objects in `WindowedTimeInterval`. Independent copies of the schedule are needed when multiple outputs are time-averaged and then added to `simulation.diagnostics`, because each schedule has a mutable state that's specific to each output. When a single schedule is used for multiple outputs, the schedule's state is mangled for one or more of the outputs. This PR also extends the NetCDF time-averaging tests to test the case of multiple outputs in addition to the case of a single output. Resolves #1517 . cc @tomchor, @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1807:468,extend,extends,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1807,1,['extend'],['extends']
Modifiability,"This PR defines and exports ""WENO"" `VectorInvariant`, which is a convenience constructor for `VectorInvariant` wherein the vorticity, divergence, and vertical schemes are all WENO. It also defines the proper type alias and refactors the code to make it slightly more readable.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3341:223,refactor,refactors,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3341,1,['refactor'],['refactors']
Modifiability,"This PR does some minor refactoring to reduce code length. It also introduces an `AdamsBashforthTimestepper` type which will be useful in the future if new timesteppers are implemented. @ali-ramadhan, can you check to see that GPU tests pass? I had some trouble on my local machine.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/325:24,refactor,refactoring,24,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/325,1,['refactor'],['refactoring']
Modifiability,"This PR eliminates `AbstractEddyDiffusivity` in favor of simply defining `viscosity` and `diffusivity` directly for the LES closures. It also converts the boundary layer parameterizations to subtype `AbstractScalarDiffusivity{TD, VerticalFormulation}`. This change eliminates much code duplication. I'm also removing the ""background"" diffusivities/viscosities from the LES closures. Closes #1277; Closes #1381. TODO:. - [x] Pass closures into `ivd_upper_diagonal` and implement `ivd_upper_diagonal` for closure tuples and filter out explicit closures before implicit solve; - [x] Change ""diffusivity extractors"" like `κᶠᶜᶜ` so they take `closure` as an argument.; - [x] Support `viscosity(closure::Tuple, K)` cc @tomchor ; - [x] Test `DiffusiveCFL` for closure tuples; - [x] We won't need `z_diffusivity` etc anymore?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2295:170,parameteriz,parameterizations,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2295,1,['parameteriz'],['parameterizations']
Modifiability,This PR enhances the `ShallowWaterModel` to allow for multiple fluid layers. The equations are summarized in [this overleaf doc](https://www.overleaf.com/read/mtyjxnnrjpqv). Closes #2507.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600:8,enhance,enhances,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600,2,"['enhance', 'layers']","['enhances', 'layers']"
Modifiability,"This PR enhances the convecting plankton example to simulate nonlinear plankton dynamics embedded in transient convection with a time-dependent, decreasing buoyancy flux. . As described by [Taylor and Ferrari (2011)](https://aslopubs.onlinelibrary.wiley.com/doi/abs/10.4319/lo.2011.56.6.2293), turbulence shuts down shortly after the surface buoyancy flux vanishes, precipitating a ""bloom"" of phytoplankton in the well-mixed, nutrient-rich waters. This is a canonical model for the spring bloom of phytoplankton. I was worried these changes dilute the pedagogical potential of this example, but ultimately decided that the changes are minor enough that it's worth it for the great increase of relevancy of this problem to oceanography. The main additional complications are the ""nonlinearization"" of the plankton dynamics (which now depend on the local plankton concentration), and the addition of time-dependent rather than constant buoyancy flux. [Preview of the example in documentation.](https://clima.github.io/OceananigansDocumentation/previews/PR1128/generated/convecting_plankton/)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1128:8,enhance,enhances,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1128,1,['enhance'],['enhances']
Modifiability,"This PR extends `BatchedTridiagonalSolver` to also work when the tridiagonal direction is `x` and `y`, in addition to `z`. This is one necessary step to getting the `NonhydrostaticModel` to work with grids that are irregularly-spacing in the `x` and `y` directions. Related to https://github.com/CliMA/Oceananigans.jl/issues/3116",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3117:8,extend,extends,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3117,1,['extend'],['extends']
Modifiability,"This PR extends the `JLD2OutputWriter` with two new options: `verbose` and `max_filesize`. When `verbose=true` the `JLD2OutputWriter` logs what it is doing, how long it takes to copy/compute output and write output, and the file size of the output (current and delta). When `max_filesize=true`, the `JLD2OutputWriter` will stop writing to the output file once the file size exceeds `max_filesize`, and write to a new one with a consistent naming scheme. In action:; ```julia; using Oceananigans; model = Model(N=(64, 64, 64), L=(1, 1, 1)). u(model) = model.velocities.u.data.parent; fields = Dict(:u => u); ow = JLD2OutputWriter(model, fields; prefix=""test"", frequency=5, max_filesize=10MiB, force=true, verbose=true); push!(model.output_writers, ow). time_step!(model, 50, 1); ```; ```; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 4.608 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=3.822 s, size=2.2 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.891 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.262 ms, size=4.4 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.118 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=22.564 ms, size=6.6 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.479 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=18.126 ms, size=8.8 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 3.421 μs; [ Info: Writing JLD2 output Symbol[:u]...; [ Info: Writing done: time=23.091 ms, size=11.0 MiB, Δsize=2.2 MiB; [ Info: Calculating JLD2 output Symbol[:u]...; [ Info: Calculation time: 2.627 μs; [ Info: Filesize 11.0 MiB has exceeded maximum file size 10.0 MiB.; [ Info: Renaming first part: ./test.jld2 -> ./test_part1.jld2; [ Info: Now writing to: ./test_part",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/350:8,extend,extends,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/350,1,['extend'],['extends']
Modifiability,"This PR extends the capability of our ""conditional computation"" framework wherein the ""re-calculation"" of expensive diagnostics and computations may be avoided if possible. Previously, expensive field recalculations were avoided *only* at the outermost level (if the field were used directly in output), which in hindsight doesn't seem very useful since we often average or otherwise reduce expensive calculations for output (if we were not reducing an expensive calculation, we could simply calculate it offline). Avoiding recalculation for field ""dependencies"" requires adding a third function for field computation: we now have `compute_at!(field, time)`, `conditional_compute!(field, time)`, and `compute!(field, time)`. `compute_at!(field, time)` is the outermost function called by `fetch_output`. It falls back to `compute!(field)`. Fields opt-in to conditional computation by overloading `compute_at!`; for example, `ComputeField` implements. ```julia; compute_at!(field::ComputedField{X, Y, Z, <:FieldStatus}, time) where {X, Y, Z} = conditional_compute!(field, time); ```. Thus `ComputedField`s that have a `field.status` which is not `Nothing` are _conditionally_ computed. But if `field.status === nothing`, the computed field is always recomputed. The function `conditional_compute!(field, time)` examines `field.status` to determine whether a field has already been computed at `time` or not. If the field has been computed, it does nothing. If the field has not been computed, then `compute!(field, time)` is called, and `field.status.time` is updated. Conditionally computed fields must define a function `compute!(field, time=nothing)` that takes an optional positional argument `time`. This ensures that both `compute!(field)` and `compute!(field, time)` are available. Finally, fields that depend on other fields should call `compute_at!(dependency, time)` on all field dependencies. I hope that makes sense. It sounds a bit convoluted so I'm not sure this is the simplest solution.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1301:8,extend,extends,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1301,1,['extend'],['extends']
Modifiability,"This PR extends the capability of the ""implicit diffusion solver"" to handle an ""additional linear term"". This feature is then used to treat the TKE dissipation term semi-implicitly in attempt to alleviate CATKE's time-step restrictions. I use quotes because it's not exactly a ""diffusion solver"" anymore. So a little name shuffling might be in order if this turns out to work well. Thanks to @yairchn for help in formulating this potential solution for CATKE's inclination toward instability.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2426:8,extend,extends,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2426,1,['extend'],['extends']
Modifiability,"This PR extends the implementation of `IsotropicDiffusivity` to accept `AbstractField`s (such as `ComputedField`) as diffusivities and viscosities. Using this implementation with `model.velocities` or `model.tracers` requires that users instantiate the velocity and tracer fields prior to building the model. The test provided with this PR gives an example:. ```julia; arch = CPU(); grid = RegularCartesianGrid(size=(1, 1, 1), extent=(1, 2, 3)) . tracer_names = (:T, :S, :c) ; u, v, w = velocities = VelocityFields(arch, grid); T, S, c = tracers = TracerFields(arch, grid, tracer_names). ν = @at (Cell, Cell, Cell) u^2 * ∂z(T); κ = @at (Cell, Cell, Cell) S * c * sin(T). closure = IsotropicDiffusivity(ν = ComputedField(ν),; κ = ComputedField(κ)). model = IncompressibleModel(architecture=arch, grid=grid, closure=closure,; velocities=velocities, tracers=tracers); ```. A major gotcha with this implementation is that users _must_ pass the velocity and tracer fields on to `IncompressibleModel` (or the prescribed viscosity will be meaningless. We should probably also ensure that diffusivities-as-`Field`s are located at `Cell, Cell, Cell`, as the viscous and diffusive flux operators assume. A way we can prevent this error is to check that `ComputedField` viscosities or diffusivities contain references to `model.velocities` or `model.tracers`. However, this could --- in principle anyways --- exclude valid cases. I'm happy to merge as-is, or to make the implementation more robust, somehow. Possible todo:. - [ ] Allow specification of `AbstractOperation`s rather than `ComputedField`s in `IsotropicDiffusivity` constructor; - [ ] Check that `Field`-viscosities and diffusivities have correct location in `IsotropicDiffusivity` constructor; - [ ] Make implementation more robust / less error-prone?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/999:8,extend,extends,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/999,1,['extend'],['extends']
Modifiability,"This PR felt so good!. The internal code base had to be massively refactored thus the size of this PR but I think it's taking the code base in the right direction with submodules for everything, and will make implementing big new features (like vertically stretched grid and MPI) much easier and cleaner. There were a few breaking changes, e.g. `Face` and `Cell` moving to `Oceananigans.Fields`. In particular, Oceananigans does not export `day`, `minute`, `second`, and `hour` anymore as they conflict with the `Dates` module used by the logger. And it might also confuse users as to why Oceananigans is exporting these common names. They are now exported by `Oceananigans.Utils`. But otherwise, the impact to user scripts is pretty minimal (the examples barely changed). This should be merged as the next PR ASAP as merging anything else in will probably create some form of merge conflict hell. Resolves #456; Resolves #495; Resolves #497; Resolves #563",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/591:66,refactor,refactored,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/591,1,['refactor'],['refactored']
Modifiability,This PR finally gets rid of all the Casette warnings and a few other similar warnings due to method redefinitions. Had to refactor the `FPlane` constructor to avoid a method redefinition. I chose to infer the float type `FT` from the inputs and remove the option to explicitly pass in an `FT`. This is a breaking change (hopefully a minor one) but I couldn't think of another approach that would less intrusive. Suggestions welcome for other ways to resolve the ambiguity between `FPlane` constructors. Resolves #537; Resolves #366,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/538:122,refactor,refactor,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/538,1,['refactor'],['refactor']
Modifiability,This PR finally upgrades the checkpointer so it can restore large models that take up more than 50% of system memory. It used to create a model then restore the fields which allocates twice as much memory as needed. Now the data needed to restore the fields is passed to the model constructor so no double allocation. Some refactoring had to happen to make this possible. This PR is also part 2/3 of making boundary conditions a field property. Should help a lot with #602 and #603. Resolves #416; Resolves #417. Note: This PR branches off #627.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/628:323,refactor,refactoring,323,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/628,1,['refactor'],['refactoring']
Modifiability,This PR fixes a bug that (apparently) crept in on #3401 --- I think. It's hard to know for sure because GPU tests don't pass right now. There may be more to fix. @jagoosw I believe that `adapt` is missing its first argument. Note the PRs were merged without tests passing... that's why we have this issue. @wsmoses @jlk9 we may need this to pass for your test PRs to be useful. @navidcy,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413:187,adapt,adapt,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413,1,['adapt'],['adapt']
Modifiability,"This PR generalizes file splitting for `JLD2OutputWriter`, replacing `max_filesize` with a `file_splitting` keyword argument. To implement a maximum filesize we use. ```julia; JLD2OutputWriter(model, outputs; file_splitting=FileSizeLimit(max_filesize), ...); ```. This feature should also be extended to `NetCDFOutputWriter` in this PR -- hopefully @josuemtzmo can help!. This PR will enable `TimeInterval` (or any other schedule --- `IterationInterval`, `WallTimeInterval`) to be used for splitting output files. Closes #2967",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3515:292,extend,extended,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3515,1,['extend'],['extended']
Modifiability,This PR greatly simplifies the logic behind `conditional_operation` and how its extended for immersd boundary grid. The end result besides source code clean up seems to be an improvement in type inference. Resolves #3750 I think. But @ali-ramadhan please test. EDIT: I decided not to work on #3791 (here) because this requires fixing a bunch of tests and is a bigger effort.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794:80,extend,extended,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794,1,['extend'],['extended']
Modifiability,"This PR implements a major refactor of the `TurbulenceClosures` module. In particular, it ""standardizes"" how turbulence closures specify diffusive fluxes. Each turbulence closure now defines 12 functions (or opts in to functionality via subtyping, eg `AbstractEddyViscosityClosure`):. * `diffusive_flux_x`, `diffusive_flux_y`, and `diffusive_flux_z` for tracer diffusive fluxes; * `viscous_flux_ux`, `viscous_flux_uy`, and `viscous_flux_uz` for viscous fluxes of x-momentum; * 6 other functions similar to `viscous_flux_ux`, etc for `y` and `z` momentum components. Then there is a single implementation of `∇_κ_∇c`, for example, which calculates the divergence of the diffusive fluxes in a way that generalizes to curvilinear grids. This refactor was not that difficult because many turbulence closures had functions analogous to these --- they were just called by different names. So in a way this PR simply establishes standard notation. A major advantage of standard notation is that we can now correctly specify flux boundary conditions even when we cannot fill halos for this purpose. For example, right now we fill halos so that (fingers crossed!) boundary fluxes are zero when the diffusion operator is evaluated on boundary-adjacent cells, and then in a second step add the specific boundary fluxes. But with a function `diffusive_flux_x`, we can now ""reverse"" boundary fluxes and add specified fluxes generically. This PR therefore makes progress towards #1400. Work on this PR started with a few extra tests for `HydrostaticFreeSurfaceModel` (though its focus is not quite different). So as a bonus this PR also adds tests for `HydrostaticFreeSurfaceModel` (which may need to be disabled if they fail on the GPU so that we can get this PR in sooner rather than later).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1449:27,refactor,refactor,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1449,2,['refactor'],['refactor']
Modifiability,"This PR implements a new framework for high-order advection schemes. There are two types of advection schemes: `AbstractCenteredAdvectionScheme` and `AbstractUpwindBiasedAdvectionScheme`. This PR implements momentum and tracer flux operators such that an centered advection scheme needs only to implement 7 functions: 6 `symmetric_interpolate_*` functions for `x, y, z` at cell centers and interfaces, and a `boundary_buffer` scheme that indicates the buffer needed around boundaries in `Bounded` directions`. . Upwind biased advection schemes need 19 functions: `halo_buffer`, 12 functions for `left_biased_interpolate_*` and `right_biased_interpolate_*`, and 6 functions for `symmetric_interpolate_*` that use a symmetric interpolation (typically of order `m-1`, where `m` is the order of the upwind scheme). These are used for momentum advection. This PR refactors fourth order advection to use the framework. It still needs:. - [x] third-order upwind biased advection (as an example); - [x] tests. Resolves #965",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/972:858,refactor,refactors,858,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/972,1,['refactor'],['refactors']
Modifiability,"This PR implements a third-order Runge-Kutta time stepping method. The implementation is based off [Le and Moin (1991)](https://www.sciencedirect.com/science/article/pii/0021999191902157). It should be noted, however, that we do not use an implicit method for diffusion, and that the pressure correction is calculated every substep. It could be possible in the future to implement the optimization described in Le and Moin (1991) that reduces the number of times the pressure Poisson equation needs to be solved each time-step from 3 to 1, though this would reduce the accuracy of the scheme from third to second-order. So far, this PR extends the dynamics tests and incompressibility test to `RungeKutta3TimeStepper`. It also extends the time stepper convergence test to the `RungeKutta3TimeStepper`. I am open to changing the name of the time stepper. It may also be a good idea to add basic documentation. The time stepper is used by setting the keyword `timestepper=:RungeKutta3` in the constructor for `IncompressibleModel`. ~~I am not sure if checkpointing will work with this timestepper.~~. Checkpointing will not work with this timestepper. A more generic checkpointer awaits a future PR. Resolves #506",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/945:636,extend,extends,636,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/945,2,['extend'],['extends']
Modifiability,"This PR implements a two-equation turbulent closure, which evolve turbulent kinetic energy and an additional ""scale variable"". Here we choose the scale variable dissipation; another name for this two-equation model is ""k-epsilon"". In Oceananigans it will be called the `TKEDissipationVerticalDiffusivity`. This PR is a WIP; we still have to implement the stability functions and, perhaps more importantly, figure out how to make time-stepping stable. . Closes #2278",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3509:59,evolve,evolve,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3509,3,"['evolve', 'variab']","['evolve', 'variable']"
Modifiability,"This PR implements an FFT-based preconditioner for `PCGImplicitFreeSurfaceSolver` on immersed boundary `RectilinearGrid`. Note that we have a direct FFT solver for _non-immersed_ `RectilinearGrid`. # Premise. The premise of the FFT-based preconditioner is to use the non-immersed FFT-based algorithm for implicit free surface solves on rectilinear grids as a _preconditioner_ for a conjugate gradient iterative solver. In a domain with variable bathymetry, the conjugate gradient method is used to solve the ""implicit step equation"". ```; (∇ʰ⋅ H ∇ʰ - 1 / (g Δt²)) ηⁿ⁺¹ = 1 / (g Δt) ∇ʰ ⋅ Q★ - 1 / (g Δt²) ηⁿ; ```. where `H(x, y)` is the bottom depth (there are some subtleties in a proper finite-volume discretization of this equation, which we'll ignore for this high-level overview). Above, `ηⁿ⁺¹` is the free surface at time-step `n+1` and `ηⁿ` is the free surface at time-step `n`, `Q★` is the _predictor_ barotropic mass flux that we are correcting, `g` is gravitational acceleration, and `Δt` is the time-step. The FFT-based preconditioner instead solves. ```; [∇² - 1 / (g H̄ Δt²)] ηⁿ⁺¹ = (∇ʰ ⋅ Q★ - ηⁿ / Δt) / (g H̄ Δt); ```. where `H̄` is an ""effective constant depth"" (here we use `grid.Lz`, but this could be changed in the future). This PR adds `validation/immersed_boundaries/bumpy_baroclinic_adjustment.jl` to test the effectiveness of this solution. A summary of what we found using that validation experiment and some more careful benchmarking is. * The FFT-based preconditioner reduces the iterations required for convergence from O(100) (usually 300-400) to O(10) over no preconditioning for the bumpy baroclinic problem.; * The FFT-based preconditioner is roughly 2x faster on both CPU and GPU than the current fastest methods (matrix iterative solver with ILU and sparse approximate inverse preconditioner, respectively).; * Unlike the other fastest methods, the time-step can be freely modified with no cost when using the FFT-based preconditioner. Notes:. * The ILU preconditioner",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2412:436,variab,variable,436,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2412,1,['variab'],['variable']
Modifiability,"This PR implements the ""MEKE"" mesoscale parameterization proposed by [Jansen et al (2015)](https://www.sciencedirect.com/science/article/pii/S1463500315000967) (see also [Kong and Jansen (2020)](https://journals.ametsoc.org/view/journals/phoc/51/3/JPO-D-20-0142.1.xml)). To implement this PR we add a property to `HydrostaticFreeSurfaceModel` called `auxiliary_prognostic_fields` which provides a container for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431:40,parameteriz,parameterization,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431,3,"['parameteriz', 'variab']","['parameterization', 'variable']"
Modifiability,"This PR implements the infrastructure for open boundary conditions in the `NonhydrostaticModel` as well as a few simple methods. . This PR:. - [x] Adds a `matching_scheme` property to `Open` boundary classifications to allow different `fill_X_halo!` to be dispatched; - [x] Introduces `update_boundary_condition!` to be called before halo fills allowing the `mathcing_scheme` to have properties which can evolve with the model; - [x] Make the existing tests pass; - [x] and implements a zero gradient matching scheme. (Others please feel free to update this comment as necessary.). ------------------------------------------------------------------------; Hi all,. Following discussion with @glwagner, @simone-silvestri, and @jm-c this is a first attempt at implementing open boundary conditions. First I will try to get it working for the non-hydrostatic model which seems to be relatively straightforward. As a first step, I have implemented east/west boundaries which allow a flow to be prescribed or to travel out of the domain (i.e. if you set `OpenBoundaryCondition(nothing)` then my code is assuming the flow will be travelling into that boundary). The outflow condition is equivalent to having a nondimensional phase speed of 1 (sec 3.1 of https://doi.org/10.1016/S0924-7963(97)00023-7) which seems to work fine. When I vary the inflow velocity I do see waves in the velocity field reflecting from the downstream boundary. I gather that we expect this with any outflowing boundary and would remedy this with a sponge layer, but maybe this is where we need to add something to the pressure solver. With a constant inflow (0.1 m/s, 0.625m resolution, AMD and SeawaterBuoyancy), and a turbulent outflow, it seems to work okay:. https://github.com/CliMA/Oceananigans.jl/assets/26657828/1509c8fa-ea24-40a2-84d5-33da424567b1. I am going to try and implement the test cases in the paper mentioned below next. I have a few things I think we should think about:; - Does it make more sense for `Open` to",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:405,evolve,evolve,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,1,['evolve'],['evolve']
Modifiability,"This PR implements vertically-implicit time integration for tracers and momentum. We restrict attention to the `HydrostaticFreeSurfaceModel` and quasi-Adams-Bashforth time integration. This requires some refactoring of function-calling in `TurbulenceClosures` some upgrades to `BatchedTridiagonalSolver`, and changes to `ab2_step!(model::HydrostaticFreeSurfaceModel, dt)`. At first we will only support vertically implicit diffusion for `HorizontallyCurvilinearAnisotropicDiffusivity`. However, `TurbulenceClosures` has been extensively refactored to permit quick extension of vertically-implicit time-stepping to `IsotropicDiffusivity`, `AnisotropicDiffusivity`, and LES closures. ~~There are a few questions to answer before implementing implicit time-stepping there that we should discuss in issues.~~ It should be straightforward enough to implement vertically implicit time stepping for these closures and test them with existing regression tests. To construct a model that steps forward the vertical component of `HorizontallyCurvilinearAnisotropicDiffusivity` implicitly, we introduce the syntax. ```julia; ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()); ```. The default `time_discretization` is `ExplicitTimeDiscretization`. The constructor for `HydrostaticFreeSurfaceModel` handles constructing a `VerticallyImplicitDiffusionSolver` when implicit time discretization is specified. This script:. ```julia; using Plots; using Printf; using Oceananigans; using Oceananigans.TurbulenceClosures: VerticallyImplicitTimeDiscretization, time_discretization. grid = RegularRectilinearGrid(size=128, z=(-0.5, 0.5), topology=(Flat, Flat, Bounded)). evd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0); ivd_closure = HorizontallyCurvilinearAnisotropicDiffusivity(κz = 1.0, time_discretization = VerticallyImplicitTimeDiscretization()). model_kwargs = (grid=grid, tracers=:c, buoyancy=nothing, velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1639:204,refactor,refactoring,204,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639,2,['refactor'],"['refactored', 'refactoring']"
Modifiability,"This PR improves the `HorizontalAverage` utility to allow users to specify a return type, and refactors the code a bit to dispatch on the length of `fields`. This will be useful in the future when more sophisticated functions for computing horizontal averages (which, for example, interpolate fields to a common location) are implemented. It also refactors the time to write function and eliminates some boilerplate.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/386:94,refactor,refactors,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/386,2,['refactor'],['refactors']
Modifiability,"This PR incorporates significant updates from PR #3306. Most importantly, it employs the new halo-filling functions to update the halos of the prognostic variables. Additionally, it removes the replace_horizontal_vector_halos! function, enhances existing methods and function calls related to the cubed sphere grid, and refines the vorticity computation function. It also implements a new test to verify that the norm of the prognostic variables of the Rossby-Haurwitz wave remains almost constant as it propagates over the cubed sphere.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3570:154,variab,variables,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3570,3,"['enhance', 'variab']","['enhances', 'variables']"
Modifiability,"This PR inserts the vertical buoyant acceleration directly into the vertical momentum equation in `NonhydrostaticModel`, rather than integrating to find the hydrostatic pressure and inserting its gradient into the horizontal momentum equations. I just did the easiest thing right because I'm curious if regression tests pass. If they do, we can refactor `NonhydrostaticModel` to eliminate hydrostatic pressure, speed up the model, and reduce its memory footprint without too much pain (🎉). If the regression tests don't pass, we will unfortunately have slightly more pain ahead of us in refactoring the regression tests. In addition to the above advantages, we also need to eliminate vertical integrals in `NonhydrostaticModel` to permit 2D distributed memory parallelization. This is because `PencilFFTs` only allows parallelization across dimensions higher than 1 (or in other words, we cannot parallelize in `x`). Thus with a vertical integral, we can only parallelize easily across `y`. If we eliminate the vertical integral, we'll be able to parallelize in `y, z`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1910:345,refactor,refactor,345,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1910,2,['refactor'],"['refactor', 'refactoring']"
Modifiability,"This PR integrates Tim's changes from the GPU hackathon. By using dynamic launch configurations and splitting up the interior source term calculation kernel (+ https://github.com/JuliaGPU/CUDAnative.jl/pull/417) we get a pretty sweet ~25% overall speedup (so the most expensive kernel which was a bottleneck is sped up by ~40%). Needs https://github.com/vchuravy/GPUifyLoops.jl/pull/90 to work for now. cc @maleadt Sorry it took so long for me to merge these improvements. Actually resolves #64 . ```; ──────────────────────────────────────────────────────────────────────────────────────; Oceananigans.jl static ocean bench... Time Allocations ; ────────────────────── ───────────────────────; Tot / % measured: 409s / 28.8% 15.0GiB / 0.50% . Section ncalls time %tot avg alloc %tot avg; ─────────────────────────────────────────────────────────────────────────────────────; 256×256×256 (CPU, Float64) 10 56.0s 47.7% 5.60s 292KiB 0.37% 29.2KiB; 256×256×256 (CPU, Float32) 10 47.2s 40.2% 4.72s 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float32) 10 5.91s 5.03% 591ms 227KiB 0.29% 22.7KiB; 128×128×128 (CPU, Float64) 10 5.87s 5.00% 587ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float64) 10 803ms 0.68% 80.3ms 292KiB 0.37% 29.2KiB; 64× 64× 64 (CPU, Float32) 10 724ms 0.62% 72.4ms 227KiB 0.29% 22.7KiB; 256×256×256 (GPU, Float64) 10 309ms 0.26% 30.9ms 9.83MiB 12.9% 0.98MiB; 256×256×256 (GPU, Float32) 10 239ms 0.20% 23.9ms 8.70MiB 11.4% 891KiB; 32× 32× 32 (CPU, Float64) 10 86.6ms 0.07% 8.66ms 292KiB 0.37% 29.2KiB; 32× 32× 32 (CPU, Float32) 10 61.0ms 0.05% 6.10ms 227KiB 0.29% 22.7KiB; 32× 32× 32 (GPU, Float64) 10 50.7ms 0.04% 5.07ms 9.83MiB 12.9% 0.98MiB; 64× 64× 64 (GPU, Float64) 10 49.7ms 0.04% 4.97ms 9.83MiB 12.9% 0.98MiB; 128×128×128 (GPU, Float64) 10 46.9ms 0.04% 4.69ms 9.83MiB 12.9% 0.98MiB; 32× 32× 32 (GPU, Float32) 10 44.8ms 0.04% 4.48ms 8.70MiB 11.4% 891KiB; 128×128×128 (GPU, Float32) 10 40.6ms 0.03% 4.06ms 8.70MiB 11.4% 891KiB; 64× 64× 64 (GPU, Float32) 10 32.6ms 0.03% 3.26ms 8.70MiB 11.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/302:81,config,configurations,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/302,1,['config'],['configurations']
Modifiability,"This PR intends to abstract the concept of a grid with ""multiple regions"" from the cubed sphere. We only need one `MultiRegionGrid` to support a wide variety of configurations, including the CubedSphere. The hope in the near term is that this clarifies the code and implementation of cross-region halo exchanges. This PR was also going to implement broadcasting and try to get `ComputedField` working for fields and `AbstractOperations` distributed across multiple regions. This would get the PreconditionedConjugateGradientSolver working on MultiRegionGrid. To get this working we ""only"" need to define `get_region(op, i)` for `op::BinaryOperation, UnaryOperation, MultiaryOperation, Derivative`, which might not be too difficult. It also intends to define a macro `@regionalize` which we can use either to decorate existing functions or to conveniently extend functions to broadcast across multiple regions. Right now ""regional broadcasting"" is done manually, which is cumbersome and presumably can only lead to a build up of boilerplate. My changes broke the halo exchange tests however. @ali-ramadhan I need your help to fix these. If we can fix the tests, then we can move forward with this PR. Otherwise we may have to start over.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1614:161,config,configurations,161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1614,2,"['config', 'extend']","['configurations', 'extend']"
Modifiability,"This PR introduces a ZStar, free surface following vertical coordinate. . the vertical coordinate evolves in time and is implemented following the recipe in ; [Rescaled height coordinates for accurate representation of free-surface flows in ocean circulation models ](https://www.sciencedirect.com/science/article/abs/pii/S1463500303000544) that allows the implementation of a general vertical coordinate where the only specification needed is the vertical derivative of the vertical coordinate. Closes https://github.com/CliMA/Oceananigans.jl/issues/1679",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3411:98,evolve,evolves,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411,1,['evolve'],['evolves']
Modifiability,"This PR introduces a `Simulation` type that manages time stepping with a high level interface. I think `diagnostics` and `output_writers` will have to become keyword arguments to `time_step!`. It will be a pretty big breaking change once we move `diagnostics` and `output_writers` outside of `Model` so would be good to agree on the design and API before refactoring. @glwagner Let me know what you think, we can iterate on the design in this PR. Resolves #432 ; Resolves #447",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/621:355,refactor,refactoring,355,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/621,1,['refactor'],['refactoring']
Modifiability,"This PR introduces a major refactor of `FieldBoundaryConditions` and changes the user API. The `grid` and field location are no longer necessary to build `FieldBoundaryConditions`. This means that the constructors `TracerBoundaryConditions`, `UVelocityBoundaryConditions`, etc, are gone. Instead we have only `FieldBoundaryConditions`, which is used like. ```julia; u_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(-1e-4), bottom=FluxBoundaryCondition((x, y, t, u) = -1e-3 * u, field_dependencies=:u)). T_bcs = FieldBoundaryConditions(top=FluxBoundaryCondition(1e-8)); ```. There's also a new constructor `AuxiliaryFieldBoundaryConditions` which takes the place of `ComputedFieldBoundaryConditions` and is now the default for `Field` and `ComputedField`. The difference is that `AuxiliaryFieldBoundaryConditions` have `nothing` instead of an `ImpenetrableBoundaryCondition` in `Bounded` directions when they're located on faces. Under the hood the `FieldBoundaryConditions` struct is ""flattened"" so there's no more `CoordinateBoundaryConditions`. In addition, a new field `immersed` is added to `FieldBoundaryConditions` in addition to `east`, `west`, etc. This will be used to support boundary conditions on immersed boundaries in the future. There's still quite a few validation experiments to clean up and probably some lingering issues with tests, but I was able to get the examples to run so I thought it was the right time to open the PR. On the API changes: it seemed like a positive change that we don't need `grid` in the boundary conditions constructor, and that we only have one name `FieldBoundaryConditions` rather than 4. However, if others feel they liked the old API, we can add convenience functions `TracerBoundaryConditions`, etc back to the source.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843:27,refactor,refactor,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843,1,['refactor'],['refactor']
Modifiability,"This PR introduces a new regression test (and renames ""golden master tests"" to ""regression tests"") based on Rayleigh-Benard convection that adds regression tests for `Value` boundary conditions, the forcing implementation and the salinity equation, by using salinity as a passive tracer in the test. The test avoids setting random initial conditions by loading both the initial model state and the comparison state from file. Note that loading the model state from file required writing a new `OutputWriter` that outputs and loads the ""source terms"", `G`. This implementation is included in `test_regression.jl`, but it may be worthwhile to integrate it into `output_writers.jl` at some point. The test runs on the CPU and GPU. However, similar to the thermal bubble tests, this test fails on the GPU. This PR also adds a file to `sandbox` to aid running and exploring solutions to Rayleigh-Benard and also demonstrates the user-specification of a forcing term.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/239:831,sandbox,sandbox,831,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/239,1,['sandbox'],['sandbox']
Modifiability,"This PR introduces full upwinding in vector invariant advection, which allows running eddy-permitting/resolving hydrostatic simulations without the need for an explicit viscous dissipation. In addition, it also refactors the whole vector scheme superseding PR #2820 . Examples of surface speed in modified neverworld configuration:. https://user-images.githubusercontent.com/33547697/206742914-d216ea2b-7cd2-4aa5-be70-a760b088698b.mp4. left: full upwinding 1/8th of a degree, no horizontal closure; center: full upwinding 1/4th of a degree, no horizontal closure; right: conservative vector invariant, biharmonic viscosity. Closes #2820",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2852:211,refactor,refactors,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2852,2,"['config', 'refactor']","['configuration', 'refactors']"
Modifiability,"This PR introduces the `NormalFlow` boundary condition, and renames `BoundaryCondition(NoPenetration, nothing)` to `BoundaryCondition(NormalFlow, 0)`. There is an alias `ImpenetrableBoundaryCondition() = BoundaryCondition(NormalFlow, 0)`, though this probably won't be touched by users. This PR also extends boundary conditions to the `x`-direction, and reversed an incorrect assumption that `Value` and `Gradient` boundary conditions should be applied at all halo points. In reality, extra boundary conditions are required for the case that halo regions are larger than 1. Developing an abstraction for higher-order boundary conditions is straightforward, but is not a priority. The implementation of `NormalFlow` boundary conditions is likely incorrect for general stretched grids. We don't have a test for this, however. I think we should wait until we have full stretched grid implementation to fix this; it should not be hard. It requires correctly satisfying the continuity equations in halo regions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/710:300,extend,extends,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/710,1,['extend'],['extends']
Modifiability,"This PR is a stab at implementing the pressure solvers plan/overhaul outlined in #586. So far it implements pressure solvers for all types of domains (triply/doubly periodic, channels, and boxes) on regular grids (except boxes on GPUs for now). Equally important, it refactors and cleans up the pressure solvers so that we can now easily add in pressure solvers for vertically stretched grids and distributed models. A lot of cleanup was done in the process as well. Pressure solver code and kernels have been fully moved from the `TimeSteppers` submodule to the `Solvers` submodule. Different parts have been reorganized into multiple files and the index permutation business has been abstracted away a bit so we have fewer ugly kernels (and fewer kernels!). I could have gone much further in condensing the code base and number of pressure solvers. You'll notice quite a bit of code repetition, but I think for now and the forseeable future this is actually a good thing. The pressure solver code is nontrivial and keeping it as simple as possible will improve the readability and longevity of the code base. It's also easier to add and modify pressure solvers now. For example, if @sandreza wants to implement a fast pressure solve that only works for horizontally periodic domains (Kleiser-Schumann?), it's now much easier to do that. I should probably add some benchmarks.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/589:267,refactor,refactors,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/589,1,['refactor'],['refactors']
Modifiability,"This PR is part 1 of _n_ implementing halo regions (originally PR #167). Here I just replace Arrays and CuArrays with OffsetArrays containing an Array or CuArray. . An important change is the introduction of the `data(::Field)` function which returns the data stored by the field, i.e. without halo data. Lots of refactoring had to happen but it was mostly in updating the tests to use the `data` function. The Poisson solver had to be refactored because FFTW and cuFFT won't work properly on an offset array containing halos. The Poisson solver now keeps track of the right-hand-side, Fourier coefficients, and solution using `solver.storage` which is a regular `Array` or `CuArray`. This cuts down memory usage as well. Works on #104. Resolves #45; Resolves #122; Resolves #177",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/250:313,refactor,refactoring,313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/250,2,['refactor'],"['refactored', 'refactoring']"
Modifiability,"This PR is part 1/3 of making boundary conditions a field property. I was refactoring the fields module, and in doing so I added optional kwargs to allow for data arrays to be passed. This allows the checkpointer to be simplified as it no longer has to keep track of array references, and makes restoring/checkpointing large models possible. I will address this in part 2. Changes:. 1. `AbstractLocatedField` has been removed. Now there is only `AbstractField`. 2. Fields can now be initialized with a data array. This will make restoring/checkpointing large models possible. Right now `field.data` can store anything. We could check to make sure that `field.data` has the same size as the grid, but this is extra code and could limit flexibility in the future so I did not add a check for this. 3. Field tuple initializers (`VelocityFields`, `TracerFields`, etc.) can now accept data arrays through keyword arguments. 4. `FaceFieldX` has been renamed to `XFaceField`, and same for y and z. Note: This PR branches off #626.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/627:74,refactor,refactoring,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/627,1,['refactor'],['refactoring']
Modifiability,"This PR is part 2 of n implementing halo regions (originally PR #167). n = 2 probably. Here I actually start using the halos and integrate them with the code. This involves filling in the halo regions as needed to enforce the periodic boundary conditions. I also rewrite the operators to use `i-1` and `i+1` instead of `decmod1` and `incmod1`. Hopefully this will speed things up a bit, especially on the GPU. I will release v0.6 once this is merged. Resolves #104",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/253:263,rewrite,rewrite,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/253,1,['rewrite'],['rewrite']
Modifiability,"This PR makes `model.diagnostics` and `model.output_writers` into `OrderedDict`s by default. In addition, we add functionality that preserves the existing behavior: when the user calls `push!(model.diagnostics, new_diagnostic)`, the diagnostic `new_diagnostic` is given a default name (something like `:diag1`). In addition, the diagnostics can be accessed by index (an integer) or by name (assumed to be a `Symbol`, though in principle anything except an integer might be used). Giving names to diagnostics should prove useful for saving `Timeseries` diagnostics, or accessing the value of a diagnostic for logging / other purposes. We use `OrderedDict` so that the diagnostics and output writers are executed in the order they were inserted, which is a potentially useful feature for interdependent diagnostics. We also add code that extends the functionality of `Timeseries` so that the user may pass a `NamedTuple` of timeseries, eg:. ```julia; cfl_timeseries = Timeseries((adv=AdvectiveCFL(dt), diff=DiffusiveCFL(dt)), frequency=1); model.diagnostics[:timeseries] = cfl_timeseries; ```. The sampled values would then be stored in `cfl_timeseries.data.adv` and `cfl_timeseries.data.diff`. By extending `getproperty`, we also provide syntax such that. ```julia; cfl_timeseries.adv; ```. returns the array `cfl_timeseries.data.adv`, for user convenience. As for ""non-tupled"" diagnostics, the samples in `cfl_timeseries.data.adv` can be plotted alongside `cfl_timeseries.time`. Resolves #362.; Resolves #361.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/411:836,extend,extends,836,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/411,2,['extend'],"['extending', 'extends']"
Modifiability,"This PR makes some changes to the `HydrostaticFreeSurfaceModel` to permit the simulation of an ""ensemble of columns"". This abstraction uses a `Flat, Flat, Bounded` topology but non-zero resolution in `x, y`, leading to a model of `Nx, Ny` independent, non-communicating columns. In addition, we support using a 2D array of turbulence closures with this ""column ensemble"" abstraction (but only with this abstraction, not generally, to hopefully minimize unexpected behavior) so that each column can simulate a different surface boundary condition and parameterization independently. An example of usage is implemented in `validation/vertical_mixing_closures/many_tke_based_free_convection.jl` and `validation/vertical_mixing_closures/gpu_tkevd_ensemble.jl`. The result is a model that can simulate thousands of columns simultaneously on the GPU efficiently. A small benchmark for an ensemble of 8000 columns (400 by 20) achieves. ```julia; [ Info: Benchmarking...; 3.265 ms (6015 allocations: 2.54 MiB); ```. per time-step on a Titan V. This is a speed up of 1800x over a single column simulation with Oceananigans. This will hopefully prove useful for calibrating boundary layer parameterizations. @xiaozhour we can use a similar ""slice ensemble"" abstraction to simulate independent 2D slices for the purpose of calibrating mesoscale parameterizations, potentially.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1924:550,parameteriz,parameterization,550,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1924,3,['parameteriz'],"['parameterization', 'parameterizations']"
Modifiability,"This PR makes the separation computation of the hydrostatic pressure anomaly an optional feature of `NonhydrostaticModel`. It's also off by default, which hopefully means that triply periodic simulations should work by default (@johnryantaylor a while ago you wanted to do a triply periodic simulation, hopefully this PR makes that possible). @tomchor ready to review, let me know what you think about the design. This PR supercedes #3080, where there is an extended description of this change plus a discussion about its pros and cons. Closes #3364 (I think...)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3574:458,extend,extended,458,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3574,1,['extend'],['extended']
Modifiability,This PR might need to be closed or refactored. We now have `VerticallyImplicitTimeDiscretization`. A new turbulence closure called `ConvectiveAdjustmentDiffusivity` would probably useful for some users. For this the convective adjustment diffusivity should be precomputed. During this computation the vertical buoyancy gradient can be calculated on the fly with the function `∂z_b`; so there would be no need to store the vertical buoyancy gradient separately.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1342#issuecomment-848999805:35,refactor,refactored,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342#issuecomment-848999805,1,['refactor'],['refactored']
Modifiability,"This PR modifies the time-stepping algorithm so that the tendencies for wall-normal velocity components are calculated on boundaries in `Bounded` directions. In other words, when `x` is `Bounded`, the algorithm now calculates `Gu` on east boundaries, where `i=Nx+1`. Previously `Gu` was only calculated on west boundaries where `i=1`. The same applies to `y` and `z`. This change is necessary because, in general, the values of `Gu`, `Gv`, and `Gw` on `x`, `y`, or `z` boundaries are needed to impose predictor velocity and pressure boundary conditions when `x`, `y`, or `z` are `Bounded` --- respectively. The changes in this PR also motivated a slight refactoring of the way ""equations"" are specified. There is now a file dedicated to equation / tendency specification, called `velocity_and_tracer_tendencies.jl` in `src/TimeStepping`. Resolves #259 (since it implements a simple / minimal abstraction for equations).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/677:654,refactor,refactoring,654,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/677,1,['refactor'],['refactoring']
Modifiability,"This PR moves the time stepping functionality into a module and refactors and orthogonalizes the time-stepping algorithm to make it easier to implement new time steppers. . It also introduces a macro `@loop_xyz` that copy-pastes code to specify a 3D loop, reducing a lot of boiler plate. There is also a new function `compute_w_from_continuity!(model)` that a user might employ to ensure their initial velocity field is non-divergent. . Resolves #485 ; Resolves #461 ; Probably resolves #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/505:64,refactor,refactors,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/505,1,['refactor'],['refactors']
Modifiability,"This PR overhauls halo filling to improve performance, especially for models that are ""thin"" in one direction (meaning that halo filling in the ""fat"" directions is expensive). It combines halo filling for opposing boundaries when possible (this is almost always possible except when using value / gradient boundary conditions). Notably it implements kernels for filling periodic boundary conditions rather than using `view` plus broadcasting, leading to significant performance improvement and reduction in memory allocations. The main problem was periodic directions I think, but there were also issues for normal velocity components. There may be more improvements to be had there. I think we can also do a lot less halo filling for flux boundary conditions, but full optimization would require a bit of work to the turbulence closures. For the default model configuration, we launch about half as many kernels for halo filling now. Before this PR:. ```julia; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 226.285 ms (404628 allocations: 164.96 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 517.198 ms (431298 allocations: 347.27 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=1, Ny=64, Nz=64)...; 432.185 ms (292065 allocations: 315.60 MiB); ```. After this PR:. ```julia; gregorywagner:benchmark/ (glw/performance✗) $ julia --project benchmark_two_dimensional_models.jl [18:25:59]; [ Info: Oceananigans will use 8 threads; [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=64, Nz=1)...; 183.673 ms (340830 allocations: 107.52 MiB); [ Info: Benchmarking model with RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded}(Nx=64, Ny=1, Nz=64)...; 229.704 ms (359167 allocations: 108.74 MiB); [ Info",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1923:861,config,configuration,861,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1923,1,['config'],['configuration']
Modifiability,"This PR overhauls the API for `Simulation`, `TimeStepWizard`, and printing of progress. It also simplifies the implementation of `run!`. After this PR, `Simulation` no longer accepts the keyword arguments `iteration_interval` or `progress`. Instead, progress printing is achieved with callbacks, eg:. ```julia; progress(sim) = @info ""Iteration: $(iteration(sim)), time: $(time(sim))""; simulation.callbacks[:progress] = Callback(progress, IterationInterval(100)); ```. It also refactors the `TimeStepWizard` so that it can be used as a callback, eg. ```julia; wizard = TimeStepWizard(cfl=1.0, max_change=1.1, max_Δt=2minutes); simulation.callbacks[:wizard] = Callback(wizard, IterationInterval(10)); ```. This is a better design for a few reasons:. 1. Adaptive time-stepping and progress printing are not longer arbitrarily constrained to occur on the same iteration interval.; 2. Both progress printing and adaptive time-stepping can use any `schedule` (rather than only `IterationInterval`).; 3. The simulation time-step is always `simulation.Δt`. No more shenanigans like `simulation.Δt.Δt`. Eventually, we should also eliminate the ""diagnostics"" list so that we have only two lists of callback-like objects: `simulation.callbacks` and `simulation.output_writers`. I think this resolves an issue or two but I need to find them. Also, I've so far only updated the examples. There are probably tests and validation cases that need to be updated for the new API as well. This PR is an important step toward generalizing `Oceananigans.Simulation` so that it can be used by [`ClimaAtmos.jl`](https://github.com/CliMA/ClimaAtmos.jl). cc @bischtob @akshaysridhar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1971:476,refactor,refactors,476,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1971,3,"['Adapt', 'adapt', 'refactor']","['Adaptive', 'adaptive', 'refactors']"
Modifiability,"This PR overhauls the infrastructure supporting user-defined forcing functions. Many of these changes are discussed in #896 . ## `ModelForcing` is no more. The first important change is the elimination of `ModelForcing`. The `forcing` kwarg in the constructor for `IncompressibleModel` now accepts a named tuple, similar to the kwarg `boundary_conditions`. ## New default for `IncompressibleModel`. Second, functions that are passed directly to `IncompressibleModel` are assumed to have the ""continuous form"" signature. ```julia; func(x, y, z, t); ```. ## New user-facing function: `Forcing`. Third, forcing functions that deviate from this default behavior should be constructed with the function `Forcing`. Thus `SimpleForcing` is eliminated, as well as `ParameterizedForcing`. Moreover, simple-forcing-like functions can now depend on arbitrary fields interpolated to the location at which the forcing is applied. We thus support constructs like. ```julia; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P); ```. provided that `:P` is in `model.tracers`. ### Docstring for `Forcing`. ```julia; """"""; Forcing(func; parameters=nothing, field_dependencies=(), discrete_form=false). Returns a forcing function added to the tendency of an Oceananigans model field. If `discrete_form=false` (the default), and neither `parameters` nor `field_dependencies`; are provided, then `func` must be callable with the signature. `func(x, y, z, t)`. where `x, y, z` are the east-west, north-south, and vertical spatial coordinates, and `t` is time.; Note that this form is also default in the constructor for `IncompressibleModel` and `Forcing` is; not needed for forcing functions of this form. If `discrete_form=false` (the default), and `field_dependencies` are provided,; the signature of `func` must include them. For example, if `field_dependencies=(:u, :S)`; (and `parameters` are _not_ provided), then `func` must be callable with the sign",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:757,Parameteriz,ParameterizedForcing,757,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,1,['Parameteriz'],['ParameterizedForcing']
Modifiability,"This PR provides a substantial rewrite to the user API for ""scheduling"" output and diagnostics. Previously, output was scheduled by specifying one of two keyword arguments when constructing the `AbstractOutputWriter`: `time_interval`, and `iteration_interval`. An example from the documentation is. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filename=""output_fields.nc"", time_interval=60). # output; NetCDFOutputWriter (time_interval=60): output_fields.nc; ├── dimensions: zC(16), zF(17), xC(16), yF(16), xF(16), yC(16), time(0); └── 2 outputs: [""T"", ""u""]; ```. Time-averaging was specified by providing one or two additional keyword arguments: `time_average_interval` and (optionally) `time_average_stride`. This PR eliminates these keyword arguments in favor of a single argument `schedule`. In general, the `schedule` is an object which returns `true` (when output should be written, or a diagnostic calculated) and `false` (otherwise). This PR implements four `AbstractSchedule`s, and more are possible:. * `TimeInterval`: periodic schedule that reoccurs on a interval of model time.; * `IterationInterval`: periodic schedule that reoccurs on an iteration of model iterations; * `WallClockInterval` periodic schedule that reoccurs on an interval of ""wall time"", as kept by the clock on your wall; * `AveragedTimeInterval`: periodic schedule that reoccurs on an interval of model time, and specifies time-averaging of output over a `window` (and a default `window` equal to `interval` is now provided for friendliness). The old syntax thus becomes. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=TimeInterval(60)); ```. and averaging is specified (with a time window of 20 seconds) by writing. ```julia; simulation.output_writers[:field_writer] =; NetCDFOutputWriter(model, fields, filepath=""fields.nc"", schedule=AveragedTimeInterval(60, window=20)); ```. This PR starts updating t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1070:31,rewrite,rewrite,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1070,1,['rewrite'],['rewrite']
Modifiability,"This PR readies `PartialCellBottom` for prime time. Mostly we reorganize code; the substantial changes are:. * Use `Field{Center, Center, Nothing}` for bottom_height. This is convenient mostly for `show` / `summary` but may also prove helpful for users.; * Extend implicit vertical diffusion functionality for partial cells. I'm not sure we did this right... Closes #3064",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3060:257,Extend,Extend,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3060,1,['Extend'],['Extend']
Modifiability,This PR refactors `diagnostics.jl` and `output_writers.jl` into their own submodules. We might want to discuss #497 as we refactor things into submodules as it increases the number of cross-module import statements. Helps with #456 and #495,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/498:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/498,2,['refactor'],"['refactor', 'refactors']"
Modifiability,"This PR refactors and improves the documentation. Some of the things done in this PR:; 1. Split long pages in section. This was done to the physics section and the model setup section.; 2. Switch from PyPlot.jl to Plots.jl for plotting in examples. Each example now comes with an mp4 animation of the output. I believe this greatly improves the examples as users will have a better idea of what each example does. Surprisingly, the plotting code has been simplified. This will also allow us to run the example tests again (currently 5 or 6 broken tests).; 3. Updated performance benchmarks. CPU and GPU used (among other info from `versioninfo()`) is included to provide context for each benchmark.; 4. Added a page in the documentation called ""Using GPUs"" which gives some instructions on how to how to start using GPUs with Oceananigans (and Julia), how to tell if you have a compatible GPU, and some resources on where to get GPUs.; 5. Fixed the public API documentation to include more docstrings and include some docstrings that were left out when we moved certain bits into submodules.; 6. Numerous small fixes and improvements. Things left to do:; 1. Fix `@example` blocks in model setup docs.; 2. Add references.; 3. Generate documentation for private API as well. Resolves #466; Resolves #482; Resolves #483; Resolves #536",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/570:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/570,1,['refactor'],['refactors']
Modifiability,"This PR refactors each of `grids.jl`, `poisson_solvers.jl`, `diagnostics.jl` and `output_writers.jl` into their own submodules. Moving stuff into modules is a pretty disruptive change that introduces tough merge conflicts into other PRs so I also created a Grids and a Solvers submodule in preparation for the vertically stretched grid as I didn't want to include them with vertically stretched PRs that could sit open for days. The whole code still feels a bit messy to me but I think working on #497 will help a lot. Helps with #456 and #495",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/512:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/512,1,['refactor'],['refactors']
Modifiability,"This PR refactors many of the existing abstractions so that they can be passed to GPU kernels #59. It massively cleans up the operators and time-stepping loop, allowing us to keep using beautiful abstractions even in GPU kernels. Note that after this PR is merged, `CUDAnative#master` and `GPUifyLoops#vc/interactive` will be required until the respective fixes are merged into an updated release. I will update the `Project.toml` when we can move to a new release. Once this is merged I will also release v0.5.0. When completed and merged this PR will:; Resolve #19; Resolve #59; Resolve #60; Resolve #66; Resolve #74 ; Resolve #133 ; Resolve #153",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/147:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/147,1,['refactor'],['refactors']
Modifiability,"This PR refactors the FieldBoundaryConditions constructor to allow a consistent user API for specifying field locations. Field locations are specified with _uninstantiated_ types: in other words, a location is . ```julia; (Face, Cell, Cell); ```. rather than. ```julia; (Face(), Cell(), Cell()); ```. The latter form was deemed too much `()`. This is open to debate of course. I am slightly worried the former form is non-Julian. But it seems fairly unequivocal that it's easier to read. I also took the opportunity to clean up field constructors a bit. We now have the concept of _default_ boundary conditions; mostly, this is useful when a user wants to build a field that will never call `fill_halo_regions` and therefore its boundary conditions are irrelevant. I changed the `two_dimensionsional_turbulence.jl` example to use this default. The constructor shenanigans aren't perfect, and there is still a constructor that actually does accept instantiated locations (despite that we officially discourage it, and instantiated field locations are not supported for boundary conditions or abstract operations). It seems the checkpointer needs this special constructor. Resolves #659 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/698:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698,1,['refactor'],['refactors']
Modifiability,"This PR refactors the Poisson solvers so that:. 1. All our solvers (FFT-based, mixed FFT / tridiagonal, tridiagonal, and preconditioned conjugate gradient) have a consistent interface that's reminiscent of linear algebra solvers, eg we use the syntax. ```julia; solve!(x, solver, b); ```. which solves `A*x = b` for `x`, where `A` is described by `solver`. This resembles the syntax `ldiv!(x, A, b)` implemented by `LinearAlgebra.jl`. One exception is the mixed FFT / tridiagonal solver, which also permits `solve!(x, solver)` as an optimization. This extension is used because the ""source term"" is represented differently (eg in a way that depends on the vertical grid spacing) than the other Poisson solvers. The mixed solver also accepts `solve!(x, solver, b)` like the others; this will launch an extra kernel to copy and scale `b` appropriately. 2. The FFT-based solver supports the ""screened"" Poisson equation. ```; (∇² + m) ϕ = b; ```. via `solve!(x, solver, b, m)`, where `m` is a _constant_. This will allow us to solve the elliptic equation posed by an implicit time discretization of the free surface evolution equation. Todo:. - [x] Implement an FFT-based solver for the implicit free surface; - [x] Test demonstrating that the preconditioned conjugate gradient solver and FFT-based solver get the same answer.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1869:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1869,1,['refactor'],['refactors']
Modifiability,"This PR refactors the `NetCDFOutputWriter` constructor by getting rid of the `write_grid_and_attributes` function and by changing the boolean `clobber` keyword argument to `mode`, which is passed to NCDatasets.jl and takes on the values `""c""` for create/clobber or `""a""` for append. Passing `mode=""a""` allows you to append to an existing NetCDF file. I added some tests for this. This is important if we want to keep using the same NetCDF file after restoring from a checkpoint. cc @suyashbire1 . Resolves #913",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/915:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/915,1,['refactor'],['refactors']
Modifiability,"This PR refactors the `NetCDFOutputWriter` to use `FieldSlicer` (which cleans it up a bit) and adds support for time-averaging for NetCDF. All the existing NetCDF tests pass (of which there are quite a few). I also added a test for strided windowed time averaging of horizontal averages for `NetCDFOutputWriter`. Oceananigans solves `∂c/∂t = - λ(x, y, z) c` where `λ(x, y, z) = x + (1 - y)^2 + tanh(z)` which is independent exoponential decay at every grid point so you can analytically compute what the output of the horizontal average and the strided windowed time average should be. Thankfully the test passes :tada:. I also reorganized `test_output_writers.jl` quite a bit. I think it's big enough that it should be split up into multiple files but I'll leave this for a future PR since it would make reviewing this PR's diff difficult. Would be nice if NetCDF accepted a named tuple for `outputs` and had a less clunky interface than just dicts for everything. Might have to wait for a future PR though... X-Ref: https://github.com/Alexander-Barth/NCDatasets.jl/issues/105. Resolves #876",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1040:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1040,1,['refactor'],['refactors']
Modifiability,"This PR refactors the `PreconditionedConjugateGradientSolver` and `ImplicitFreeSurface` and their tests. It adds one new test that ensures a single time-step of the `HydrostaticFreeSurfaceModel` can be made with `free_surface = ImplicitFreeSurface()`. In the new interface the maximum iterations and tolerance of the conjugate gradient solver used for the implicit free surface step are adjusted via kwargs to `ImplicitFreeSurface`. For example:. ```julia; free_surface = ImplicitFreeSurface(tolerance = 1e-7, maximum_iterations = Nx * Ny); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1575:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1575,1,['refactor'],['refactors']
Modifiability,"This PR refactors the boundary conditions container to reflect the fact that there are three boundary conditions: a tuple of `FieldBoundaryConditions` for the `solution`, a tuple of `FieldBoundaryConditions` for the `tendencies`, and a single `FieldBoundaryConditions` for the `pressures` (which is also used to set boundary conditions on `diffusivities`. To reflect these facts, this model creates a new tuple called `SolutionBoundaryConditions` to hold the boundary conditions for solution. `ModelBoundaryConditions` then becomes a named tuple with fields `solution`, `tendency`, and `pressure`. The model constructor may be passed either a `SolutionBoundaryConditions` (preserving existing behavior), or a `ModelBoundaryConditions` (convenient for checkpointing). Ditto for `PoissonBCs` --- though technically we don't need `PoissonBCs` anymore; we simply need to dispatch on the type of `model.boundary_conditions.pressure` (work for the future). Previously, a new instance of boundary conditions for pressure was created every time-step. This PR avoids that unnecessary cost / allocation. It also moves boundary conditions out of `timestepper`, slightly changing the time stepper struct. @ali-ramadhan, the tests pass so I think the checkpointer works, but it'd be worth thinking about whether its doing the right thing now.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/405:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/405,1,['refactor'],['refactors']
Modifiability,"This PR refactors the calculation of `isopycnal_rotation_components` to _actually_ use the ""Cox stencil"" described by [Griffies et al 1998](https://journals.ametsoc.org/view/journals/phoc/28/5/1520-0485_1998_028_0805_idiazc_2.0.co_2.xml). ~~It looks to me like MITgcm uses this so-called anti-Cox stencil.~~ It looks like MITgcm uses the Cox stencil. For example, when calculating the ""Gradient of Sigma at rVel points"" --- which appears in `isopycnal_rotation_tensor_xz_ccf` --- MITgcm uses. https://github.com/MITgcm/MITgcm/blob/9bcb4977016b9cc234328aa357b105d227417e43/pkg/gmredi/gmredi_calc_tensor.F#L712. which reconstructs the x-component of the density gradient by _averaging the gradient_ (with a four point average). On the other hand, we use. https://github.com/CliMA/Oceananigans.jl/blob/001ec56debf0447103d9b75c81de4036a8d6a94a/src/TurbulenceClosures/isopycnal_rotation_tensor_components.jl#L68. which instead computes the _gradient of the average_ (first by averaging with 4 points, then calculating the gradient of that). ~~But Griffies 1998 describers the Cox87 discretization as~~ EDIT: we were confused by Griffies' notation. NOW, this PR changes all the buoyancy gradient calculations so they are similar to MITgcm (average of the gradient) --- the ""actually-Cox stencil"". We'll see what that does.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2481:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2481,1,['refactor'],['refactors']
Modifiability,"This PR refactors the grid implementation so that the coordinate arrays `xC`, `yC`, `zC`, `xF`, `yF`, and `zF` have nodal points within the halo regions of fields and are reshape to match their respective dimension. In other words, we now have `size(c, 2) == length(yC)` and `size(u, 1) == length(xF)`, for example, and `xC * yC * zC` produces an object of `size(c)`. There are three new methods `xnodes(loc, grid::AbstractGrid)`, `ynodes(loc, grid::AbstractGrid)`, `znodes(loc, grid::AbstractGrid)`. For example, `xnodes(Cell, grid)` extracts a view over the interior nodes `grid.xC`, while `xnodes(Face, grid) extracts a view over the physical points of `grid.xF`, which include both boundaries for `Bounded` directions. In addition, the `RegularCartesianGrid` keyword `length` is changed to `extent`, and the `VerticallyStretchedCartesianGrid` no longer accepts a keyword `length`, or a keyword `z`.; Note that the `VerticallyStretchedCartesianGrid` implementation is incomplete and untested. This PR should enable saving the halos of fields in NetCDF data if desired, which is needed for reconstructing field gradients and interpolating fields in post-processing. ~~However, it seems the output writer is currently broken and tests are failing. Thus this PR is WIP.~~",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/715:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/715,1,['refactor'],['refactors']
Modifiability,"This PR refactors the implementation of the Field abstraction. There is now only one type of `Field`, with the type signature . ```julia; Field{Lx, Ly, Lz, A, G}; ```. where `Lx, Ly, Lz` denote the 'locations' of the field within a cell. For example, a `CellField` is now defined via. ```julia; const CellField = Field{Cell, Cell, Cell}; ```. Let's consider this PR carefully and ensure that it makes sense. Resolves #298.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/409:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/409,1,['refactor'],['refactors']
Modifiability,This PR refactors the kernels for turbulence closures to pave the way for new closures that require knowledge of buoyancy and buoyancy gradients. It also performs some minor cleanup in `closure_operators.jl` and moves the turbulence closure implementations into a separate folder so that it is clear from the source structure which turbulence closures are implemented.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/515:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/515,1,['refactor'],['refactors']
Modifiability,"This PR refactors the names we export publically. I think that many names have been added that are poorly motivated --- for example, MultiRegionGrid and cubed sphere grid are _very_ experimental yet still exported. This PR mostly removes exports. Most of the removals are motivated by one of two reasons: (i) the feature is experimental or (ii) the feature is not commonly used. For (i) we would like to avoid export because as an experimental feature we would like to fix bugs or change the API without incurring an ""officially breaking change"". For (ii), the purpose is merely to avoid over-polluting the namespace. For example, `XPartition` for `MultiRegionGrid` is very easily confused with `Partition` for `DistributedComputations` (the API here should probably be reconsidered, cc @simone-silvestri). More than once I have lost cluster time because I confused `YPartition(N)` with `Partition(y=N)`. But `YPartition` isn't really useful so there's little benefit to exporting this. Of course these changes are up for debate so I welcome comments. More detail:. * Remove `OceananigansLogger`: rarely used; * Add `PartialCellBottom`: we are using it in an example, indicating that it is ready for use (not necessarily completely bug-free but we would like to bring it into regular / default use now); * Remove `WENOThirdOrder`, `WENOFifthOrder`: the syntax `WENO(order=5)` is preferred (same for `Centered` and `UpwindBiased`); * Remove `location`: this is a low-level function that does not need to be part of the API; * Add `CATKEVerticalDiffusivity`: this is ready for use, a publication is imminent.; * Remove `StateChecker`: not used as far as I know.; * Remove multi-region and cubed sphere functionality: these are experimental.; * Remove `apply_regionally!, construct_regionally, @apply_regionally, MultiRegionObject`: experimental.; * Remove `Time`: too low-level.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3872:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3872,1,['refactor'],['refactors']
Modifiability,"This PR refactors the time-stepping algorithm to use the ""predictor velocities"" abstraction in the fractional step method. This brings the implemented algorithm in line with the algorithm described in the documentation.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/666:8,refactor,refactors,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/666,1,['refactor'],['refactors']
Modifiability,"This PR reintroduces checkpointing. This time the checkpointer saves the bare essentials to a JLD2 file. Checkpointer will not save forcing functions as before (see #141). Need to test GPU checkpointing, checkpointing with LES closures (I assumed `model.diffusivities` does not need to be checkpointed), and checkpointing with fancier boundary conditions. A major issue with this checkpointer is that it can't restore the largest models because it creates a `Model` and then copies the data from the checkpoint file into the model fields. But if the model is using up all memory, then there's no room for reading data from disk to memory. It should feed the data directly through the Model constructor, but this would require refactoring some of the model and field code. This can be addressed in this PR or in a future PR, although it's kind of useless because checkpointing becomes more important the larger the model/simulation... Resolves #324",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/326:726,refactor,refactoring,726,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/326,1,['refactor'],['refactoring']
Modifiability,"This PR removes . * `src/TurbulenceClosures/turbulence_closure_implementations/rozema_anisotropic_minimum_dissipation.jl`; * `src/TurbulenceClosures/turbulence_closure_implementations/blasius_smagorinsky.jl`. from the source. It also does a bit of refactoring, since types like `AbstractSmagorinsky` are no longer needed to organize the Smagorinsky implementations. RIP `AbstractSmagorinsky`. PS @ali-ramadhan you might have some opinions about how I should provide citations in the source code / docstrings, which I am happy to oblige on this PR. Plus any other misc. cleanup. This PR makes progress towards #1381, and. Resolves #1002 (since the other concerns raised in #1002 can be addressed when resolving #1381).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1428:248,refactor,refactoring,248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1428,1,['refactor'],['refactoring']
Modifiability,"This PR removes a bunch of scalar operations introduced by #3575 on the GPU and instead performs operations on CPU and converts to CuArrays afterwards. There are two issues that don't allow us to create the grid natively on the GPU but rather force us to create the grid on CPU and then convert it. 1. The metrics for the `OrthogonalSphericalShellGrid` use scalar operations; see the functions that are called at https://github.com/CliMA/Oceananigans.jl/blob/4c853b94e6c99949134981153250a4e2391bb0f1/src/Grids/orthogonal_spherical_shell_grid.jl#L780-L782. 2. When we create the `ConformalCubedSphreGrid`, to fill the metric and coordinate horizontal halos properly we use the same functionality that we use to fill halos for prognostic variables. To do that, we create Fields with the coordinate and metric values, call `fill_halo_regions!` on these fields, and then copy back the data from the Fields to the metrics. Copying the data from the metrics to the fields and vice-versa requires scalar operations, e.g., see ; https://github.com/CliMA/Oceananigans.jl/blob/7f12be3d82486b8be2923d8675d2e59c84efd722/src/MultiRegion/cubed_sphere_grid.jl#L280-L292. cc @siddharthabishnu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3579:736,variab,variables,736,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3579,1,['variab'],['variables']
Modifiability,"This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains.; No stretched mesh is supported at the moment (that will come in a later PR). The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes ; - the starting configuration is always a _z-free_ configuration.; - the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; - the y-direction is integer divisible by the number of ranks that divide the x-direction; - the z-direction is integer divisible by the number of ranks that divide the y-direction. An additional assumption is that:; - if TY is Bounded, also TZ needs to be Bounded; - if TX is Bounded, also TY needs to be Bounded. All these assumptions can be relaxed in following PRs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279:404,config,configuration,404,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279,2,['config'],['configuration']
Modifiability,"This PR removes the adapting of the immersed map from the immersed boundary grid by shuffling some definitions around and making sure that the active cells map is always passed as an argument instead of being embedded in the grid. This can possibly help with parameter space issues in complex kernels (see [ClimaOcean, Issue#116](https://github.com/CliMA/ClimaOcean.jl/issues/116#issuecomment-2273878888)). . This PR is still a draft because I would like to take the opportunity to add some docstring for the immersed map",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3690:20,adapt,adapting,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3690,1,['adapt'],['adapting']
Modifiability,"This PR removes the definition of `group` and `test_file` from the `dependencies_for_runtests.lj` otherwise these were redefined with every test file. Now, we are able to set their values and they remain constant for the whole test suite. Also, now if the test find that `test_file != :none` then they set `group = :none` so that the test suite exits after the `@testset ""Single file test""`. With the current PR we can run a single file test-suite by providing it as an ENV variable. For example:. ```Julia; $ TEST_FILE=test_coriolis.jl julia --project -e""using Pkg; Pkg.test()""; Testing Oceananigans; Status `/private/tmp/jl_p57glG/Project.toml`; ⌃ [79e6a3ab] Adapt v4.0.2; [6e4b80f9] BenchmarkTools v1.5.0; [052768ef] CUDA v5.2.0; [a2441757] Coverage v1.6.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [124859b0] DataDeps v0.7.13; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [7da242da] Enzyme v0.11.19; [7a1cc6ca] FFTW v1.8.0; [c27321d9] Glob v1.3.1; [40713840] IncompleteLU v0.2.1; [42fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] Ab",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:474,variab,variable,474,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,2,"['Adapt', 'variab']","['Adapt', 'variable']"
Modifiability,"This PR renames `TKEBasedVerticalDiffusivity` as `CATKEVerticalDiffusivity`, and implements the _triple max_ CATKE formulation that involves a ""convective mixing length"", in addition to the grid-proportional mixing length, and stably stratified mixing length. This formulation is described here (missing some context):. ![image](https://user-images.githubusercontent.com/15271942/128558326-5ee9e1dd-9f0e-4c98-91ee-694b4e9d72c4.png). This requires some minor modifications to the `HydrostaticFreeSurfaceModel` time-stepping algorithm and also refactoring of the `calculate_diffusivities!` interface. cc @adelinehillier",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1926:542,refactor,refactoring,542,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1926,1,['refactor'],['refactoring']
Modifiability,"This PR resolves #2052 by consolidating `Field` to encompass:; - `Field`; - `ComputedField`; - `ReducedField`; - `AveragedField`. In addition, it gets rid of `KernelComputedField` since that functionality is now covered by `KernelComputedOperation` + `Field`. `Field` will no longer explicitly keep track of `architecture`, because `architecture` belongs to `grid` now. This PR also change the API for constructing fields:. ```julia; a = Field{Face, Face, Center}(grid) # constructs a field at `(Face, Face, Center)`; b = Field{Nothing, Face, Center}(grid) # constructs a field that is reduced in the x-direction at `(Face, Center)` in `y, z`; c = Field{Center, Center, Center}(grid); csq = Field(c^2) # constructs a ""computed field"" that calculates and stores c^2 via `compute!(c_sq)`; ```. There are also convenience constructors that take a tuple of locations:. ```julia; loc = (Face, Face, Center); a = Field(loc, grid); ```. `AveragedField` functionality is now wrapped into `Field`. Rather than writing `c_sq_avg = AveragedField(c^2, dims=(1, 2))`, we now write. ```julia; c_sq_avg = Field(Average(c^2, dims=(1, 2))); ```. There is also an interface for generic reductions, so another possibility is. ```julia; c_sq_max = Field(Reduction(maximum!, c^2, dims=(1, 2))); compute!(c_sq_max); ```. It was already possible to compute `maximum!` with a `ReducedField` and an `AbstractField`; this interface simply provides a way to compute these things on the fly for diagnostics purposes while running simulations. In summary, this PR is meant to reduce the amount of code we have to maintain, significantly declutter our `Field` implementations, clean up the API, and hopefully make it easier to extend `Field` implementations in the future, especially regarding reductions of operations such as `SummedField`, `SlicedField`, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2121:1697,extend,extend,1697,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121,1,['extend'],['extend']
Modifiability,"This PR rewrites every kernel and kernel launcher to use `KernelAbstractions` rather than `GPUifyLoops`. A key new function is `launch!`:. https://github.com/CliMA/Oceananigans.jl/blob/7bc83752f72508d6147a8d2e940baf69eff762c0/src/Utils/kernel_launching.jl#L58-L69. This function launches a kernel over `layout`. Performance differences are a crucial question. To start, I've written a function `work_layout` to define the workgroup and worksize for each of our layouts:. https://github.com/CliMA/Oceananigans.jl/blob/7bc83752f72508d6147a8d2e940baf69eff762c0/src/Utils/kernel_launching.jl#L41-L54. This function may need to be improved for performance reasons. Hopefully this is the right way to use `KernelAbstractions`... cc @vchuravy, @leios",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/805:8,rewrite,rewrites,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/805,1,['rewrite'],['rewrites']
Modifiability,"This PR rewrites how we do benchmarking so it's easier to analyze, visualize, and compare benchmark results. It's also easier to add new benchmarks. And we have automated multithreading benchmarks (we can approach MPI benchmarking in a similar manner). We used to use TimerOutputs.jl for benchmarking but really it's made more for profiling. This PR; 1. switches to using the `BenchmarkGroup` from BenchmarkTools.jl which makes it easy to compare benchmarks (e.g. check for CPU -> GPU performance and for performance relative to a base case).; 2. Dataframes.jl and PrettyTables.jl are used to visualize benchmarks, which are prettier, and you can output HTML tables that can be easily embedded into documentation.; 3. PkgBenchmark.jl allows use to compare benchmarks between two commits or branches (right now only via `benchmark_regression.jl`) which should make it easy to automate checking for performance regressions between PRs and the master branch. The next big step for benchmarking would be to create a Buildkite benchmarks pipeline that can be triggered via GitHub comments (this would involve looking into https://github.com/buildkite/trigger-pipeline-action). I started embedding HTML tables into the docs but it's going to be hard for users to parse tables full of numbers. Plots and bar graphs might be much more useful here, but this might require a Buildkite pipeline to generate the figures to embed into the documentation. So I'll leave this important step for a different PR. I also want to add a script that generates a better version of the benchmark plots in the README, but this might have to wait for a future PR. It's a little rough around the edges but I think it's polished enough to be considered for merging. Feels like benchmarks share a lot of boilerplate but might try to reduce it in a future PR. Some fun benchmarking facts:; * GPU models using WENO-5 are 250x faster than CPU models using WENO-5!; * TEOS-10 slows down your CPU model by ~30%, but only ~3% for GPU mo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1169:8,rewrite,rewrites,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1169,1,['rewrite'],['rewrites']
Modifiability,"This PR rewrites much of the docs, adds a show function for `Model` and various boundary conditions structures (which fixes very long output in the docs), and updates many of the examples to be docs-friendly. The docs are still very much preliminary even after the updates in this PR. Once this PR is merged, I will open an issue to define a roadmap for getting the docs to the place we need them to be.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/488:8,rewrite,rewrites,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/488,1,['rewrite'],['rewrites']
Modifiability,This PR rewrites the top-level `export` statement for `Oceananigans.jl`. Mainly it omits many names from the `export` statement that we do not intend to be part of the user API. Resolves #364.; Resolves #313.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/399:8,rewrite,rewrites,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/399,1,['rewrite'],['rewrites']
Modifiability,"This PR rewrites the user interface for specifying rotation rates and buoyancy parameters, such as gravitational acceleration, and the relationship between tracers and density via an equation of state. The main purpose of this PR is to move towards a more logical, functionality-driven encapsulation of parameters. . For rotation, this PR defines a new type called `AbstractRotation` whose subtypes are intended to describe parameters related to the background rotation rate of the model. At the moment there is only one such type: `VerticalRotationAxis`, or `FPlane`. In the future we expect to have `BetaPlane` and `TiltedRotationAxis` or `FullCoriolis`. The `AbstractRotation` types are uniquely associated with a function that computes the x, y, and z components of ""f X U"", associated with the background vorticity `f`. For density, equations of state, and buoyancy, a new abstract type `AbstractBuoyancy` is defined. This type is intended to encapsulate both a gravitational acceleration parameter (when applicable), and an equation of state that contains parameters associated with the relationship between tracer values and density. The advantage of this design is that parameters logically associated with certain terms in the equation of motion are now associated with a particular abstract type. This permits an easy extension of the rotational of buoyancy/equation of state models currently contained in the code; for example in the future we hope to support a `TracerBuoyancy` type for the case that buoyancy is itself a tracer and gravitational acceleration is no longer a parameter, and perhaps a `TemperatureBuoyancy` type for the case that only temperature contributes to buoyancy, rather than both temperature and salinity as is currently the case. In addition, our hydrostatic and non-hydrostatic pressure fields now have the same units and can be directly summed to obtain the total pressure. Resolves #191.; Resolves #217.; Resolves #403.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/412:8,rewrite,rewrites,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/412,1,['rewrite'],['rewrites']
Modifiability,"This PR serves as an important step toward integrating the split-explicit free surface with `MultiRegionGrid`. It introduces an optional parameter, `extended_halos`, which allows users to control the behavior of halo filling during each substep. Setting `extended_halos` to `false` maintains the halo size to be the same as the original grid, diverging from the previous default behavior where `extended_halos = true` would automatically extend the halo to cover all split-explicit substeps, significantly enhancing computational performance. Although setting `extended_halos` to `false` may be less efficient for long simulations on high-resolution`MultiRegionGrids` grids, this feature is helpful for debugging purposes. Additionally, this PR addresses and resolves a couple of bugs related to the interaction between `ImmersedBoundaryGrid` and `MultiRegionGrid`. These modifications ensure that `ImmersedBoundaryGrid` now correctly wraps over `MultiRegionGrid`, reversing the prior implementation approach. With @simone-silvestri and @jm-c.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3596:438,extend,extend,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3596,1,['extend'],['extend']
Modifiability,This PR sets out to refactor advection along the lines proposed in #2454; A final form for the new advection scheme is still to be decided though,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2642:20,refactor,refactor,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2642,1,['refactor'],['refactor']
Modifiability,"This PR simplifies the API for specifying boundary conditions that are functions. We build boundary conditions by writing. ```julia; bc = BoundaryCondition(BCType, condition); ```. where `BCType` is the ""type"" of the boundary condition (`Value`, `Gradient`, `Flux`, `NormalFlow`), and `condition` is the boundary condition. If `condition` is a function, it is now assumed it can be called with the signature `condition(ξ, η, t)`, where `(ξ, η)` are spatial coordinates that vary along the boundary in question (`y, z` for `x`-boundaries, `x, z` for `y`-boundaries, and `x, y` for `z`-boundaries). Different behavior is achieved by specifying keyword arguments of `BoundaryCondition`. For example, a non-`nothing` `parameters` keyword argument means that the last argument of condition is `parameters`: `condition(ξ, η, t, parameters)`. If `discrete_form=true`, the original behavior of `BoundaryCondition` is recovered, so that `condition` is called with the ""discrete form"" `condition(i, j, grid, clock, state)`, where `i, j` are indicies that vary along the boundary in question. Specifying both `discrete_form=true` and non-`nothing` `parameters` transforms `condition` into a `ParameterizedDiscreteBoundaryFunction`, which is called with `condition(i, j, grid, clock, state, parameters)`. Under the hood, this functionality is achieved by assuming that boundary conditions for fields are always built with `FieldBoundaryConditions`. This assumptions means we can use the information provided there to ensure that `BoundaryFunction`s are always tagged with the correct boundary plane and cell location. This relieves the user from having to specify the boundary plane and cell location of a `BoundaryFunction` explicitly. We hope this simplifies the API. Resolves #769",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894:1181,Parameteriz,ParameterizedDiscreteBoundaryFunction,1181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894,1,['Parameteriz'],['ParameterizedDiscreteBoundaryFunction']
Modifiability,"This PR simplifies the Docs/Appandix/Library and also adds missing modules in it. . Furthermore, it enhances formatting in several docstrings and converts some examples to doctests. Closes #2080. For example, regarding 2 vs 4 spaces in markdown formatting,. **before this PR**. <img width=""994"" alt=""Screen Shot 2021-11-25 at 4 03 01 pm"" src=""https://user-images.githubusercontent.com/7112768/143382619-b30f8312-fd64-4240-a59a-d8b3d6e50484.png"">. while **after this PR**. <img width=""861"" alt=""Screen Shot 2021-11-25 at 4 02 41 pm"" src=""https://user-images.githubusercontent.com/7112768/143382640-469f9d58-07cc-4a42-97f4-1c6c4bdeb43b.png"">",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2082:100,enhance,enhances,100,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2082,1,['enhance'],['enhances']
Modifiability,"This PR simplifies the function signatures for boundary condition functions and forcing functions. ; It also nukes the `model.parameters` field in favor of more local ""parameters"" functionality, and adds `ParameterizedForcing` and `ParameterizedBoundaryCondition` convenience types and functions. The new forcing function signature is. ```julia; F(i, j, k, grid, clock, state); ```. while the new boundary condition function signature is. ```julia; bc(i, j, grid, clock, state); ```. where `i, j` are indices along the boundary. `state` is a `NamedTuple` with fields `:velocities`, `:tracers`, and `:diffusivities`, each corresponding to an `OffsetArray` that references the data associated with each field. In the future, if we make substantial changes to `model`, the hope is that we can modify/extend `state` appropriately and thus leave user code unbroken. We should probably release a new minor version when this is merged. Resolves #682 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697:205,Parameteriz,ParameterizedForcing,205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697,3,"['Parameteriz', 'extend']","['ParameterizedBoundaryCondition', 'ParameterizedForcing', 'extend']"
Modifiability,"This PR splits the tests into four test groups, selectable with the `TEST_GROUP` environment variable: `unit`, `integration`, `regression`, and `scripts`. Using `TEST_GROUP=all` (the default if `TEST_GROUP` is not defined) will run all tests. The purpose of this PR is to address long test build times (see #860) that time out at 50 minutes on Travis CI and at 60 minutes on GitLab CI by splitting tests into multiple jobs (i.e. building a job matrix) that each should individually run much faster. If the different jobs could be run in parallel this would speed up our test builds significantly, but alas we are stuck with free-tier CI pipelines so we can't run too many jobs in parallel and will probably end up waiting longer. But at least our jobs won't time out. In working on this PR I was also able to revive the Appveyor and Docker CI pipelines (I think Appveyor will only show up for future PRs). Resolves #139",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/872:93,variab,variable,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/872,1,['variab'],['variable']
Modifiability,"This PR tweaks the API to simplify non-uniform partitioning which should already be supported by the algorithm. This PR also extends the tests to include non-uniform distributed partitioning . The proposal of this PR (up to discussion and tweaking) is to allow calling; ```julia; arch = Distributed(CPU(); partition = Partition(Rx = [0.3, 0.1, 0.6]); ```; which allows to distributed the domain over 3 workers which hold 30%, 10% and 60% of the computation, respectively",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3339:125,extend,extends,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3339,1,['extend'],['extends']
Modifiability,"This PR updates CATKE with an improved model for how the presence of shear modulates the mixing length and turbulent mixing. A few preliminary calibration results suggest that these changes are very promising, especially at coarse resolutions. A short summary is that, originally, CATKE was flexible enough to model both convection and shear-driven mixing --- just not at the same time (because TKE levels are much higher for shear-driven mixing). Adding a more explicit model for the modulation of the mixing length in the presence of shear allows CATKE to capture both convection and shear-driven regimes. We can update the default values for CATKE in this PR as well. This figure is a little out of context, but it shows agreement between LES (gray line) and the ""best parameters"" from a calibration run (blue line) at 8m resolution with five physical scenarios (from LESbrary's 4 day suite). The ""other line"" is the ""worst"" parameters in the calibration ensemble (so that one should be ignored). ![image](https://user-images.githubusercontent.com/15271942/155232297-9fa83269-0383-4f9e-a060-757b3632ce9d.png). Closes #2272",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2273:291,flexible,flexible,291,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2273,1,['flexible'],['flexible']
Modifiability,"This PR uses a continuous forcing immersed boundary method to simulate viscous flow around a cylinder. I think this is a pretty common test case of CFD codes: as you increase the Reynolds number, you should start to see vortex shedding behind the cylinder which we do see. Movie: https://www.youtube.com/watch?v=s7u_OJXFMoQ; ![image](https://user-images.githubusercontent.com/20099589/76267706-05081200-6242-11ea-8567-41068235616e.png). I think it shows the ease with which Oceananigans can support topography and arbitrary boundaries that could even depend on time: e.g. static cavities in ice shelves, an urban skyline, or a moving lid (non-interacting ice floe?). This method is much simpler to implement than sigma coordinates, is more flexible, and is probably pretty accurate for most problems you'd try to model with Oceananigans (i.e. we're not modeling coastlines on a sphere). Should discuss what an API for topography/boundaries would look like before finishing this PR off. See #694. X-Ref #530",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/693:740,flexible,flexible,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/693,1,['flexible'],['flexible']
Modifiability,"This PR uses https://github.com/CliMA/CubedSphere.jl to add grids and fields for the conformal cubed sphere (both a grid for representing one face and for the full cubed sphere). I tried to keep it flexible so that we can do things on only one face, a portion of a face, multiple faces, and can rotate the faces any way in case we want to put the corners on land, etc. This PR is still a work-in-progress. Need to add a `fill_halo_regions!` function and add more tests! Also need to figure out how to compute grid spacings and areas... Originally I wasn't sure how to organize everything so I'm doing everything in a `sandbox` for now. Might also be cool to maybe produce some visualizations for the docs. ![image](https://user-images.githubusercontent.com/20099589/109649608-284e6000-7b2a-11eb-9c67-0ca5bf0d26e5.png). Looking kinda cramped at those corners. ![image](https://user-images.githubusercontent.com/20099589/109650065-b6c2e180-7b2a-11eb-8aa9-f5c8064858ed.png). Unfortunately I had plotting issues with GeoMakie.jl (e.g. https://github.com/JuliaPlots/GeoMakie.jl/issues/55) which is not being maintained right now, so I went back to using matplotlib + cartopy for plotting on maps with projections. ![cubed_sphere_points](https://user-images.githubusercontent.com/20099589/109649281-afe79f00-7b29-11eb-87bf-aa3fe3192cca.png). ![cubed_sphere_staggered_grid](https://user-images.githubusercontent.com/20099589/109649284-b118cc00-7b29-11eb-955f-49ce81cfa3a8.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1417:198,flexible,flexible,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1417,2,"['flexible', 'sandbox']","['flexible', 'sandbox']"
Modifiability,"This PR was created yesterday to start a discussion about how we might want to change the input arguments for `VerticallyStetchedRectilinearGrid`. After some disucssion there is no concensus that a chance should be made so I'm going to close this PR. . I think it's better that users get to play with stretched grids in any or all dimensions sooner rather than later. Hence, I'm going to return to #1532 and change the arguments to be inline with what `VerticallyStretchedRectilinearGrid`. . One change that I would like to make is instead of having `zF` as input, I would prefer to have `zFs` or even `zFaces`, to emphasize that all the faces are specified. Usually, when I see `zF` I think of a face, and that's not the case here. @tomchor , what do you think about this?. When users have played with grid stretching we will be better able to asses from experience what is good for the user, and we will be able to adapt to that in the future.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518:917,adapt,adapt,917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1544#issuecomment-814054518,1,['adapt'],['adapt']
Modifiability,"This PR will rename some variables and funcitons in the `TurbulenceClosures` module to make things more clear. ~It will also remove the fallback dispatch of `calc_ κᶜᶜᶜ()` and define `calc_ κᶜᶜᶜ()` at least for the Smagorisnky-Lilly closure.~. It also changes the behavior of `viscosity()` to return a tuple when given a tuple, instead of `sum`ming all the viscosities in the tuple. This avoids misuse by unattentive users who have a tuple with different-formulation-viscosities (for example horizontal and vertical formulations). ([This comment](https://github.com/CliMA/Oceananigans.jl/pull/2752#issuecomment-1270199938) provides an example.). Closes https://github.com/CliMA/Oceananigans.jl/issues/2751. CC @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2752:25,variab,variables,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2752,1,['variab'],['variables']
Modifiability,"This PR writes new `Adapt.adapt_structure` methods for `Field`, `AveragedField`, and `ComputedField`:. * `Field` and `ComputedField` are adapted to their data (thus shedding location information, the grid, and boundary conditions). This is fine because we don't reference location information or boundary conditions _inside_ GPU kernels. * `AveragedField` sheds `operand` and `grid` when adapted to the GPU. `AveragedField` still needs location information for `getindex` to work correctly. This obviates the need for `datatuple` (we still keep the function around however because its useful for tests). It also obviates the need for `gpufriendly`. ~~We can now use `AveragedField` and `ComputedField` inside kernels.~~ This still doesn't work. We need to open an issue once this PR is merged. This PR supersedes #746 . Finally, we can dramatically simplify the time-stepping routine since we don't need to ""unwrap"" fields anymore. It's probably worthwhile running a benchmark before merging but hopefully there's no issue. Resolves #722 .",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1057:20,Adapt,Adapt,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1057,3,"['Adapt', 'adapt']","['Adapt', 'adapted']"
Modifiability,"This WIP PR implements a `TKEBasedVerticalDiffusivity` that intends to describe mixing in the ocean surface boundary layer and interior with an eddy diffusivity that depends on a prognostic subgrid turbulent kinetic energy variable. This scheme may eventually also contain ""convective adjustment"" as a submodel, in which case it will have the short hand ""CATKE"" which stands for ""Convective adjustment and turbulent kinetic energy parameterization"". The scheme without convective adjustment is briefly described in [a poster presented at Ocean Sciences 2020](https://glwagner.github.io/assets/figures/ocean_sciences_2020_poster.png), with a few minor differences in the details.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1664:223,variab,variable,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1664,2,"['parameteriz', 'variab']","['parameterization', 'variable']"
Modifiability,"This draft PR introduces a few enhancements to `RiBasedVerticalDiffusivity`. `RiBasedVerticalDiffusivity` imposes viscosities and diffusivities of the form. ```; ν₀ * tapering(Ri, Ri_c, Ri_d); ```. where `Ri_c` is a ""critical"" Richardson number where tapering starts and `Ri_d` is the width of the tapering function. We have piecewise-linear tapering. ```julia; piecewise_linear_tapering = 1 - min(1, max(0, (Ri - Ri_c) / Ri_d)); ```. This PR introduces an exponential tapering. ```julia; exponential_tapering = exp(- max(0, (Ri - Ri_c) / Ri_d)); ```. and hyperbolic tangent tapering. ```julia; hyperbolic_tangent_tapering = (1 - tanh((x - x₀) / δ)) / 2; ```. (which I haven't tested yet). I calibrated the piecewise linear case and exponential case using https://github.com/glwagner/LocalOceanClosureCalibration. ; Neither is perfect but the exponential results look a bit better, so I'm making them default. Here's some results from an EKI calibration algorithm, calibrating the closure to the [""LESbrary 1.0""]:. ![multi_case_model_observation_comparison_iteration_220](https://user-images.githubusercontent.com/15271942/162448303-7dfa75eb-f1bf-4fdb-8d7f-e34c4b288d31.png). apologies for no plot labels... every row is a different LES ""truth"" case ranging from convection to pure shear with no rotation. The parameters are. ```; latest_summary = IterationSummary for 4000 particles and 6 parameters at iteration 220; ν₀ | κ₀ | Ri₀ν | Ri₀κ | Riᵟν | Riᵟκ |; ensemble_mean: 8.760e-01 | 2.089e-01 | -1.241e+00 | -3.919e-01 | 5.919e-01 | 6.570e-01 |; best particle: 9.243e-01 | 1.779e-01 | -1.342e+00 | -1.252e-01 | 6.104e-01 | 5.959e-01 | error = 3.728775e-01; worst particle: 9.677e-01 | 2.479e-01 | -2.920e+00 | -1.969e-01 | 6.291e-01 | 4.083e-01 | error = 9.724616e-01; minimum: 2.634e-02 | 3.839e-02 | -3.590e+00 | -2.641e+00 | 1.856e-02 | 7.557e-02 |; maximum: 9.973e-01 | 9.938e-01 | 2.362e+00 | 1.775e+00 | 8.018e+00 | 2.498e+00 |; ensemble_variance: 4.043e-03 | 2.982e-03 | 1.173e-01 | 1.078e-01",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2423:31,enhance,enhancements,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2423,1,['enhance'],['enhancements']
Modifiability,"This feature adds support for using a checkpoint file to initialize a model that contains additional passive tracers that weren't present in the original simulation. The use case in mind is whenever a user wants to start passive tracers only after simulation spin-up, for example. At the moment, on main, this isn't possible since if we try to pickup a simulation but a given variable can't be found in the checkpointer file, the code throws a warning when trying to set the data for that variable, and an error when trying to set its tendencies. This PR changes the code so that it throws an error for both cases. After this PR a user can then do:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (4, 4, 4), extent = (1,1,1)). model_spinup = NonhydrostaticModel(; grid, tracers = :b); set!(model_spinup, b=1). simulation = Simulation(model_spinup, Δt = 1, stop_time = 10); simulation.output_writers[:checkpointer] = checkpointer = Checkpointer(model_spinup,; schedule=TimeInterval(5),; prefix=""checkpoint""). run!(simulation). using Oceananigans.OutputWriters: write_output!; write_output!(checkpointer, model_spinup). model = NonhydrostaticModel(; grid,; tracers = (keys(model_spinup.tracers)..., :t1, :t2)). @info ""Restarting model with more tracers""; checkpoint_file_path = Oceananigans.OutputWriters.checkpoint_path(true, simulation.output_writers); set!(model, checkpoint_file_path). simulation = Simulation(model, Δt = 1, stop_time = 20). run!(simulation); ```. On main this throws a `KeyError`. On this branch this produces:. ```julia; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (1.614 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (20.304 seconds).; [ Info: Simulation is stopping after running for 22.039 seconds.; [ Info: Simulation time 10 seconds equals or exceeds stop time 10 seconds.; [ Info: Restarting model with more tracers; ┌ Warning: Could not restore t1 from checkpoint.; └ @ Oceanani",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2938:376,variab,variable,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2938,2,['variab'],['variable']
Modifiability,This is a wilderness of the code with not many tests. This is part of ongoing work to build infrastructure for calibrating mesoscale parameterizations in conjunction with `OceanTurbulenceParameterEstimation.jl`. cc @sandreza,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2215:133,parameteriz,parameterizations,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2215,1,['parameteriz'],['parameterizations']
Modifiability,This is an amazing refactor.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2214#issuecomment-1029976527:19,refactor,refactor,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2214#issuecomment-1029976527,1,['refactor'],['refactor']
Modifiability,"This is for explicit free surface, I ll extend the benchmarks for implicit and weak scaling",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116689634:40,extend,extend,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116689634,1,['extend'],['extend']
Modifiability,This is great to see!. I imagine we could use this for the height field in `ShallowWaterModel` to allow for wetting and drying for a single layer. And also to prevent layer collapse in the case of multiple layers.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128280245:206,layers,layers,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2557#issuecomment-1128280245,1,['layers'],['layers']
Modifiability,"This is probably fine as I don't think the MITgcm uses adaptive time stepping and for what we do I doubt we'll be changing Δt halfway through a simulation, but as it stands if Δt changes it will break some code, `read_output(...)` methods in particular.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/37:55,adapt,adaptive,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/37,1,['adapt'],['adaptive']
Modifiability,"This is related to the discussion in https://github.com/CliMA/Oceananigans.jl/pull/2262. Instead of defining structs specifically to symbolize directions (`Vertical`, `ThreeDimensional`, `Horizontal`) to use with `ScalarDiffusivity`, is it possible/worth it to use arrays, similar to what `Average()` does?. In this way, instead of specifying a `ConstantDiffusivity` as . ```julia; horizontal_closure = ScalarDiffusivity(ν=1e-3, κ=2e-3, isotropy=Horizontal()); ```. a user would write. ```julia; horizontal_closure = ScalarDiffusivity(ν=1e-3, κ=2e-3, isotropy=(1,2)); ```. Seems to me like this would be more general and it would also decrease the amount of code used, but I'm not very familiar with that part of the code (especially since the recent refactor) so can't be sure. I thought it was worth posting about this though. @glwagner @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2265:751,refactor,refactor,751,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2265,1,['refactor'],['refactor']
Modifiability,"This is the first draft of the updated benchmark docs. There are still many things to add in such as the weak and strong scaling benchmarks, but as of now it would be greatly appreciated if I can get some feedback on suggestions on the formatting and descriptions. A few questions and notes:; 1. I do not know what the static ocean benchmark results are. There is no longer a script for it in the benchmarks folder since all the results are quite old. I feel like I should replace it with the nonhydrostatic model benchmarks if that is what makes sense.; 2. I do not know what the channel benchmark results are either. Either the script was removed, or the form of it that produced these old results have been lost under a lot of renames and refactors. ; 3. The tracers and turbulence closures benchmarks still have corresponding scripts in the benchmarks folder. They were simply replaced with newer results. The newer results also includes CPU to GPU speedup analysis, unlike the old results.; 4. The shallow water model benchmark results are the best looking ones with maximum 400 times speedup using WENO5. Graphs are also included with a quick one sentence analysis.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1930:742,refactor,refactors,742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1930,1,['refactor'],['refactors']
Modifiability,This is the latest attempt to preserve locations when adapting `Field` to the GPU.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1906:54,adapt,adapting,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1906,1,['adapt'],['adapting']
Modifiability,"This issue describes an overhaul / refactoring of the ""Model setup"" part of the documentation. We've noticed that while our examples and docstrings seem to be useful, the ""model setup"" is less so, and also leaves out a lot of information necessary for running more complex simulations. ## What we have now. The basic idea is to flatten the current structure a bit. Right now it reads:. ```; - Home; - Quick start; - Examples > ; - Physics > ; - Numerical implementation > ; - Model setup > ; - <etc>; ```. ## What we propose. We propose to create top-level sections for important concepts such as `Grids`, `Fields`, `Simulations` etc. Then less important details would be subsumed into the `Models` section (which would overlap strongly with the current `Model setup` section). Here's an outline:. ```; - Home; - Quick start; - Examples >; - Grids, architectures, and number types; - Fields and operations; - Models; - Setting initial conditions; - Tracers; - Advection schemes; - Turbulence closures; - Buoyancy models and equations of state; - Rotation and Coriolis forces; - Turbulence closures; - Forcing functions; - Background fields; - Lagrangian particles; - Clocks; - Simulations; - Callbacks; - Output writers; - Checkpointing and picking up from a checkpoint; - Physics > ; - Numerical implementation > ; - <etc>; ```. The ordering of subjects is carefully chosen here, so please comment on that if you think it should be changed. To do this incrementally, I will open a PR that adds the `Grids` and `Fields` sections. Then we can build the `Models` section incrementally by porting material from `Model setup`. While we are working I will add the qualifer `Model setup (legacy)`. Related issues:. * https://github.com/CliMA/Oceananigans.jl/issues/3594; * https://github.com/CliMA/Oceananigans.jl/issues/3166; * https://github.com/CliMA/Oceananigans.jl/issues/2448; * https://github.com/CliMA/Oceananigans.jl/issues/2308; * https://github.com/CliMA/Oceananigans.jl/issues/1879; * https://gi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3672:35,refactor,refactoring,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3672,1,['refactor'],['refactoring']
Modifiability,"This kind of feature can't be implemented directly in `Forcing`, because all explicit tendency terms are evaluated in the same kernel. So we have to evaluate `forcing` in every cell that requires a tendency. It is possible to expose a feature that allows kernels to be launched over some subset of cells. Then users could implement this kind of optimization in their script by using an array to represent the forcing, and then by precomputing the forcing into that array using a kernel that only evaluates some subset of all the cells in a callback. Or something like that. If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830:750,layers,layers,750,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2028469830,2,['layers'],['layers']
Modifiability,"This major PR changes the way difference operators work so that across boundaries (either the end of the domain in `Bounded` directions, or across immersed boundaries), differences always return 0 and interpolation always returns the value on the ""active"" or ""wet"" side of the domain. This change means the halos do not need to be filled for `Value / Gradient` boundary conditions. Instead, value and gradient boundary conditions will be enforced across `Bounded` the same way they are enforced across immersed boundaries. Moreover these boundary conditions will only be supported for `AbstractScalarDiffusivity`. This leads to considerable code reduction, because it unifies the algorithms for non-immersed and immersed boundaries. This may decrease compile times. In addition, the reduction in halo filling will hopefully lead to further performance increases, as we have found that halo filling is inefficient especially on the GPU and should be avoided when possible. Finally, avoiding halo filling is important for distributed models, since it eliminates the dependency that halos must be filled across `Bounded` before they are sent between processes across a `Communication` topology. Evaluating performance changes will be an important part of this PR. There's still a bit todo:. - [x] Refactor halo filling and `apply_flux_x` to enforce value / gradient boundary conditions; - [x] Implement homogeneous interpolation operators; - [ ] Possibly eliminate halo filling for `OpenBoundaryCondition`, leaving halo filling only for periodic and communication bcs",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477:1294,Refactor,Refactor,1294,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477,1,['Refactor'],['Refactor']
Modifiability,This may help https://github.com/JuliaGPU/Adapt.jl/pull/88,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445748178:42,Adapt,Adapt,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445748178,1,['Adapt'],['Adapt']
Modifiability,"This may require extending `heatmap!` directly, probably using the utilities developed for Imaginocean. Another possibility is to generate heatmaps in ""array coordinates"" rather than making heatmaps in geographic coordinates. cc @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3811:17,extend,extending,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3811,1,['extend'],['extending']
Modifiability,This might be a duplicate of PR #3830 but looks like both will be superseded by PR #3847 which is doing the refactoring necessary for this fix.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3846#issuecomment-2412494690:108,refactor,refactoring,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3846#issuecomment-2412494690,1,['refactor'],['refactoring']
Modifiability,"This pull request changes the compat entry for the `Adapt` package from `3` to `3, 4`.; This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry.; It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3409:52,Adapt,Adapt,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3409,1,['Adapt'],['Adapt']
Modifiability,"This pull request changes the compat entry for the `Adapt` package from `^2` to `^2, 3.0`. This keeps the compat entries for earlier versions. Note: I have not tested your package with this new compat entry. It is your responsibility to make sure that your package tests pass before you merge this pull request.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287:52,Adapt,Adapt,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287,1,['Adapt'],['Adapt']
Modifiability,This release will go alongside the JOSS paper. Release notes:. * Support for multithreaded CPU simulations! Set the number of threads via the `JULIA_NUM_THREADS` environment variable or via the `-t` flag in Julia 1.5+.; * New `OceananigansLogger` for fancy log messages with time stamps.; * New experimental diagnostic `WindowedTimeAverage`.; * `Average` diagnostic can include or exclude halos via the `with_halos` keyword argument.; * Improved testing infrastructure made possible by splitting tests into four groups.; * Cleaned up convergence test scripts and plots. Convergence tests can be run via the `TEST_GROUP=convergence`.; * Numerous bug fixes and documentation updates.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/891:174,variab,variable,174,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/891,1,['variab'],['variable']
Modifiability,"This sounds interesting but I'm not sure if I complete understand. . Can we think of an example of a prognistic field as velocity: `𝐯`, and a diagnostic field as vorticity: ζ?. If yes, I see that you need to fill halos to evolve the velocity and then you need to fill halos when you compute the vorticity. Are you simply saying we allocate the space for the two sets of halos at the same time?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860:222,evolve,evolve,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2509#issuecomment-1116396860,2,['evolve'],['evolve']
Modifiability,"This sounds like a good idea!. I guess it shouldn't be too hard to extend the implementation to support `fx`, `fy`, and `fz` like you're suggesting.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-783478944:67,extend,extend,67,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1372#issuecomment-783478944,1,['extend'],['extend']
Modifiability,"This will further crystallize the distinction between linear distances (x, y, z) and ""native coordinate systems"" (Cartesian for Rectilinear, geographic for LatitudeLongitude). We already have this partially implemented; ie `Δx` returns a linear distance. But the implementation has not extended to xnodes, ynodes, etc. Kind of a side note but it'd be nice to figure out a cleaner / more concise way to implement the `with_halos` feature. It's hard to read the code as it is now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2978#issuecomment-1470714440:286,extend,extended,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2978#issuecomment-1470714440,1,['extend'],['extended']
Modifiability,"This would be a major new feature for Oceananigans!. The implementation would probably resemble what we've done for ""CATKE"", which has a prognostic TKE variable:. https://github.com/CliMA/Oceananigans.jl/tree/main/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities. I would vote to implement Burchard and Umlauf's ""generic length scale"" equation. In this formulation there's a TKE variable (like CATKE), and also a ""length scale"" variable, which can either be epsilon, omega, or Mellor-Yamada's ""q^2 l"". So we get all of those models with one implementation:. https://www.ingentaconnect.com/content/jmr/jmr/2003/00000061/00000002/art00004. The implementation might also want to take into account / support a few other formulations like. * [Harcourt 2015](https://journals.ametsoc.org/view/journals/phoc/45/1/jpo-d-14-0046.1.xml); * [Kantha Clayon 2004](https://www.sciencedirect.com/science/article/abs/pii/S1463500302000628). I think @simone-silvestri could be interested in this kind of thing. It's a major undertaking! I think we should refactor `TurbulenceClosures` to make implementing new models (like this one) easier, either before or at the same time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114:152,variab,variable,152,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2278#issuecomment-1051139114,4,"['refactor', 'variab']","['refactor', 'variable']"
Modifiability,"Those are all possible developments. To put fields in `closure` we have to implement a pattern (implemented for things like boundary conditions, though it's taken a lot of work to get it right) whereby users instantiate a ""template"" `closure`, to which fields / data are added later given knowledge of the grid in the model constructor. Otherwise, users have to provide `grid` as an argument when constructing both a closure and a model. Either pattern is possible --- but implementing a ""template + materialization"" design is complicated, whereas requiring users to provide `grid` when constructing a closure changes the API. When a complicated algorithm endows the code with more features, I feel it could be justified if the feature is good enough. But if its only purpose is to rearrange where array references are bound, it feels less worth the trade off of code maintenance and the work to implement it. Another solution is documentation. Storing constant values in `diffusivities` is possible, but could be interpreted as boilerplate. The coefficients need to be stored in `closure`, because that's where users specify them. So copying the constants or functions into `diffusivities` (this would have to be done individually for all closures) requires additional code. I think of all the changes to `diffusivities`, the one that makes the most sense is to eliminate that field and change the API so that `grid` is a required argument for closures that have fields associated with them. This is a substantial internal refactor, but perhaps someone wants to take it up?. Note: I don't this will work for memory parallel models until #1825 is resolved.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883709160:1524,refactor,refactor,1524,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1878#issuecomment-883709160,1,['refactor'],['refactor']
Modifiability,Time_step refactor and new Model constructor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97:10,refactor,refactor,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97,1,['refactor'],['refactor']
Modifiability,"Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKernels.jl:103; [23] (::KernelAbstractions.Kernel{CUDA.CUDAKernels.CUDABackend, KernelAbstractions.NDIteration.StaticSize{…}, KernelAbstractions.NDIteration.StaticSize{…}, typeof(Oceananigans.BoundaryConditions.gpu__no_fill!)})(::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{…}}, ::Vararg{Any}); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKe",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2453,Adapt,Adapt,2453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Modifiability,"To do:. - [ ] Add docs for `UpwindBiased` reconstruction; - [ ] Refactor `UpwindBiased` to get rid of ""coeffs"" for stretched grids; - [ ] Fix up docs for `WENO`; - [ ] Clean up constructors for advection schemes; - [ ] Throw errors in advection scheme constructors if the grid halo is too small. Resolves #2717",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2972:64,Refactor,Refactor,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2972,1,['Refactor'],['Refactor']
Modifiability,"To reduce the number of operations, the number of memory allocations, and register pressure in GPU kernels, we might want to try refactoring upwind schemes to convert this pattern. ```julia; @inline upwind_biased_product(ũ, ψᴸ, ψᴿ) = ((ũ + abs(ũ)) * ψᴸ + (ũ - abs(ũ)) * ψᴿ) / 2. @inline function momentum_flux_uv(i, j, k, grid, scheme::AbstractUpwindBiasedAdvectionScheme, u, v). ṽ = _symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid, scheme, v); uᴸ = _left_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u); uᴿ = _right_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u). return Ayᵃᵃᶠ(i, j, k, grid) * upwind_biased_product(ṽ, uᴸ, uᴿ); end; ```. to something like. ```julia; @inline function momentum_flux_uv(i, j, k, grid, scheme::AbstractUpwindBiasedAdvectionScheme, u, v); ; ṽ = _symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid, scheme, v); u = ṽ > 0 ? _left_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u) :; _right_biased_interpolate_yᵃᶠᵃ(i, j, k, grid, scheme, u); ; return Ayᵃᵃᶠ(i, j, k, grid) * ṽ * u; end; ```. Could save a lot of operations and register pressure for higher-order schemes. I actually don't see why `((ũ + abs(ũ)) * ψᴸ + (ũ - abs(ũ)) * ψᴿ) / 2` is used instead of if-statements. Maybe @christophernhill or @jm-c know?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/987:129,refactor,refactoring,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/987,1,['refactor'],['refactoring']
Modifiability,True portable RNG for deep convection golden master test,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/219:5,portab,portable,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/219,1,['portab'],['portable']
Modifiability,"Try. ```julia; const width = 100kilometers; @inline ν(x, y, z, t) = ifelse(abs(y - Ny*kilometers/2) < Ny*kilometers/2 - width, 1, 10) # sponge layers; ```. The `const` is necessary here for GPU and will also improve performance on CPU. The reason is that we need to assure the compiler that the type of `width` will not change for GPU compilation to be possible. If that fails you may also need to change `kilometers` to `1e3`, or to define another `const`. However, I think that `kilometers` should already b `const` so this may not be necessary.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068643259:143,layers,layers,143,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359#issuecomment-1068643259,1,['layers'],['layers']
Modifiability,Trying to think of a way to avoid adding another name... we can extend `on_architecture` to have different behavior when `grid::String` (and thus a path to file). But `on_architecture` isn't specific to `grid` so that doesn't really make sense.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420:64,extend,extend,64,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2179#issuecomment-1025777420,1,['extend'],['extend']
Modifiability,Turbulence closure kernel refactor,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/515:26,refactor,refactor,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/515,1,['refactor'],['refactor']
Modifiability,"UG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; [ Info: Oceananigans will use 8 threads; MPIPreferences:; binary: MPICH_jll; abi: MPICH. Package versions; MPI.jl: 0.20.19; MPIPreferences.jl: 0.1.10; MPICH_jll: 4.2.0+0. Library information:; libmpi: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; libmpi dlpath: /Users/navid/.julia/artifacts/5c81ad3c4ead80006fae560b5e6f06fa265aefb1/lib/libmpi.12.dylib; MPI version: 4.1.0; Library version: ; MPICH Version: 4.2.0; MPICH Release date: Fri Feb 9 12:29:21 CST 2024; MPICH ABI: 16:0:4; MPICH Device: ch3:nemesis; MPICH configure: --prefix=/workspace/destdir --build=x86_64-linux-musl --host=aarch64-apple-darwin20 --disable-dependency-tracking --docdir=/tmp --enable-fast=all,O3 --enable-static=no --mandir=/tmp --with-device=ch3 --with-hwloc=/workspace/destdir FFLAGS=-fallow-argument-mismatch FCFLAGS=-fallow-argument-mismatch; MPICH CC: cc -fno-common -DNDEBUG -DNVALGRIND -O3; MPICH CXX: c++ -DNDEBUG -DNVALGRIND -O3; MPICH F77: gfortran -fallow-argument-mismatch -O3; MPICH FC: gfortran -fallow-argument-mismatch -O3; MPICH features: ; ; WARNING: Method definition test_architectures() in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:14 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition summarize_regression_test(Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:32 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition center_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/OC11.jl/test/utils_for_runtests.jl:53 overwritten on the same line (check for duplicate calls to `include`).; WARNING: Method definition boundary_clustered_coord(Any, Any, Any) in module Main at /Users/navid/Research/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:13402,config,configure,13402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['config'],['configure']
Modifiability,Update packages and one less adapt,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1142:29,adapt,adapt,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1142,1,['adapt'],['adapt']
Modifiability,Updated CUDA.jl to v2.3.0 since it was downgraded in PR #1295 for some reason. Waiting for https://github.com/JuliaGPU/CUDA.jl/pull/626 and tagged release to update to Adapt v3.0.0 as well.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1296:168,Adapt,Adapt,168,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1296,1,['Adapt'],['Adapt']
Modifiability,"Upon thinking about it I think perhaps it makes more sense to run `dynamics` first before `advect_lagrangian_particles!`, one example of which might be that particles sink depending on the radius of the particle, which changes with time. In such a case it is perhaps better to evolve the particle radius, then compute the sinking velocity given the new radius before advective it. Also provided a draft example of how one could set up a problem where the particle sinks with a drag in the form of $\frac{d \boldsymbol{v}}{dt} = \frac{C_d}{\tau}(\boldsymbol{u} - \boldsymbol{v})$. ; Note: in the calculation the velocity of the particle itself needs to be tracked. This is done in `u_particle`, `v_particle`, and `w_particle` in `particles.properties` where `particles::LagrangianParticles`. The particle velocities are computed and updated in the `dynamics` step, then `ParticleVelocities` only has functions that access the particle properties to grab the particle velocity. It is slightly clunky but unless we keep track of the particle velocities right out of the box and update them during the `advect_lagrangian_particles!` step, this is the way I could think of. Since particle velocities are not updated when the particle is bounced, it will not work if the particles bounce from the boundaries back into the interior during the advection step, but for doubly-periodic domian and sinking particles it might not be very important.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350:277,evolve,evolve,277,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1872156350,1,['evolve'],['evolve']
Modifiability,Use a dynamic launch config for more kernels,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/271:21,config,config,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/271,1,['config'],['config']
Modifiability,Use adaptive timestep in two-dimensional turbulence example,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3540:4,adapt,adaptive,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3540,1,['adapt'],['adaptive']
Modifiability,"Using a variable grid spacing like the [Ocean wind mixing and convection example](https://clima.github.io/OceananigansDocumentation/stable/generated/ocean_wind_mixing_and_convection/) in a direction other than `z` raises a `MethodError` when creating a `NonhydrostaticModel`. Modified from OWM&C:; ```; using Oceananigans; Nz = 24 # number of points in the vertical direction; Lz = 32 # (m) domain depth. refinement = 1.2 # controls spacing near surface (higher means finer spaced); stretching = 12 # controls rate of stretching at bottom. # Normalized height ranging from 0 to 1; h(k) = (k - 1) / Nz. # Linear near-surface generator; ζ₀(k) = 1 + (h(k) - 1) / refinement. # Bottom-intensified stretching function; Σ(k) = (1 - exp(-stretching * h(k))) / (1 - exp(-stretching)). # Generating function; z_faces(k) = Lz * (ζ₀(k) * Σ(k) - 1). grid = RectilinearGrid(size = (32, Nz, 32),; x = (0, 64),; y = z_faces,; z = ( 0, 64 )). model = NonhydrostaticModel( grid = grid ); ```. I get the following error if I try to use the above code or put the variable grid spacing in the x-direction; ```; ERROR: MethodError: no method matching PressureSolver(::CPU, ::RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191:8,variab,variable,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191,2,['variab'],['variable']
Modifiability,"Using hu vs u: My reasoning was always the following: The dynamical balance of your model will depend on the practical problem and scales you will look at, hence the conclusion which (dominant) terms should be discretized ""naturally"" and ""nicely"" may vary. On the other hand, all incompressible models have the same volume conservation constraint which is most naturally discretized using hu as fundamental variables (specially on a C-grid). m2c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358:407,variab,variables,407,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119302358,1,['variab'],['variables']
Modifiability,"Using the code from `fjp/benchmark-incompressiblemodel-WENO5` branch I get this:. ```Julia; julia> using Oceananigans; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/E3Wer/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> N = 32; 32. julia> grid = RegularRectilinearGrid(Float32, size=(N, N, N), extent=(1, 1, 1)); RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}; domain: x ∈ [0.0, 1.0], y ∈ [0.0, 1.0], z ∈ [-1.0, 0.0]; topology: (Periodic, Periodic, Bounded); resolution (Nx, Ny, Nz): (32, 32, 32); halo size (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δx, Δy, Δz): (0.03125f0, 0.03125f0, 0.03125f0). julia> model = IncompressibleModel(architecture=GPU(), float_type=Float32, advection=WENO5(), grid=grid); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 3) when constructing the grid.; └ @ Oceananigans.Grids /g/data/v45/nc3020/Oceananigans.jl/src/Grids/automatic_halo_sizing.jl:41; IncompressibleModel{GPU, Float32}(time = 0 seconds, iteration = 0); ├── grid: RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded}(Nx=32, Ny=32, Nz=32); ├── tracers: (:T, :S); ├── closure: Nothing; ├── buoyancy: SeawaterBuoyancy{Float32, LinearEquationOfState{Float32}, Nothing, Nothing}; └── coriolis: Nothing. julia> time_step!(model, 1); ERROR: InvalidIRError: compiling kernel gpu_calculate_Gw!(Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelA",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:257,Config,Configuration,257,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['Config'],['Configuration']
Modifiability,Variable grid spacing in horizontal dimension (x or y) causes `NonhydrostaticModel` instantiation to fail,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2191:0,Variab,Variable,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2191,1,['Variab'],['Variable']
Modifiability,"Very cool. Many thanks!. Petr Krysl; Prof. and Vice chair for undergraduate education; Department of Structural Engineering; <https://urldefense.com/v3/__https://www.linkedin.com/company/uc-san-diego-structural-engineering-department/__;!!Mih3wA!DXYUp152SRRo03xCfQJ9NlAXovNVk-zBYRalwekzmzf2bGwdDMmY8gy9t6iQo9ok2_dvk8m987An93w0pnT_6lM$>; University of California, San Diego; 9500 Gilman Drive #0085; La Jolla, CA 92093. On Mon, Oct 7, 2024 at 6:38 AM Simone Silvestri ***@***.***>; wrote:. > Yep, we used nsys because our primary objective is to trace GPU execution.; > I think it will work also on CPU programs.; > There is nothing really specific about profiling julia with nsys, provided; > that MPI is correctly configured (i.e. your script works with MPI already).; > An example of a batch script that traces MPI calls is; >; > #!/bin/bash; > #SBATCH -N 2; > #SBATCH --ntasks-per-node=4; > #SBATCH --cpus-per-task=16; > #SBATCH --mem=500GB; > #SBATCH --time 24:00:00; > #SBATCH --gres=gpus:4; >; > cat > launch.sh << EoF_s; > #! /bin/sh; > export CUDA_VISIBLE_DEVICES=0,1,2,3; > exec \$*; > EoF_s; > chmod +x launch.sh; >; > srun nsys profile --trace=nvtx,cuda,mpi --output=report_%q{SLURM_PROCID} ./launch.sh julia --check-bounds=no --project scaling_experiments.jl; >; > Here, nsys will produce one report per processor. You can use mpirun or; > mpiexec instead of srun.; > If you want to insert NVTX annotations inside the code you need to add the; > environment variable (ref; > <https://urldefense.com/v3/__https://github.com/JuliaGPU/NVTX.jl__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6C7RIjP6$>; > ); >; > export JULIA_NVTX_CALLBACKS=gc; >; > —; > Reply to this email directly, view it on GitHub; > <https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/pull/3125*issuecomment-2396961670__;Iw!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6H5RkVsz$>,; > or unsubscribe; > <https://urld",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719:715,config,configured,715,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719,1,['config'],['configured']
Modifiability,"Very nice @simone-silvestri . I think we have to regenerate the ocean LES regression test data. Unfortunately this regression test doesn't use `DataDeps` yet so regenerating it will increase the size of the repo by a little bit. Another option is to refactor the regression tests to use DataDeps but this might be best saved for a future PR. I think this fix may actually resolve some ancient issues that we didn't understand until now, for example:. https://github.com/CliMA/Oceananigans.jl/issues/1179. To summarize:. When running a model that has both `Periodic` and `Bounded` directions, _and_ when using a stencil that touches corner points (such as with `coriolis isa FPlane`, the order in which halos are filled matters. In particular, we must fill periodic directions _last_, because the corners then depend on a halo point which is just outside the boundary in the `Bounded` direction(s). The ocean large eddy simulation regression test is one such case (horizontally-periodic, bounded in z). There is a no-flux surface velocity boundary condition that creates a dependency between the bounded and periodic halo fills. The previous algorithm assumed that all halos could be filled simultaneously with no dependencies on one another. However, because the CPU is serial the halos were nevertheless filled in the ordering prescribed by `fill_halo_regions!`:. https://github.com/CliMA/Oceananigans.jl/blob/2d6ccfe94ce2c68857f70b2f8839020049932e00/src/BoundaryConditions/fill_halo_regions.jl#L32-L42. In other words, the vertical halos (the bounded direction) are filled last on the CPU. On the GPU the ordering may change because on the GPU KernelAbstractions is no longer serial. Thus on occasion the periodic halos might have been filled _after_ the bounded halos, leading to a failure of the regression test. This PR fixes that issue so that periodic directions are always filled last. So I think we should expect that regression tests fail on both the CPU and GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800:250,refactor,refactor,250,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035#issuecomment-958102800,1,['refactor'],['refactor']
Modifiability,"Visualization is taking a bit of time. I am adding the vorticity as an output field and then hope to adapt the following to create a similar plot to what you produced before. When I get something working I might push it so that others can use it too, if they like. https://github.com/CliMA/Oceananigans.jl/blob/main/validation/near_global_lat_lon/visualize.jl. I have found that I couple of things don't work so easily. `Node(0)`. ` wireframe!(ax, Sphere(Point3f0(0), 1f0), show_axis=false)`. It seems that `Node` and `Point3f0` are not defined. Is there another library that I need?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483:101,adapt,adapt,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1126317483,1,['adapt'],['adapt']
Modifiability,"Was just looking through this, and not sure if there is still room for comments from noobs (happy to be ignored). Would `tensor_diffusivity` be a good name - skewsymmetric seems a bit like saying that a T-junction is a left_right_turn. :) . > > May I ask why it was decided to not call it Gent-McWilliams? I agree that in general it's good to avoid people's names in things, but in this case (imo) it makes it so much more clear what closure this is since that's what people always call it.; > ; > As far as I can tell when people say they use ""Gent-McWilliams"" they are referring to a constant skew diffusivity (typically 0.3 m^2 / s). But in this closure, the diffusivity can be an arbitrary function or field.; > ; > If anything it would have to be `GentMcWilliamsRedi` since we include the symmetric component as well as the skew component.; > ; > Still though, I think it's important to emphasize that this closure is more general than Gent-McWilliams; not least because the only point in implementing this scheme is to develop a new, better, different parameterization.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449:1058,parameteriz,parameterization,1058,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1994#issuecomment-971930449,2,['parameteriz'],['parameterization']
Modifiability,"We _do_ check that intervals are increasing:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=2, z=(0, -1), topology=(Flat, Flat, Bounded)); ERROR: ArgumentError: z=(0, -1) should be an increasing interval.; Stacktrace:; [1] validate_dimension_specification(T::Type, ξ::Tuple{Int64, Int64}, dir::Symbol, N::Int64, FT::Type); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:73; [2] validate_rectilinear_domain(TX::Type, TY::Type, TZ::Type, FT::Type, size::Tuple{Int64, Int64, Int64}, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/input_validation.jl:100; [3] validate_rectilinear_grid_args(topology::Tuple{DataType, DataType, DataType}, size::Int64, halo::Nothing, FT::Type, extent::Nothing, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:293; [4] RectilinearGrid(architecture::CPU, FT::DataType; size::Int64, x::Nothing, y::Nothing, z::Tuple{Int64, Int64}, halo::Nothing, extent::Nothing, topology::Tuple{DataType, DataType, DataType}); @ Oceananigans.Grids ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:268; [5] RectilinearGrid; @ ~/.julia/packages/Oceananigans/0y15B/src/Grids/rectilinear_grid.jl:254 [inlined]; [6] top-level scope; @ REPL[4]:1; ```. However, if we use explicit interfaces rather than an interval, the constructor seems to be happy:. ```julia; julia> grid = RectilinearGrid(size=2, z=[0, -0.5, -1], topology=(Flat, Flat, Bounded)); 1×1×2 RectilinearGrid{Float64, Flat, Flat, Bounded} on CPU with 0×0×3 halo; ├── Flat x; ├── Flat y; └── Bounded z ∈ [0.0, -1.0] variably spaced with min(Δz)=-0.5, max(Δz)=-0.5; ```. This grid is invalid but was able to be constructed. We should check that and throw an appropriate error so users don't get confused.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3307:1742,variab,variably,1742,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3307,1,['variab'],['variably']
Modifiability,"We also need to figure out how to adapt instruction 2:. <img width=""851"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/129913721-0a12190d-af28-43c6-9070-92eb9e8f5a25.png"">. to buildkite.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073:34,adapt,adapt,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1909#issuecomment-901149073,1,['adapt'],['adapt']
Modifiability,"We could also define this at the top level in `src/Oceananigans.jl`. For coupling, we will have to set these constants in the simulation constructor (hopefully we won't be changing source code)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2981#issuecomment-1472741495:73,coupling,coupling,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2981#issuecomment-1472741495,1,['coupling'],['coupling']
Modifiability,"We currently allow users to implement custom forcing functions with the signature:. ```julia; F(i, j, k, grid, time, U, C, parameters); ```. where `U` is a named tuple of velocity fields, `C` is a named tuple of tracer fields, and `parameters` is the object passed to `IncompressibleModel` via the `parameters` keyword argument. Boundary condition functions have the signature:. ```julia; condition(i, j, grid, time, iteration, U, C, parameters); ```. To stabilize the API, we may want to get rid of `parameters`, include `clock` rather than `time` or `iteration`, and add a named tuple container called `state` that holds `U`, `C`, and any other state variables that we want to add (now or in the future) as accessible to forcing functions or boundary condition functions. I'd propose that state be defined something like. ```julia; state = (velocities=U, tracers=C, diffusivities=K, pressures=pressures, tendencies=G); ```. If we form `state` within the time-stepping loop, it could also simplify the function signatures for time-stepping kernels. Related is #565.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/682:653,variab,variables,653,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/682,1,['variab'],['variables']
Modifiability,"We have two functions called `arch_array` and `on_architecture` that pretty much do the same thing: moving a variable between GPU and CPU. However, neither of them covers all the types in Oceananigans, like `Fields` or `Models`. So, this PR tidies things up a bit. It removes `arch_array` in favor of `on_architecture`. In addition, it extends `on_architecture` to all the types with memory-allocated variables.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3490:109,variab,variable,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3490,3,"['extend', 'variab']","['extends', 'variable', 'variables']"
Modifiability,"We have variables `∇²eᵢⱼₖ` implying that `∇²` acts on `eᵢⱼₖ`. But that's not always the case, right?. Let's change all `∇²eᵢⱼₖ` -> `Aeᵢⱼₖ`? And add a small remark, e.g.,. ```Julia; eᵢⱼₖ = similar(template_field) # the basis vector; Aeᵢⱼₖ = similar(template_field) # A * eᵢⱼₖ; ```. I think everything should be here:; https://github.com/CliMA/Oceananigans.jl/blob/639d337b4449c7aa846b1005ce5109ba590ff786/src/Solvers/multigrid_solver.jl#L192-L233",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241429332:8,variab,variables,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241429332,1,['variab'],['variables']
Modifiability,"We may have discussed this in the past or proposed similar ideas but just thought I'd open a suggestion issue as I think it might make model construction simpler for future users. Right now, for example, creating a parameterized boundary function takes 5 steps; ```julia; B_params = (; Ly = Ly,; B½ = 1.96e-7, # Buoyancy flux at midchannel [m²/s³]; Lᶠ = 10kilometer # Characteristic length scale of the forcing [m]; ); B(x, y, p) = p.B½ * (tanh(2 * (y - p.Ly/2) / p.Lᶠ) + 1) # Surface buoyancy flux [m²/s³]; B_bf = BoundaryFunction{:z, Cell, Cell}(B, B_params); top_b_bc = FluxBoundaryCondition(B_bf); b_bcs = TracerBoundaryConditions(grid, top=top_b_bc); ```. I wonder if we can brush a lot of this under the hood so the user just has to type; ```julia; B_params = (; Ly = Ly,; B½ = 1.96e-7, # Buoyancy flux at midchannel [m²/s³]; Lᶠ = 10kilometer # Characteristic length scale of the forcing [m]; ); B(x, y, p) = p.B½ * (tanh(2 * (y - p.Ly/2) / p.Lᶠ) + 1) # Surface buoyancy flux [m²/s³]; b_bcs = TracerBoundaryConditions(grid, top=FluxBoundaryCondition(B)); ```; I guess it really only skips one step but with 3 arguments it can be inferred to be a parameterized boundary function and the location `{:z, Cell, Cell}` can be inferred from the fact that the BC is being applied at the `top` and it's for a tracer field. Other construction patterns can probably be streamlined too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/769:215,parameteriz,parameterized,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/769,2,['parameteriz'],['parameterized']
Modifiability,"We may want vertical profiles of many variables, e.g. u, v, w, T. Would be nice to have a diagnostic that does this efficiently, especially if we have very frequent diagnostics. If it's literally every iteration then a CUDA kernel might be the way to go. But if it's like every 20-100+ iterations then it might be faster to copy stuff to the CPU and do a lot of extended on-the-fly analysis there (similar to what we do with asynchronous NetCDF output). Not sure if the same diagnostic can handle products of fields, e.g. _w'T'_. That could be another diagnostic?. cc @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/186:38,variab,variables,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/186,2,"['extend', 'variab']","['extended', 'variables']"
Modifiability,We maybe need to adapt the constructor of the `KrylovSolvers` (workspaces) for your specific type.; Example: https://github.com/JuliaSmoothOptimizers/Krylov.jl/blob/main/src/krylov_solvers.jl#L162. It works fine for CPU / GPU arrays as well as various partitioned arrays but `Field` seems quite different.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387573678:17,adapt,adapt,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387573678,1,['adapt'],['adapt']
Modifiability,"We need a diagnostic to compute the horizontal average of terms like `K * dT/dz` which can't be done with the existing `HorizontalAverage` diagnostic. I have an implementation that needs to be polished up, and may take a bit of thought if we want to integrate it with the existing diagnostics:; https://github.com/ali-ramadhan/seasonal-cycle-mixed-layers/blob/6e9834000561bdbbbcb9812e87f8dbdd876e48b0/simulation/deepening_mixed_layer.jl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/428:348,layers,layers,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/428,1,['layers'],['layers']
Modifiability,"We need a unified interface for specifying forcing functions. The first change needed is to assume that, by default, forcing functions are called with the signature. ```julia; forcing(x, y, z, t); ```. This can be achieved with modest changes to [`ModelForcing`](https://github.com/CliMA/Oceananigans.jl/blob/f13a0a26df78cd1c1495d56ef5e7ea2fbbbfb23c/src/Forcing/model_forcing.jl). Next, we can introduce an interface, something like `Forcing(func; kwargs...)`, where `func` is the forcing function. A few kwargs that we might want:. - `parameters`: when `parameters` is specified, `func` is transformed into either a `SimpleForcing` or `ParameterizedForcing` which takes parameters. - `discrete_form`: when `discrete_form=true`, the function signature is assumed to have the ""discrete form"" `func(i, j, k, grid, clock, state)`. - `field_dependent`: this only applies when `discrete_form=false`, and specifies that the function signature contains field. We'll also need a new type, perhaps `DiscreteForcing`, that ensures a forcing function is not transformed into a `SimpleForcing` inside the `ModelForcing` constructor. Finally, we can add keyword arguments to `ModelForcing` that apply the relevant transformations to every forcing function as a convenience.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/896:637,Parameteriz,ParameterizedForcing,637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/896,1,['Parameteriz'],['ParameterizedForcing']
Modifiability,"We need an MPI tips / wiki section... been working on getting distributed simulations running on Engaging since yesterday (we need people to be able to start running distributed simulations immediately with minimal start up time). Here are a few things I learned:. * Remember to load a system MPI on your HPC, eg `module load openmpi`; * MPI may have to be installed / configured carefully --- after loading a system MPI. `MPIPreferences` can help:. ```julia; using MPIPreferences; MPIPreferences.use_system_binary(); ```. https://juliaparallel.org/MPI.jl/stable/configuration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436:369,config,configured,369,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436,5,"['Config', 'config']","['Configuring', 'configuration', 'configured']"
Modifiability,"We need to extend our verification tests for the AMD closure to compare results for all turbulence closures we have implemented. As of now, the only turbulence closure implemented is `SmagorinskyLilly`. When #440 is resolved we can compare to the Vreman closure as well. This applies to . * Stratified Couette flow verification; * free convection verification; * Kato-Phillips verification. ref #81 and #381 . cc @tapios",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/441:11,extend,extend,11,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/441,1,['extend'],['extend']
Modifiability,"We should modify the netCDF variable names to `λF`, `λC` or something... I didn't do this in #2979 because I didn't know if netCDF allows unicode (and because I felt it was outside of the scope of that PR).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1498446661:28,variab,variable,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2248#issuecomment-1498446661,1,['variab'],['variable']
Modifiability,"We think there is a race condition in the CI. Partly discussed on #3661 and also #3662, although one conclusions is that we should update to use the buildkite plugin (started on #3042)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3751#issuecomment-2322236885:159,plugin,plugin,159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3751#issuecomment-2322236885,1,['plugin'],['plugin']
Modifiability,"We use that function to initialize a correct array before performing global reductions (i.e. all zeros for sums, all 1s for prods and so on...) which are called when showing a field (if you put a semicolon after `myfield = CenterField(grid)` the error will disappear) Apparently they have changed the signature of the function in julia-1.8. Adapting Oceananigans to the new `initarray!` was on the table, I guess it's a good time to fix it",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632:341,Adapt,Adapting,341,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2663#issuecomment-1185068632,1,['Adapt'],['Adapting']
Modifiability,"We'll be refactoring the way grids and architectures work soon, so this PR isn't needed anymore.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1485#issuecomment-903978139:9,refactor,refactoring,9,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1485#issuecomment-903978139,1,['refactor'],['refactoring']
Modifiability,"We've seen issues noise in the vertical velocity along immersed boundaries in other configurations too. I've seen at least one result in which the noise is substantially mitigated by using the PCG solver, which avoids the approximations of the ""naive"" FFT solver. Unfortunately, we don't yet have a performant PCG-based solver cc @simone-silvestri @xkykai . I think it's interesting and also convenient that the noise is mitigated in turbulent cases or by the inclusion of bottom drag.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028935410:84,config,configurations,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3526#issuecomment-2028935410,1,['config'],['configurations']
Modifiability,"Well, fractional indices work, just not `DateTimes` indices. I am not super familiar with what date-times supports in terms of operations, if it supports summation and division it is straightforward to extend indexing with to `DateTimes`",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1695852941:202,extend,extend,202,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1695852941,1,['extend'],['extend']
Modifiability,"What about designing an interface that's model-specific (since that's where the time-stepper lives). Something like. ```julia; validate_time_step_size(model, dt) = nothing; ```. that's optionally extendable; for example for `NonhydrostaticModel`, which can further dispatch on the time-stepper being used. Then we can implement. ```julia; function set_dt!(simulation, new_dt); validate_time_step_size(simulation.model, dt); simulation.dt = dt; return nothing; end; ```. Now, model developers have the option to implement this function (and the fallback would be `nothing`). I guess the annoying thing here is that in order to error or warn, we have to calculate the CFL which has a cost. So we may not really want to validate time steps all the time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276:196,extend,extendable,196,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3183#issuecomment-1697328276,1,['extend'],['extendable']
Modifiability,"What do we think about the pros and cons of an alternative design that adds `state_callbacks` to `Simulation` and extends `time_step(model, dt, state_callbacks)` to accept the state callbacks as a positional argument?. It might be slightly less code and we don't have to bloat the model structs anymore. It also keeps the callback implementations in `Simulation`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271627269:114,extend,extends,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2773#issuecomment-1271627269,1,['extend'],['extends']
Modifiability,"What does `find_neighboring_panels` do that is not already included in the `grid.connectivity`?; `find_neighboring_panels` seems like a bit of a ""hack"" to me that only works for 1-region-per-panel configs? `grid.connectivity` is general. Why don't we use the grid's connectivity to read out the rank of the neighboring panels. (I really should have made this comment in #3488, but it's never too late..)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2045607056:197,config,configs,197,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3547#issuecomment-2045607056,1,['config'],['configs']
Modifiability,"What if `nu` varies? Do we write this. ```; h⁻¹ ∇ ⋅ (ν h ∇u); ```. ?. this could be implemented using the existing closures:. 1. Add a property `velocities = (u = uh / h, v = vh / h)` (the abstract operations, no data) to `ShallowWaterModel`; 2. Support only `HorizontalScalarDiffusivity` and `HorizontalScalarBiharmonicDiffusivity` (explicitly forbid other closures in the constructor); 3. Then in the constructor, rewrite the closures with. ```julia; if closure isa HorizontalScalarDiffusivity; ν = closure.ν; thickness_weighted_ν = h * ν # Works when `ν` is a number, field, or function of (x, y, z); thickness_weighted_closure = HorizontalScalarDiffusivity(ν = thickness_weighted_ν); end; ```. The same sort of logic applies to tracers diffusivities and also for biharmonic viscosity / diffusivities. 4. Write the kernel functions as. ```julia; 1 / h[i, j, k] * ∂ⱼ_τ₁ⱼ(i, j, k, grid, closure, diffusivities, velocities, tracers, clock, nothing); ```. (the `nothing` is `buoyancy` in our 3D models). I think that should work. The only case that won't work is diffusivities that are functions of `(x, y, z, t)`. But in fact this could be supported too by wrapping function `ν` in `FunctionField` with the model `clock` in the model constructor when `ν_effective` is calculated.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833:416,rewrite,rewrite,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2403#issuecomment-1084969833,1,['rewrite'],['rewrite']
Modifiability,"What is the error you are getting when you try to use it?. The only function you'd need to extend is `update_Δt!` I think, which is probably a small piece of work if we know what error we're getting. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Simulations/time_step_wizard.jl#L32",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761079404:91,extend,extend,91,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-761079404,1,['extend'],['extend']
Modifiability,"What is the intent of these tests? Are they intended to be included in CI, or are they more in the style of “benchmarks” that are run relatively infrequently?. @edoddridge A twist on option 1 is to design a forcing that exactly cancels the terms associated with nonlinear and linear terms in a given equation for some simple initial condition consisting of sines and cosines. For example, pick an initial condition, calculate all terms in a given equation, and then write a forcing that exactly cancels those terms. Then check that the initial condition doesn’t change after a few time-steps. This method allows a test at low resolution with low computational burden and allows each nonlinear and linear term in each equation to be assessed separately. . It would also be good to run “benchmarks” that are designed to be run less frequently, which is a category I think some of the suggested tests fall into (?) Is the algorithm in Oceananigans.jl identical to some configuration of MITgcm? If so that opens the possibility to compare a solution grid-point for grid-point.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467266242:966,config,configuration,966,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/81#issuecomment-467266242,1,['config'],['configuration']
Modifiability,What make sense logically is that `validate_closure` is called first. Because if it's not a valid closure why bother doing anything else... But I'm not sure if it's difficult to refactor.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2347365219:178,refactor,refactor,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3753#issuecomment-2347365219,1,['refactor'],['refactor']
Modifiability,"When I try your suggestion I get that it is an Array, which is good to know. ; ```; julia> typeof(results[CenteredSecondOrder][1].cx.analytical); Array{Float64,1}; ```. I wonder if a simpler idea is to call the plotting for each advection_scheme, that way the scheme is fixed. . Clearly `results` is a very powerful and almost all knowing variable, but I am struggling with how to pin it down.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729:339,variab,variable,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1272#issuecomment-745483729,2,['variab'],['variable']
Modifiability,"When `StepRangeLen` is adapted to GPU it goes through this `adapt_structure`:. https://github.com/JuliaGPU/Adapt.jl/blob/5ef7c5329609df7ffb5b19942d6747b3dcc162c2/src/base.jl#L79-L80. This is invalid though, because it does not preserve the type of the range. It calls this constructor in Julia's base:. https://github.com/JuliaLang/julia/blob/9850a3881221a57a382e98c9b9ae2bf97ac3966d/base/range.jl#L524-L525. specifically we get a range of type `typeof(ref+zero(step))`, which is `Float64` if `step isa Float64`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445730630:23,adapt,adapted,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445730630,2,"['Adapt', 'adapt']","['Adapt', 'adapted']"
Modifiability,"When setting up scripts to run on HPC clusters with strict job time limits you need to write scripts that continuously checkpoint and restore from checkpoint and submit the job script again once a wall time limit has been reached. This introduces some complexity into the script, e.g. a `if model.clock.iteration != 0` statement for setting initial conditions and potentially extra data wrangling if an output writer needs to be configured to append to an existing file. It's quite easy to forget to do something important and introduce bugs into these scripts which is undesirable as these jobs tend to run for a long time and we frequently submit many such jobs so the cost of a mistake can be quite high. In the future I think developing some kind of abstraction for setting up this kind of script will be important for people who run scripts on HPC clusters with time limits. Not sure what to do but ideally it would minimize the chance of misconfiguration: it could allow users to take a regular script without checkpointing and somehow allow the script to be restored from checkpoint without having to worry about correctly setting initial conditions, configuring output writers, etc.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/779:429,config,configured,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/779,2,['config'],"['configured', 'configuring']"
Modifiability,"When using `with_halos = true` in the `JLD2OutputWriter` works well, however in `NetCDFOutputWriter` it crashes with the following error: . ```; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 11 seconds, wall time: 0 seconds; ERROR: LoadError: DimensionMismatch: new dimensions (156, 156, 22, 1) must be consistent with array size 24336; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDataset{Nothing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/CommonDataModel/pO4st/src/cfvariable.jl:419; [6] save_output!(ds::NCDataset{…}, output::Field{…}, model::HydrostaticFreeSurfaceModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:479; [7] write_output!(ow::NetCDFOutputWriter{…}, model::HydrostaticFreeSurfaceModel{…}); @ Oceananigans.OutputWriters /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/OutputWriters/netcdf_output_writer.jl:518; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations /home/datawork-lops-drakkarcom/SIMULATION-OUTPUTS/ICE-CHANEL/.julia/packages/Oceananigans/17XSY/src/Simulations/run.jl:212; [9] time_step!(sim::Simul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819:601,Variab,Variable,601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3260#issuecomment-2007187819,1,['Variab'],['Variable']
Modifiability,Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007:229,adapt,adapted,229,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197356007,1,['adapt'],['adapted']
Modifiability,"Why the lat-lon validation _only_ happens if `isnothing(topology)`? See here:. https://github.com/CliMA/Oceananigans.jl/blob/29a99a0c235b2f6bf0cec525f2249125ad254ccc/src/Grids/latitude_longitude_grid.jl#L240-L262. This way, if I prescribe latitudes beyond +/-90 no error is given...... ```Julia; julia> using Oceananigans. julia> grid = LatitudeLongitudeGrid(topology=(Bounded, Bounded, Bounded), size = (5, 5, 2), longitude = [0, 1, 3, 6, 12, 20], latitude = [10, 12, 20, 40, 100, 170], z = (-1, 0)); 5×5×2 LatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded} on CPU with 3×3×3 halo and with precomputed metrics; ├── longitude: Bounded λ ∈ [0.0, 20.0] variably spaced with min(Δλ)=1.0, max(Δλ)=8.0; ├── latitude: Bounded φ ∈ [10.0, 170.0] variably spaced with min(Δφ)=2.0, max(Δφ)=70.0; └── z: Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.5; ```. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3241:658,variab,variably,658,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3241,2,['variab'],['variably']
Modifiability,"With the recent updates of Oceananigans, I noticed an unusual behavior of the model that often leads to much slower initialization. . Below is a minimum working example that demonstrates the issue:. ```Julia; using Oceananigans; using Oceananigans.Units. grid = RectilinearGrid(CPU(),; size = (3, 3, 3),; extent = (1, 1, 1),; topology = (Periodic, Bounded, Bounded)); model = HydrostaticFreeSurfaceModel(; grid); simulation = Simulation(model, Δt=20minutes, stop_time=20days). u, v, w = model.velocities; ζ = ∂x(v) - ∂y(u); fields_slice = Dict(""u"" => u, ""v"" => v, ""w"" => w, ""ζ"" => ζ); simulation.output_writers[:top] = NetCDFOutputWriter(model, fields_slice;; filename = ""mwe.nc"",; schedule = TimeInterval(0.5day),; overwrite_existing = true,; indices = (:, :, grid.Nz)); run!(simulation). ```; Running this code with Julia 1.9.3 and Oceananigans v0.90.0 gives an initialization time of ~ 15 minutes, much longer than common values of a few seconds. The same issue also appears on GPU. This speed issue disappears either when `ζ = ∂x(v) - ∂y(u)` is replaced with `ζ = Field(∂x(v) - ∂y(u))`, or when `ζ` is the only variable in `fields_slice`. However, as pointed out by @tomchor, wrapping outputs in `Field()` tends to waste more memory (a very precious resource on the GPU), so it may be worthwhile to investigate further why this happens.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381:1115,variab,variable,1115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381,1,['variab'],['variable']
Modifiability,Woops sorry I meant to delete the sandbox! Would be great to increase variety among the existing examples so it's a great idea.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1394#issuecomment-783459067:34,sandbox,sandbox,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1394#issuecomment-783459067,1,['sandbox'],['sandbox']
Modifiability,"Would be good to adapt our `Field` structs to be `isbits` for CUDA kernels. Same with `FieldSet` structs, although `FieldVector`s might be a good choice here. We would have to adapt `FieldVector` ourselves though. See this PR for an example on how to adapt: https://github.com/JuliaArrays/OffsetArrays.jl/pull/57",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/163:17,adapt,adapt,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/163,3,['adapt'],['adapt']
Modifiability,"Would be nice to have a nice and user-friendly API for setting boundary conditions. What boundary conditions should we be supporting? What should this API look like? Just starting a discussion around this that I've had with @SandreOuza and @glwagner. @glwagner made the point that the user should just have to specify whether they'd like Dirchlet, Neumann, or Robin boundary conditions. Periodic should be another option. We don't have to support all combinations. But in finite volume boundary conditions are converted into conditions on the fluxes. Right now we have something like this; ```julia; model.boundary_conditions = BoundaryConditions(x=:periodic, y=:periodic, top=:free_slip, bottom=:free_slip); ```; and all the ugliness is swept under the rug. This may involve refactoring some of the difference and interpolation operators as they might have been implicitly assuming that free-slip is being imposed. Will have to confirm with @jm-c. PS: Assigning multiple people as I don't have much experience around this (just to get your attention) Would be good to talk and figure out what kind of API works for all of us. Pinging: @SandreOuza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/86:776,refactor,refactoring,776,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/86,1,['refactor'],['refactoring']
Modifiability,"Would be nice to specify a list of e.g. 32 parameters and just spin off 32 models running in different configurations, maybe on Google Cloud. I think this is something Chris might have already figured out:; * https://github.com/christophernhill/oceananiganshacks; * https://github.com/ali-ramadhan/gcloudhacks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/144:103,config,configurations,103,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/144,1,['config'],['configurations']
Modifiability,"Would it make sense to initialize with the analytical solution to the (linear or weakly nonlinear) barotropic problem? Even if a simple Laplacian viscosity is a poor parameterization for eddy effects, it should dramatically accelerate the equilibration process, right?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1031920493:166,parameteriz,parameterization,166,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1085#issuecomment-1031920493,1,['parameteriz'],['parameterization']
Modifiability,"Writing `@allowscalar` will of course always fix a scalar indexing error. But you may end up with slow code, which defeats the purpose of using the GPU. Taking a look at the script: https://github.com/CliMA/Oceananigans.jl/blob/main/examples/kelvin_helmholtz_instability.jl. we see that there are calls to getindex in a few places:. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L190. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L197. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L256C1-L257C1. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L266. https://github.com/CliMA/Oceananigans.jl/blob/fb9455bc10721a880d9911a39735e37f1c4961e0/examples/kelvin_helmholtz_instability.jl#L270. Wherever we write `energy[1, 1, 1]`, it is safe to use `@allowscalar`. This is just a single indexing operation and will be fast. However, where we write `collect`, its probably better to rewrite this in a different way. But note that `collect` is only used for plotting. So what we do here depends on the application. @sangeethasankar01 are you trying to get this to run on the GPU for some specific purpose? Or is this merely an educational exercise?. I also think we should convert this issue to a discussion. I don't think we want to make these changes to the example in the source code.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563:1200,rewrite,rewrite,1200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2023037563,1,['rewrite'],['rewrite']
Modifiability,"Yeah I agree with no code being better than broken code. So I guess that means nuke non-working scripts and they can always be revived later with the intention of maintaining them long-term. Also agree that sandbox is bad. We can discourage further short-term additions to `validation` and encourage people to use branches or other short-term repositories for them?. As for repo size yeah the biggest files are images and regression files which we could aim to get rid of in the long-term, maybe in one fell swoop with BFG repo cleaner. We've done in the past but it takes some preparation and is rewriting git history which is bad.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872562473:207,sandbox,sandbox,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872562473,1,['sandbox'],['sandbox']
Modifiability,"Yeah I think some of those one-off experiments in `validation` should probably be nuked. Maybe we should put them in a `sandbox` directory in the future. Ideally they would serve both as actual validation against existing results (e.g. convergence test, lid-driven cavity, viscous flow around a cylinder) and as advanced examples, so maybe they should become Literate examples (or Pluto examples/notebooks...).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872543143:120,sandbox,sandbox,120,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872543143,1,['sandbox'],['sandbox']
Modifiability,Yeah for sure we should add docs before merging. This PR may be open for a bit because I'd like to refactor the tests. Right now they take almost 2 hours on average which I feel is much too slow.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-905859491:99,refactor,refactor,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-905859491,1,['refactor'],['refactor']
Modifiability,Yeah seems like it might be easiest to define a new `define_output_variable!` that dispatches on `WindowedTimeAverage{<:WindowedSpatialAverage}`. `define_output_variable!` is only used by `NetCDFOutputWriter` since it needs to know which dimensions belong to the variable.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784317252:263,variab,variable,263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784317252,1,['variab'],['variable']
Modifiability,Yeah so Adapt v3.0.0 is blocked by CUDA.jl right now: https://github.com/JuliaGPU/CUDA.jl/pull/626. I think we just need to wait for a new tagged release.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971:8,Adapt,Adapt,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1287#issuecomment-756774971,1,['Adapt'],['Adapt']
Modifiability,"Yeah that would definitely help with modularization. They might need to take in the whole model, e.g. `validate_coriolis(model)`, `validate_advection(model)`, etc. since it seems hard to anticipate all the inconsistent configurations. I remember you raised the concern of slowdowns in the case of running tons of small/column models. So maybe a kwarg like `check_consistency=true` would be good to add with this feature.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796342103:219,config,configurations,219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-796342103,1,['config'],['configurations']
Modifiability,"Yeah, there a couple of bugs with the adaptive time step that I meant to fix with #3125 that reworks the internals of the split explicit solver to enable overlayed communication, but that is taking a bit too much, and we want to refactor the constructor (and internal structure) anyway so it's better to do it in a separate (maybe quicker) PR. I can adapt #3125 later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450:38,adapt,adaptive,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3238#issuecomment-1695689450,3,"['adapt', 'refactor']","['adapt', 'adaptive', 'refactor']"
Modifiability,Yeah... Let's put this in the pot for a potential buoyancy refactor (see #2022).,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2027#issuecomment-951393626:59,refactor,refactor,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2027#issuecomment-951393626,1,['refactor'],['refactor']
Modifiability,"Yeap, I agree. So are you thinking a config similar to the examples (e.g., rectilinear), start with mean state + some prescribed perturbation and run for up to, e.g., t=20 and compare output? How does that sound?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137969032:37,config,config,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1137969032,1,['config'],['config']
Modifiability,"Yeap, let’s add them now and enhance/improve later",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880689429:29,enhance,enhance,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-880689429,1,['enhance'],['enhance']
Modifiability,"Yep, we used nsys because our primary objective is to trace GPU execution. I think it will work also on CPU programs. ; There is nothing really specific about profiling julia with nsys, provided that MPI is correctly configured (i.e. your script works with MPI already). An example of a batch script that traces MPI calls is; ```; #!/bin/bash; #SBATCH -N 2; #SBATCH --ntasks-per-node=4; #SBATCH --cpus-per-task=16; #SBATCH --mem=500GB; #SBATCH --time 24:00:00; #SBATCH --gres=gpus:4. cat > launch.sh << EoF_s; #! /bin/sh; export CUDA_VISIBLE_DEVICES=0,1,2,3; exec \$*; EoF_s; chmod +x launch.sh. srun nsys profile --trace=nvtx,cuda,mpi --output=report_%q{SLURM_PROCID} ./launch.sh julia --check-bounds=no --project scaling_experiments.jl ; ```; Here, `nsys` will produce one report per processor. You can use `mpirun` or `mpiexec` instead of `srun`.; If you want to insert GC (garbage collection) annotations in the report through nvtx you need to add the environment variable ([ref](https://github.com/JuliaGPU/NVTX.jl)) ; ```; export JULIA_NVTX_CALLBACKS=gc; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396961670:217,config,configured,217,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396961670,2,"['config', 'variab']","['configured', 'variable']"
Modifiability,"Yes that would be ideal!. Actually I guess right now it might be tricky since you have to create the grid first for stretched and curvilinear grids. But for multi-architectures, you need to pass the grid as the grid topology could change the rank connectivity. So you end up having to specify `CPU()` for the grid, then pass it to the `MultiCPU` constructor, then pass that to the model. Would be great if we can specify the architecture in one place, but might require some refactoring that we'd have to think more about.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799746052:475,refactor,refactoring,475,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1453#issuecomment-799746052,1,['refactor'],['refactoring']
Modifiability,"Yes we definitely need to speed up the tests. I think 95% of the time it takes to run tests is spent in compilation, however, so creating fewer models may not help much. Instead we may need to be more strategic with how we run tests, and perhaps also work on speeding up compilation time using something like [SnoopCompile.jl](https://github.com/timholy/SnoopCompile.jl). On #1962 we add bars capability, which will allow us to separate the tests into a few categories: fast-running, crucial tests will run on every commit to a PR, and slower, more comprehensive integration tests will run only when `bors try` or `bors r+` is invoked. This might help streamline the development workflow. Also if we are using Caltech's central cluster for CI we can potentially split the jobs amongst more workers, which might help speed up tests overall. Even more important is simplifying the test implementation. Right now updating tests and validation experiments is a time sink for developers that change the API and has really slowed development down lately. So we shouldn't rewrite tests in a way that makes development more difficult (eg keeping the maintenance burden of the test infrastructure small is more important than decreasing the computational cost of tests). This is really a side comment --- we should be able to improve the tests both so they are faster _and_ easier to maintain, if we are careful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970:1065,rewrite,rewrite,1065,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1990#issuecomment-922526970,2,['rewrite'],['rewrite']
Modifiability,"Yes we have some notes on the Fourier Poisson solver here: https://climate-machine.github.io/Oceananigans.jl/latest/algorithm/#Discrete-Fourier-spectral-method-1. Yes we'd need a _new_ Poisson solver with Neumann boundary conditions in two directions but this would be a minor change. I think we'd just have to use the same wavenumbers in the _y_-direction as we do for the _z_-direction [see equations (47) and (48)] and use DCTs in the _y_-direction instead of FFTs. I think that should be it but not 100% sure if it's that simple. **Note**: It's only this simple if _Δy_ and _Δz_ are constants (well, _Δz_ can be variable #46). But if both _Δy_ and _Δz_ are variable, then the Poisson solve will become much slower and more difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-468944198:616,variab,variable,616,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/100#issuecomment-468944198,2,['variab'],['variable']
Modifiability,"Yes, most containers are ""adapted"" on the GPU. We adapt `field` to `field.data`:. https://github.com/CliMA/Oceananigans.jl/blob/7debded91d24520d72857c120303bcd22b805104/src/Fields/field.jl#L394. And note that `field.data` will be further adapted. For example, `CuArray` becomes `CuDeviceArray`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370320395:26,adapt,adapted,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2859#issuecomment-1370320395,3,['adapt'],"['adapt', 'adapted']"
Modifiability,"Yes, that is pretty much what I had in mind but for a different physical problem. . There are a variety of ways one can do this. Below are a few that come to mind. 1. Power method: worked well for Kelvin-Helmholtz instability and should work well for other problems. Two nice features are that it's pretty simple, and it's already coded up for one example so should be easy to adapt. One not so nice feature is that it only tells us the most unstable mode (spatial structure, growth rates and phase speed) but it doesn't tell us about any other unstable modes. 2. Arnoldi Method: A quick google search came across this [library](https://haampie.github.io/ArnoldiMethod.jl/stable/). I have not tried it but could try adapting it to the above mentioned KH problem. . 3. Standard eigenvals: If we assume periodicity in two directions it boils down to a 1D eigenvalue problem that should be easy to solve using eigenvals. There should be a direct solver that forms a full matrix and gives you all the eigenfunctions but the indirect uses Arnoldi and gives you some. . As for where they appera I don't kown but at some point, after I get a ShallowWaterModel off the ground, I will play around with different solvers and see what looks promising. This won't happen this week I'm pretty sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731274044:377,adapt,adapt,377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1191#issuecomment-731274044,2,['adapt'],"['adapt', 'adapting']"
Modifiability,"Yes. To be honest after your comments I'm completely lost. I thought I was getting a grasp on how structs and multiple dispatch worked, but now I'm 100% sure that I am 0% about everything :laughing: . I've defined something like this:. ```julia; struct SpatialWindowAverage{X, Y, Z, A, G, F, S, D} <: AbstractField{X, Y, Z, A, G}; data :: A; grid :: G; field :: F; field_slicer :: S; dims :: D; end. SpatialWindowAverage(field; dims, field_slicer=FieldSlicer()) =; SpatialWindowAverage(field.data, field.grid, field, field_slicer, dims); ```. But of course, it's missing `X, Y, Z`. But to get them I need those `drop_averaged_dims` functions and I'm not sure how to work them on reduced fields. . So far I've been looking at how `AveragedField` is defined, but that's exactly what @glwagner recommended I not do, since apparently it's difficult to adapt it for what I want... And in the mean time I'm computing these averages offline, which is taking a very long time haha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675:848,adapt,adapt,848,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1392#issuecomment-783547675,1,['adapt'],['adapt']
Modifiability,"Yesterday I tried running the diffusion example on a server and it run but there was a lot of output that appeared when doing simple plotting, see below. This is not an oceananigans thing as much as a `Plots.jl` thing. We found out that adding the line `ENV[""GKSwstype""]=""nul""` seemed to resolve the issue. Do people know how common a problem this is? If not then nothing to do but if it does happen a lot I wonder whether addin this line in the examples, or somewhere, might be helpful?. ```; julia> plt = plot(1:10); qt.qpa.xcb: could not connect to display ; qt.qpa.plugin: Could not load the Qt platform plugin ""xcb"" in """" even though it was found.; This application failed to start because no Qt platform plugin could be initialized. Reinstalling the application may fix this problem. Available platform plugins are: linuxfb, minimal, offscreen, vnc, xcb. connect: Connection refused; GKS: can't connect to GKS socket application. GKS: Open failed in routine OPEN_WS; GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine FILLAREA; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSAC or SGOP in routine POLYLINE; GKS: GKS not in proper state. GKS must be either in the state WSA",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1657:569,plugin,plugin,569,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1657,4,['plugin'],"['plugin', 'plugins']"
Modifiability,"Yesterday, @ali-ramadhan and I discussed a new idea for improving the abstraction of equations. The idea is to abstract a `RightHandSide` consisting of a tuple of `Flux`es and `VolumeTerm`s or `SourceTerm`s. Each `Flux` or `VolumeTerm` type would define a `getindex` method, and carry around the references needed to execute that `getindex` method on CPU or GPU. This would greatly simplify the time-stepping routines, which currently involve long function signatures. There'd be no need for 'unpacking', because each term in the equation would perform unpacking upon instantiation. It would also probably be easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them referen",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:629,extend,extend,629,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,1,['extend'],['extend']
Modifiability,"You can use `FluxBoundaryCondition` with `closure=nothing` (it's `Value` and `Gradient` that won't work). You can obtain global dissipation by differencing globally integrated TKE (and perhaps a pointwise dissipation by evaluating the TKE budget), but I agree that it's probably more difficult. @simone-silvestri may have some tips as he has been developing an implicit LES scheme for mesoscale turbulence. Does `AnisotropicMinimumDissipation` work? Or other closures?. I'm wondering if the problem is the use of a `BinaryOperation` for the diffusivities with `SmagorinskyLilly`:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/turbulence_closure_implementations/smagorinsky_lilly.jl#L214. It might be possible to avoid using that `BinaryOperation` by instead extending the three diffusivity getter functions:. https://github.com/CliMA/Oceananigans.jl/blob/b7ad891c718c16db35d70ee86da81a74ad2f7370/src/TurbulenceClosures/abstract_scalar_diffusivity_closure.jl#L87-L89",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597:823,extend,extending,823,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1403103597,1,['extend'],['extending']
Modifiability,"You need to use `Open` to set boundary-normal velocities. However, what you're trying to do may not be supported. @jagoosw may know more. Can you please provide more detail about the setup you are trying to run?. > Then, i have another question. i want to output wind stress (top flux boundary condition) to jld2 or netcdf. But i cannot save or find wind stress (top flux boundary condition) from model. So, which field or variable can i set to save wind stress. Is there a simple example?. This depends on how you are setting the wind stress --- are you using a function or array? If you provide more details we can figure it out. I converted this to a discussion because we are not trying to change the source code (as far as I can tell).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056:423,variab,variable,423,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3612#issuecomment-2148897056,2,['variab'],['variable']
Modifiability,"You should write. ```julia; import Oceananigans.Utils: cell_advection_timescale; ```. at the top of the file `shallow_water_cell_advection_timescale.jl`. This ""imports"" the name `cell_advection_timescale` into your present scope such that the function can be extended with new methods. Next, you want to define a new method for `cell_advection_timescale` with the signature. ```julia; cell_advection_timescale(model::ShallowWaterModel) = # definition here; ```. Note that the function signature. ```julia; cell_advection_timescale(uh, vh, h, grid); ```. is already taken by one of the existing methods for `cell_advection_timescale`:. https://github.com/CliMA/Oceananigans.jl/blob/2016e730350e0b6b625a5cf85a68269a370686fd/src/Utils/cell_advection_timescale.jl#L2-L12. This means that you need to either use type annotations to distinguish the version that takes arguments `uh, vh, h, grid` from the method that takes `u, v, w, grid`, or (probably better) use a unique name. A good name for the method that takes the arguments `uh, vh, h, grid` could be. ```julia; shallow_water_cell_advection_timescale(uh, vh, h, grid) = # definition here; ```. Remember that with this new name, the function `cell_advection_timescale(model::ShallowWaterModel)` must call `shallow_water_cell_advection_timescale`; eg. ```; cell_advection_timescale(model::ShallowWaterModel) =; shallow_water_cell_advection_timescale(model.solution.uh.data.parent,; model.solution.vh.data.parent,; model.solution.h.data.parent,; model.grid); ```. when this file is put together, you should include it in `ShallowWaterModels.jl`. This should allow you to `run!` a `Simulation` with `TimeStepWizard`. Perhaps it makes sense to add a test for this in this PR?. If this does not work, feel free to copy/paste the error here so that we can debug the issue. Note: I was confused earlier --- I definitely prefer `shallow_water_cell_advection_timescale.jl` for the filename. But anything will do.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764060246:259,extend,extended,259,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1307#issuecomment-764060246,1,['extend'],['extended']
Modifiability,"[This `if`-statement](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/time_steppers.jl#L140) is not necessary, because the architecture can be known from the array types of the `CellField`s. Specifically, [this line](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/spectral_solvers.jl#L389) can be changed to. ```; function solve_poisson_3d_ppn_planned!(ssp::SpectralSolverParameters, g::RegularCartesianGrid, f::CellField{T}, ϕ::CellField{T}) where T<:CuArray. ... end; ```. I think it would actually be preferable to dispatch on the type of the arrays in `RegularCartesianGrid`. However, it does not appear that the arrays representing the coordinates of the grid are parameterized in [the definition of `RegularCartesianGrid`](https://github.com/ali-ramadhan/Oceananigans.jl/blob/e1be1f0e3f067cdb4236eb5e7b962e0c772ce4d1/src/grids.jl#L12). Why is that? . If the array type of the problem is part of `RegularCartesianGrid`, then dispatch can be used in place of `if`-statements all over the code, especially in `fields.jl`. Finally, the term 'spectral solvers' is misleading here. The solver does not have spectral accuracy; it simply uses the FFT, which *happens* to be used to solve different problems that have a 'spectral' character.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/45:770,parameteriz,parameterized,770,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/45,1,['parameteriz'],['parameterized']
Modifiability,[WIP] Adapt Field to run on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/746:6,Adapt,Adapt,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/746,1,['Adapt'],['Adapt']
Modifiability,[WIP] Enhance `ShallowWater` model to allow for multiple fluid layers,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2600:6,Enhance,Enhance,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2600,2,"['Enhance', 'layers']","['Enhance', 'layers']"
Modifiability,[WIP] Extend MultiRegion to NonhydrostaticModel,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523:6,Extend,Extend,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523,1,['Extend'],['Extend']
Modifiability,"[WIP] Implement ""MEKE"" parameterization with prognostic mesoscale eddy kinetic energy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431:23,parameteriz,parameterization,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431,1,['parameteriz'],['parameterization']
Modifiability,[WIP] Work on AMD gpu portability,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2540:22,portab,portability,22,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2540,1,['portab'],['portability']
Modifiability,"[`Relaxation`](https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L24-L73) applies to more than just sponge layers --- it's a convenience wrapper for a forcing function that ""relaxes"" a field to some `target` at a specified `rate`, limited to a region outside a `mask` function. `Relaxation` is actually a special type of callable `ContinuousForcing`:. https://github.com/CliMA/Oceananigans.jl/blob/35f749ef09fe021d13e8bad6433d889e8c39d6ca/src/Forcings/relaxation.jl#L81-L82. The snippet shows that `mask` is callable with the signature `x, y, z` and target is callable with the signature `x, y, z, t`. Any appropriate `mask` and `target` will work. Also, we've provided a parameterized convenience type for a Gaussian `mask`. So, sponge layers are simply one application of `Relaxation`. @tomchor, perhaps what you're saying is that a Gaussian is not appropriate for a sponge layer `mask`, since one might want a function with a sharper cutoff (subject to @navidcy's caveats). I think this is a valid criticism --- it might make sense to add more appropriate parameterized types (using tanh's, etc?) This could be added in a PR that also updates the documentation and provides a better example for implementing a sponge layers.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410:171,layers,layers,171,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203#issuecomment-733252410,5,"['layers', 'parameteriz']","['layers', 'parameterized']"
Modifiability,[da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [9e8cae18] Oceananigans v0.76.5 `/g/data/v45/nc3020/OC.jl`; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [91a5bcdd] Plots v1.36.0; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [a759f4b9] TimerOutputs v0.5.19; [bdfc003b] TimesDates v0.3.1; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates `@stdlib/Dates`; [b77e0a4c] InteractiveUtils `@stdlib/InteractiveUtils`; [37e2e46d] LinearAlgebra `@stdlib/LinearAlgebra`; [56ddb016] Logging `@stdlib/Logging`; [44cfe95a] Pkg `@stdlib/Pkg`; [de0858da] Printf `@stdlib/Printf`; [9a3f8284] Random `@stdlib/Random`; [2f01184e] SparseArrays `@stdlib/SparseArrays`; [10745b16] Statistics `@stdlib/Statistics`; [8dfed614] Test `@stdlib/Test`; Status `/jobfs/73413669.gadi-pbs/jl_XhyZPR/Manifest.toml`; [621f4979] AbstractFFTs v1.1.0; [79e6a3ab] Adapt v3.3.3; [4fba245c] ArrayInterface v6.0.1; [30b0a656] ArrayInterfaceCore v0.1.2; [ab4f0b2a] BFloat16s v0.2.0; [6e4b80f9] BenchmarkTools v1.3.2; [d1d4a3ce] BitFlags v0.1.7; [fa961155] CEnum v0.4.2; [179af706] CFTime v0.1.2; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [49dc2e85] Calculus v0.5.1; [7057c7e9] Cassette v0.3.10; [d360d2e6] ChainRulesCore v1.15.0; [9e997f8a] ChangesOfVariables v0.1.3; [944b1d66] CodecZlib v0.7.1; [35d6a980] ColorSchemes v3.20.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.9.10; [5ae59095] Colors v0.12.10; [34da2185] Compat v3.43.0; [a216cea6] CompoundPeriods v0.5.1; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [9a962f9c] DataAPI v1.10.0; [124859b0] DataDeps v0.7.10; [864edb3b] DataStructures v0.18.12; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.11.0; [ffbed154] DocStringExtensions v0.8.6; [fa6b7ba4] DualNu,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:1917,Adapt,Adapt,1917,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Modifiability,"\chi \right) G^{n-1}; ```; The $\chi$ term should be a small deviation from the time integral, added to reduce the noise generated by non-linear terms. ; I wanted to open a bit of a discussion about the details of ; 1. the $\chi$ value; 2. the time integral when we use variable time stepping that is a feature we use quite often. By default, we use $\chi = 0.1$, which is quite large (20% of the smaller coefficient). This will introduce quite a bit of implicit dissipation in the model. Generally, there is a tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have added only one $G^{n}$ because the extra tendency we have added in $c^{n+1}$ is removed in the successive timestep.; With variable time steps, this is not the case! Suppose the time-step changes between $n+1$ and $n+2$; ```math; c^{n+1} += \Delta t^n (1.5 G^{n} - ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738:1200,variab,variable,1200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738,2,['variab'],['variable']
Modifiability,`Adapt`ing all fields of the `OrthogonalSphericalShellGrid`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3619:1,Adapt,Adapt,1,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3619,1,['Adapt'],['Adapt']
Modifiability,`FieldTimeSeries` does not adapt correctly on GPU,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3472:27,adapt,adapt,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472,1,['adapt'],['adapt']
Modifiability,`Field` major refactor: one `Field` to rule them all,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2121:14,refactor,refactor,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2121,1,['refactor'],['refactor']
Modifiability,`MultiRegion` adaptation of the `NonhydrostaticModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795:14,adapt,adaptation,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795,1,['adapt'],['adaptation']
Modifiability,"`Oceananigans.Solver.BatchedTridiagonalSolver`). Building the compressible model on top of Oceananigans.jl has allowed it to run on GPUs and make use of the same operators, grids, Coriolis terms, forcing function and boundary conditions, diagnostics, output writers, higher-order advection schemes, and user-interface niceties. Turbulent diffusivity closures may take more work to integrate and not all of them can be shared as the stress tensor is not traceless when the fluid is compressible (see #654 for more discussion). # Reasons why we may consider adding a compressible model to the Oceananigans.jl ecosystem. 1. I see Oceananigans.jl as a general-purpose package for fluid dynamics even though we mostly apply it to ocean problems. With both incompressible and compressible models, Oceananigans.jl would appeal to a larger audience and may be used to investigate a greater range of problems.; 2. One potential use of the `CompressibleModel` is to simulate a compressible ocean (with pressure as a prognostic variable) in which sound waves artificially slowed down for practical purposes. There were some discussions around this idea and @johncmarshall54 might still be interested.; 3. With PR #590, Oceananigans.jl will support distributed parallelism via MPI. While incompressible models (and anelastic models) don't scale that well to many nodes due to the need to solve an elliptic Poission equation globally across all ranks, a compressible model is completely local and might easily scale well on many GPUs. So even if the scalability of incompressible models on many GPUs is dissapointing, we may get a very scalable compressible model almost for free. Actually, the efficiency of the Oceananigans MPI algorithm might be best tested using a compressible model.; 4. Since distributed FFTs aren't generally available on GPUs (CuFFT only goes up to 16 GPUs), CUDA-aware MPI for incompressible models might take some time and effort to support once PR #590 is merged. However, CUDA-aware M",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:2732,variab,variable,2732,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['variab'],['variable']
Modifiability,`Oceananigans.short_show` should really extend `Base.summary`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1986:40,extend,extend,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1986,1,['extend'],['extend']
Modifiability,"`PartialCellBottom` has a couple of bugs in the implementation that make it crash in simple cases like the `internal_tide.jl` example. @jm-c is working on fixing the implementation and should open a PR soon to fix the bugs.; However, it is indeed a problem in the adapt. ; I can it in a PR, still if you use PartialCellBottom know that probably it will lead to a crashing simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138:264,adapt,adapt,264,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681#issuecomment-2269880138,2,['adapt'],['adapt']
Modifiability,`PartialCellBottom` needs to be adapted correctly for the GPU when using a `HydrostaticFreeSurfaceModel`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:32,adapt,adapted,32,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['adapt'],['adapted']
Modifiability,"```; [e9e359dc] CUDA_jll v10.0.130+3; ```. That JLL is deprecated and shouldn't be used. For one, it `dlopen`s plenty of libraries eagerly, as can be seen at the start of the test:. ```; Testing Running tests...; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ```. Opening many copies of CUDA libraries easily breaks the whole system, and might explain the CUBLAS failure here.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2902#issuecomment-1418738849:253,variab,variable,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2902#issuecomment-1418738849,4,"['Config', 'config', 'variab']","['Config', 'config', 'variable']"
Modifiability,"```; julia> using Distributed. help?> addprocs; search: addprocs. addprocs(manager::ClusterManager; kwargs...) -> List of process identifiers. Launches worker processes via the specified cluster manager. For example, Beowulf clusters are supported via a custom cluster manager implemented in the package ClusterManagers.jl. The number of seconds a newly launched worker waits for connection establishment from the master can be specified via variable; JULIA_WORKER_TIMEOUT in the worker process's environment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:442,variab,variable,442,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variable']
Modifiability,"```julia; julia> f = Adapt.adapt(0); (::Base.Fix1{typeof(adapt), Int64}) (generic function with 1 method). julia> typeof(f); Base.Fix1{typeof(adapt), Int64}; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187:21,Adapt,Adapt,21,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1867021187,4,"['Adapt', 'adapt']","['Adapt', 'adapt']"
Modifiability,"```julia; mutable struct Clock{T}; time :: T; iteration :: Int; end; ```; Ah right so mutable structs are not `isbits` and so they cannot be passed into GPU kernels... We might have to roll back to using `time, iteration` in kernel and forcing/boundary function signatures instead of `clock`. But maybe it's simple enough that it could be adapted to the GPU...?. @vchuravy @maleadt Would it be possible to adapt a very simple `mutable struct` like `Clock{T}` to work in GPU kernels with Adapt.jl? It's never modified in a GPU kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599079071:339,adapt,adapted,339,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/697#issuecomment-599079071,2,['adapt'],"['adapt', 'adapted']"
Modifiability,"```julia> using Pkg; pkg""st --manifest""; Status `~/.julia/environments/v1.5/Manifest.toml`; [621f4979] AbstractFFTs v1.0.1; [79e6a3ab] Adapt v3.3.0; [4fba245c] ArrayInterface v3.1.7; [56f22d72] Artifacts v1.3.0; [ab4f0b2a] BFloat16s v0.1.0; [6e34b625] Bzip2_jll v1.0.6+5; [fa961155] CEnum v0.4.1; [179af706] CFTime v0.1.1; [052768ef] CUDA v2.4.3; [83423d85] Cairo_jll v1.16.0+6; [7057c7e9] Cassette v0.3.5; [d360d2e6] ChainRulesCore v0.9.38; [944b1d66] CodecZlib v0.7.0; [35d6a980] ColorSchemes v3.12.0; [3da002f7] ColorTypes v0.10.12; [5ae59095] Colors v0.12.7; [34da2185] Compat v3.27.0; [e66e0078] CompilerSupportLibraries_jll v0.3.4+0; [d38c429a] Contour v0.5.7; [a8cc5b0e] Crayons v4.0.4; [7445602f] CubedSphere v0.1.0; [9a962f9c] DataAPI v1.6.0; [864edb3b] DataStructures v0.18.9; [e2d170a0] DataValueInterfaces v1.0.0; [b552c78f] DiffRules v1.0.2; [ffbed154] DocStringExtensions v0.8.4; [5ae413db] EarCut_jll v2.1.5+1; [b305315f] Elliptic v1.0.1; [2e619515] Expat_jll v2.2.7+6; [e2ba6199] ExprTools v0.1.3; [c87230d0] FFMPEG v0.4.0; [b22a6f82] FFMPEG_jll v4.3.1+4; [7a1cc6ca] FFTW v1.3.2; [f5851436] FFTW_jll v3.3.9+7; [53c48c17] FixedPointNumbers v0.8.4; [a3f928ae] Fontconfig_jll v2.13.1+14; [59287772] Formatting v0.4.2; [d7e528f0] FreeType2_jll v2.10.1+5; [559328eb] FriBidi_jll v1.0.5+6; [0656b61e] GLFW_jll v3.3.3+0; [0c68f7d7] GPUArrays v6.2.2; [61eb1bfa] GPUCompiler v0.8.3; [28b8d3ca] GR v0.57.4; [d2c73de3] GR_jll v0.57.2+0; [5c1252a2] GeometryBasics v0.3.12; [78b55507] Gettext_jll v0.20.1+7; [7746bdde] Glib_jll v2.59.0+4; [c27321d9] Glob v1.3.0; [42e2da0e] Grisu v1.0.0; [0234f1f7] HDF5_jll v1.12.0+1; [cd3eb016] HTTP v0.9.5; [615f187c] IfElse v0.1.0; [83e8ac13] IniFile v0.5.0; [1d5cc7b8] IntelOpenMP_jll v2018.0.3+2; [c8e1da08] IterTools v1.3.0; [82899510] IteratorInterfaceExtensions v1.0.0; [033835bb] JLD2 v0.4.3; [692b3bcd] JLLWrappers v1.3.0; [682c06a0] JSON v0.21.1; [0f8b85d8] JSON3 v1.8.0; [aacddb02] JpegTurbo_jll v2.0.1+3; [63c18a36] KernelAbstractions v0.5.5; [c1c5ebd",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115:135,Adapt,Adapt,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1601#issuecomment-824063115,1,['Adapt'],['Adapt']
Modifiability,"`const` matters when a variable is referenced as a global variable in a function; something like. ```julia; const a = 2; f(x) = a * x; ```. `a` is not an argument to `f(x)`; it's value is taken from the global scope. In that case it needs to be `const`, or `f(x)` cannot be compiled on the GPU. When numbers are added to explicit data structures --- which is what happens when they are inserted into the `parameters` kwarg in the constructor for `BoundaryCondition` or `Forcing` --- then it's irrelevant whether a variable is declared `const`. This is because in that case the variable is explicitly an argument to the function (eg via the argument `p` in `boundary_condition(x, y, t, p)`). In fact, this is the purpose of the `parameters` kwarg --- to avoid having to use `const` (which is annoying or inconvenient, and has compilation / performance pitfalls). However the API has not developed enough to completely avoid `const` in all cases (eg for `BackgroundFields`, or for masking / target functions in things like `Relaxation`). So we still wrestle with it from time to time.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697:23,variab,variable,23,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881683697,4,['variab'],['variable']
Modifiability,"`interior` is interesting. Are we sure that we should extend this at all? It's main purpose would be debugging I guess, since any time you are using MultiRegion for real, you likely wouldn't want to call it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1305850688:54,extend,extend,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1305850688,1,['extend'],['extend']
Modifiability,"`parameters`, then `func` must be; callable with the signature. `func(x, y, z, t, u, v, w, c, parameters)`. If `discrete_form=true` then `func` must be callable with the ""discrete form"". `func(i, j, k, grid, clock, model_fields)`. where `i, j, k` is the grid point at which the forcing is applied, `grid` is `model.grid`,; `clock.time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitrary in principle, however GPU compilation can place; constraints on `typeof(parameters)`. Examples; =======. ```julia; # Parameterized forcing; parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t). v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π)). # Field-dependent forcing; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P). # Parameterized, field-dependent forcing; tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) . c_forcing = Forcing(tracer_relaxation,; field_dependencies = :c,; parameters = (μ=1/60, λ=10, H=1000, dCdz=1)). # Unparameterized discrete-form forcing function; filtered_relaxation(i, j, k, grid, clock, model_fields) =; @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3. simple_forcing = Forcing(simple_nonlinear_source, discrete_form=true). # Discrete-form forcing function with parameters; masked_damping(i, j, k, grid, clock, model_fields, parameters) = ; @inbounds - parameters.μ * exp(grid.zC[k] / parameters.λ) * model_fields.u",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:3557,Parameteriz,Parameterized,3557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,1,['Parameteriz'],['Parameterized']
Modifiability,`time_step!` function for adaptive time stepping,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/431:26,adapt,adaptive,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/431,1,['adapt'],['adaptive']
Modifiability,a 'simple forcing' script to reproduce this error is here:. https://github.com/climate-machine/Oceananigans.jl/blob/631b861bcfdbfd894c4cb6b2257a16aa8c55f8cc/sandbox/simple_forcing.jl,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496482547:157,sandbox,sandbox,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/248#issuecomment-496482547,1,['sandbox'],['sandbox']
Modifiability,"a `Field` that's reduced over 3 dimensions to a NetCDF file I get an error. For the example the MWE below. ```julia; using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.Off",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857:1004,Variab,Variable,1004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857,1,['Variab'],['Variable']
Modifiability,"adrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Ocea",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:11570,Adapt,Adapt,11570,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,2,['Adapt'],['Adapt']
Modifiability,"adrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2028,Adapt,Adapt,2028,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Modifiability,"ally $z_grid_type grid ...""; grid = lagrangian_particle_test_grid(arch, y_topo, z); # run_simple_particle_tracking_tests(arch, grid, timestepper); @show grid; end; ```. which would give us these 8 (per architecture) test cases. ```julia; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Periodic on vertically uniform grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Periodic on vertically stretched grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically uniform grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically stretched grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5 ; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically uniform grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232:1758,variab,variably,1758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232,1,['variab'],['variably']
Modifiability,"an Diego; 9500 Gilman Drive #0085; La Jolla, CA 92093. On Mon, Oct 7, 2024 at 6:38 AM Simone Silvestri ***@***.***>; wrote:. > Yep, we used nsys because our primary objective is to trace GPU execution.; > I think it will work also on CPU programs.; > There is nothing really specific about profiling julia with nsys, provided; > that MPI is correctly configured (i.e. your script works with MPI already).; > An example of a batch script that traces MPI calls is; >; > #!/bin/bash; > #SBATCH -N 2; > #SBATCH --ntasks-per-node=4; > #SBATCH --cpus-per-task=16; > #SBATCH --mem=500GB; > #SBATCH --time 24:00:00; > #SBATCH --gres=gpus:4; >; > cat > launch.sh << EoF_s; > #! /bin/sh; > export CUDA_VISIBLE_DEVICES=0,1,2,3; > exec \$*; > EoF_s; > chmod +x launch.sh; >; > srun nsys profile --trace=nvtx,cuda,mpi --output=report_%q{SLURM_PROCID} ./launch.sh julia --check-bounds=no --project scaling_experiments.jl; >; > Here, nsys will produce one report per processor. You can use mpirun or; > mpiexec instead of srun.; > If you want to insert NVTX annotations inside the code you need to add the; > environment variable (ref; > <https://urldefense.com/v3/__https://github.com/JuliaGPU/NVTX.jl__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6C7RIjP6$>; > ); >; > export JULIA_NVTX_CALLBACKS=gc; >; > —; > Reply to this email directly, view it on GitHub; > <https://urldefense.com/v3/__https://github.com/CliMA/Oceananigans.jl/pull/3125*issuecomment-2396961670__;Iw!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6H5RkVsz$>,; > or unsubscribe; > <https://urldefense.com/v3/__https://github.com/notifications/unsubscribe-auth/ACLGGWEQFWMJVYNAYQ7WX4LZ2KFD3AVCNFSM6AAAAABPKAGA5GVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDGOJWHE3DCNRXGA__;!!Mih3wA!Ddu9-FVfAupB2XwS3KrF6PADRaFUORHCHdZEo-HuqlK3va2LdvyLAbpllyVWNEIiD_TVMU-miX1JnMaM6OcpZ5Rs$>; > .; > You are receiving this because you were mentioned.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719:1470,variab,variable,1470,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125#issuecomment-2396992719,1,['variab'],['variable']
Modifiability,"and greatly expand the docstring. Much help was provided by @jipolanco on this journey. Note right now we depend on `PencilFFTs#master` but hopefully that'll change with https://github.com/jipolanco/PencilFFTs.jl/pull/47. This required a bit of thinking and logic about pencil decompositions. What I learned is hopefully well-summarized in the docstring:. ```; """"""; DistributedFFTBasedPoissonSolver(global_grid, local_grid). Return a FFT-based solver for the Poisson equation,. ∇²x = b. for `MultiArch`itectures. Supported configurations; ========================. We support two ""modes"":. 1. Two-dimensional decompositions in (x, y) for problems with either; `Nz > Rx` or `Nz > Ry` (therefore, three-dimensional). 2. One-dimensional decompositions in either x or y for problems that are; either two-dimensional, or have limited dimensionality in z. Above, `Nz = size(global_grid, 3)` and `Rx, Ry, Rz = architecture(local_grid).ranks`. Other configurations that are decomposed in (x, y) but have too few Nz,; or any configuration decomposed in z, are not supported. Algorithm for two-dimensional decompositions; ============================================. When decomposition in two-dimensions for a three-dimensional problem,; there are three forward transforms, three backward transforms,; and 4 transpositions requiring MPI communication. In the following schematic, the first; dimension is always the local dimension. The following algorithm requires that `Nz > Rx`,; where `Nz` is the number of vertical cells and `Rx` is the number of ranks in x.; For `Nz < Rx` but `Nz > Ry`, a similar algorithm applies with x and y swapped:. 1. `first(storage)` is initialized with layout (z, x, y).; 2. Transform along z.; 3 Transpose + communicate to storage[2] in layout (x, z, y),; which is distributed into `(Rx, Ry)` processes in (z, y).; 4. Transform along x.; 5 Transpose + communicate to last(storage) in layout (y, x, z),; which is distributed into `(Rx, Ry)` processes in (x, z).; 6. Transform in",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2536:982,config,configurations,982,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2536,2,['config'],"['configuration', 'configurations']"
Modifiability,"annoying that the tests need a little refactoring too, but maybe its all for the best.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1520495458:38,refactor,refactoring,38,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1520495458,1,['refactor'],['refactoring']
Modifiability,"arshall54 <https://github.com/johncmarshall54>, Ali experimented; > with a simple immersed boundary implemented via Oceananigans's user-defined; > forcing functions. The code is these 9 lines:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/a921fc3edbf795bf4a2193cca84cad41ebdd5625/verification/flow_around_cylinder/flow_around_cylinder.jl#L18-L27; >; > This implementation damps the velocity field to zero on a very fast; > time-scale (specified by the parameter K) within the immersed boundary.; > This is certainly a nice, simple immersed boundary implementation for; > Dirichlet / Value boundary conditions and could a good starting point.; > However, I also think there's some good reasons to pursue an alternate; > immersed boundary implementation to what @ali-ramadhan; > <https://github.com/ali-ramadhan> has done for the following reasons:; >; > 1. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > doesn't obviously extend to other boundary conditions, like prescribed; > gradients or fluxes (the latter being crucial for the geophysical problems; > we're interested in). So, even if we use a continuous forcing method; > similar to @ali-ramadhan <https://github.com/ali-ramadhan>'s; > implementation, we need to figure out how to enforce boundary conditions; > other than Dirichlet boundary conditions.; > 2. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > conforms exactly to the grid; however we would like to be able to model; > smoothly-varying boundaries.; > 3. As noted by @whitleyv <https://github.com/whitleyv>, @ali-ramadhan; > <https://github.com/ali-ramadhan>'s ""continuous forcing method""; > implementation introduces a time-step restriction due to the need to; > explicitly resolve the damping time-scale in the forcing function. It seems; > that a discrete forcing method overcomes this restriction and could prove; > crucial for geophysical problems that involve otherwise long time-steps.; >; > —; > You are receiving this becaus",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052:1148,extend,extend,1148,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052,1,['extend'],['extend']
Modifiability,"art @visr @evetion @mkborregaard and @juliohm will be in a better position to comment about it.; > ; > *The packages in JuliaGeo have been mostly focused on IO and has not had the bandwidth to think about how it might interface with packages for (climate/ocean/etc) models. That might be useful down the line! Yes we're both around MIT. I think we're still figuring how we want to do IO in the long-term but will definitely want some way to output NetCDF. > Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project.; > ; > My last attempt at improving the NetCDF solved many of the issues with the package JuliaGeo/NetCDF.jl#61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite.; > ; > Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages.; > ; > I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype.; > ; > I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool. Thanks so much for working on NetCDF.jl! I didn't mean to sound ungrateful about NetCDF.jl's performance. We were just debating which package to use. With https://github.com/JuliaGeo/NetCDF.jl/issues/87 fixed, I think we'll be happy for a long time. The `compress=9` bug explains why the IO was slow. @glwagner has suggested that for a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847:1205,rewrite,rewrite,1205,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476298847,1,['rewrite'],['rewrite']
Modifiability,"ary conditions by using the gradient boundary condition, the script can be found [here](https://github.com/liuchihl/Simple-tests/blob/85f34ec2443a6ff9860f5adfbc68ff39995f00bb/1Ddiffusion_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. https://github.com/CliMA/Oceananigans.jl/assets/68127124/d350c5ad-2e14-4992-8c5d-f947a1ddf7bb. This brings up the question: what should the default behavior for background fields b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568:1218,config,configurations,1218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568,1,['config'],['configurations']
Modifiability,"aryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}, Const{NamedTuple{(:c,), Tuple{BoundaryCondition{Flux, Nothing}}}}, Const{Nothing}, Const{NamedTuple{(), Tuple{}}}, Const{typeof(Oceananigans.Forcings.zeroforcing)}, Duplicated{Clock{Float64}}}, dynamic::KernelAbstractions.NDIteration.NoDynamicCheck, static_threads::Bool);   | @ KernelAbstractions /storage5/buildkite-agent/.julia-14477/packages/KernelAbstractions/WoCk1/src/cpu.jl:82;   | [6] (::KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(64, 64, 8)}, typeof(EnzymeExt.aug_fwd)})(::Function, ::Vararg{Any}; ndrange::Nothing, workgroupsize::Nothing);   | @ KernelAbstractions /storage5/buildkite-agent/.julia-14477/packages/KernelAbstractions/WoCk1/src/cpu.jl:44;   | [7] augmented_primal(::EnzymeCore.EnzymeRules.ConfigWidth{1, false, false, (false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true)}, ::Const{KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(64, 64, 8)}, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.cpu_compute_hydrostatic_free_surface_Gc!)}}, ::Type{Const{Nothing}}, ::Duplicated{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929:17070,Config,ConfigWidth,17070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929,1,['Config'],['ConfigWidth']
Modifiability,"ase.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Vararg{Any}; ndrange::Nothing, workgroupsize::Nothing);   | @ EnzymeExt /storage5/buildkite-agent/.julia-14477/packages/KernelAbstractions/WoCk1/ext/EnzymeExt.jl:62;   | [8] augmented_primal(::EnzymeCore.EnzymeRules.ConfigWidth{1, false, false, (false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, false, true)}, ::Const{KernelAbstractions.Kernel{KernelAbstractions.CPU, KernelAbstractions.NDIteration.StaticSize{(16, 16)}, KernelAbstractions.NDIteration.StaticSize{(64, 64, 8)}, typeof(Oceananigans.Models.HydrostaticFreeSurfaceModels.cpu_compute_hydrostatic_free_surface_Gc!)}}, ::Type{Const{Nothing}}, ::Duplicated{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929:18835,Config,ConfigWidth,18835,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-1953382929,1,['Config'],['ConfigWidth']
Modifiability,"at line 93. ```julia; @inline Fxn_scale(t) = spl_scale(t); ```. which itself is calling some kind of spline. ```julia; spl_scale = Spline1D(secs, df.scale, k=1) ; ```. Since these functions are going to be called in GPU kernels, I think everything used by these functions should be made locally available to the functions and any arrays need to be `CuArray`s. Just looking around your script it looks like `secs` is just a regular array when it should be a `CuArray` if you want to use it in a GPU kernel, e.g. as part of `UniformStokesDrift`. I think the `df` dataframe object might not be GPU-compatible (i.e. it's not `isbits` and has no Adapt.jl function) so you might not want to use the `df` variable inside GPU kernels. It looks like you mostly use numbers from `df` (?) so you could instead pull out what you need. ```julia; const secs = CuArray(...); const scale = CuArray(...); const spl_scale = Spline1D(secs, scale, k=1); @inline Fxn_scale(t) = spl_scale(t); ```. You might also need to make variables `const`, e.g. `const secs = ...` so that they can be accessed from the GPU kernels. There's also the question of whether these splines are GPU-compatible, i.e. do they do the right thing on the GPU when given `CuArray`s instead of regular `Array`s. Unfortunately not every Julia package is GPU-compatible and not always efficient if it falls back on CPU methods to deal with `CuArray`s. I notice you're using Dierckx.jl for splines, which looks like a wrapper around a Fortran library so that's not going to work inside a GPU kernel. The Julia GPU/CUDA compiler can only compile pure Julia code to run on GPUs. We can look around a bit to see if there's a better package unless Dierckx splines are essential to your setup? Interpolations.jl might be an option but I'm not sure if it's GPU compatible. Worst case scenario maybe it wouldn't be too hard to code up a simple spline/interpolation scheme?. If you're looking for a 5~10x speedup you could try running multithreaded (run `julia",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660:1280,variab,variables,1280,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1317#issuecomment-767551660,2,['variab'],['variables']
Modifiability,"at the moment, the default time stepping function is designed with the non-hydrostatic model in mind, so the logical steps of a time step (or substep for RK3) are. ```julia; step_variables!(...); calculate_pressure_correction!(...) ; pressure_correct_velocities!(...); compute_new_tendencies!(...); ```; In the hydrostatic model, we are extending the `step_variables!` function to include a `step_free_surface!` function that calculates `η` and we set ; ```julia; calculate_pressure_correction!(::HydrostaticFreeSurfaceModel, ...) = nothing; ```; I would like to calculate the free surface in the `calculate_pressure_correction!` function to unify conceptually the `NonhydrostaticModel` and the `HydrostaticFreeSurfaceModel`, minimize the amount of code, and reduce the necessity for extending the time-stepping function.; This will make it easier to implement new time-stepping schemes that work for both the models",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3895:337,extend,extending,337,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3895,2,['extend'],['extending']
Modifiability,"ay has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:110 [inlined]; [10] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:103; [11] (::KernelAbstractions.Kernel{…})(::ImmersedBoundaryGrid{…}, ::Vararg{…}); @ CUDA.CUDAKernels C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\CUDAKernels.jl:89; [12] macro expansion; @ C:\Users\Ali\.julia\packages\KernelAbstracti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1827,Adapt,Adapt,1827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['Adapt'],['Adapt']
Modifiability,before it was 52 or 56min... so perhaps it helped slightly but also sometimes depending on how many thing tartarus is doing at the moment you can have some variability in times.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163:156,variab,variability,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1601994163,1,['variab'],['variability']
Modifiability,"belms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing);   | @ Base ./loadi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:1071,Config,Config,1071,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,1,['Config'],['Config']
Modifiability,"bservation at [Ocean Station Papa](https://www.pmel.noaa.gov/ocs/Papa). The UW APL group has very nice [Waverider mooring observations there](https://cdip.ucsd.edu/themes/cdip?d2=p70&u2=s:166:v:parameter). Fig. 7 and Fig.8a,b of [this paper](https://doi.org/10.5194/gmd-14-4261-2021) is a comparison of the Stokes drift between the ""theory wave"" and OS Papa in one year. [Here](https://github.com/qingli411/A2020_CVMix_in_GOTM/blob/main/OSPapa/ospapa_stokes_drift.nc) is the half-hourly Stokes drift data I computed from the wave spectrum at OS Papa used in that paper (without directional spreading). It was computed on a 1 m vertical grid in the upper 36 m and a much coarser grid below. But I can easily compute it on a finer grid if we need. . > Since Oceananigans doesn't yet have bulk formulae, we have to ""invert"" a toy bulk formula to obtain an ""expected air speed"" for a given kinematic momentum flux τ. I'm not sure whether it makes more sense to parameterize Stokes drift in terms of U10 or momentum flux (momentum fluxes saturate when waves stop growing at high wind speeds?). The reason we used U10 in the ""theory wave"" is that the empirical relations we used to estimate the peak wave number are based on wind speed. We need a bulk formula to convert these relations to momentum flux. The relation between U10 and surface Stokes drift does vary with U10 (see, e.g., Fig. 6 of [Rascle & Ardhuin 2013](http://dx.doi.org/10.1016/j.ocemod.2012.12.001)). But Langmuir number also seems to vary with U10 even for fully developed waves (Below is an example showing the relation between the turbulent Langmuir number and U10 assuming Pierson-Moskowitz spectrum). So I'm not sure which way is better...; <img width=""519"" alt=""image"" src=""https://user-images.githubusercontent.com/12438579/156286196-846d07eb-e8a2-4762-b2c8-3d3226401334.png"">. >Another option is to use a model proposed by [Pizzo et al. 2019](https://airsea.ucsd.edu/wp-content/uploads/sites/10/2019/06/2019_Pizzo_Melville_Deike-",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1056109704:1346,parameteriz,parameterize,1346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2290#issuecomment-1056109704,1,['parameteriz'],['parameterize']
Modifiability,"but FYI:. ```; @setup example1; ```. is used to configure `@examples`, not doctests; that's why it didn't work. On a different note, using `# hide` notation won't work in the sense the code will run but it won't be hidden -- that's syntax from Literate.jl package and we are not liberating the docs; only examples.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3707#issuecomment-2287911921:48,config,configure,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3707#issuecomment-2287911921,1,['config'],['configure']
Modifiability,"ce to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then compare some statistic of the model (ideally the entire velocity field, but @sandreza has gotten away just comparing something like `[maximum(abs, u), maximum(abs, v), maximum(abs, w)]`). If there's no race condition, identical models should produce identical results.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:1427,config,configurations,1427,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865,1,['config'],['configurations']
Modifiability,"cell is ""wet"" or not?. ```julia; inactive_node(i, j, k, grid, lx, ly, lz); ```. returns `true` if a cell is immersed / inactive, and `false` if a cell is active. The boundary points are special, because their status depends on whether they are a prognostic or diagnostic field. Therefore we have another function,. ```julia; peripheral_node(i, j, k, grid, lx, ly, lz); ```. which returns true if a cell is inactive _or_ if it lies on the boundary between active and inactive (ie, the ""periphery"" of the domain). This distinction is only meaningful for `Face`-centered fields: `Center` locations cannot lie on the boundary. > ```julia; > julia> using Oceananigans; > ; > julia> grid = RectilinearGrid(size = (4, 4, 4), x=(0,1), y=(0,1), z=0:0.25:1); > 4×4×4 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; > ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=0.25; > ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.25; > └── Bounded z ∈ [0.0, 1.0] variably spaced with min(Δz)=0.25, max(Δz)=0.25; > ; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.25; > 0.25; > 0.25; > 0.25; > 0.25; > ```; > ; > To be in line with [`xgcm`'s standards for metrics](https://github.com/xgcm/xgcm/issues/306#issuecomment-776124591) the output in the above case (considering only the ""wet"" or interior or fluid-filled cells when calculating `Δz`) should be; > ; > ```julia; > julia> grid.Δzᵃᵃᶠ[1:grid.Nz+1]; > 5-element Vector{Float64}:; > 0.125; > 0.25; > 0.25; > 0.25; > 0.125; > ```; > ; > since the first and last spacings on a bounded grid are ""half inside the domain and half outside"". Are you sure? For immersed boundaries, this would mean that all the metrics must be 3D arrays even when the grid directions are separable --- greatly inflating the size of your output file. > Or maybe there's a way to use abstract operation metrics to do this that I'm not aware?. It is simple. Write a `KernelFunctionOperation` that checks if a node is `peripheral_nod",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561:1066,variab,variably,1066,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2652#issuecomment-1516655561,2,['variab'],['variably']
Modifiability,"center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); - `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells.; - `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells.; - `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes).; - `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells. I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. * It seems that we should really use `Bounded` topology to be synonymous with ""impenetrable"". This might help us disentangle a few issues (eg satisfying impenetrability, correct divergences, etc.) I think we are discovering that in some cases its better to hard code certain ""assumed boundary conditions"" directly into operators, such as impenetrable conditions (considering complex domains is the key to realize the right abstractions here, since there are many simple solutions for non-complex domains and no obvious way to distinguish their tradeoffs). This means that we need to ""assume"" boundary conditions based on grid topology (information centralized on the grid), rather than requiring knowledge of the field boundary conditions (information scattered throughout the fields); * Related to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430:1852,extend,extend,1852,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100699430,2,['extend'],['extend']
Modifiability,"chitectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced wit",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1410,Config,Configuration,1410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,1,['Config'],['Configuration']
Modifiability,"ckages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/2kjXI/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] cudaconvert; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:198 [inlined]; [15] map; @ ./tuple.jl:293 [inlined]; [16] macro expansion; @ ~/.julia/packages/CUDA/2kjXI/src/compiler/execution.jl:110 [inlined]; [17] #launch_heuristic#1200; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:17 [inlined]; [18] launch_heuristic; @ ~/.julia/packages/CUDA/2kjXI/src/gpuarrays.jl:15 [inlined]; [19] gpu_call(::GPUArrays.var""#6#7"", ::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, ::Float64; target::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}, elements::Nothing, threads::Nothing, blocks::Nothing, name::Nothing); @ GPUArrays ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:61; [20] gpu_call; @ ~/.julia/packages/GPUArrays/qt4ax/src/device/execution.jl:34 [inlined]; [21] fill!; @ ~/.julia/packages/GPUArrays/qt4ax/src/host/construction.jl:14 [inlined]; [22] fill!; @ ~/atdepth/Oceananigans.jl/src/Fields/field.jl:407 [inlined]; [23] initialize_free_sur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:11641,Adapt,Adapt,11641,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,2,['Adapt'],['Adapt']
Modifiability,"ckages/CUDA/Tl08O/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:174; [5] is_capturing; @ ~/.julia/packages/CUDA/Tl08O/lib/cudadrv/graph.jl:179 [inlined]; [6] convert(::Type{CUDA.CuPtr{Float64}}, managed::CUDA.Managed{CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKerne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2099,Adapt,Adapt,2099,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,2,['Adapt'],['Adapt']
Modifiability,"ckpointing or not. Also, I think that overwrite_existing should not delete your files if you are picking up from a checkpoint (regardless of what it is set to). Do you agree?. Yes, I completely agree, if the simulation picks up from a checkpoint it should not delete data. >Assume for the following discussion that the ""overwriting issue"" is solved for checkpointing:; >; >In my experience, I typically set up a script with overwrite_existing=true from the very beginning. This is because when we first write a script, we are prototyping. I have never then gone back and changed overwrite_existing=false because of some concern about overwriting data. It's inconvenient, in fact, to set overwrite_existing=false.; >; >My thought is that it makes more sense to ask people to intentionally request overwrite_existing=false in the rare case that this is desired. The key insight is that we spend the vast majority of time prototyping. I would even argue from an economic standpoint that the productivity saved from this setting outweights any rare instances of lost data, if they actually would ever occur due to changing the default. Now it is clear. If we handle properly picking up simulations, I completely agree with you that best option is for the user to manually change `overwrite_existing=false` to ensure their own data. I also follow the same workflow when creating a simulation in which I rely on the `overwrite_existing=true` until I reach the ""production"" phase of the simulation. > Also curious --- do you split files to make them easier to download? . I mostly do it to keep a consistent size and chunks across files for post-processing, but supporting both things will make the user workflow more flexible, particularly when running long simulations with multiple pickups. It's likely that the post-processing you suggest will be useful, but in that case it may be more useful to include support to zarr files within the possible simulation outputs (https://github.com/JuliaIO/Zarr.jl).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393101043:1876,flexible,flexible,1876,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2393101043,2,['flexible'],['flexible']
Modifiability,"consider the tilted bottom boundary layer example: https://clima.github.io/OceananigansDocumentation/stable/literated/tilted_bottom_boundary_layer/. In this problem, the buoyancy is decomposed ($b=\bar{b} + b^{\prime}$) into a background component $\bar{b} = N^{2} \hat{z}$ (where $\hat{z}$ is positive in the direction opposite the gravitational vector) and the remaining perturbation. The current example script applies no boundary conditions to the perturbation buoyancy, which I believe defaults to a no-normal-flux condition at the top and bottom boundary. Because no boundary conditions are applied to the background field, there is an implied diffusive flux $\hat{\mathbf{n}} \cdot (-\kappa \nabla \bar{b}) = ±\kappa N^{2} \cos{\theta}$ across these boundaries. This means that the boundary condition on the total buoyancy is a non-zero flux across the seafloor, which does not make much sense for this problem. The normal way of implementing this problem is to apply a gradient boundary condition, $\frac{\partial b^{\prime}}{\partial z} = -N^{2}\cos{\theta}$, at the bottom, to impose the no-flux condition. (In my MITgcm configurations, I verified that implementing the boundary condition this way recovered the classical analytical solutions of [Garrett et al. 1993](https://www.annualreviews.org/doi/10.1146/annurev.fl.25.010193.001451). Here is [another example using Dedalus](https://github.com/hdrake/bmli-linear/blob/main/examples/evp_replicate_Wenegrat2018_growth_rates.ipynb) to replicate some of Jacob Wenegrat's results, where I also include a non-zero gradient boundary condition on the perturbation buoyancy to impose no flux on the total buoyancy.). I understand why one might want background fields to be constructed a certain way for idealized problems, but it should be communicated clearly (and consistently) to the user exactly how this works. Is the tilted bottom boundary layer example incorrectly implemented or do I still not understand how the background fields work?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198:1186,config,configurations,1186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568#issuecomment-2083158198,2,['config'],['configurations']
Modifiability,"d = Int.(Ny/2-40:Ny/2+40); bottom[bound, bound] .= 0.5. grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bottom)); mrg = MultiRegionGrid(grid, partition=XPartition(2), devices = 2); ```; and ; ```; u(x, y, z) = (x * z) / 10; ```. (with `ImplicitFreeSurface`) we get. #### Strong Scaling; | Grid size | Grid | GPUs | wall time | efficiency |; | -- | -- | -- | -- | -- |; | `1440×600×48`| `RectilinearGrid` | 1 | 1.85 minutes | 100% |; | `1440×600×48`| `MultiRegionGrid` | 2 | 1.12 minutes | 82.5% |. Scaling gets better?? at this point I a little confused...; Bottomline... ; there is still a bunch of optimization and more systematic benchmarking to be done, I'll merge this PR and then we can think about improving the scaling, the first things that come in mind are; - Ensure that all the `apply_regionally!` and `construct_regionally` calls are asynchronous. This might not be the case if there are memory copies inside function calls. That would serialize the execution of part of the code. To ensure this we require a more in-depth profiling using ***nsys***; - remove all `fill_halo_regions!` that are not `Periodic` or `Communication` which will allow asynchronous execution of halo filling across different direction (luckily already being done in #2477); - Bundle together the halo passing in a single boundary buffer to allow sending field tuples together (depends on #2509). Additional work to do on `MultiRegion` is ; - Perform more systematic benchmarking; - Design correct `OutputWriters` and `OutputReaders` for `MultiRegionFields`. Maybe not immediate priorities but definitely important; - Adapt `RungeKutta3` to `Multiregion` through `@apply_regionally`; - Implement a multi-region version of the Nonhydrostatic pressure solver; - Overlap computation and communication (for this we require _non-blocking_ `fill_halo_regions!` with returning `events`); - Optimize the distributed implicit solver (maybe using `PETSc.jl`? Might not be needed when the implicit solve fits in one GPU)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178:1787,Adapt,Adapt,1787,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116853178,1,['Adapt'],['Adapt']
Modifiability,"d = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.00276553 -0.00220933 -0.00157462 -0.00105926 -0.000692536 -0.000446557 -0.00028606 … 0.00062928 0.000993307 0.0015715 0.00249751 0.00400184 0.00649",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6102,adapt,adapt,6102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,2,['adapt'],['adapt']
Modifiability,"daryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[2]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:30; ```. But also, I anticipate there are more bugs waiting to be found with `VerticallyStretchedGrids`. If I issue the command `grep -r ""\<Δz\>"" *` (which basically looks for instances of `Δz` and excludes `Δzᵃᵃᶜ` and `Δzᵃᵃᶠ`) and I get this:. ```; ~/repos2/Oceananigans.jl/src$ grep -r ""\<Δz\>"" *; Fields/interpolate.jl:@inline fractional_z_index(z, ::Center, grid::RegularRectilinearGrid) = @inbounds (z - grid.zC[1]) / grid.Δz; Fields/interpolate.jl:@inline fractional_z_index(z, ::Face, grid::RegularRectilinearGrid) = @inbounds (z - grid.zF[1]) / grid.Δz; Grids/regular_latitude_longitude_grid.jl: Δz :: FT; Grids/regular_latitude_longitude_grid.jl: Δλ, Δϕ, Δz = Δ = @. L / N; Grids/regular_latitude_longitude_grid.jl: return RegularLatitudeLongitudeGrid{FT, TX, TY, TZ, typeof(λᶠᵃᵃ)}(Nλ, Nϕ, Nz, Hλ, Hϕ, Hz, Lλ, Lϕ, Lz, Δλ, Δϕ, Δz, λᶠᵃᵃ, λᶜᵃᵃ, ϕᵃᶠᵃ, ϕᵃᶜᵃ, zᵃᵃᶠ, zᵃᵃᶜ, radius); Grids/regular_latitude_longitude_grid.jl: ""grid spacing (Δλ, Δϕ, Δz): "", (g.Δλ, g.Δϕ, g.Δz)); Grids/regu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466:16597,sandbox,sandbox,16597,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466,1,['sandbox'],['sandbox']
Modifiability,"did you use the test environment or Oceananigans's enviroment? On Tartarus, branch main in the test environment does this. ```; Precompiling project...; 1 dependency successfully precompiled in 38 seconds. 218 already precompiled.; Testing Running tests...; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; [2023/02/14 16:22:39.804] INFO Running shallow water regression tests...; [2023/02/14 16:22:40.097] INFO Testing shallow water Bickley jet simulation regression [GPU, VectorInvariantFormulation]; [2023/02/14 16:23:08.854] WARN Inflating model grid halo size to (4, 4, 0) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point. -@-> /home/ssilvest/stable_oceananigans/Oceananigans.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:233; [2023/02/14 16:24:01.792] INFO Initializing simulation...; [2023/02/14 16:24:08.481] INFO ... simulation initialization complete (6.689 seconds); [2023/02/14 16:24:08.481] INFO Executing initial time step...; [2023/02/14 16:24:43.227] INFO ... initial time step complete (34.746 seconds).; [2023/02/14 16:24:43.387] INFO Simulation is stopping after running for 41.593 seconds.; [2023/02/14 16:24:43.387] INFO Model iteration 20 equals or exceeds stop iteration 20.; [2023/02/14 16:24:48.950] INFO Δu: min=-1.671992e-04, max=+4.237079e-06, mean=-8.685825e-06, absmean=+8.778487e-06, std=+2.661356e-05 (16384/16384 matching grid points); [2023/02/14 16:24:48.951] INFO Δv: min=-2.347391e-05, max=+4.751164e-05, mean=+1.746998e-06, absmean=+3.169677e-06, std=+8.513593e-06 (10752/16512 matching grid points); [2023/02/14 16:24:48.952] INFO Δh: min=-1.340684e-04, max=+1.454704e-04, mean=+2.980232e-08, absmean=+1.029445e-05, std=+2.835074e-05 (16384/16384 matching grid points); Shallow Water Bickley jet simulation [GPU, VectorInvar",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637:298,variab,variable,298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1430401637,4,"['Config', 'config', 'variab']","['Config', 'config', 'variable']"
Modifiability,"different in that case. That seems OK:. ```Julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; WARNING: Method definition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1073,variab,variable,1073,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,2,"['config', 'variab']","['config', 'variable']"
Modifiability,"ditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/TimeSteppers/generic_ti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:63192,Parameteriz,ParameterizedForcing,63192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,3,['Parameteriz'],['ParameterizedForcing']
Modifiability,"e change we could make would be instead write. ```Julia; ""Calculate the right-hand-side of the u-momentum equation at I, j, k.""; u_eqn(args..., F::Function i, j, k) = stuff + F(u, v, w, T, S, Nx, Ny, Nz, Δx, Δy, Δz, i, j, k); u_eqn(args..., F::AbstractArray i, j, k) = stuff + F[i, j, k]; u_eqn(args..., F::Nothing, i, j, k) = stuff. ""Store previous value of the source term and calculate current source term.""; function update_source_terms!(::Val{Dev}, fCor, χ, ρ₀, κh, κv, 𝜈h, 𝜈v, Nx, Ny, Nz, Δx, Δy, Δz,; u, v, w, T, S, pHY′, Gu, Gv, Gw, GT, GS, Gpu, Gpv, Gpw, GpT, GpS, F) where Dev; ; # ...; # u-momentum equation; @inbounds Gu[i, j, k] = u_eqn(args..., F.u, i, j, k); # ...; ```; We could write even less code if we created an abstraction for the right hand side, something like. ```Julia; struct Equation{TF}; G::Function; F::TF; end. (eq::Equation{TF})(args..., i, j, k) where TF <: Function = eq.G(args..., i, j, k) + eq.F(args..., i, j, k); (eq::Equation{TF})(args..., i, j, k) where TF <: AbstractArray = eq.G(args..., i, j, k) + eq.F(args..., i, j, k); (eq::Equation{TF})(args..., i, j, k) where TF <: Nothing = eq.G(args..., i, j, k) . u_eqn = Equation(Gu, Fu). ...; @inbounds Gu[i, j, k] = u_eqn(args..., i, j, k); ```. We can then load all the equations we have into a `FieldVector` or `LabeledArray` to make things even better and do something like . ```julia; @loop for k in (1:Nz; blockIdx().z); @loop for j in (1:Ny; (blockIdx().y - 1) * blockDim().y + threadIdx().y); @loop for i in (1:Nx; (blockIdx().x - 1) * blockDim().x + threadIdx().x); for (Gφ, i) in enumerate(G); φ_eqn = equation[i]; Gφ[i, j, k] = φ_eqn(args... i, j, k); end; end; end; end; ```. With a time-stepping kernel of that form we can easily add and subtract tracers, equations, sub grid closure variables, etc. I think the inner loop gets unrolled when the array is static, so the compiled code is no different from what we currently have. . This is somewhere down the line hopefully. Maybe v0.6... or 1.0. Heh.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470624169:2405,variab,variables,2405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470624169,1,['variab'],['variables']
Modifiability,"e code/documentation and examples of Oceananigans. When I started this issue, I wasn't really expecting to have Pacanowski-Philander parameterization implemented in a few hours. Kudos to you!!; I know this parameterization is very simple, but implementing it on a FORTRAN-based GCM from scratch would take waaaay more time, at least for me. Can you help me to see if I understood everything correctly? Please, sorry if I am asking too-trivial questions. Why you need to define `f²`, wouldn't work simply using `∂zᶠᶜᶠ` and squaring the operation?. I understand that you create a fake model and don't run it, simply use it to update the auxiliary field. I don't understand why you could not do the same for the main model. For instance, you could first create the model, define Ri and closure and then `set!` the model with this new closure and auxiliary field. Does that makes sense? I understand the in the background this might not work the way it is now. Something like this:. ```; model = HydrostaticFreeSurfaceModel(; grid, tracers=:b, buoyancy=BuoyancyTracer()). Ri = Field(KernelFunctionOperation{Center, Center, Center}(Riᶜᶜᶜ, grid, computed_dependencies=(model.velocities, model.tracers.b))). ν = ν₀ + ν₁ / (1 + c * Ri^n); κᵇ = κ₀ + κ₁ / (1 + c * Ri^(n+1)). closure = ScalarDiffusivity(VerticallyImplicitTimeDiscretization(); ν, κ=(; b=κᵇ)). set!(model, closure = closure, auxiliary_fields = (; Ri)); ```. Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. Including using any model in general that could come in a form of a function. For instance, a ML model could be simply used as a turbulence closure. Again, thanks for all attention you are giving to me. As a new user, it makes me learn more and more and maybe sometime I can also retribute by contributing to the model development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688:1817,parameteriz,parameterizations,1817,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066110688,2,['parameteriz'],['parameterizations']
Modifiability,"e easier for users to extend / add terms to an equation. As an example, we can consider a simple implementation. ```julia; struct AdvectiveFlux{S, D, C, G}; u :: D; v :: D; w :: D; c :: C; grid :: G; scheme :: S; end. getindex(adv::AdvectiveFlux{Centered}, i, j, k) = # centered advective flux calculation. struct IsotropicDiffusiveFlux{N, D, G}; ν :: N; ψ :: D; grid :: G; end. getindex(diff::IsotropicDiffusiveFlux, i, j, k) = # calculates flux due to isotropic diffusion by ν. struct RightHandSide{F, V}; fluxes :: F; volume_terms :: V; end. advection = AdvectiveFlux(velocities..., tracers.c); diffusion = IsotropicDiffusiveFlux(ν, tracers.c). tracer_rhs = RightHandSide((advection, diffusion), nothing); ```. We'd have functions that look something like. ```julia; function x_flux_divergence(i, j, k, grid, fluxes...); incoming_flux = add_fluxes(i, j, k, grid, fluxes...); outgoing_flux = add_fluxes(i+1, j, k, grid, fluxes...); return (incoming_flux - outgoing_flux) * grid.Ax / grid.V; end; ```. ... for example. Obviously questions of performance are paramount, though in the case that _everything_ is inlined I think there is hope. A downside of this approach is that we can't use shared memory stencils on the GPU. Shared memory stencils on the GPU require _functions_ for all terms that avoid carrying around internal references to data (since we need to be able to pass them references to shared memory blocks, rather than references to global memory. This is a fair rewrite of the code internals. For example, each term in the `u_velocity_tendency`:. https://github.com/climate-machine/Oceananigans.jl/blob/8e3c27504be68ca06bacc7502cd6095ae390f8c6/src/TimeSteppers/velocity_and_tracer_tendencies.jl#L24. would get it's own type. It's worth brainstorming ways to implement such abstraction incrementally so we might avoid possibly time-consuming total-code-demolishment. This is mostly food for thought at this point. I don't think we should take action without substantial consideration.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394:2086,rewrite,rewrite,2086,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259#issuecomment-600078394,1,['rewrite'],['rewrite']
Modifiability,"e the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:1106,variab,variable,1106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165,1,['variab'],['variable']
Modifiability,"e)). #Incompressible model initiation . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = GPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed. Tᵢ(x, y, z) = T0 + dTz * z + dTz * model.grid.Lz * Factor_T * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * Factor_V * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= 0.6, Δt = 0.05, max_change = 1.1, max_Δt = 0.2minute). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_n",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613:4269,adapt,adaptive,4269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613,1,['adapt'],['adaptive']
Modifiability,"e). model = NonhydrostaticModel(; grid,; advection = WENO(grid=grid, order=5),; tracers = (:b, :τ1, :τ2, :τ3), # This runs fine with one fewer tracer now; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. My actual production code is far too complicated to paste here, but the relevant forcings I'm using there are:. ```julia; const z₀ = -100; const z₂ = -120; const z₁ = -grid.Lz. @inline function bottom_mask_cos(x, y, z); if z₀ >= z > z₁; return 1/2 * (1 - cos( π*(z-z₀)/(z₁-z₀) )); elseif z₁ >= z #> z₂; return 1.0; else; return 0.0; end ; end. @inline sponge_u(x, y, z, t, u, p) = -bottom_mask_cos(x, y, z) * p.σ * u; @inline sponge_v(x, y, z, t, v, p) = -bottom_mask_cos(x, y, z) * p.σ * v; @inline sponge_w(x, y, z, t, w, p) = -bottom_mask_cos(x, y, z) * p.σ * w; @inline sponge_b(x, y, z, t, b, p) = -bottom_mask_cos(x, y, z) * p.σ * (b - b∞(0, 0, z, 0, p)). Fᵤ = Forcing(sponge_u, field_dependencies = :u, parameters = (; params.σ)); Fᵥ = Forcing(sponge_v, field_dependencies = :v, parameters = (; params.σ)); Fw = Forcing(sponge_w, field_dependencies = :w, parameters = (; params.σ)); Fb = Forcing(sponge_b, field_dependencies = :b, parameters = (; params.σ, params.N²∞)); ```. The above are the forcing functions, and below is the background field. There are also parameters passed for the boundary conditions. ```julia; @inline b_bg(x, y, z, t, p) = p.M² * x; B_field = BackgroundField(b_bg, parameters = (; params.M²)); ```. Changing things so that variables that are currently passed as parameters are set as `const`ants helps (as you can see I did with `z₀`, etc.). However, that also means I can't run back-to-back simulations where those parameters differ, which is something that makes my workflow way more streamlined, so I'm trying to avoid that. (Although I'll ultimately have to do that if we can't figure this error out...)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401329050:3056,variab,variables,3056,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401329050,1,['variab'],['variables']
Modifiability,"e-dimensional. I'm not sure I understand the point about newbie mistakes though. > I also think a user can easily infer that z in the signature can be ignored if they just defined a grid with a Flat z topology, so I think the added user-friendliness is minor. It's true that in our examples, `set!` is typically invoked close to the grid definition. But such proximity is not guaranteed. In complicated applications (say for example a realistic simulation on the globe), a grid may be constructed ""for"" the user. One case that's come up recently is coupled ocean, sea-ice simulations. For a realistic case covering the globe, the user script may well not include the creation of the grid (which would happen within a helper function like `build_global_ocean_sea_ice_simulation`). Even if the grid construction is immediately readable, I think it's still weird to read. ```julia; initial_ice_thickness(x, y, z) = 1 # meter; ```. as determining sea ice thickness --- its nonsensical for the ice thickness to depend on `z`. Ice thickness _cannot_ depend on `z`. The z topology of a slab ice model cannot be anything but `Flat`; it doesn't make sense to have a z-coordinate. That's also true for the `ShallowWaterModel`. Also there function signatures depend on `z` despite that no shallow water field can possibly depend on the third coordinate. > (Maybe even negative since the signatures now can change based on topology(grid)?). I think it's correct to observe that this change does not prioritize _writing_ scripts --- it prioritizes the experience of _reading_ scripts. I think the scripts read better with this change. The purpose of ""function notation"" is to indicate the variables on which the function depends (usually including just dependent coordinates, like `x`, `y`, or `z`). In almost all contexts, we should not include irrelevant variables in a function signature. So I feel this change brings the experience of reading Oceananigans code into better alignment with most scientific text.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405:2155,variab,variables,2155,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3285#issuecomment-1776585405,4,['variab'],['variables']
Modifiability,"e. I guess you're trying to couple an agent-based larvae model to an ocean model?. Oceananigans.jl should have the features you need I think: mainly Lagrangian particle tracking to advect the larvae around and arbitrary forced passive tracers for the odor from the reef?. I've actually been meaning to set up an example of an agent-based model coupled to Oceananigans.jl (simulating interacting ""microbes"" in the ocean). It's not fully complete yet but might give you some ideas of how to use Lagrangian particles as agents: https://github.com/CliMA/Oceananigans.jl/pull/1244. > If that works, I will implement a continuity equation to simulate the odor which comes from the reef and which is supposed to help the larvae to find back to the home reef. What is the continuity equation for the odor? It should be easy to advect the odor around as a passive tracer but just curious what the equation looks like. > Since I have found Oceananigans, which is also a CFD tool, I was wondering what you think the differences are between that and WaterLily.jl? Given my description of the project above, would you tend to use either of them?. I'm not super familiar with WaterLily.jl but it's definitely a very nice package (and a great README)!. I think WaterLily.jl has a more mature immersed boundary implementation if you need to have complex boundaries and is auto-diff friendly if you need to do some optimization/inference. @weymouth might be able to elaborate!. Oceananigans.jl has native support for Lagrangian particle tracking and might have more mature diagnostics (e.g. if you need to compute vorticity or other statistics) and more mature output writers (among other quality of life features). The examples in the docs should give a pretty good of the current set of mature features. E.g. this example shows how to add in a passive tracer for plankton and evolve it according to some (continuity?) equation: https://clima.github.io/OceananigansDocumentation/stable/generated/convecting_plankton/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1438#issuecomment-793113703:2010,evolve,evolve,2010,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1438#issuecomment-793113703,1,['evolve'],['evolve']
Modifiability,"e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas: same effect as for SSHManager, see documentation for; addprocs(machines::AbstractVector). │ Julia 1.9; │; │ The inheriting of the package environment and the env keyword argument were added in Julia 1.9.; ```. Ha",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5705,variab,variable,5705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variable']
Modifiability,"eBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₁₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Face,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₂₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}},NamedTuple{(:b,),Tuple{Field{Cell,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecisio",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1034:16377,Parameteriz,ParameterizedDiscreteBoundaryFunction,16377,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034,2,['Parameteriz'],['ParameterizedDiscreteBoundaryFunction']
Modifiability,"eananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},Int64,typeof(identity),typeof(identity),typeof(identity),RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Tuple{Int64,Int64}}}}; filepath::String, schedule::AveragedTimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:340; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[16]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/windowed_spatial_avg.jl:90; ```. Like I said, I'm not sure the best to deal with this. Should I define another separate function to deal with the `WindowedTimeAverage` case?. Also, I'm a little confused. Does this set-up only work at the moment with the NetCDF writer? Because if so, it seems to me it wouldn't be recommended to add to Oceananigans liek this, right? I think we'd want diagnostics on Oceananigans to be independent of the writing method, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:16088,sandbox,sandbox,16088,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449,2,['sandbox'],['sandbox']
Modifiability,"ec u^\star$ term having the term `u_{2jk} - u_{1jk}` at the `i=1` point (in the central difference case, I don't know where spatial operation approximations are defined in the code) change from `u_{2jk} - 0` in the no penetration case to `u_{2jk} - u_{open boundary}$. In the case where the interior velocity is already the same as the specified velocity (and everything else is uniform), this means that at `i=1` $\nabla^2 P_{non}$ changes from being positive to zero, so we go from having a pressure gradient at the wall counteracting the flow away from the wall (or I suppose a reconfiguration to `u=0` everywhere to enforce compressibility) to having no pressure gradient across the wall. . Thinking about it this is exactly what happens for periodic domains where we are essentially specifying the flow outside of the domain. That makes me think that we don't need to do anything else for time-varying inflows.; </details>. As for making the outflows more correct, I think we should be able to extend to the method for calculating ht phase velocity by the method in 3.3 of https://doi.org/10.1016/0021-9991(83)90127-4 (linked in https://github.com/CliMA/Oceananigans.jl/issues/833) which doesn't depend on previous time steps as some other Orlanski methods do, but it does depend on the time difference of the interior solution with the next step which currently does not get passed to the boundary conditions. Perhaps it might be most straightforward to evaluate $c=-\frac{\partial\phi/\partial t}{\partial\phi/\partial x}$ by passing the tendencies and using $\partial\phi/\partial t = G_n$ (although this isn't quite correct for the velocity so maybe $-\nabla P$. I think passing the tendencies automatically is going to require some materialization step when the model is setup to pass $G^n$ into the boundary conditions but I know we're trying to avoid doing that so any other suggestions would be useful. I've started testing this by initialising the timestepper first but it is a bit clums",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482:4054,extend,extend,4054,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482,1,['extend'],['extend']
Modifiability,"ed MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> u = Field{Face, Center, Center}(rectilinear_grid); 128×128×64 Field{Face, Center, Center} on RectilinearGrid on GPU; ├── grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> maximum(abs, u); 0.0. julia> v = Field{Center, Face, Center}(rectilinear_grid); 128×129×64 Field{Center, Face, Center} on RectilinearGrid on GPU; ├── grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Nothing, north: Nothi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:2380,variab,variably,2380,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,1,['variab'],['variably']
Modifiability,"eling software are implemented using a ""Generalized Vertical Coordinate"" (GVC). Generalized vertical coordinates contain a ""fixed z"" coordinate as a limiting case, but generalize to vertical coordinates that. * Are fixed in time but conform to topographic variations (`σ` coordinates);; * Vary in time in a diagnostic manner (for example, _z-star_ coordinates, which vary with the sea surface displacement);; * Vary in time according to some prognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:995,refactor,refactoring,995,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,2,"['refactor', 'variab']","['refactoring', 'variables']"
Modifiability,"ence and believe there is a problem with method 2 (evolving the total fields). . When pick there to be zero perturbations, the jet is an exact solution to the governing equations (even though it is an unstable one) and it should persist, until perturbations arise because of numerical errors. The good news is that when we use method 1, evolve the perturbations, when we pick zero perturbations, no pertrubations develop for a long time. . The not so good news, is that when we use method 2, evolve the total field, a distrubance develops right away,in the center of the jet that spans the entire depth, and this seems to radiate gravity waves to the left and right. The amplitude of the distrubance is small and it does decrease with increasing resolution but it seems problematic. I am going to include an animation that shows the problem that develops in the first 6 hours and the two codes, which are almost identical. Is there something that we are doing wrong here? @glwagner ?. Method 1: Evolve perturbations. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z, t) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z, t) = N² * z + 2*f*Umax*Lⱼ/D^2 * (tanh(y/Lⱼ)) * (z-z0) * exp(-(z-z0)^2/D^2); ; Random.seed!(25); uᵢ(x, y, z) = 0.0; bᵢ(x, y, z) = 0e-6*rand(). model = NonhydrostaticModel(; grid,; background_fields = (u=U, b=B),; coriolis = FPlane(f = f),; buoyancy = BuoyancyTracer(),; tracers = (:b,),; advection = WENO(grid=grid),; closure = VerticalScalarDiffusivity(ν=ν, κ=ν); ); set!(model, u = uᵢ, b = bᵢ). x, y, z = nodes((Center, Center, Center), grid). function progress(sim); umax =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251:1523,Evolve,Evolve,1523,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251,1,['Evolve'],['Evolve']
Modifiability,"environment variable. For this we introduce an environment variable, say `OCEANANIGANS_NUMBER_TYPE`. Then we can write a small utility:. ```julia; function global_number_type(default=Float64); user_number_type = get(""OCEANANIGANS_NUMBER_TYPE"", ENV, nothing). if isnothing(user_number_type); FT = default; else; try; FT = eval(Symbol(user_number_type)); catch; error(""The environment variable OCEANANIGANS_NUMBER_TYPE=$user_number_type is not supported!""); end; end. return FT; end; ```. This also permits a script-based approach because users can write. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for Seawater",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800:1500,variab,variables,1500,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800,1,['variab'],['variables']
Modifiability,"er.elsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any sophisticated formulation derived in a particularly idealized situation (take the example of Leith derived in homogeneous 2D turbulence and the geostrophic eddies in the ocean), and guarantees (or at least helps) stability. For this reason, it's pretty handy when you have different unresolved processes at different scales that may be characterized by different dissipation characteristi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433:1426,adapt,adapts,1426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433,2,['adapt'],['adapts']
Modifiability,"er_regression.jl:12 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:11 [inlined]; [5] macro expansion; @ /g/data/v45/nc3020/julia/usr/share/julia/stdlib/v1.6/Test/src/Test.jl:1151 [inlined]; [6] top-level scope; @ /g/data/v45/nc3020/OC.jl/test/test_shallow_water_regression.jl:6; Test Summary: | Pass Fail Total; Oceananigans | 4 2 6; Shallow Water Regression | 4 2 6; Shallow Water Bickley jet simulation [GPU, VectorInvariantFormulation] | 2 1 3; Shallow Water Bickley jet simulation [GPU, ConservativeFormulation] | 2 1 3; ERROR: LoadError: Some tests did not pass: 4 passed, 2 failed, 0 errored, 0 broken.; in expression starting at /g/data/v45/nc3020/OC.jl/test/runtests.jl:3; ERROR: Package Oceananigans errored during testing. (Oceananigans) pkg> st; Project Oceananigans v0.76.5; Status `/g/data/v45/nc3020/OC.jl/Project.toml`; [79e6a3ab] Adapt v3.3.3; [052768ef] CUDA v3.10.0; [72cfdca4] CUDAKernels v0.3.3; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.0; [ffbed154] DocStringExtensions v0.8.6; [7a1cc6ca] FFTW v1.4.6; [c27321d9] Glob v1.3.0; [40713840] IncompleteLU v0.2.0; [42fd0dbc] IterativeSolvers v0.9.2; [033835bb] JLD2 v0.4.22; [63c18a36] KernelAbstractions v0.7.2; [da04e1cc] MPI v0.19.2; [85f8d34a] NCDatasets v0.12.4; [6fe1bfb0] OffsetArrays v1.11.2; [bac558e1] OrderedCollections v1.4.1; [0e08944d] PencilArrays v0.17.2; [4a48f351] PencilFFTs v0.13.6; [6038ab10] Rotations v1.3.1; [1bc83da4] SafeTestsets v0.0.1; [d496a93d] SeawaterPolynomials v0.2.3; [09ab397b] StructArrays v0.6.7; [bc48ee85] Tullio v0.3.4; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. julia> versioninfo(); Julia Version 1.6.7; Commit 3b76b25b64* (2022-07-19 15:11 UTC); Platform Info:; OS: L",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:17669,Adapt,Adapt,17669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Adapt'],['Adapt']
Modifiability,"erent advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of grid points (per dimension?). And if we also upgrade time stepper from AB2 to something like LSRK54 then we should be able to take ~3x longer time steps. ![Gaussian_SecondOrderCentered_AB3_N64_CFL0 60](https://user-images.githubusercontent.com/20099589/72",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592:1178,extend,extending,1178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592,1,['extend'],['extending']
Modifiability,"eriodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Float64,BuoyancyTracer,FPlane{Float64},Nothing,NamedTuple{(:u, :v, :w),Tuple{Field{Face,Cell,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₁₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Face,Cell,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Oceananigans.BoundaryConditions.ParameterizedDiscreteBoundaryFunction{typeof(τ₂₃_linear_drag),NamedTuple{(:μ, :H),Tuple{Float64,Float64}}}},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularCartesianGrid{Float64,Period",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1034:15541,Parameteriz,ParameterizedDiscreteBoundaryFunction,15541,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034,2,['Parameteriz'],['ParameterizedDiscreteBoundaryFunction']
Modifiability,"es because serialization and code distribution might fail; otherwise. • exeflags: additional flags passed to the worker processes. • topology: Specifies how the workers connect to each other. Sending a message between unconnected workers results in an error.; • topology=:all_to_all: All processes are connected to each other. The default.; • topology=:master_worker: Only the driver process, i.e. pid 1 connects to the workers. The workers do not connect to each; other.; • topology=:custom: The launch method of the cluster manager specifies the connection topology via fields ident and; connect_idents in WorkerConfig. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for conne",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:4899,variab,variables,4899,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variables']
Modifiability,"es. In no particular order:. 1. Having to compile two separate models and `Simulation`s can take a long time for small runs. When your code is production-ready and you're running the final big simulations that's okay, since those extra minutes of compilation are small compared to the many hours of run. But when you're doing small exploratory simulations (which may be the majority of times you run your code), then that extra compilation time required to build an extra model, simulation, writers, etc., can increase the code run-time significantly.; 2. Since you end up compiling and running two sets of model and simulation, this ends up taking extra space which can be a problem on the GPU. (I'm not aware of any way to ""remove"" the old `Simulation` from the GPU memory, but if there is, then this downside can be negated.); 3. It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work.; 4. When outputting to NetCDF you generally need at least two files: one for the fields in the spin-up simulations and one for the extra tracers (or one NetCDF for the spin-up period and another one for the rest of the run). I'm not sure if this is also a limitation of the JLD2 writer though. I think if we implement a way to build just one model which has every tracer needed and (optionally ofc) specify start times for each tracer (before which the tracers would just not be evolved in time) it would solve all the of the problems above. The downsides that I can think of are:. 1. Simulations using this feature would possibly waste space on disk by outputting ""frozen"" tracer fields before they start evolving.; 2. One more thing in the models to test and maintain. Maybe the biggest issue is that I'm not sure this is something enough people actually want to do with their simulations. This has been a relatively common thing for my research, and I know @whitleyv does this too, but maybe we're the exception?. cc @whitleyv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154:1981,evolve,evolved,1981,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154,1,['evolve'],['evolved']
Modifiability,"escribes a time-evolving state. In this case, parent velocities and tracers are specified at each point in space and time -- both on the boundary, and inside the ""child"" `NonhydrostaticModel` domain. We can imagine that this case would involve a utility that takes in the parent state (or a filename / list of filenames) and returns boundary conditions on velocities and tracers. The utility might also return forcing functions that prescribe a sponge layer that relaxes the model solution to the parent state near the boundary, like [MITgcm's ""relaxation boundary conditions"" package](https://mitgcm.readthedocs.io/en/latest/phys_pkgs/rbcs.html). As for how the boundary conditions work, an arbitrary parent state will dictate wall-normal velocities that are variously either inward or outward (fluxing information out of the domain). Somehow, the inflow / outflow specified by the parent state has to be reconciled with the model state. The discussion on this PR seems to suggest that the outflow velocity used by the boundary condition may need to be _different_ than what is specified by the parent state (otherwise, why would we need to ""compute"" an outflow velocity?). But I don't understand anything further than that. I also don't understand the implications of a sponge layer, which almost certainly seems required. . 2. Constant or idealized inflows and outflows. This seems to be the case in the movie on the original post and also of @simone-silvestri 's movie. On one (or more?) boundaries, an inflow state is prescribed. The inflow boundaries could use 1) `OpenBoundaryCondition` on both velocities and tracers, or 2) `OpenBoundaryCondition` for velocities and `ValueBoundaryCondition` on tracers. The second case would be used when attempting to prescribe the tracer fluxes precisely. There are also outflow boundaries, which either have a prescribed outflow velocity, a computed-yet-still-spatially-uniform bulk outflow velocity, or a computed and spatially-variable outflow velocity?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979894207:2130,variab,variable,2130,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1979894207,1,['variab'],['variable']
Modifiability,"existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then output writer constructors can search for this environment variable and override `overwrite_existing` (with a warning?) in the output writer constructor. ""pickup mode"" has other usability benefits (ie it's annoying we have to change the run script / prepare the run script to be ""pickup"" aware: pickup mode avoids this so we can toggle to pickup mode from _outside_ the run script without internal changes) and also obviates the need to separate output writer constructor from output writer ""initialization"". 2. If we ""delay"" output writer construction, we can also extract the option ""overwrite_existing"" and put it elsewhere (eg as a global option `overwrite_existing_output` for all output writers in `run!`). This makes a stronger connection between `pickup` and `overwrite_existing`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:2279,variab,variable,2279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,2,['variab'],['variable']
Modifiability,f2h/lib/pkgconfig:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/lib/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib64/pkgconfig:/glade/u/apps/casper/23.10/opt/view/lib/pkgconfig; INFOPATH = :/glade/u/apps/casper/23.10/opt/view/share/info:/usr/local/share/info:/usr/share/info; NCAR_LDFLAGS_JULIA = /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.9.2/gcc/7.5.0/mjea/lib; NCAR_LDFLAGS_HDF5 = /glade/u/apps/casper/23.10/spack/opt/spack/hdf5/1.12.2/oneapi/2023.2.1/6vf2/lib; NCAR_WRAPPER_MPI_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/ncarcompilers/1.0.0/oneapi/2023.2.1/mai6/bin/mpi; __LMOD_STACK_LMOD_PACKAGE_PATH = L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==:L2dsYWRlL3dvcmsvY3NndGVhbS9zcGFjay1kZXBsb3ltZW50cy9jYXNwZXIvMjMuMTAvZW52cy9wdWJsaWMvdXRpbA==; ```; and the status check message gave me:; ```; Status `~/.julia/environments/v1.9/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; [79e6a3ab] Adapt v4.0.4; ⌅ [4fba245c] ArrayInterface v7.7.1; [a9b6321e] Atomix v0.1.0; [ab4f0b2a] BFloat16s v0.5.0; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.4.3; [1af6417a] CUDA_Runtime_Discovery v0.3.4; [d360d2e6] ChainRulesCore v1.24.0; [3da002f7] ColorTypes v0.11.5; [5ae59095] Colors v0.12.11; [1fbeeb36] CommonDataModel v0.3.6; [34da2185] Compat v4.15.0; [187b0558] ConstructionBase v1.5.5; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.20; [e2d170a0] DataValueInterfaces v1.0.0; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [e2ba6199] ExprTools v0.1.10; [7a1cc6ca] FFTW v1.8.0; [5789e2e9] FileIO v1.16.3; [53c48c17] FixedPointNumbers v0.8.5; [0c68f7d7] GPUArrays v10.2.3; [46192b85] GPUArraysCore v0.1.6; [61eb1bfa] GPUCompiler v0.26.7; [c27321d9] Glob v1.3.1; [615f187c] IfElse v0.1.1;,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:16102,Adapt,Adapt,16102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['Adapt'],['Adapt']
Modifiability,"f5c54c55a7a9a3aa42bf931c72aa""; uuid = ""85f8d34a-cbdd-5861-8df4-14fed0d494ab""; version = ""0.11.3"". [[NNlib]]; deps = [""Adapt"", ""ChainRulesCore"", ""Compat"", ""LinearAlgebra"", ""Pkg"", ""Requires"", ""Statistics""]; git-tree-sha1 = ""80b8360670f445d88b3475e88b33bbcc92f7866e""; uuid = ""872c559c-99b0-510c-b3b7-b6c96a88d5cd""; version = ""0.7.19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; version = ""0.56.0"". [[OffsetArrays]]; deps = [""Adapt""]; git-tree-sha1 = ""87a728aebb76220bd72855e1c85284c5fdb9774c""; uuid = ""6fe1bfb0-de20-5000-8ca7-80f57d26f881""; version = ""1.7.0"". [[OpenMPI_jll]]; deps = [""Libdl"", ""Pkg""]; git-tree-sha1 = ""41b983e26a7ab8c9bf05f7d70c274b817d541b46""; uuid = ""fe0851c0-eecd-5654-98d4-656369965a5c""; version = ""4.0.2+2"". [[OpenSSL_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""71bbbc616a1d710879f5a1021bcba65ffba6ce58""; uuid = ""458c3c95-2e84-50aa-8efc-19380b2a3a95""; version = ""1.1.1+6"". [[OpenSpecFun_jll]]; deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""9db77584158d0ab52307f8c04f8e7c08ca76b5b3""; uuid = ""efe28fd5-8261-553b-a9e1-b2916fc3738e""; version",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:11070,Adapt,Adapt,11070,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,fd0dbc] IterativeSolvers v0.9.4; [033835bb] JLD2 v0.4.46; [63c18a36] KernelAbstractions v0.9.18; [da04e1cc] MPI v0.20.19; [3da0fdf6] MPIPreferences v0.1.10; [85f8d34a] NCDatasets v0.14.3; [9e8cae18] Oceananigans v0.90.11 `~/Research/OC11.jl`; [6fe1bfb0] OffsetArrays v1.13.0; [bac558e1] OrderedCollections v1.6.3; [0e08944d] PencilArrays v0.19.3; [4a48f351] PencilFFTs v0.15.1; [91a5bcdd] Plots v1.40.2; [6038ab10] Rotations v1.7.0; [1bc83da4] SafeTestsets v0.1.0; [d496a93d] SeawaterPolynomials v0.3.4; [09ab397b] StructArrays v0.6.18; [a759f4b9] TimerOutputs v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [124859b0] DataDeps v0.7.13; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.18; [e2d170a0] DataValueInterfaces v1.0.0; [8bb1440f] DelimitedFiles v1.9.1; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:2033,Adapt,Adapt,2033,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Adapt'],['Adapt']
Modifiability,for the GPU config you can see the hardware it is being run on here:; https://buildkite.com/clima/oceananigans-central/builds/8#5ef96bf8-7b5f-47d3-84fd-726b4cb3fc33/9-11,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906765232:12,config,config,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906765232,1,['config'],['config']
Modifiability,"fsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},Array{Int64,1},Array{Periodic,1},Int64,Nothing,Nothing},Oceananigans.Solvers.DiscreteTransform{Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing,Nothing}}}}},Nothing,NamedTuple{(:velocities, :tracers),Tuple{NamedTuple{(:u, :v, :w),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}},NamedTuple{(:T, :S),Tuple{Oceananigans.Fields.ZeroField,Oceananigans.Fields.ZeroField}}}},Nothing,Nothing},TimeStepWizard{Float64},Array{Any,1},Float64,Float64,Float64,Float64,OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractDiagnostic},OrderedCollections.OrderedDict{Symbol,Oceananigans.AbstractOutputWriter},typeof(print_progress),Int64,Nothing}) at /home/tomas/repos2/Oceananigans.jl/src/Simulations/run.jl:127; [7] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; [8] include(::String) at ./client.jl:457; [9] top-level scope at REPL[1]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:48; ```. This is the MWE I'm running:. ```julia; using Oceananigans; using Oceananigans.Units. const Nx = 128; const Lx = 500; const Nz = 32; const Lz = 100. topo = (Periodic, Periodic, Bounded); S = 1.5; zF(k) = Lz*(1 + tanh(S * ( (k - 1) / Nz - 1)) / tanh(S)); grid = VerticallyStretchedRectilinearGrid(topology=topo,; architecture = CPU(),; size=(Nx, 1, Nz), ; x=(0, Lx), y=(0, 6*Lx/Nx), zF=zF,; halo=(3,3,3)); ; ; model = IncompressibleModel(grid = grid,; ); ; wizard = TimeStepWizard(Δt=0.1); print_progress(sim) = @info ""iteration: $(sim.model.clock.iteration), time: $(prettytime(sim.model.clock.time))""; simulation = Simulation(model, Δt=wizard,; stop_time=10days,; progress=print_progress,; iteration_interval=10,; ). run!(simulation); ```. The bug in question seems to be in the `cell_advection_timescale` routine: htt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1465:51286,sandbox,sandbox,51286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1465,1,['sandbox'],['sandbox']
Modifiability,"g, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, LX::Center, LY::Center, LZ::Nothing, grid::RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, CPU}, x::Float64, y::Float64, z::Int64); @ Oceananigans.Fields ~/.julia/packages/Oceananigans/ususO/src/Fields/interpolate.jl:187; [5] top-level scope; @ REPL[19]:1; ```. It doesn't really make sense to have to pass a `z` location into `interpolate`. I think we should refactor this function to read something like. ```julia; interpolate(to_node, from_field, from_location, from_grid); ```. Then `to_node` can be a tuple of appropriate length for the `from_location` and `from_grid` topology.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356:2908,refactor,refactor,2908,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356,1,['refactor'],['refactor']
Modifiability,"g. A worker with a cluster manager identity ident will connect to all workers specified in; connect_idents. • lazy: Applicable only with topology=:all_to_all. If true, worker-worker connections are setup lazily, i.e. they are setup at the first; instance of a remote call between workers. Default is true. • env: provide an array of string pairs such as env=[""JULIA_DEPOT_PATH""=>""/depot""] to request that environment variables are set on the; remote machine. By default only the environment variable JULIA_WORKER_TIMEOUT is passed automatically from the local to the remote; environment. • cmdline_cookie: pass the authentication cookie via the --worker commandline option. The (more secure) default behaviour of passing the; cookie via ssh stdio may hang with Windows workers that use older (pre-ConPTY) Julia or Windows versions, in which case; cmdline_cookie=true offers a work-around. │ Julia 1.6; │; │ The keyword arguments ssh, shell, env and cmdline_cookie were added in Julia 1.6. Environment variables:. If the master process fails to establish a connection with a newly launched worker within 60.0 seconds, the worker treats it as a fatal; situation and terminates. This timeout can be controlled via environment variable JULIA_WORKER_TIMEOUT. The value of JULIA_WORKER_TIMEOUT on the; master process specifies the number of seconds a newly launched worker waits for connection establishment. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(np::Integer=Sys.CPU_THREADS; restrict=true, kwargs...) -> List of process identifiers. Launch np workers on the local host using the in-built LocalManager. Local workers inherit the current package environment (i.e., active project, LOAD_PATH, and DEPOT_PATH) from the main process. Keyword arguments:. • restrict::Bool: if true (default) binding is restricted to 127.0.0.1. • dir, exename, exeflags, env, topology, lazy, enable_threaded_blas",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:5483,variab,variables,5483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['variab'],['variables']
Modifiability,"githubusercontent.com/33547697/225382686-301b4f32-73b5-40a3-b5e3-74c52fa189f1.png). ~left is `k = grid.Nz-1` and right is `k = grid.Nz`. `grid.Nz-1` seems to be correct, while `grid.Nz` is completely off.; This is the code I used to generate the regridded data~. ```; using ClimaOcean; using ClimaOcean.DataWrangling; using Oceananigans ; using Oceananigans.BoundaryConditions; using DataDeps; using GLMakie; using JLD2 . regrid_in_z = true. path = ""https://github.com/CliMA/OceananigansArtifacts.jl/raw/ss/new_hydrostatic_data_after_cleared_bugs/quarter_degree_near_global_input_data/"". dh = DataDep(""quarter_degree_near_global_lat_lon"",; ""Forcing data for global latitude longitude simulation"",; path * ""z_faces-50-levels.jld2""; ). DataDeps.register(dh). datadep""quarter_degree_near_global_lat_lon"". datadep_path = @datadep_str ""quarter_degree_near_global_lat_lon/z_faces-50-levels.jld2""; file_z_faces = jldopen(datadep_path); z_faces = file_z_faces[""z_faces""][3:end];. file_init = jldopen(""evolved-initial-conditions-1105days.jld2""). # A spherical domain; grid12 = LatitudeLongitudeGrid(size = (4320, 1800, 48),; longitude = (-180, 180),; latitude = (-75, 75),; z = z_faces,; precompute_metrics = true). T12 = set!(CenterField(grid12), file_init[""T""]); S12 = set!(CenterField(grid12), file_init[""S""]). @inline exponential_profile(z; Lz, h) = (exp(z / h) - exp( - Lz / h)) / (1 - exp( - Lz / h)) . function exponential_z_faces(Nz, Depth; h = Nz / 4.5). z_faces = exponential_profile.((1:Nz+1); Lz = Nz, h). # Normalize; z_faces .-= z_faces[1]; z_faces .*= - Depth / z_faces[end]; ; z_faces[1] = 0.0. return reverse(z_faces); end. Depth = - grid12.Lz. @info ""start regridding in Z!!""; grid12z = LatitudeLongitudeGrid(size = (4320, 1800, 120),; longitude = (-180, 180),; latitude = (-75, 75),; z = exponential_z_faces(120, Depth),; precompute_metrics = true). T12z = CenterField(grid12z); S12z = CenterField(grid12z). using Oceananigans.Fields: regrid!; fill_halo_regions!((T12, S12)); regrid!(T12z, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2881#issuecomment-1470377304:1213,evolve,evolved-initial-conditions-,1213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2881#issuecomment-1470377304,1,['evolve'],['evolved-initial-conditions-']
Modifiability,"global tracer conservation for the hydrostatic lock-release configuration in `validation/moving_coordinate/z_star_lock_release.jl`. Better than the z-coordinate but still not machine-precision conserving. <img width=""289"" alt=""Screenshot 2023-12-21 at 11 00 02 AM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/33547697/e7f913c5-07e6-47ab-a391-24af71ea65a5"">",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201:60,config,configuration,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3411#issuecomment-1865979201,1,['config'],['configuration']
Modifiability,"h`.; * Probably `MultiArch` should take a similar approach as the grid constructor; ie we can't distribute a grid in `Flat` directions, so `ranks` should be a 2-tuple for 2D topology, 1-element for 1D topology.; * We might want some functions for `arch` (and also `grid`, `model`, `sim`):; * `communicator(grid)` returns eg `MPI.COMM_WORLD`; * `local_rank(grid)` returns eg `MPI.Comm_rank(communicator(grid))` (or maybe just `rank(grid)`, or something); * This is maybe not our scope (belongs more to `MPI.jl`) but it does seem like it'd be nice to have a macro that a) prints normally for non-mpi and b) prints just from rank 0 if using MPI. That way we only have to change `arch` when switching from single-process runs to distributed runs.; * We need `Base.summary(::MultiArch)` so logs don't get mutilated; * How should reductions behave? Should `mean` over all dims reduce everything, or should we do a local reduction (as we do now?) Perhaps we want a special `mean` for `DistributedField`, and `mean(interior(field))` can still be used for local reductions? We already have to redefine any reductions on `Field`, so it makes sense that we further extend for `Field` on `MultiArch`; * `ReducedField` across the partition is also hard. We can reduce only locally, which could be fine for output in some cases. But if `ReducedField` are used in `AbstractOperation` we clearly need to gather and scatter for that to work. Probably the right thing is to implement gather and scatter by default, and then to add features for ""local `ReducedField` that could maybe be used to optimize I/O performance for the biggest problems. Note: a macro / logger manipulation that avoids ""extra"" logging for distributed simulations might actually be essential because Oceananigans is pretty chatty:. ```; ┌ Warning: defaulting to uniform WENO scheme with Float64 precision, use WENO5(grid = grid) if this was not intended; └ @ Oceananigans.Advection ~/Projects/Oceananigans.jl/src/Advection/weno_fifth_order.jl:14",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2349:1708,extend,extend,1708,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2349,1,['extend'],['extend']
Modifiability,"hat sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?. I think so, but I also don't think that you can guarantee this problem won't ever occur. The presence of the buoyancy does somehow impact the divergence that accumulates during a time-step / the pressure correction that has to be applied. So it's possible that the buoyancy configuration affects these results. Not sure.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025:2335,config,configuration,2335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025,2,['config'],['configuration']
Modifiability,"he context of this theory (in other contexts, the drag coefficient is a non-dimensional number that characterizes the bulk drag on an object and in that case its more appropriate). But anyways. When the distance is fixed (ie when we evaluate this on a fixed mesh) --- and the roughness length is given --- then it's a constant. The roughness length is not always constant. Above a wavy free surface, we often use the Charnock relation $\ell = c_g u_\star^2 / g$ where $g$ is gravitational acceleration and $c_g$ is the Charnock parameter, often taken to be $c_g = 0.011$. Above a _smooth_ surface, laboratory measurements indicate $\ell = 0.11 \nu / u_\star$ (the reference for this is hard to pin down, but it dates to laboratory experiments in the 1930s, see [Turbulent transfer near the interface from ""Atmosphere-Ocean interaction""](https://academic.oup.com/book/42082/chapter-abstract/355996383?redirectedFrom=fulltext) by Kraus and Businger). With this background let's talk about how these parameterizations might be implemented in Oceananigans... ## Constant roughness case. For an isotropic grid, _constant roughness length_ case --- a lot of simplification! --- we have to write something like. ```julia; using Oceananigans.Operators: ℑxyᶠᶜᵃ, ℑxyᶜᶠᵃ, ℑxzᶠᵃᶜ, ℑxzᶜᵃᶠ, ℑyzᵃᶠᶜ, ℑyzᵃᶜᶠ. @inline ϕ²(i, j, k, grid, ϕ) = @inbounds ϕ[i, j, k]^2; @inline speedᶠᶜᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(u[i, j, k]^2 + ℑxyᶠᶜᵃ(i, j, k, grid, ϕ², v) + ℑxzᶠᵃᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶠᶜ(i, j, k, grid, u, v, w) = @inbounds sqrt(v[i, j, k]^2 + ℑxyᶜᶠᵃ(i, j, k, grid, ϕ², u) + ℑyzᵃᶠᶜ(i, j, k, grid, ϕ², w)); @inline speedᶜᶜᶠ(i, j, k, grid, u, v, w) = @inbounds sqrt(w[i, j, k]^2 + ℑxzᶜᵃᶠ(i, j, k, grid, ϕ², u) + ℑyzᵃᶜᶠ(i, j, k, grid, ϕ², v)); @inline u_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.u[i, j, k] * speedᶠᶜᶜ(i, j, k, grid, f.u, f.v, f.w); @inline v_drag(i, j, k, grid, clock, f, cᴰ) = @inbounds - cᴰ * f.v[i, j, k] * speedᶜᶠᶜ(i, j, k, grid, f.u, f.v, f.w); @inline w_d",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3807:2450,parameteriz,parameterizations,2450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3807,1,['parameteriz'],['parameterizations']
Modifiability,"he source code. As for the source code and the topic of this issue, I think it will be generally impossible to include the diffusivity fields in the model fields. First of all, closures and diffusivity fields can be user defined. We want people to be free to do creative things in closure design without having to worry about whether trying to merge the diffusivity fields into `model_fields` will cause their model to fail to compile, preventing them from doing work. However, it might be possible to ""whitelist"" some fields when the situation calls for it, like the eddy diffusivities in LES closures. For that we need to introduce a new function, something like `nonhydrostatic_fields` (mirroring the `hydrostatic_fields` we have now for the `HydrostaticFreeSurfaceModel`) which, unlike `fields`, is more low-level and not user facing. Then this function can be designed to take `closure` as an argument to support the inclusion of diffusivity fields where appropriate, something like. ```julia; @inline nonhydrostatic_model_fields(closure, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields) # fallback. @inline nonhydrostatic_model_fields(::SmagorinskyLilly, velocities, tracers, aux_fields, diffusivity_fields) =; merge(velocities, tracers, aux_fields, (; νₑ=diffusivity_fields.νₑ)) # desired behavior; ```. then we can use that in the tendency kernel functions. I think this would probably succeed because we can simply omit the closures with too-complex diffusivity fields. It might require a bit more work for closure tuples though. It's an interesting idea for a contribution. But note that the current ways to solve this problem (creating a new field for the forcing, and then utilizing callbacks to compute the needed field during time stepping) are fairly straightforward and also generalize to much more complex situations that I'm not sure it makes sense to go down the rabbit hole of extending `model_fields` to cover more exotic situations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095180262:2450,extend,extending,2450,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3582#issuecomment-2095180262,2,['extend'],['extending']
Modifiability,"hich accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:3027,variab,variables,3027,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,3,"['evolve', 'variab']","['evolve', 'variables']"
Modifiability,"hm described by Makhoul (1982) as CUFFT does not provide cosine transforms for the GPU and does not support FFTs along non-batched dimensions (see https://github.com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three 1D transforms is ~15% slower than doing one 3D transform. So it makes sense to batch transforms when possible. Note than FFT along dimension 1 is the fastest and FFT along dimension 2 is the slowest. FFT along dimension 3 is in the middle. So whatever FFTW is doing under the hood, FFTs along non-batched dimensions (e.g. along dimension 2) are slow. ```; ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:1419,extend,extend,1419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['extend'],['extend']
Modifiability,"hmmm I cannot reproduce the bug; ```; julia> underlying_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded), ; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> . julia> . julia> const H_deep = H = underlying_grid.Lz; 2.9999999999999996. julia> const H_shelf = h = 0.5; 0.5. julia> const width_shelf = 100; 100. julia> . julia> shelf(x, y) = -(H + h)/2 - (H - h)/2 * tanh(y / width_shelf); shelf (generic function with 1 method). julia> bathymetry(x, y) = shelf(x, y); bathymetry (generic function with 1 method). julia> . julia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-2.99e+00, max(h)=0.00e+00); ├── underlying_grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> u = XFaceField(grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:487,variab,variably,487,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152,1,['variab'],['variably']
Modifiability,"how about if we make it to something like. ```julia; julia> b′b′; mean! over dims (1,) of BinaryOperation at (Center, Center, Center); └── operand: BinaryOperation at (Center, Center, Center); call b′b′.operand to see the operation tree; └── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ```. I tried but I can't seem to be able to get the variable name as a string, e.g., a string with `""b′b′""` for this case.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073153192:384,variab,variable,384,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2365#issuecomment-1073153192,1,['variab'],['variable']
Modifiability,https://github.com/ali-ramadhan/Oceananigans.jl/blob/a41c604e9360ba79ce11efe6d4d6370bf79a3cc6/src/model.jl#L1. It would make model construction much more flexible. Would this hinder performance?,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/42:154,flexible,flexible,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/42,1,['flexible'],['flexible']
Modifiability,"https://painterqubits.github.io/Unitful.jl/stable/. The obvious use case would be to replace the units (e.g. `minutes` and `years`) in `Oceananigans.Utils` with ""proper units"" from Unitful.jl. Not sure if we want to use it absolutely everywhere. Would be cool and there should be no performance hit, but might take quite a bit of refactoring. Could also be useful for defining constants in examples and scripts? Might be cool to play around with it a bit. Apparently @alanedelman is gonna be making fun of us for not using it.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1116:330,refactor,refactoring,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1116,1,['refactor'],['refactoring']
Modifiability,"ia so not sure I interpret the error correctly. I tried removing Oceananigans and all dependencies, installing CuArrays first and then adding Oceananigans, but I get the same problem doing things in that order. ```; ERROR: Unsatisfiable requirements detected for package CuArrays [3a865a2d]:; CuArrays [3a865a2d] log:; ├─possible versions are: [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2] or uninstalled; ├─restricted to versions * by an explicit requirement, leaving only versions [0.2.1, 0.3.0, 0.4.0, 0.5.0, 0.6.0-0.6.2, 0.7.0-0.7.3, 0.8.0-0.8.1, 0.9.0-0.9.1, 1.0.0-1.0.2, 1.1.0, 1.2.0-1.2.1, 1.3.0, 1.4.0-1.4.7, 1.5.0, 1.6.0, 1.7.0-1.7.3, 2.0.0-2.0.1, 2.1.0, 2.2.0-2.2.2]; ├─restricted by compatibility requirements with Adapt [79e6a3ab] to versions: [0.2.1, 0.3.0] or uninstalled, leaving only versions: [0.2.1, 0.3.0]; │ └─Adapt [79e6a3ab] log:; │ ├─possible versions are: [0.3.0-0.3.1, 0.4.0-0.4.2, 1.0.0-1.0.1, 1.1.0, 2.0.0-2.0.2] or uninstalled; │ └─restricted to versions 2 by Oceananigans [9e8cae18], leaving only versions 2.0.0-2.0.2; │ └─Oceananigans [9e8cae18] log:; │ ├─possible versions are: 0.30.0 or uninstalled; │ └─Oceananigans [9e8cae18] is fixed to version 0.30.0; ├─restricted by compatibility requirements with GPUArrays [0c68f7d7] to versions: 0.2.1 or uninstalled, leaving only versions: 0.2.1; │ └─GPUArrays [0c68f7d7] log:; │ ├─possible versions are: [0.3.0-0.3.4, 0.4.0-0.4.2, 0.5.0, 0.6.0-0.6.1, 0.7.0-0.7.2, 1.0.0-1.0.4, 2.0.0-2.0.1, 3.0.0-3.0.1, 3.1.0, 3.2.0, 3.3.0, 3.4.0-3.4.1, 4.0.0] or uninstalled; │ └─restricted by compatibility requirements with CUDA [052768ef] to versions: 4.0.0; │ └─CUDA [052768ef] log:; │ ├─possible versions are: [0.1.0, 1.0.0-1.0.2, 1.1.0] or uninstalled; │ └─restricted to versions 1 by Oceananigans [9e8cae18], leaving only versions [1.0.0-1.0.2, 1.1.0]; │ └─Oceananigans [9e8cae18] log: ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/796:1556,Adapt,Adapt,1556,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/796,1,['Adapt'],['Adapt']
Modifiability,"ical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:1023,config,configured,1023,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['config'],['configured']
Modifiability,"iff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fY29udmVjdGlvbl93aXRoX3BsYW5rdG9uLmps) | `0.00% <0.00%> (ø)` | |; | [examples/ocean\_wind\_mixing\_and\_convection.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-ZXhhbXBsZXMvb2NlYW5fd2luZF9taXhpbmdfYW5kX2NvbnZlY3Rpb24uamw=) | `0.00% <0.00%> (ø)` | |; | [src/AbstractOperations/AbstractOperations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9BYnN0cmFjdE9wZXJhdGlvbnMuamw=) | `50.00% <ø> (ø)` | |; | [src/AbstractOperations/derivatives.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9kZXJpdmF0aXZlcy5qbA==) | `88.88% <ø> (ø)` | |; | [src/AbstractOperations/show\_abstract\_operations.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0Fic3RyYWN0T3BlcmF0aW9ucy9zaG93X2Fic3RyYWN0X29wZXJhdGlvbnMuamw=) | `16.66% <ø> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <ø> (ø)` | |; | [src/BoundaryConditions/show\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0.00% <ø> (ø)` | |; | [src/Fields/show\_fields.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree#diff-c3JjL0ZpZWxkcy9zaG93X2ZpZWxkcy5qbA==) | `0.00% <ø> (ø)` | |; | ... and [41 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/989?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002:2489,parameteriz,parameterized,2489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989#issuecomment-699576002,1,['parameteriz'],['parameterized']
Modifiability,"igansDocumentation/stable/simulation_tips/#Arrays-in-GPUs-are-usually-different-from-arrays-in-CPUs) section of the docs probably needs updating. For example it says. > For example, if can be difficult to just view a CuArray since Julia needs to access its elements to do that. Consider the example below:. This example is contrived though; the problem is that the `show` method for `OffsetArrays` has scalar indexing. But the `show` method for `CuArray` works fine, so. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(GPU(), size=(1, 1, 1), extent=(1, 1, 1), halo=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on GPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> c.data.parent; 3×3×3 CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}:; [:, :, 1] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 2] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0. [:, :, 3] =; 0.0 0.0 0.0; 0.0 0.0 0.0; 0.0 0.0 0.0; ```. The example also creates a `model` which is probably overkill, a `Field` would do. Also, the example uses. ```julia; julia> adapt(Array, model.velocities.u.data); ```. To show an array on CPU. But we have a built-in method `on_archiecture(CPU(), field)` that would probably be better to use, since its more flexible and also generalizes to distributed architectures, etc...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3594:1804,adapt,adapt,1804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3594,2,"['adapt', 'flexible']","['adapt', 'flexible']"
Modifiability,"iguration/. * Configuring SLURM correctly may also require some trial and error, because the documentation is unclear and there are a huge number of options. I can't figure out if the documentation is wrong, in fact, or if instead the engaging cluster does not support some options. Either way, a small test script like. ```julia; using MPI. MPI.Init(); @show MPI.Comm_rank(MPI.COMM_WORLD); @show MPI.Comm_size(MPI.COMM_WORLD); ```. Is helpful for debugging. Also, I recommend first trying to start jobs interactively before using `sbatch`. Interactive jobs launch faster, so we get a faster trial-error iteration. I'm still working on things, but it seems like another point may be salient:. * Initialize / precompile outside of a parallel job before trying to launch a parallel job via `mpiexec`. Here are some notes that may be specific to engaging:. I'm using `srun` to get a 4-GPU node to use interactively:. ```; srun -p my_partition --tasks-per-node=4 --cpus-per-task=32 --gres=gpu:4 --gpus-per-node=4 --mem=0 -t 01:00:00 -N 1; ```. it seems we have to use the option `gpus-per-node`, rather than setting the total number of GPUs. Also we redundantly also have to specify `gres=gpu:4` (`gres` stands for ""generalized resource""). Why `gres` can't tell what `gpus-per-node` is, I don't know. `-N 1` means 1 node. Finally we also have to specify ``--tasks-per-node=4` (matching `gres` _and_ the number of GPUs per node), otherwise we cannot launch `mpiexec` with 4 tasks (1 for each GPU). It's helpful to have the maximum number of CPUs for precompilation. Otherwise precompilation is very slow. I also set. ```; export JULIA_NUM_PRECOMPILE_TASKS=64; ```. (half the total) --- adapt for your system. Here is also a small test script for debuggin Oceananigans:. ```julia; using Oceananigans; arch = Distributed(GPU()); @show arch; ```. as a side note, it would be nice if we could print to the screen from different ranks without them talking over one another. It makes it hard to read the output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436:2248,adapt,adapt,2248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3698#issuecomment-2389107436,2,['adapt'],['adapt']
Modifiability,"imilar).; >; > What does the jargon ""sounding"" mean?; >; > Merger means we need to think carefully about how to reduce boilerplate to; > minimize (within reason) the cost of maintaining two parallel models as we; > develop their shared subcomponents.; >; > I wonder if splitting off the output writers and diagnostics into a; > Simulation type that wraps AbstractModel may help. In this paradigm, a; > ""Model"" is reduced to numerics + physics specification. This would be easy; > to implement (while I think an Equation abstraction would be relatively; > difficult due to myriad difficult design problems, including the; > abstraction of tuples of terms with heterogeneous function signatures; > numerical aspects of the equation, implicit vs explicit treatment of terms,; > etc).; > The Simulation type can then be used to ""run"" simulations over multiple; > time steps, eg; >; > simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); > run!(simulation); >; > and is tasked with managing things like output writing, diagnostics; > calculation, adaptive time-stepping, and progress logging. Each Model; > then simply needs to define a function that performs a single time-step to; > interface with Simulation. This is discussed further in #447; > <https://github.com/climate-machine/Oceananigans.jl/issues/447>. Such a; > orthogonalization of the code means we can develop the Simulation; > abstraction without having to worry about updating each AbstractModel; > individually.; >; > —; > You are receiving this because you commented.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/605?email_source=notifications&email_token=AKXUEQRA7COBFTVWBSDE3ATRALQCRA5CNFSM4KNLLK52YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGOEKLF25Y#issuecomment-580279671>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQSOSWBJGZJKTTSGCZ3RALQCRANCNFSM4KNLLK5Q>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805:2180,adapt,adaptive,2180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580309805,1,['adapt'],['adaptive']
Modifiability,"in general. We currently handle this only during time-stepping --- there is no guarantee, for example, that the diffusivities or ghost cell values are consistent with the velocity field if the velocity field is set by the function `set!` (in fact, the diffusivities are *always* inconsistent with the current velocity field due to the fact that they are calculated *prior* to taking a time-step). If we want to guarantee such a consistency, we can develop the concept of a model ""state"" and apply it to both ocean and atmospheric models (eg a function `update_state!(model)`, or something similar). What does the jargon ""sounding"" mean?. Merger means we need to think carefully about how to reduce boilerplate to minimize (within reason) the cost of maintaining two parallel models as we develop their shared subcomponents. I wonder if splitting off the output writers and diagnostics into a `Simulation` type that wraps `AbstractModel` may help. In this paradigm, a ""Model"" is reduced to numerics + physics specification. This would be easy to implement (while I think an `Equation` abstraction would be relatively difficult due to myriad difficult design problems, including the abstraction of tuples of terms with heterogeneous function signatures, numerical aspects of the equation, implicit vs explicit treatment of terms, etc).; The `Simulation` type can then be used to ""run"" simulations over multiple time steps, eg. ```julia; simulation = Simulation(model, Δt=1.0, end_time=8day, output=output_writers, diagnostics=diagnostics); run!(simulation); ```. and is tasked with managing things like output writing, diagnostics calculation, adaptive time-stepping, and progress logging. Each `Model` then simply needs to define a function that performs a single time-step to interface with `Simulation`. This is discussed further in #447. Such a orthogonalization of the code means we can develop the `Simulation` abstraction without having to worry about updating each `AbstractModel` individually.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671:1960,adapt,adaptive,1960,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605#issuecomment-580279671,1,['adapt'],['adaptive']
Modifiability,"in my opinion no, it's fine to have an `MPI.Init()` if the script directly uses MPI variables. It is more explicit. The other option to not use MPI variables is to hardcode the number of processors",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890582696:84,variab,variables,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1890582696,2,['variab'],['variables']
Modifiability,"inition next_stream() in module CUDAKernels at /g/data/v45/nc3020/.julia/packages/CUDAKernels/kCOA4/src/CUDAKernels.jl:33 overwritten in module Architectures at /g/data/v45/nc3020/Oceananigans.jl/src/Architectures.jl:23.; ** incremental compilation may be fatally broken for this module **. [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf'; [NVBLAS] Cannot open default config file 'nvblas.conf'; [NVBLAS] Config parsed; [NVBLAS] CPU Blas library need to be provided; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI /g/data/v45/nc3020/.julia/packages/MPI/08SPr/deps/deps.jl:15; [ Info: Oceananigans will use 48 threads. julia> using Oceananigans.ImmersedBoundaries: ImmersedBoundaryGrid, GridFittedBottom. julia> Lx, Ly, Lz = 500, 600, 3; (500, 600, 3). julia> Nx, Ny, Nz = 128, 128, 64; (128, 128, 64). julia> σ = 1.04 # linear stretching factor; 1.04. julia> linearly_spaced_faces(k) = - Lz * (1 - σ^(1 - k + Nz)) / (1 - σ^Nz); linearly_spaced_faces (generic function with 1 method). julia> rectilinear_grid = RectilinearGrid(GPU(),; topology = (Periodic, Bounded, Bounded),; size = (Nx, Ny, Nz),; x = (-Lx/2, Lx/2),; y = (-Ly/2, Ly/2),; z = linearly_spaced_faces,; halo = (4, 4, 4)); 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457:1210,Config,Config,1210,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1256161457,1,['Config'],['Config']
Modifiability,"interpolated u on coarse grid; coarse_grid = RectilinearGrid(size = (grid.Nx, grid.Ny, grid.Nz÷2), extent = (grid.Lx, grid.Ly, grid.Lz)); coarse_u = Field{Face, Center, Center}(coarse_grid). using Oceananigans.Fields: interpolate!; update_coarse_u(simulation) = interpolate!(coarse_u, simulation.model.velocities.u); simulation.callbacks[:update_interp] = Callback(update_coarse_u). # Create coarse output; simulation.output_writers[:coarsefields] = NetCDFOutputWriter(model, (; coarse_u,), coarse_grid;; filename=""coarsefields.nc"",; schedule=TimeInterval(5),; overwrite_existing=true,). run!(simulation); ```. Throws the following error:. ```; ERROR: LoadError: DimensionMismatch: new dimensions (1, 1, 8, 1) must be consistent with array size 4; Stacktrace:; [1] (::Base.var""#throw_dmrsa#328"")(dims::NTuple{4, Int64}, len::Int64); @ Base ./reshapedarray.jl:41; [2] reshape(a::Array{Float64, 3}, dims::NTuple{4, Int64}); @ Base ./reshapedarray.jl:45; [3] setindex_disk!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing, Missing}}, ::Array{Float64, 3}, ::Function, ::Vararg{Any}); @ DiskArrays ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:56; [4] setindex!; @ ~/.julia/packages/DiskArrays/bZBJE/src/diskarray.jl:229 [inlined]; [5] setindex!(::CommonDataModel.CFVariable{…}, ::Array{…}, ::Colon, ::Colon, ::Colon, ::UnitRange{…}); @ CommonDataModel ~/.julia/packages/CommonDataModel/GGvMn/src/cfvariable.jl:477; [6] save_output!(ds::NCDatasets.NCDataset{…}, output::Field{…}, model::NonhydrostaticModel{…}, ow::NetCDFOutputWriter{…}, time_index::Int64, name::String); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:482; [7] write_output!(ow::NetCDFOutputWriter{…}, model::NonhydrostaticModel{…}); @ Oceananigans.OutputWriters ~/repos/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:525; [8] initialize!(sim::Simulation{…}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:212; [9] time_step!(sim:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084:1548,Variab,Variable,1548,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3576#issuecomment-2092831084,1,['Variab'],['Variable']
Modifiability,"is PR proposes to eliminate the pressure decomposition so that there is only one pressure. In principle, this has a computational advantage because the hydrostatic pressure integral does not need to be evaluated (in practice, this computation has a negligible cost). It also reduces the number of memory loads that take place in the momentum advection kernels (though these are typically domained by advection scheme, so this may not matter except for centered advection schemes). Also in principle, it would allow 3D domain decompositions for distributed computations, in addition to 2D (but again, these are rarely used because typical ocean domains are shallow and wide, rather than deep and narrow). Having a single pressure also simplifies diagnostics. Finally, and perhaps most importantly, we can avoid allocating memory for an additional 3D field. In the absolute best case scenario of a model with no tracers and pure implicit dissipation, this means we go from 14 3D fields (9 for prognostic momentum + tendencies, 4 (?) for nonhydrostatic pressure including scratch variables for FFTs, and 1 for hydrostatic pressure) to 13 3D fields. So it saves about 7%. In more typical situations with LES closure and one active tracer, the savings is more marginal: we go from 19 3D fields to 18 3D fields, and thus have 5% more memory. Note also that more scratch variables are needed for FFTs in domains that are not horizontally-periodic. (This memory bookkeeping should be double checked.). In summary, the main advantages and risks of this PR are:. **Risk**: loss of accuracy in scenarios that are dominated by hydrostatic balance. This issues may be exacerbated by experimental or not-yet-existing features, such as: cut cell and partial cell bathymetry, curvilinear grids, nonlinear free surfaces, reduced precision arithemetic, etc. . **Advantage**: memory savings of at most 7% but more typically 1-5%, and a cleaner code and user interface. Note, there was another attempt to coalesce the pr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080:2705,variab,variables,2705,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080,1,['variab'],['variables']
Modifiability,"ismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Ste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:1184,Variab,Variable,1184,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165,1,['Variab'],['Variable']
Modifiability,"ite. ```julia; ENV[""OCEANANIGANS_NUMBER_TYPE""] = ""Float32"". grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); coriolis = FPlane(f=1); equation_of_state = TEOS10EquationOfState(); buoyancy = SeawaterBuoyancy(; equation_of_state); ```. ## Introducing an internal ""settings"" dictionary. Then users might write. ```julia; Oceananigans.settings[:default_number_type] = Float32; ```. This avoids the string-based restriction of environment variables, so may generalize to more types of settings should we need that. It's a slippery slope of course, we want to keep this to a minimum because global settings inhibit programmability (ie one cannot have multiple simulations in a single instance with different settings). Here, the setting only controls a default, so it remains possible to have two simulations in one instance with different number types --- they just cannot be set up simultaneously (or one has to do more work to set the number type ""manually""). External packages can opt into using this only if they depend on Oceananigans. Which may be ok, in fact. External packages that extend Oceananigans of course must depend on Oceananigans. There is just the question of what to do with SeawaterPolynomials, where the dependency goes the other direction... I thought of the environment-variable approach so that SeawaterPolynomials could implement it without depending on Oceananigans. But as I think about it more, it is hacky for SeawaterPolynomials to contain an environment variable called OCEANANIGANS_NUMBER_TYPE. So now I think the second approach may be better in fact, and to support this kind of thing with SeawaterPolynomials, perhaps what we need is a way to extend the key SeawaterPolynomials constructors inside Oceananigans somehow. I also think it would be nice to have `validate_number_type` utility for comparing number types to the grid eltype to catch inconsistent number types. @ali-ramadhan may be interested since it I noticed some Float32's creeping into scripts...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3800:2151,extend,extend,2151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3800,4,"['extend', 'variab']","['extend', 'variable']"
Modifiability,"l and we end up with `Nx*Ny` tridiagonal systems, one for each column so they can be solved in parallel. We might be able to speed up the already fast tridiagonal solve via cyclic reduction. For PNN boundary conditions, it should work if we use an FFT in the x and a DCT in the y. So far I have a working 1D solver. The two tricks that had to be made were:; 1. @christophernhill figured out that we need to stop the algorithm once a zero eigenvalue is reached. This should only occur at the last element for our tridiagonal systems.; 2. There are `Nz+1` faces in the vertical but we only keep track of the first `Nz`. The tridiagonal system needs to explicitly account for all `Nz+1` faces. Thus we impose the staggered Neumann boundary conditions at `k=Nz+1` and the (Nz+1)th entry of right-hand-side is zero. (Chris probably told me this but I forgot...) Previously, the DCT did this for us as all the eigenfunctions satisfied the boundary condition anyways. I tested it against our existing solver but it doesn't work for variable dz yet. Not sure if it's because of my implementation of the Laplacian in PR #283 or because I discretized the vertical derivative incorrectly here. Just opening this PR early so everyone's in the loop. I'm not 100% sure whether we will be able to utilize cyclic reduction:; * I think you need a symmetric tridiagonal system (or at least block-symmetric) which we don't have when the grid is vertically stretched. Maybe this is a sign that I discretized things wrong?; * It can be modified for Neumann boundary conditions (which break the symmetry on the first and last rows) but in this case it seems cyclic reduction must be applied recursively `m+1` times for a system of size `Nz = 2^m + 1`. The optimal number of cyclic reductions is `log2(log2(Nz))` so it's possible that we don't gain much. There may also be numerical accuracy issues with taking too many cyclic reduction steps. Some thoughts:; * The batched cyclic reduction solver @maleadt developed only wo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/306:1375,variab,variable,1375,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/306,1,['variab'],['variable']
Modifiability,"left` and `right`; * `FieldBoundaryConditions` with fields `x`, `y`, and `z`; * `BoundaryConditions` with fields `u`, `v`, `w`, `T`, and `S`. ### Specifying boundary conditions and user API. A boundary condition is now specified by defining a function that calculates it within a kernel that loops over the boundary in question. The arguments of a flux boundary conditions on a top or bottom boundary (the only situation supported so far) are. ```julia; u, v, w, T, S, t, step, Nx, Ny, Nz, Δx, Δy, Δz, i, j; ```. This will probably change in the future. The user API is rather threadbare at the moment. To define a constant flux boundary condition, for example, the user might write (to specify the boundary condition as a function). ```julia; model = Model(...). const constant_flux = # something; surface_temperature_flux(args...) = constant_flux; flux_bc = BoundaryCondition{Flux}(surface_temperature_flux); model.boundary_conditions.T.z.right = flux_bc; ```. to specify the boundary condition as a constant, . ```julia; model = Model(...). flux_bc = BoundaryCondition(Flux, constant_flux); model.boundary_conditions.T.z.right = flux_bc; ```. There are probably some sugary things that we can implement to smooth this specification. ### Caveats. * We support only flux boundary conditions at top and bottom at the moment; * We can only handle fluxes in terms of the constant vertical viscosities and diffusivities; * If the viscosities and diffusivities are allowed to vary in the vertical at some point in the future, we will have to re-configure the implementation; * We cannot intercept the specification of a flux if we have, for example, a parameterization like KPP that takes care of the surface fluxes with a closure (rather than as a boundary condition). ### A side note. I think that, at some point, it would be preferable to move the implementation of boundary conditions and equations to a new file / module so that new physics can be easily implemented my modifying that module / file.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/118:2894,config,configure,2894,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/118,2,"['config', 'parameteriz']","['configure', 'parameterization']"
Modifiability,"lenceClosures.HyperbolicTangentRiDependentTapering}, NamedTuple{(:u, :v, :w), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, NamedTuple{(:b,), Tuple{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}}}, Buoyancy{BuoyancyTracer, Oceananigans.Grids.NegativeZDirection}, NamedTuple{(:b,), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:\u03bb, :initial_buoyancy), Tuple{Float64, typeof(WenoNeverworld.initial_buoyancy_parabola)}}, typeof(WenoNeverworld.buoyancy_top_relaxation)}}}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to xnode); Stacktrace:; [1] node; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/grid_utils.jl:230; [2] buoyancy_top_relaxation; @ /nobackup1c/users/ssilvest/WenoNeverworld.jl/src/weno_neverworld.jl:47; [3] getbc; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BoundaryConditions/discrete_boundary_function.jl:41; [4] top_buoyancy_flux; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BuoyancyModels/buoyancy_tracer.jl:18; [5] top_buoyancy_flux; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/BuoyancyModels/buoyancy.jl:76; [6] macro expansion; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl:190; [7] gpu_compute_ri_based_diffusivities!; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/KernelAbstractions/C8flJ/src/macros.jl:81; [8] gpu_compute_ri_based_diffusivities!; ```. Instances of `xnode` (and I would have to guess also `ynode` and `znode`) are not adapted to fit the new syntax",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:6944,adapt,adapted,6944,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['adapt'],['adapted']
Modifiability,ll/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy9UaW1lU3RlcHBlcnMuamw=) | `87.50% <0.00%> (-12.50%)` | :arrow_down: |; | [src/Models/clock.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9jbG9jay5qbA==) | `80.00% <0.00%> (-8.89%)` | :arrow_down: |; | [src/Models/Models.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9Nb2RlbHMuamw=) | `100.00% <0.00%> (ø)` | |; | [src/TimeSteppers/velocity\_and\_tracer\_tendencies.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL1RpbWVTdGVwcGVycy92ZWxvY2l0eV9hbmRfdHJhY2VyX3RlbmRlbmNpZXMuamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [src/Forcing/parameterized\_forcing.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0ZvcmNpbmcvcGFyYW1ldGVyaXplZF9mb3JjaW5nLmps) | `100.00% <0.00%> (ø)` | |; | [src/BoundaryConditions/apply\_no\_penetration\_bcs.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9hcHBseV9ub19wZW5ldHJhdGlvbl9iY3Muamw=) | `58.33% <0.00%> (+1.19%)` | :arrow_up: |; | [src/Models/incompressible\_model.jl](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree#diff-c3JjL01vZGVscy9pbmNvbXByZXNzaWJsZV9tb2RlbC5qbA==) | `92.30% <0.00%> (+3.41%)` | :arrow_up: |; | ... and [1 more](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/climate-machine/Oceananigans.jl/pull/698?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522:2601,parameteriz,parameterized,2601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/698#issuecomment-599273522,1,['parameteriz'],['parameterized']
Modifiability,"lliptic]]; git-tree-sha1 = ""71c79e77221ab3a29918aaf6db4f217b89138608""; uuid = ""b305315f-e792-5b7a-8f41-49f472929428""; version = ""1.0.1"". [[ExprTools]]; git-tree-sha1 = ""10407a39b87f29d47ebaca8edbc75d7c302ff93e""; uuid = ""e2ba6199-217a-4e67-a87a-7c52f15ade04""; version = ""0.1.3"". [[FFTW]]; deps = [""AbstractFFTs"", ""FFTW_jll"", ""IntelOpenMP_jll"", ""Libdl"", ""LinearAlgebra"", ""MKL_jll"", ""Reexport""]; git-tree-sha1 = ""1b48dbde42f307e48685fa9213d8b9f8c0d87594""; uuid = ""7a1cc6ca-52ef-59f5-83cd-3a7055c09341""; version = ""1.3.2"". [[FFTW_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""5a0d4b6a22a34d17d53543bd124f4b08ed78e8b0""; uuid = ""f5851436-0d7a-5f13-b9de-f02708fd171a""; version = ""3.3.9+7"". [[FileIO]]; deps = [""Pkg"", ""Requires"", ""UUIDs""]; git-tree-sha1 = ""b647ed22f176a4f12eabe2afd90d19a95af2e8ca""; uuid = ""5789e2e9-d7fb-5bc7-8068-2c6fae9b9549""; version = ""1.8.0"". [[GPUArrays]]; deps = [""AbstractFFTs"", ""Adapt"", ""LinearAlgebra"", ""Printf"", ""Random"", ""Serialization""]; git-tree-sha1 = ""9c95b2fd5c16bc7f97371e9f92f0fef77e0f5957""; uuid = ""0c68f7d7-f131-5f86-a1c3-88cf8149b2d7""; version = ""6.2.2"". [[GPUCompiler]]; deps = [""DataStructures"", ""InteractiveUtils"", ""LLVM"", ""Libdl"", ""Scratch"", ""Serialization"", ""TimerOutputs"", ""UUIDs""]; git-tree-sha1 = ""c853c810b52a80f9aad79ab109207889e57f41ef""; uuid = ""61eb1bfa-7361-4325-ad38-22787b887f55""; version = ""0.8.3"". [[Glob]]; git-tree-sha1 = ""4df9f7e06108728ebf00a0a11edee4b29a482bb2""; uuid = ""c27321d9-0574-5035-807b-f59d2c89b15c""; version = ""1.3.0"". [[HDF5_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""LibCURL_jll"", ""Libdl"", ""OpenSSL_jll"", ""Pkg"", ""Zlib_jll""]; git-tree-sha1 = ""fd83fa0bde42e01952757f01149dd968c06c4dba""; uuid = ""0234f1f7-429e-5d53-9886-15a909be8d59""; version = ""1.12.0+1"". [[IfElse]]; git-tree-sha1 = ""28e837ff3e7a6c3cdb252ce49fb412c8eb3caeef""; uuid = ""615f187c-cbe4-4ef1-ba3b-2fcf58d6d173""; version = ""0.1.0"". [[IntelOpenMP_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""d979e54b71da82f3a65",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:5373,Adapt,Adapt,5373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,looking at the benchmarks in #2335 it seems that it does. But only for some configurations,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261412615:76,config,configurations,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261412615,1,['config'],['configurations']
Modifiability,"losures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rotate the diffusivity into an isopycnal coordinate. The others are a bit more challenging. 4. Extensive profiling and benchmarking on the GPU to identify bottlenecks / places for improvement in the algorithm (numerics). We might be able to make the code a lot faster (but we aren't sure). 5. A solver for hydrostatic problems with a free surface that uses a split-explicit time-integration method. This is notoriously tricky, but we've made a lot of progress on this for the purposes of the ClimateMachine and it might be interesting to translate what we've learned into Oceananigans. There's also some minor package stuff that I want to work on, such as refactoring the output writer (#963), improving logging / feedback while oceananigans builds a model or runs a simulation (#1013), getting arrays with named axes to work (#457), and figuring out what's going wrong with models that have `Flat` dimensions (#1024). A more fun project is to come up with cool plotting recipes in 1D, 2D, and 3D (!) We'd like to show people how to use Makie (for example) to create really cool visualizations / animations of turbulence. The examples do some animation, but more complicated stuff (such as 3D contourf plots, or volume rendering) might require dedicated scripts. @navidcy and I have also discussed projects to implement 1) a shallow water model using Oceananigans functionality and 2) a quasi-geostrophic model in Oceananigans (which would use the tridiagonal solver I mentioned earlier). What else? The best project is probably one that aligns with you and your students' research... ? Definitely happy to chat further and also collaborate on something if you'd like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:2654,refactor,refactoring,2654,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['refactor'],['refactoring']
Modifiability,"lsevier.com/reader/sd/pii/S0377042717303035?token=83A413B5659B8B16B96E1D0CBDAD5865D8552AE5B2FF2FDFE78FFDEF064F2820B38D1BBFF646D3F7B75D58FE010DF7DB&originRegion=us-east-1&originCreation=20230125193548). You can always try with higher order (maybe 7th?) but the higher the order the lower the stability (i.e. at a certain order your implicit dissipation will be so low that you will start to generate grid-scale noise). . The KE dissipation is there with `closure=nothing` and a WENO scheme, it is just not strictly physical: it's (roughly) akin to a 4th to a 6th-order hyperviscosity. You can compare this to using `UpwindBiased(order = 5)` which would give you everywhere a dissipation that converges to a 6th-order hyperviscosity. In general:. $$\partial_x {uu}^{Upwind_N} \sim \partial_x {uu}^{Centered_{N+1}} + \partial_x {K_{numerical}} \partial_x^{N} u$$. where $K_{numerical} \sim \Delta x u$ and $N$ is the order. The nice thing about using WENO instead of a simple Upwind discretization is that the order of the hyperviscosity adapts to the smoothness of the field. Therefore, where the field is noisier (like in regions of higher gradients) the dissipation is more aggressive. . This procedure not only ensures a smooth field but can be thought of as mimicking the subgrid-scale dissipation (which also increases with the gradient of resolved scale variables. As such people have referred to using particularly diffusive advective schemes (such as WENO) as _Implicit_ LES. I like the idea of implicit LES because it allows you to ""fill in"" for the subgrid-scale dissipation without committing to any sophisticated formulation derived in a particularly idealized situation (take the example of Leith derived in homogeneous 2D turbulence and the geostrophic eddies in the ocean), and guarantees (or at least helps) stability. For this reason, it's pretty handy when you have different unresolved processes at different scales that may be characterized by different dissipation characteristics.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433:1749,variab,variables,1749,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1404144433,2,['variab'],['variables']
Modifiability,"lways have them together. At some point we have to get the external value, and if it's in the condition slot in `BoundaryCondition` we can get it like this:; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/fill_halo_regions_value_gradient.jl#L9. which can be e.g.; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L124-L133; which is called because of there being a `ContinuousBoundaryFunction` in the `BoundaryCondition` type:; https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L119; which was automatically set-up and then `regularize`-d. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/boundary_condition.jl#L53-L67. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/continuous_boundary_function.jl#L74-L75. But if we have this as part of the condition we get something like:; ```julia; BoundaryCondition{<:Open, <:OpenConditions{ES, MS}}; ```. then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. In the existing code the condition and classification are never directly accessed (except from inside `getbc`) and all of the other bits are based on the types:. https://github.com/CliMA/Oceananigans.jl/blob/77ee4980a32d39d802fc6c7b2a8ef81b4c6c0c1a/src/BoundaryConditions/fill_halo_regions_value_gradient.jl#L15. so we can just write methods like:. ```julia; @inline function _fill_west_halo!(j, k, grid, c, bc::BoundaryCondition{Open{<:SomeMatchingScheme}}, loc, args...); ```. I don't really understand how it makes the code any harder to understand if we then get the condition as above v.s. writing new things so we can do `external_state = some_function(bc)`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988307344:1370,rewrite,rewrite,1370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988307344,1,['rewrite'],['rewrite']
Modifiability,"macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuMemcpyDtoHAsync_v2(dstHost::Ptr{Float64}, srcDevice::CuPtr{Float64}, ByteCount::Int64, hStream::CuStream); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] #unsafe_copyto!#12; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/memory.jl:410 [inlined]; [5] unsafe_copyto!(dest::Vector{Float64}, doffs::Int64, src::CuArray{Float64, 1}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/array.jl:357; [6] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:314 [inlined]; [7] copyto!; @ ~/.julia/packages/CUDA/DL5Zo/src/array.jl:318 [inlined]; [8] copyto_axcheck!; @ ./abstractarray.jl:1104 [inlined]; [9] Vector{Float64}(x::CuArray{Float64, 1}); @ Base ./array.jl:563; [10] Array; @ ./boot.jl:481 [inlined]; [11] convert; @ ./array.jl:554 [inlined]; [12] adapt_storage; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:45 [inlined]; [13] adapt_structure; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:42 [inlined]; [14] adapt; @ ~/.julia/packages/Adapt/wASZA/src/Adapt.jl:40 [inlined]; [15] print_array; @ ~/.julia/packages/GPUArrays/umZob/src/host/abstractarray.jl:48 [inlined]; [16] show(io::IOContext{Base.TTY}, #unused#::MIME{Symbol(""text/plain"")}, X::CuArray{Float64, 1}); @ Base ./arrayshow.jl:396; [17] (::REPL.var""#43#44""{REPL.REPLDisplay{REPL.LineEditREPL}, MIME{Symbol(""text/plain"")}, Base.RefValue{Any}})(io::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:266; [18] with_repl_linfo(f::Any, repl::REPL.LineEditREPL); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:510; [19] display(d::REPL.REPLDisplay, mime::MIME{Symbol(""text/plain"")}, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:259; [20] display(d::REPL.REPLDisplay, x::Any); @ REPL ~/julia-1.7.2/share/julia/stdlib/v1.7/REPL/src/REPL.jl:271; [21] display(x::Any); @ Base.Multimedia ./multimedia.jl:328; [22] #invokelatest#2; @ ./essentials.jl:716 [inlin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685:7089,Adapt,Adapt,7089,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2413#issuecomment-1090342685,2,['Adapt'],['Adapt']
Modifiability,"me = "" * string(prettytime(times[$n])); fig[1, 1:5] = Label(fig, title, fontsize=24, tellwidth=false);. resize_to_layout!(fig); @info ""Animating...""; record(fig, filename * "".mp4"", 1:length(times), framerate=10) do i; n[] = i; end; ```. This simulation runs for 10 minutes and then plots this (on a 32x32 grid):. https://github.com/CliMA/Oceananigans.jl/assets/13205162/e4fc9a13-f14f-4c6d-bda6-0d4aae79ac4c. So basically there's a discontinuity in the vertical direction's pressure, which causes an artificial vertical pressure gradient, causing a spurious flow at the top and bottom, even those aren't supposed to be boundaries since the grid is periodic in `z`.; It seems like this comes from the fact that the hydrostatic pressure isn't periodic (since it always comes from a vertical b integral I think), but the nonhydrostatic pressure *is* periodic. This in turn leads the total pressure to have a discontinuity. In fact if we run the exact same configuration but make both the gravitational direction and the periodic direction the `x` direction (code [here](https://pastebin.com/skAB1Bt4)) we have a plume looks and behaves as expected and has no discontinuities:. https://github.com/CliMA/Oceananigans.jl/assets/13205162/97ab7df9-4b64-4f65-9433-4eb9a5e7fe22. I'm not sure if this is something that needs fixing or if it's just a consequence of the hydrostatic decomposition, which always assumes gravity is in the `NegativeZDirection()` and that `z` is `Bounded`. Hence I'm not sure this is better left as an issue or a discussion, so please lmk if I should move this to a discussion. Also, if I run the example above (where gravity is in the `z` direction) using https://github.com/CliMA/Oceananigans.jl/pull/3080, which gets rid of the hydrostatic pressure separation, then I get what I believe to be the correct behavior (all pressures in the animation below are actually total pressure):. https://github.com/CliMA/Oceananigans.jl/assets/13205162/60ef470d-22d7-429a-9029-adb7db5687ba. Whic",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3290:4019,config,configuration,4019,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3290,1,['config'],['configuration']
Modifiability,more flexible and less code -- what can go wrong?. yeap!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2239#issuecomment-1034433920:5,flexible,flexible,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2239#issuecomment-1034433920,1,['flexible'],['flexible']
Modifiability,"n . using Oceananigans.Advection; using Oceananigans.TurbulenceClosures. model = IncompressibleModel(architecture = CPU(),; advection = UpwindBiasedFifthOrder(),; timestepper = :RungeKutta3,; grid = computational_grid,; coriolis = FPlane(f=f),; buoyancy = buoyancy,; closure = SmagorinskyLilly(),; boundary_conditions = (u=u_bcs, v=v_bcs, T=T_bcs)). # Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz) # noise. # Temperature initial condition: a stable density gradient with random noise superposed. Tᵢ(x, y, z) = T0 + dTz * z + dTz * model.grid.Lz * Factor_T * Ξ(z). # Velocity initial condition: random noise scaled by the friction velocity.; uᵢ(x, y, z) = sqrt(abs(Qᵘ)) * Factor_V * Ξ(z). # `set!` the `model` fields using functions or constants:; set!(model, u=uᵢ, v=uᵢ, w=uᵢ, T=Tᵢ). wizard = TimeStepWizard(cfl= CFL, Δt = initial_timestep, max_change = max_allowable_change_in_Δt, max_Δt = maximum_Δt). # A type for calculating adaptive time steps based on capping the CFL number at `cfl`.; # On calling `update_Δt!(wizard, model)`, the `TimeStepWizard` computes a time-step such that; # ``cfl = max(u/Δx, v/Δy, w/Δz) Δt``, where ``max(u/Δx, v/Δy, w/Δz)`` is the maximum ratio; # between model velocity and along-velocity grid spacing anywhere on the model grid. The new; # `Δt` is constrained to change by a multiplicative factor no more than `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_n",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999:4483,adapt,adaptive,4483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999,1,['adapt'],['adaptive']
Modifiability,"n_testBCflux.jl). . In the experiment, I have specified both the initial temperature (perturbation) and a constant background temperature < T > gradient, so that the total temperature T_total = < T > + T.; ; The movie below shows T_total and presents two simple experiments with an existing initial temperature. In the blue case, the default no-flux boundary condition is applied (i.e., no gradient in the wall-normal direction), but the gradient at the boundaries is nonzero because the boundary condition does not account for the background temperature. In contrast, the red case includes a boundary condition that forces the gradient of T_total to be 0. ; With this corrected boundary condition (red curve), the flux at the boundaries is 0, which is physical. However, it remains unclear how to incorporate these corrected fluxes for more complicated configurations. https://github.com/CliMA/Oceananigans.jl/assets/68127124/69e64cf9-6248-4274-9b6d-5f763827e768. The movie below shows two additional cases without an initial temperature, indicating that the background temperature, < T > defines the entire field. ; The constant blue line throughout the simulation implies that the background scalar does not diffuse either within the domain or at the boundaries. However, in the red case, despite the absence of diffusion affecting the background temperature, the nonzero flux at the boundaries causes the curve to become smoothed. ; If diffusion does not affect the background field, would it still make sense if the stratification is not a constant, such as in a Kelvin-Helmholtz instability configuration, e.g., < b > = tanh(z)?. https://github.com/CliMA/Oceananigans.jl/assets/68127124/d350c5ad-2e14-4992-8c5d-f947a1ddf7bb. This brings up the question: what should the default behavior for background fields be? Should they really only appear in the advective terms, or should they also be diffused? And what should the boundary conditions on perturbations be when there are background fields?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3568:1961,config,configuration,1961,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3568,1,['config'],['configuration']
Modifiability,"ncies adjacent to boundaries.; Before computing tendencies near the boundaries, boundary-adjacent auxiliary diagnostic variables are recalculated (hydrostatic pressure, vertical velocity and diffusivities for the hydrostatic model, hydrostatic pressure and diffusivities for the non-hydrostatic model). Also, this PR introduces ; - 8-way halo passing for distributed grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/kernel_launching.jl` to remove when offsets will be implemented); - [x] Adapt that implementation in this PR; - [x] Generalize the current implementation of kernel offsets for Diffusivities, Pressures and W-velocity; - [x] Find a general way to tag MPI requests to allow large number of cores (currently `Nranks < 100`); - [x] Remove `views` halo passing. #### API changes; - When calling `RectilinearGrid(arch::DistributedArch, size = (Nx, Ny, Nz), ....)`, `(Nx, Ny, Nz)` are the _per-rank_ local sizes, not the global size to be divided (easy way to specify non-uniform partitioning, see `validation/distributed/mpi_geostrophic_adjustment.jl`); - added the `enable_overlapped_communication` keyword to `DistributedArch` (defaults to true); - removed the `use_buffers` keyword to `DistributedArch` (_always_ use buffers, as views did not give significant speedup to justify maintaining two implementations); - added the keyword argument `active_cells_map::Bool = false` to `ImmersedBoundaryGrid` (ex: `ImmersedBoundaryGrid(grid, ib, active_cells_map = true)`; - added a `required_halo_size::Int ` keyword argument to `ScalarDiffusivity` (defaults to 1) and `ScalarBiharmonicDiffusivity",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125:2071,Adapt,Adapt,2071,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125,1,['Adapt'],['Adapt']
Modifiability,"nd see an unfamiliar function so I scroll to the top to see where it was imported from. If the `import` statement is in the module file, then I have to scroll through a screenful of import statements in another file in search of the relevant line. > What is the problem that this change would solve? If one is reading code in a file, and an unfamiliar function appears, one presumably looks to the top-level to see where it is imported. If one is reading a module, why is it crucial to know where in the code the package is used?. It solves two problems: messy module files, and makes it easier to understand where import statements are used. Maybe we do things differently, but I always scroll to the top of the current file to look for import statements. I've never thought to look the module top-level file. Additionally, a list of import statements at the top of the file tell me what to expect in this file. I always skim the import statements before reading a file, although this may be Pythonic behavior haha. > This new convention could create issues in which functionality from a package imported in one file is used elsewhere, making it hard to trace exactly where an unfamiliar function first arrived in the namespace. Or, if two packages conflict with one another. In julia, resolving method conflicts when two packages export the same name can be tricky and the resolution depends on the order in which packages are imported. We can break with convention when needed, but presumably this is the rare exception rather than rule. > I think having more submodules (#495, #456) is really the right solution to this problem; in that case each module is short so the issue of tracing import statements to usage within a huge module is alleviated. Yeah maybe after we have more submodule it'll be clearer how to tackle this issue and maybe it won't be as bad. Although I think some refactoring/reorganizing/reordering of import statements may be needed to make the import statements more local.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547:3004,refactor,refactoring,3004,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/497#issuecomment-547225547,1,['refactor'],['refactoring']
Modifiability,"ndaryConditions/boundary\_function.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9mdW5jdGlvbi5qbA==) | `81.48% <0.00%> (-4.24%)` | :arrow_down: |; | [...lementations/anisotropic\_biharmonic\_diffusivity.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfaW1wbGVtZW50YXRpb25zL2FuaXNvdHJvcGljX2JpaGFybW9uaWNfZGlmZnVzaXZpdHkuamw=) | `96.66% <0.00%> (-3.34%)` | :arrow_down: |; | [src/Simulations/run.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1NpbXVsYXRpb25zL3J1bi5qbA==) | `94.20% <0.00%> (-1.04%)` | :arrow_down: |; | [...rbulenceClosures/turbulence\_closure\_diagnostics.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL1R1cmJ1bGVuY2VDbG9zdXJlcy90dXJidWxlbmNlX2Nsb3N1cmVfZGlhZ25vc3RpY3Muamw=) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <0.00%> (ø)` | |; | [...daryConditions/fill\_halo\_regions\_value\_gradient.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWxsX2hhbG9fcmVnaW9uc192YWx1ZV9ncmFkaWVudC5qbA==) | `28.30% <0.00%> (ø)` | |; | ... and [14 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/905?src=pr&el=footer). Last update [f13a0a2...a40305f](https://c",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/905#issuecomment-686484714:2788,parameteriz,parameterized,2788,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/905#issuecomment-686484714,1,['parameteriz'],['parameterized']
Modifiability,"nditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}, Field{Center, Center, Face, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing}}}}, Nothing}, Float64, Float64, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractDiagnostic}, OrderedCollections.OrderedDict{Symbol, Oceananigans.AbstractOutputWriter}, OrderedCollections.OrderedDict{Symbol, Callback}}); @ Oceananigans.Simulations ~/repos/Oceananigans.jl/src/Simulations/run.jl:195; ```. That is to say `NetCDFWriter` isn't correctly inferring the sizes for each variable when creating the NetCDF file. I think atm each file creating assumes all outputs are sliced similarly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:49725,variab,variable,49725,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,1,['variab'],['variable']
Modifiability,"ndom""]; git-tree-sha1 = ""6a8a2a625ab0dea913aba95c11370589e0239ff0""; uuid = ""1914dd2f-81c6-5fcd-8719-6d5c9610ff09""; version = ""0.5.6"". [[Markdown]]; deps = [""Base64""]; uuid = ""d6f4376e-aef5-505a-96c1-9c027394607a"". [[MbedTLS_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""0eef589dd1c26a3ac9d753fe1a8bcad63f956fa6""; uuid = ""c8ffd9c3-330d-5841-b78e-0817d7145fa1""; version = ""2.16.8+1"". [[MicrosoftMPI_jll]]; deps = [""Artifacts"", ""JLLWrappers"", ""Libdl"", ""Pkg""]; git-tree-sha1 = ""e5c90234b3967684c9c6f87b4a54549b4ce21836""; uuid = ""9237b28f-5490-5468-be7b-bb81f5f5e6cf""; version = ""10.1.3+0"". [[Mmap]]; uuid = ""a63ad114-7e13-5084-954f-fe012c677804"". [[NCDatasets]]; deps = [""CFTime"", ""DataStructures"", ""Dates"", ""NetCDF_jll"", ""Printf""]; git-tree-sha1 = ""b71d83c87d80f5c54c55a7a9a3aa42bf931c72aa""; uuid = ""85f8d34a-cbdd-5861-8df4-14fed0d494ab""; version = ""0.11.3"". [[NNlib]]; deps = [""Adapt"", ""ChainRulesCore"", ""Compat"", ""LinearAlgebra"", ""Pkg"", ""Requires"", ""Statistics""]; git-tree-sha1 = ""80b8360670f445d88b3475e88b33bbcc92f7866e""; uuid = ""872c559c-99b0-510c-b3b7-b6c96a88d5cd""; version = ""0.7.19"". [[NaNMath]]; git-tree-sha1 = ""bfe47e760d60b82b66b61d2d44128b62e3a369fb""; uuid = ""77ba4419-2d1f-58cd-9bb1-8ffee604a2e3""; version = ""0.3.5"". [[NetCDF_jll]]; deps = [""Artifacts"", ""HDF5_jll"", ""JLLWrappers"", ""LibCURL_jll"", ""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""d5835f95aea3b93965a1a7c06de9aace8cb82d99""; uuid = ""7243133f-43d8-5620-bbf4-c2c921802cf3""; version = ""400.701.400+0"". [[Oceananigans]]; deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""FFTW"", ""Glob"", ""InteractiveUtils"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SafeTestsets"", ""SeawaterPolynomials"", ""Statistics"", ""StructArrays"", ""Tullio""]; git-tree-sha1 = ""861d8cca4447304a21a94110e3ffc786cab52dce""; uuid = ""9e8cae18-63c1-5223-a",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:10403,Adapt,Adapt,10403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"nearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically stretched grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5 ; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically uniform grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically stretched grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Flat on vertically uniform grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Flat on vertically stretched grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5 ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232:3222,variab,variably,3222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232,2,['variab'],['variably']
Modifiability,"necessarily reproduce the Manifest. I think unless you pin something, Pkg will try to get the latest set of packages that are still compatible. In fact, I don't think it's even recommended to add a Manifest with the github repo (at least not according to github: https://github.com/github/gitignore/blob/b0012e4930d0a8c350254a3caeedf7441ea286a3/Julia.gitignore#L20-L24). This is an example of a fresh Oceananigans install I just made. Notice it installed CUDA v3.4.2:. ```julia; (@v1.6) pkg> activate .; Activating new environment at `~/Dropbox/tests/fresh/Project.toml`. (fresh) pkg> add Oceananigans; Updating registry at `~/.julia/registries/General`; Resolving package versions...; Installed ChainRulesCore ─ v1.7.2; Installed Tables ───────── v1.6.0; Installed Parsers ──────── v2.0.5; Installed StaticArrays ─── v1.2.13; Updating `~/Dropbox/tests/fresh/Project.toml`; [9e8cae18] + Oceananigans v0.63.1; Updating `~/Dropbox/tests/fresh/Manifest.toml`; [621f4979] + AbstractFFTs v1.0.1; [79e6a3ab] + Adapt v3.3.1; [4fba245c] + ArrayInterface v3.1.33; [ab4f0b2a] + BFloat16s v0.1.0; [fa961155] + CEnum v0.4.1; [179af706] + CFTime v0.1.1; [052768ef] + CUDA v3.4.2; [72cfdca4] + CUDAKernels v0.3.0; [7057c7e9] + Cassette v0.3.9; [d360d2e6] + ChainRulesCore v1.7.2; [34da2185] + Compat v3.39.0; [a8cc5b0e] + Crayons v4.0.4; [7445602f] + CubedSphere v0.1.0; [9a962f9c] + DataAPI v1.9.0; [864edb3b] + DataStructures v0.18.10; [e2d170a0] + DataValueInterfaces v1.0.0; [b552c78f] + DiffRules v1.3.1; [ffbed154] + DocStringExtensions v0.8.5; [b305315f] + Elliptic v1.0.1; [e2ba6199] + ExprTools v0.1.6; [7a1cc6ca] + FFTW v1.4.5; [5789e2e9] + FileIO v1.11.1; [0c68f7d7] + GPUArrays v8.1.1; [61eb1bfa] + GPUCompiler v0.12.9; [c27321d9] + Glob v1.3.0; [615f187c] + IfElse v0.1.0; [92d709cd] + IrrationalConstants v0.1.0; [82899510] + IteratorInterfaceExtensions v1.0.0; [033835bb] + JLD2 v0.4.14; [692b3bcd] + JLLWrappers v1.3.0; [0f8b85d8] + JSON3 v1.9.1; [63c18a36] + KernelAbstractions v0.7.0; [929cbde3] +",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237:1041,Adapt,Adapt,1041,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1996#issuecomment-933978237,1,['Adapt'],['Adapt']
Modifiability,need a test too I think. Probably some refactoring to come for Lagrangian particles...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2397#issuecomment-1083725453:39,refactor,refactoring,39,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2397#issuecomment-1083725453,1,['refactor'],['refactoring']
Modifiability,"ng packages. An alternative would be to use the much more mature [netcdf4-python](http://unidata.github.io/netcdf4-python/) but I'd rather not have to use PyCall...; > ; > _Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/31#issuecomment-468288154_. Some more comments:; * Right now NetCDF output is much slower than expected. We have asynchronous output writing #137 but spending 2-3 minutes to write out the fields of a 256³ grid is ridiculous.; * Compression doesn't seem to work in NetCDF.jl: See https://github.com/JuliaGeo/NetCDF.jl/issues/87; * We might want to share this output writing feature with CliMA.jl. See https://github.com/climate-machine/CLIMA/issues/114; * @simonbyrne and @charleskawczynski suggested looking at [HDF5.jl](https://github.com/JuliaIO/HDF5.jl). As NetCDF4 is built on HDF5, we should be able to generate valid NetCDF files with it.; * Whatever we end up doing, @christophernhill makes a good point that we should produce portable NetCDF files as this is what all our potential users would expect and want.; * Thinking more long-term @lcw says that IO performance is a hard problem and thinks we are going to want something that plays well on clusters (e.g., something MPI IO based). Some extra features we might want in the short-term:; - [ ] Option to only write out a specific subset of the model state, e.g. surface velocities only, or a vertical temperature slice. This would really speed up IO if you don't need full 3D fields.; - [ ] Select which fields to write out to NetCDF.; - [ ] Include diagnostics in NetCDF output. I believe this will be possible if we resolve the item above as output writing occurs right after diagnostics are run, so diagnostic fields can just be included as one of the fields to write out.; - [ ] Option to create one NetCDF file for each iteration, or to combine all output into one NeCDF file. I think the main point of this issue is that we should decide how to output NetCDF. Pac",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145:1496,portab,portable,1496,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145,1,['portab'],['portable']
Modifiability,"nge:. ```; #-----; Lx = Ly = 16_000; Lz = 1_000; topology = (Periodic, Periodic, Bounded); factor = 1; grid = RegularCartesianGrid(size=(2048÷factor, 1, 256÷factor),; x=(0, Lx),; y=(0, 1),; z=(-Lz/2, +Lz/2),; topology=topology); #-----. #-----; ubc = UVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); vbc = VVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, 0),; top = BoundaryCondition(Gradient, 0),; ); wbc = WVelocityBoundaryConditions(grid,; bottom = BoundaryCondition(Value, 0),; top = BoundaryCondition(Value, 0),; ); bbc = TracerBoundaryConditions(grid,; bottom = BoundaryCondition(Gradient, N2),; top = BoundaryCondition(Gradient, N2),; ); #-----. #-----; # Set-up sponge layer; bottom_mask = GaussianMask{:z}(center=minimum(znodes(Face, grid)), width=grid.Lz/10); mom_sponge = Relaxation(rate=1/10, mask=bottom_mask, target=0); #----. model = IncompressibleModel(; architecture = GPU(),; grid = grid,; advection = UpwindBiasedThirdOrder(),; timestepper = :RungeKutta3,; closure = IsotropicDiffusivity(ν=1e-4, κ=1e-4),; coriolis = FPlane(f=f0),; tracers = (:b,),; buoyancy = BuoyancyTracer(),; boundary_conditions = (b=bbc, u=ubc, v=vbc, w=wbc),; forcing = (u=mom_sponge, v=mom_sponge, w=mom_sponge),; ```. From the docs, I expected this to ; > relax velocity fields to zero [...] in the bottom 1/10th of the domain. which leads me to believe that there's some a sharp cut-off in the function mask so that velocities above the range `[-500, -400]`aren't affected. However, when I plot the vertical velocities (and other variables with zero mean) I get the results below, which indicate that the sponge layer is active in the approximate range `[-500, -200]`, which is around 3 times larger than what I (thought I) set up. ![Screenshot from 2020-11-24 08-45-47](https://user-images.githubusercontent.com/13205162/100126723-2e4dea00-2e33-11eb-8a80-f97c525c6e91.png). Am I missing something here?. Thanks!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1203:1901,variab,variables,1901,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1203,1,['variab'],['variables']
Modifiability,"nicDiffusivity` (defaults to 2) to be specified by the user which sets the required halo for the specific `ν` or `κ` function (closures have now an explicitly required number of halos); #### **Major** internals change; 1) The tendencies are calculated at the **end** of a time step. Therefore at the end of a simulation `model.timestepper` will hold tendencies for the last time step completed . 2) Removed `fill_halo_regions!` for hydrostatic pressure in both the non-hydrostatic and the hydrostatic model and for w-velocity in the hydrostatic model. The halos are filled by enlarging the size of the kernels in `update_hydrostatic_pressure!` and `compute_w_from_continuity!` to incorporate the needed ghost points. 2) Removed `fill_halo_regions!` for diffusivities **only for halo-passing BC**; the halo calculation is now performed by launching the `calculate_diffusivity!` kernel inside the ghost nodes before recomputing the tendencies. This requires knowing how many halos each closure requires. 3) Added a _required_halo_ parameter to `AbstractTurbulenceClosure`. This means that each parameterization will have to specify explicitly the number of halos required to calculate the diffusivity: ; e.g ; ```julia; abstract type AbstractTurbulenceClosure{TimeDiscretization, BoundaryBuffer} end; abstract type AbstractScalarDiffusivity{TD, F, N} <: AbstractTurbulenceClosure{TD, N} end; struct TwoDimensionalLeith{FT, CR, GM, M} <: AbstractScalarDiffusivity{ExplicitTimeDiscretization, ThreeDimensionalFormulation, 2}; ``` ; Where Leith closure requires 2 halos (one for the vorticity calculation and an additional one for the vorticity derivative). #### **Minor** internals change; removed the general `calculate_nonlinear_viscosity!` and `calculate_nonlinear_diffusivity!` kernels (to each turbulence closure their own kernel). ~Requires https://github.com/JuliaGPU/KernelAbstractions.jl/pull/399 # On hold at the moment~; Closes #615; Closes #1882; Closes #3067; Closes #3068 ; Supersedes #2953",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125:4263,parameteriz,parameterization,4263,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125,1,['parameteriz'],['parameterization']
Modifiability,"ntext of the Nonhydrostatic model and having some success but some difficulties as well. We have tried two different approaches: . Method 1: define the jet and stratification to be part of the background field and evolve the perturbations. Method 2: define the jet and stratification as part of the initial conditons and evolve the total field. These are mathematically equivalent and should both yield the same results, but we are finding a difference and believe there is a problem with method 2 (evolving the total fields). . When pick there to be zero perturbations, the jet is an exact solution to the governing equations (even though it is an unstable one) and it should persist, until perturbations arise because of numerical errors. The good news is that when we use method 1, evolve the perturbations, when we pick zero perturbations, no pertrubations develop for a long time. . The not so good news, is that when we use method 2, evolve the total field, a distrubance develops right away,in the center of the jet that spans the entire depth, and this seems to radiate gravity waves to the left and right. The amplitude of the distrubance is small and it does decrease with increasing resolution but it seems problematic. I am going to include an animation that shows the problem that develops in the first 6 hours and the two codes, which are almost identical. Is there something that we are doing wrong here? @glwagner ?. Method 1: Evolve perturbations. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z, t) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z, t) = N² * z + 2*f*Umax*Lⱼ/D^",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251:1020,evolve,evolve,1020,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251,1,['evolve'],['evolve']
Modifiability,"nvironment. Relevant only when using TCP/IP as transport. To launch workers without blocking the REPL, or the containing function if launching workers programmatically, execute addprocs in its own task. Examples; ≡≡≡≡≡≡≡≡≡≡. # On busy clusters, call `addprocs` asynchronously; t = @async addprocs(...). # Utilize workers as and when they come online; if nprocs() > 1 # Ensure at least one new worker is available; .... # perform distributed execution; end. # Retrieve newly launched worker IDs, or any error messages; if istaskdone(t) # Check if `addprocs` has completed to ensure `fetch` doesn't block; if nworkers() == N; new_pids = fetch(t); else; fetch(t); end; end. ────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────. addprocs(machines; tunnel=false, sshflags=``, max_parallel=10, kwargs...) -> List of process identifiers. Add worker processes on remote machines via SSH. Configuration is done with keyword arguments (see below). In particular, the exename keyword; can be used to specify the path to the julia binary on the remote machine(s). machines is a vector of ""machine specifications"" which are given as strings of the form [user@]host[:port] [bind_addr[:port]]. user defaults to; current user and port to the standard SSH port. If [bind_addr[:port]] is specified, other workers will connect to this worker at the specified; bind_addr and port. It is possible to launch multiple processes on a remote host by using a tuple in the machines vector or the form (machine_spec, count), where; count is the number of workers to be launched on the specified host. Passing :auto as the worker count will launch as many workers as the number; of CPU threads on the remote host. Examples:. addprocs([; ""remote1"", # one worker on 'remote1' logging in with the current username; ""user@remote2"", # one worker on 'remote2' logging in with the 'user' username; ""user@remote3:2222"", # specifying SSH port to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636:1470,Config,Configuration,1470,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3135#issuecomment-1579765636,1,['Config'],['Configuration']
Modifiability,"o switch on/off different terms in the MEKE budget. For instance, as of now, MOM6 OM4 only uses the `PrognosticMEKEDiffusivity` (and no backscatter), but the CPT and others are looking into the energetically-constrained backscatter term intensively these days!; 3. **MEKE vs. GEOMETRIC**: As you mention above, the two schemes are very similar. There are maybe three notable differences: ; a) **energy type**: MEKE solves a prognostic equation for `EKE`, whereas GEOMETRIC solves a prognostic equation for `EKE + EPE`. To inform GM, the two schemes then use the variable `2 * EKE` and `EKE + EPE`, respectively. [Bachman (2017)](10.1016/j.ocemod.2016.12.004) found that in practice, kappa_GM is not sensitive to whether one solves for `EKE` (as MEKE does) or `EKE + EPE` (as GEOMETRIC does). So we could probably start by following the MEKE approach, and just solve for `EKE`.; b) **GM/energy source term**: In MEKE, it is left to the user how to specify the mixing length scale `L_mix` in `kappa_GM = c * sqrt(2 MEKE) * L_mix` and in the inferred MEKE source term. (Options are: the deformation scale, Rhines scale, grid scale, frictional halting scale, Eady length scale, or any combination of those, see [here](https://github.com/NOAA-GFDL/MOM6/blob/0e8acd90b46656ccb7fbc73bc5911ef2733a345c/src/parameterizations/lateral/MOM_MEKE.F90#L995-L1012).) In GEOMETRIC, the mixing length scale is essentially chosen as the Eady length scale. So if you use MEKE with the Eady length scale `L_e` (see Appendix Ab in Kong and Jansen, 2021), you recover the GEOMETRIC source term.; c) **sub-grid dissipation**: MEKE assumes only bottom drag, GEOMETRIC uses one ""catch-all"" linear damping term as the energy sink term in the sub-grid energy budget. As highlighted in [Mak et al. (2022)](https://onlinelibrary.wiley.com/doi/abs/10.1029/2021GL097259), this sub-grid dissipation term is probably the big elephant in the room, which the solution is very sensitive to but noone knows what the term should look like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692:2466,parameteriz,parameterizations,2466,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431#issuecomment-1122829692,1,['parameteriz'],['parameterizations']
Modifiability,"o the 3D compressible Euler equations. The free-surface SW is a compressible model, which is why we don't have to solve any elliptic problem, and instead we simply integrate the three prognostic equations. . The rigid-lid SW model (which we don't have yet) is different of course. I am sure we can use the existing solves to determine the surface pressure as the hydrostatic model currently does. Here are some thoughts to consider:. 1. Introducing topography is pretty easy but when we do so, we should probably introduce a free-surface. Following the convention of the hydrostatic model seems like the way to proceed. Agreed?; 2. Visosity is not difficult to include but there's a question of which form of viscosity to include. The standard harmonic or biharmonic diffiusivities would be good choices, where they act on the velocities not the transport velocities. If we had a `VectorInvariant` form then I think we could use the current libraries. For the conservative forms, I think we have to adapt them, which will take more effort I suspect.; 3. Note: these forms of viscosity are not strictly positive preserving and they can increase kinetic energy. I know of a form of the harmonic case that is positive preserving and we could include that. But does anyone case about those levels of details? If yes I can include the form in the writeup and even a short derivation of how to get it from the 3D equations.; 4. @glwagner pointed out that `ShallowWaterModel` is very separate from everything else in Oceananigans and that is a bit of a pain to maintain. One advantage of a `VectorInvariant` form is that it could rely heavily on `HydrostaticModel`, that way they grow together. It might even ben an embarassingly simply application.; 5. I would like there to be a switch from free-surface to rigid-lid. In the latter we have to solve an elliptic problem, and again probably easier with a `VectorInvariant` form but probably not difficult with a conservative form either. How do people sugge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381:2116,adapt,adapt,2116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064259381,2,['adapt'],['adapt']
Modifiability,"o: Computing wτ6 done: time=292.708 μs; [ Info: Computing wτ2 done: time=192.674 ms; [ Info: Computing wτ5 done: time=190.263 ms; [ Info: Computing wτ4 done: time=193.185 ms; [ Info: Computing wτ1_yavg done: time=1.210 seconds; [ Info: Computing wτ4_yavg done: time=2.954 seconds; [ Info: Computing wτ3_yavg done: time=2.953 seconds; [ Info: Writing done: time=17.732 seconds, size=19.5 KiB, Δsize=0.0 B; [ Info: ... simulation initialization complete (18.528 seconds); [ Info: Executing initial time step...; [ Info: ... initial time step complete (30.965 seconds).; [ Info: Simulation is stopping after running for 49.565 seconds.; [ Info: Model iteration 4 equals or exceeds stop iteration 4.; ```. and then . ```Julia; julia> using NCDatasets. julia> ds = NCDataset(simulation.output_writers[:xz1_writer].filepath, ""r""); NCDataset: ./test.nc; Group: /. Dimensions; zC = 16; zF = 17; xC = 16; yF = 1; xF = 16; yC = 1; time = 1. Variables; zC (16); Datatype: Float64; Dimensions: zC; Attributes:; units = m; longname = Locations of the cell centers in the z-direction. zF (17); Datatype: Float64; Dimensions: zF; Attributes:; units = m; longname = Locations of the cell faces in the z-direction. xC (16); Datatype: Float64; Dimensions: xC; Attributes:; units = m; longname = Locations of the cell centers in the x-direction. yF (1); Datatype: Float64; Dimensions: yF; Attributes:; units = m; longname = Locations of the cell faces in the y-direction. xF (16); Datatype: Float64; Dimensions: xF; Attributes:; units = m; longname = Locations of the cell faces in the x-direction. yC (1); Datatype: Float64; Dimensions: yC; Attributes:; units = m; longname = Locations of the cell centers in the y-direction. time (1); Datatype: Float64; Dimensions: time; Attributes:; units = seconds; longname = Time. wτ3 (16 × 1 × 17 × 1); Datatype: Float64; Dimensions: xC × yC × zF × time. wτ2_yavg (16 × 17 × 1); Datatype: Float64; Dimensions: xC × zF × time. wτ6_yavg (16 × 17 × 1); Datatype: Float64; Dimension",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387:2563,Variab,Variables,2563,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1435832387,1,['Variab'],['Variables']
Modifiability,"odel = HydrostaticFreeSurfaceModel(; closure=ivd_closure, model_kwargs...); explicit_model = HydrostaticFreeSurfaceModel(; closure=evd_closure, model_kwargs...); models = (implicit_model, explicit_model); ; initial_temperature(x, y, z) = exp(-z^2 / 0.02). [set!(model, c=initial_temperature) for model in models]. z = znodes(implicit_model.tracers.c). c_implicit = view(interior(implicit_model.tracers.c), 1, 1, :); c_explicit = view(interior(explicit_model.tracers.c), 1, 1, :). c_plot = plot(c_implicit, z, linewidth = 2, label = ""t = 0"", xlabel = ""Tracer concentration"", ylabel = ""z""); ; diffusion_time_scale = implicit_model.grid.Δz^2 / implicit_model.closure.κz.c; stop_time = 100diffusion_time_scale. simulations = [Simulation(explicit_model, Δt = 1e-1 * diffusion_time_scale, stop_time = stop_time),; Simulation(implicit_model, Δt = 1e0 * diffusion_time_scale, stop_time = stop_time)]. [run!(simulation) for simulation in simulations]. plot!(c_plot, c_implicit, z, linewidth = 3, alpha = 0.6, label = @sprintf(""implicit model, t = %.3e"", model.clock.time)); plot!(c_plot, c_explicit, z, linewidth = 2, linestyle = :dash, label = @sprintf(""explicit model, t = %.3e"", model.clock.time)). display(c_plot); ```. produces. <img width=""1392"" alt=""image"" src=""https://user-images.githubusercontent.com/15271942/117589924-a6f2eb00-b0e1-11eb-87a2-fb51a4eacc85.png"">. Note that with implicit treatment of the diffusion term we can use a time step comparable to the diffusion time-scale. The same time-step with explicit time discretization leads to model blow up. ~~Future~~ This PR ~~will hopefully~~ extends functionality to other closures and also to `IncompressibleModel` and the RK3 time-stepper. In the process of cleaning up TurbulenceClosures I am also resolving a few other issues, such as an incorrect formulation of viscous fluxes for `IsotropicDiffusivity` and the semi-random default viscosity and thermal diffusivities that we've been using. Resolves #1278; Resolves #1643 ; Resolves #1644",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1639:3643,extend,extends,3643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1639,1,['extend'],['extends']
Modifiability,"odel::NonhydrostaticModel{…}, callbacks::Vector{…}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/compute_nonhydrostatic_tendencies.jl:31; > [11] #apply_regionally!#56; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:121 [inlined]; > [12] apply_regionally!; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:118 [inlined]; > [13] macro expansion; > @ ~/Research/OC10.jl/src/Utils/multi_region_transformation.jl:206 [inlined]; > [14] update_state!(model::NonhydrostaticModel{…}, callbacks::Vector{…}; compute_tendencies::Bool); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:47; > [15] update_state!; > @ ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:19 [inlined]; > [16] update_state!(model::NonhydrostaticModel{…}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl:19; > [17] NonhydrostaticModel(; grid::RectilinearGrid{…}, clock::Clock{…}, advection::Centered{…}, buoyancy::Nothing, coriolis::Nothing, stokes_drift::Nothing, forcing::@NamedTuple{…}, closure::Nothing, boundary_conditions::@NamedTuple{}, tracers::Tuple{}, timestepper::Symbol, background_fields::@NamedTuple{}, particles::Nothing, biogeochemistry::Nothing, velocities::Nothing, pressures::Nothing, diffusivity_fields::Nothing, pressure_solver::Nothing, immersed_boundary::Nothing, auxiliary_fields::@NamedTuple{}); > @ Oceananigans.Models.NonhydrostaticModels ~/Research/OC10.jl/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:198; > [18] top-level scope; > @ REPL[5]:1; > Some type information was truncated. Use `show(err)` to see complete types.; > ```. Ok I fixed that. Probably we should use a `Field` rather than `ones` for the test and examples, because it automatically adapts to GPU, distributed, etc, so its a bit better.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1986430708:5212,adapt,adapts,5212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3498#issuecomment-1986430708,1,['adapt'],['adapts']
Modifiability,"odes((Center, Center, Center), grid). function progress(sim); umax = maximum(abs, sim.model.velocities.u); bmax = maximum(abs, sim.model.tracers.b); @info @sprintf(""Iter: %d, time: %.2e, max|u|: %.2e, max|b|: %.2e"",; iteration(sim), time(sim), umax, bmax). return nothing; end; simulation = Simulation(model; Δt=30, stop_time=6hours); simulation.callbacks[:p] = Callback(progress, TimeInterval(1minutes)). u, v, w = model.velocities; b = model.tracers.b; outputs = (; v, u, w, b). simulation.output_writers[:fields] = NetCDFOutputWriter(; model, outputs;; filename = ""NH_BC_jet_pert_fields.nc"",; schedule = TimeInterval(1minutes),; array_type = Array{Float32},; 	 overwrite_existing = true). perturbation_norm(args...) = norm(u). simulation.output_writers[:growth] = NetCDFOutputWriter(; model, (; perturbation_norm),; filename = ""NH_BC_jet_pert_norm.nc"",; schedule = TimeInterval(1minutes),; dimensions = (; perturbation_norm = ()),; overwrite_existing = true). run!(simulation); ```. Method 2: evolve total field. ```julia; using Oceananigans; using Oceananigans.Units; using NCDatasets, Printf; using Statistics, Random; using LinearAlgebra: norm. ## background consts; f = 0.864e-4 ; fₕ = 0.0 ; N² = (3.7e-3)^2 ; ν = 0.36/2.2e5; Umax = 0.36; Lx = 10000; Ly = 30000; Lⱼ = 2000; Lz = 1000; D = 200; z0 = -Lz/2. grid = RectilinearGrid(; CPU(),; size=(1, 200, 100),; x= (-Lx, Lx),; y = (-Ly, Ly),; z = (-Lz, 0),; topology=(Periodic, Bounded, Bounded); ). U(x, y, z) = Umax / cosh(y/Lⱼ)^2 * exp(-(z-z0)^2/D^2); B(x, y, z) = N² * z + 2*f*Umax*Lⱼ/D^2 * (tanh(y/Lⱼ)) * (z-z0) * exp(-(z-z0)^2/D^2); ; Random.seed!(25); uᵢ(x, y, z) = U(x, y, z); bᵢ(x, y, z) = B(x, y, z) + 0e-6*rand(). b_bc = FieldBoundaryConditions(top = GradientBoundaryCondition(N²), bottom = GradientBoundaryCondition(N²)). model = NonhydrostaticModel(; grid,; coriolis = FPlane(f = f),; buoyancy = BuoyancyTracer(),; tracers = (:b,),; advection = WENO(grid=grid),; closure = VerticalScalarDiffusivity(ν=ν, κ=ν),; boundary_conditions =",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3251:3456,evolve,evolve,3456,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3251,1,['evolve'],['evolve']
Modifiability,"ognostic equation (fully Lagrangian isopycnal coordinates, semi-Lagrangian hybrid coordinates / _z-tilde_ coordinates that vary only with high frequency motion, and adaptive methods that prescribe GVC dynamics to obtain favorable properties like concentration in regions of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equation",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:1452,variab,variable,1452,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['variab'],['variable']
Modifiability,"ok, @simone-silvestri, I did what you were suggesting.; we now need to refactor the tests....... oh dear........",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1994981771:71,refactor,refactor,71,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3503#issuecomment-1994981771,1,['refactor'],['refactor']
Modifiability,"ok, now that #2522 is merged we can start thinking of multiple layers :) ; I put an overleaf doc with eqs at https://www.overleaf.com/read/mtyjxnnrjpqv",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146735146:63,layers,layers,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2507#issuecomment-1146735146,1,['layers'],['layers']
Modifiability,"ok, so now we have. ```julia. julia> grid; 32×32×24 RectilinearGrid{Float64} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 64.0) regularly spaced with Δx = 2.0; ├── Periodic y ∈ [0.0, 64.0) regularly spaced with Δy = 2.0; └── Bounded z ∈ [-32.0, -0.0] variably spaced with min(Δz) = 0.682695, max(Δz) = 1.830909; ```. and. ```julia; julia> c; 32×32×24 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── data: 34×34×26 OffsetArray(::Array{Float64, 3}, 0:33, 0:33, 0:25) with eltype Float64 with indices 0:33×0:33×0:25; │ └── max=0.999994, min=0.000024, mean=0.497759; ├── grid: 32×32×24 RectilinearGrid{Float64} on CPU with 1×1×1 halo; └── boundary conditions: west=Periodic, east=Periodic, south=Periodic, north=Periodic, bottom=ZeroFlux, top=ZeroFlux, immersed=ZeroFlux; ```. what do we think so far?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017914892:253,variab,variably,253,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2161#issuecomment-1017914892,1,['variab'],['variably']
Modifiability,"ol, precision::Type, boundary_layer_parameterization::Oceananigans.TurbulenceClosures.RiBasedVerticalDiffusivity{Oceananigans.TurbulenceClosures.VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.HyperbolicTangentRiDependentTapering}); @ OceanScalingTests ~/src/OceanScalingTests.jl/src/near_global_simulation.jl:64; [10] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:54 [inlined]; [11] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:78 [inlined]; [12] macro expansion; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:53 [inlined]; [13] macro expansion; @ ~/.julia/packages/PrecompileTools/L8A3n/src/workloads.jl:140 [inlined]; [14] top-level scope; @ ~/src/OceanScalingTests.jl/src/OceanScalingTests.jl:32; [15] include; @ ./Base.jl:556 [inlined]; [16] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::Nothing); @ Base ./loading.jl:2664; [17] top-level scope; @ stdin:4; in expression starting at /home/vchuravy/src/OceanScalingTests.jl/src/OceanScalingTests.jl:1; in expression starting at stdin:; ```. Caused by `@eval`. Note that `@eval` uses the current module and not the module the user is calling this function from.; This means we are trying to modify the Oceananigans after it has already been closed. This is imcompatible with precompilation since we are unable to track and restore this modification. My intuition is that you probably just want a dictionary for these kind of globals, maybe even within the model? ; Instead of using global variables. . https://github.com/CliMA/Oceananigans.jl/blob/00f028bb37f13692e24921588aeb8a9150f6dd55/src/Grids/latitude_longitude_grid.jl#L554-L555. The use-case is shown in https://github.com/simone-silvestri/OceanScalingTests.jl/pull/8 where one wants to use `PrecompileTools` to cache important functions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3555:7183,variab,variables,7183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3555,1,['variab'],['variables']
Modifiability,"on getting a WENO-5 tracer advection scheme working in Julia. Thanks @RaphaelRR for helping with the WENO-5 advection scheme!. This PR adds a 1D advection verification experiment to start exploring different advection schemes and time steppers to help us decide what to implement. I hope this PR can serve as test-driven development: Oceananigans should be able to reproduce the results of this PR, at which point it becomes a true verification experiment. `weno.jl` defines `advective_tracer_flux` functions (`weno5_flux`) so it should work nicely with the existing `Oceananigans.Operators`. At some point in the future I'd like to follow this PR up with a 2D advection test using the Munk gyre solution. Should also test momentum advection. Of course, can't always generalize 1D advection results to 3D turbulence simulations... Things to do to integrate WENO-5:; 1. Design an abstraction for selecting advection schemes.; 2. Extend to multi-dimensional advection scheme.; 3. Extend to a momentum advection scheme as well.; 4. Decide whether we want WENO-3 and/or WENO-7 (or even higher-order advection schemes). Note: On extending to multi-dimensional advection, we can perform the 1D WENO interpolation along each dimension separately to come up with a multidimensional advection scheme. This is what most packages do in practice as true multidimensional would involve huge stencils (and some numerical quadrature?) so it's not worth it for the small increase in accuracy. Doing it dimension-wise might be fine at lower order like WENO <= 7. I should cite the appropriate papers for these claims. This relatively recent paper might be of interest to us: Buchmüller & Helzel (2014), [Improved Accuracy of High-Order WENO Finite Volume Methods on Cartesian Grids](https://doi.org/10.1007/s10915-014-9825-1). Resolves #481; Resolves #934. ---; Not sure if it'll generalize to 3D but seems that you get better accuracy even with half the number of grid points (per dimension?). And if we also upgrade ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/592:1032,Extend,Extend,1032,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/592,1,['Extend'],['Extend']
Modifiability,"on`s with default locations. In other words, a `PolynaryOperation` only arises when location is specified, eg:. ```julia; julia> op1 = u + v + w;. julia> op2 = @at (Cell, Cell, Cell) u + v + w;. julia> typeof(op1).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation. julia> typeof(op2).name.wrapper; Oceananigans.AbstractOperations.PolynaryOperation; ```. This also means that all fields in a `PolynaryOperation` are interpolated *prior* to computation. # Computations. This PR also adds a type for making ""computations"" with an `AbstractOperation`. We call this a `Computation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here has been defined as `model.pressures.pHY′`). We also extend `HorizontalAverage` to work with `Computation`, (and add a constructor that constructs a `Computation` from an `AbstractOperation` and `Model`), eg. ```julia; T, S = model.tracers; ST = HorizontalAverage(S + T, model); computed_profile = ST(model); ```. Calling `run_diagnostic` for `HorizontalAverage{<:Computation}` first calls `compute!(computation)`, and then compute the horizontal average of `computation.result`. # Some important details. * This PR changes the meaning of `data`, which is used extensively in forming operations. This resolves #454. A new function `interior` serves the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:5788,extend,extend,5788,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['extend'],['extend']
Modifiability,"onal changes and it seems to be doing much better! Still three tests that fail. I looked ath the initialize environments and saw what I copied below. It seems to have probelms with Oceananigans?. ```. ✗ Oceananigans; --;   | 105 dependencies successfully precompiled in 112 seconds;   | 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package;   | Precompiling project...;   | ✗ Oceananigans;   | 0 dependencies successfully precompiled in 22 seconds. 105 already precompiled.;   |  ;   | ERROR: The following 1 direct dependency failed to precompile:;   |  ;   | Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09];   |  ;   | Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /storage5/buildkite-agent/.julia-9773/compiled/v1.8/Oceananigans/jl_yggB5x.;   | [NVBLAS] No Gpu available;   | [NVBLAS] NVBLAS_CONFIG_FILE environment variable is NOT set : relying on default config filename 'nvblas.conf';   | [NVBLAS] Cannot open default config file 'nvblas.conf';   | [NVBLAS] Config parsed;   | [NVBLAS] CPU Blas library need to be provided;   | ERROR: LoadError: syntax: missing comma or ) in argument list;   | Stacktrace:;   | [1] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/non_traditional_beta_plane.jl:75;   | [2] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [3] include(x::String);   | @ Oceananigans.Coriolis ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:1;   | [4] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Coriolis/Coriolis.jl:28;   | [5] include(mod::Module, _path::String);   | @ Base ./Base.jl:419;   | [6] include(x::String);   | @ Oceananigans ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:5;   | [7] top-level scope;   | @ ~/builds/tartarus-1/clima/oceananigans/src/Oceananigans.jl:230;   | [8] include;   | @ ./Base.jl:419 [inlined];   | [9] include_package_for_output(pkg::Base.PkgId, input::String, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445:1031,config,config,1031,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2877#issuecomment-1414372445,1,['config'],['config']
Modifiability,"op=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perhaps we should check whether everything passed into these functions is a `Field` or `AbstractField`. But for now that's extra code and it's not an exported function so I'm okay leaving it as is (we might want the flexibility in the future?).~~ A check was added in #627. 5. Model no longer has the `boundary_conditions` property. 6. There is no need for `SolutionBoundaryConditions` and `ModelBoundaryConditions` anymore: code is simpler :tada:. 7. `TurbulentDiffusivities` has been renamed to `DiffusivityFields` for consistency with `VelocityFields` and `TracerFields`, etc. 8. For each turbulence closure, `DiffusivityFields` gets the same two versions (one if you want control over the full field, another if you just want to set boundary conditions). 9. Halo filling and parts of the time stepping have been simplified as there is no need to juggle around and bundle up boundary conditions. Some comments:; 1. It's not clear whether fields for abstract operations should have boundary conditions as they don't have halos and we don't impose boundary conditions on them. Do we want to generally set their boundary conditions to `nothing`? I did this for the abstract operations tests and they all passed.; 2. We could further simplify the time stepping code if we adapt the `Field` abstraction to be GPU compatible (#298).; 3. This is probably an edge case but I don't think setting diffusivity BCs when using a tuple of closures will actually work. Or rather, I'm not sure how to specify two different diffusivity BCs, one for each closure.; 4. Before merging I still need to update the checkpointer and update the documentation. Resolves #606. Note: This PR branches off from #628.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:3615,adapt,adapt,3615,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['adapt'],['adapt']
Modifiability,"or example, we'll have to make sure all unit tests for differential operators pass before we can add a new biogeochemistry model implementation. I think development might be faster and more accessible if we do it in a different repo. There are also some details to discuss regarding implementation. Oceananigans' design already supports reacting systems via `Forcing`. Oceananigans `Forcing` are arbitrary functions of spatial coordinates, time, prognostic model fields, and forcing function parameters --- or alternatively, indices `i, j, k`, `grid`, `clock`, and a NamedTuple of model fields that can be indexed into arbitrarily. @iuryt and @syou83syou83 (and perhaps others) have experimented in this direction. However, I think we might benefit from adding a model property to both `NonhydrostaticModel` and `HydrostaticFreeSurfaceModel` that's specifically dedicated to `biogeochemistry`, and designing an interface that allows users / other packages (like Biogeoceananigans.jl) to build custom `biogeochemistry` types. One advantage I think is we'll have more flexibility in designing the code that hooks into Oceananigans than if we limit ourselves to using `model.forcing`. I also think it will yield a cleaner and more interpretable user API: biogeochemistry models are sometimes complicated, so it's helpful to disentangle their specification from the specification of more ""vanilla"" forcing terms, like sponge layers, etc. We may want special time-stepping methods for some types of biogeochemistry in the future. I also think we can build an interface for `biogeochemistry` that uses similar or identical syntax to `Forcing` (like requiring functions of `x, y, z, t, fields` --- etc) because this will allow directly transferring code for biogeochemistry models that's first implemented as a system of forcing functions (a very common and useful development paradigm). What do others think about this? @iuryt @johnryantaylor @rafferrari @simone-silvestri @christophernhill @jm-c @sandreza",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2512:2685,layers,layers,2685,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2512,1,['layers'],['layers']
Modifiability,"ostaticFreeSurfaceModel`. I believe it's an Adapt issue. It works with `NonhydrostaticModel`. Might just be an issue with functions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1141,adapt,adapt,1141,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['adapt'],['adapt']
Modifiability,"otentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2090,refactor,refactored,2090,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['refactor'],['refactored']
Modifiability,"othing` boundary condition for all other cases. 4. For closures, all tracer-diffusivity-related fields permit users to specify either:. * a constant (applied to all tracers), or ; * a `NamedTuple` with fields for *every* tracer. . In the future, we could possibly implement some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452:2492,refactor,refactor,2492,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452,1,['refactor'],['refactor']
Modifiability,"pInfo]]; > git-tree-sha1 = ""2e5c102cfc41f48ae4740c7eca7743cc7e7b75ea""; > uuid = ""8b046642-f1f6-4319-8d3c-209ddc03c586""; > version = ""1.0.0""; 412c431; < git-tree-sha1 = ""f2355693d6778a178ade15952b7ac47a4ff97996""; ---; > git-tree-sha1 = ""50901ebc375ed41dbf8058da26f9de442febbbec""; 414c433; < version = ""1.3.0""; ---; > version = ""1.3.1""; 499c518; < git-tree-sha1 = ""781916a2ebf2841467cda03b6f1af43e23839d85""; ---; > git-tree-sha1 = ""8f6af051b9e8ec597fa09d8885ed79fd582f33c9""; 501c520; < version = ""0.1.9""; ---; > version = ""0.1.10""; 526c545; < git-tree-sha1 = ""a7023883872e52bc29bcaac74f19adf39347d2d5""; ---; > git-tree-sha1 = ""b01beb91d20b0d1312a9471a36017b5b339d26de""; 528c547; < version = ""10.1.4+0""; ---; > version = ""10.1.4+1""; 570a590,601; > [[deps.Oceananigans]]; > deps = [""Adapt"", ""CUDA"", ""Crayons"", ""CubedSphere"", ""Dates"", ""Distances"", ""DocStringExtensions"", ""FFTW"", ""Glob"", ""IncompleteLU"", ""InteractiveUtils"", ""IterativeSolvers"", ""JLD2"", ""KernelAbstractions"", ""LinearAlgebra"", ""Logging"", ""MPI"", ""NCDatasets"", ""OffsetArrays"", ""OrderedCollections"", ""PencilArrays"", ""PencilFFTs"", ""Pkg"", ""Printf"", ""Random"", ""Rotations"", ""SeawaterPolynomials"", ""SparseArrays"", ""Statistics"", ""StructArrays""]; > path = ""/Users/gregorywagner/Projects/Oceananigans.jl""; > uuid = ""9e8cae18-63c1-5223-a75c-80ca9d6e9a09""; > version = ""0.90.1""; >; > [deps.Oceananigans.extensions]; > OceananigansEnzymeCoreExt = ""EnzymeCore""; >; > [deps.Oceananigans.weakdeps]; > EnzymeCore = ""f151be2c-9106-41f4-ab19-57ee4f262869""; >; 588,589c619,620; < deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""TOML""]; < git-tree-sha1 = ""e25c1778a98e34219a00455d6e4384e017ea9762""; ---; > deps = [""Artifacts"", ""CompilerSupportLibraries_jll"", ""Hwloc_jll"", ""JLLWrappers"", ""LazyArtifacts"", ""Libdl"", ""MPIPreferences"", ""PMIx_jll"", ""TOML"", ""Zlib_jll"", ""libevent_jll"", ""prrte_jll""]; > git-tree-sha1 = ""694458ae803b684f09c07f90459cb79655fb377d""; 591c622; < version = ""4.1.6+0""; ---; > versi",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361:7871,Adapt,Adapt,7871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1807091361,1,['Adapt'],['Adapt']
Modifiability,"plemented yet. In this case, silently defaulting to `zero()` made be lose some hours of work because I thought there was something wrong with my script, when in reality `calc_κᶜᶜᶜ()` just wasn't defined for the closure I was using. Sure, this is a bit my fault for not checking the code thoroughly, but from a user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L160. it's not clear to me what's `c`, `C`, `U`. It takes some amount of digging for me (who, admittedly, am not super familiar with the code) to conclude that `c` is the `tracer` and `U` is the `velocities` tuple. (I'm still not 100% sure what `C` is). I understand that, again, I'm not super familiar with the code, so most Oceananigans developers would understand that module faster than me, but I think it's advantageous to make the code in general more easily understandable for",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751:1702,variab,variables,1702,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751,1,['variab'],['variables']
Modifiability,"ple{Nothing, Nothing}, NamedTuple{(:u, :v, :w, :b), NTuple{4, typeof(Oceananigans.Forcings.zeroforcing)}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float64, Int64, Int64}}) resulted in invalid LLVM IR; Reason: unsupported dynamic function invocation (call to overdub); ```. Click to download the full [log file](https://github.com/CliMA/Oceananigans.jl/files/8258026/log.txt). I had no problem to run this with CPU or constant coefficients. Below is the full code for the simulation I am running:. ```; using Plots; using LaTeXStrings; using Oceananigans; using Oceananigans.Units. Ny = 4000 # number of points in y; Nz = 50 # number of points in z; H = 1000 # maximum depth. grid = RectilinearGrid(GPU(),; size=(Ny, Nz),; halo=(3,3),; y=(0, Ny*kilometers), ; z=(H * cos.(LinRange(π/2,0,Nz+1)) .- H)meters,; topology=(Flat, Bounded, Bounded); ). coriolis = BetaPlane(β=2.3e-11,latitude=0) # equatorial beta plane. width=100kilometers; @inline ν(x,y,z,t) = ifelse(abs(y-Ny*kilometers/2)<Ny*kilometers/2-width, 1, 10) # sponge layers; horizontal_closure = HorizontalScalarDiffusivity(ν=ν, κ=ν); vertical_closure = ScalarDiffusivity(ν=1e-4, κ=1e-4). model = NonhydrostaticModel(grid = grid,; advection = UpwindBiasedFifthOrder(),; coriolis = coriolis,; closure=(horizontal_closure,vertical_closure),; tracers=:b, buoyancy=BuoyancyTracer()). h = 50meters # mld; Hv = 150meters # virtual h (stratification) ; S = 2.8 # m/s; c=2750kilometers # center of the storm; l=pi/(250kilometers) # horizontal wavenumber of the storm. @inline B(x, y, z) = ifelse(z>-h, (S^2)/(Hv+h), (S^2)/(Hv-z)); @inline U(x, y, z) = ifelse(abs(l*(y-c))<pi && z>-h, sin(l*(y-c)), 0). set!(model;b=B,u=U). simulation = Simulation(model, Δt = 1minutes, stop_time = 20days). simulation.output_writers[:velocities] =; JLD2OutputWriter(model, model.velocities, prefix = ""../data/velocities"",; schedule=TimeInterval(3hour), force = true). run!(simulation); ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2359:4446,layers,layers,4446,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2359,1,['layers'],['layers']
Modifiability,proabably because of previous refactoring,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3827:30,refactor,refactoring,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3827,1,['refactor'],['refactoring']
Modifiability,"propriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don't need that). `DiscreteBoundaryFunction` won't be very convenient for most people for immersed boundary conditions, but we can treat it the same way we treat constant `Value` or `Flux`. I wasn't planning to implement support for `Gradient` just yet, though this can be done too. Finally, one remaining task is to define or generalize the existing `conditional_flux` so that it adds fluxes only on _immersed_ boundaries. It looks like right now it's too eager and will add fluxes on non-immersed boundaries. Associated with this development I'd like to refactor our naming scheme for the boolean tools we have. Right now these are `solid_node` and `solid_interface`. I'd like to change `solid_node` to `external_node` (ie external to the active domain) and perhaps something like `external_or_boundary_node` for `solid_interface` to represent _both_ nodes that are completely external, or which lie _on_ the boundary. A better name is welcome...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:2553,refactor,refactor,2553,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991,2,['refactor'],['refactor']
Modifiability,"put unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https://www.sciencedirect.com/science/article/pii/S1463500311000126?casa_token=K2HHnGIuaukAAAAA:5PhiRAM7tprmr73KhLpcARMloUdkxYFc0j8hukBAsr_MVpz6BlPSHTg-OoIajqdiaBvQbug-9w) (Leclair and Madec 2011); * [Evaluation of various GVC in MPAS-Ocean](https://www.sciencedirect.com/science/article/pii/S1463500314001796) (Petersen et al 2015); * [GVC in a nonhydrostatic compressible atmospheric model ENDgame](https://rmets.onlinelibrary.wiley.com/doi/full/10.1002/qj.3368) (Kavcic and Thuburn, 2018); * [Correct calculation of pressure gradients in a finite volume model](https://www.sciencedirect.com/science/article/pii/S1463500308000243?casa_token=vsSBQiBsJugAAAAA:GHaDu6afxrLQ4NIdCDiGWl47xClDdYRdM-CSFlZ8kGxQMAOov7vSHAKp_Ch5hQ9OsousvG8sCg) (Adcroft et al 2008); [An “adaptive”, semi-Lagrangian GVC](https://www.sciencedirect.com/science/article/pii/S1463500302000604) (Burchard and Beckers 2004) See also a [3D description](https://www.sciencedirect.com/science/article/pii/S1463500309002248?casa_token=l2d7ijIAiN8AAAAA:kVzMMRqaP2d6U0QDaqB1vqfWKHjIpGWZr0EovdkMJtxHxGSb_xEQ8SlG3OtYkb2mz-6ggmGwGA) (Hofmeister et al 2010) and [realistic test case](https://www.sciencedirect.com/science/article/pii/S1463500311000801?casa_token=CkEoHLOnIxMAAAAA:QWjy9Ck26XOhdWf5K-IaJghogprZ06FDTuCZeORuBO69lWLcRYiWkz4uFtoXRLbfTATnuk932w) (Hofmeister et al 2011); [“z star” GVC in MITgcm](https://www.sciencedirect.com/science/article/pii/S1463500303000544) (Adcroft and Campin 2004)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:4652,adapt,adaptive,4652,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['adapt'],['adaptive']
Modifiability,"rdinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2724,evolve,evolve,2724,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['evolve'],['evolve']
Modifiability,"reates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.Twic",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:1161,Variab,Variable,1161,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,1,['Variab'],['Variable']
Modifiability,refactoring of the `SplitExplicitFreeSurface` to comply with issue #3873,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3894:0,refactor,refactoring,0,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3894,1,['refactor'],['refactoring']
Modifiability,"rettytime(wizard.Δt). function Base.print(progress::ProgressMessenger); @printf(""i: %04d, t: %s, Δt: %s, ; progress.model.clock.iteration, prettytime(progress.model.clock.time), pretty_Δt(progress.Δt)) ; return nothing; end; ```. One could then expand on this design by setting up the `diagnostics` field to accept a list of callable objects or functions. Or even better, a list of objects that look something like. ```julia; struct PrintableDiagnostic{D}; diagnostic :: D; format :: String; name :: String; units :: String; end. function pretty_diagnostic(pd::PrintableDiagnostic, model); return @sprintf(""%s: $(pd.format) %s"", pd.name, pd.diagnostic(model), pd.units); end; ```. with this design, the user can pass a list of `PrintableDiagnostics` to `ProgressPrinter`, which are then evaluated and the results turned into a string via the function `pretty_diagnostic`. As for option 1 of using a logging package, perhaps it could be nice to use some logging functionality that's configurable with global variables (?) rather than manually creating a `ProgressPrinter` that does ""brute force"" printing as I have described above. However I think that it would require some customization of existing logging packages, since the typical `info` or `debug` settings are not sufficient for the purposes of logging simulation output (right?) Instead, we would need more options, and it'd be nice to obtain the ability to also print the output of diagnostics / monitoring functions, as we do in the example script. And I think doing it this way might involve adding some lines to our time stepping loop. Perhaps @ali-ramadhan has more to say. Another thing we have talked about is somehow having the ability to live-update messages in the terminal (rather than printing a stream of message). This would be nice because it could dramatically reduce the text-noise that a stream of messages invokes, allowing the user to much more easily read and interpret the output of a simulation progress (in addition to ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:3265,config,configurable,3265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,2,"['config', 'variab']","['configurable', 'variables']"
Modifiability,revamp of lagrangian particles to make sure that they work on a `LatitudeLongitudeGrid` and on an `ImmersedBoundaryGrid` (and adaptation to all the new changes to Oceananigans). closes #2397 ; closes #2395,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2658:126,adapt,adaptation,126,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2658,1,['adapt'],['adaptation']
Modifiability,"rid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64},",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857:1230,Variab,Variable,1230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857,1,['Variab'],['Variable']
Modifiability,"rsed_bc, velocities, tracers, clock, buoyancy); ```. This would allow the `immersed` boundary condition specified by the user to make its way into the tendency calculation. We think this might be simpler (in terms of the code) than passing `immersed_bc` into ` ∂ⱼ_τ₁ⱼ` (where we would throw it away unless we are on `ImmersedBoundaryGrid`.). Another advantage is that we can then isolate the code that calculates flux divergences for `Value` and `Gradient` (eg for no-slip boundary conditions), which could get a little complicated. I'm also trying to figure out if that would cover this case. I think we can use `ContinuousBoundaryCondition` for this kind of drag boundary condition. So in the user script we'd write something like. ```julia; u_drag(x, y, z, t, u, v, w, Cd) = - Cd * u * sqrt(u^2 + v^2 + w^2); v_drag(x, y, z, t, u, v, w, Cd) = - Cd * v * sqrt(u^2 + v^2 + w^2); w_drag(x, y, z, t, u, v, w, Cd) = - Cd * w * sqrt(u^2 + v^2 + w^2). u_immersed_bc = FluxBoundaryCondition(u_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); v_immersed_bc = FluxBoundaryCondition(v_drag, parameters=Cd, field_dependencies=(:u, :v, :w)); w_immersed_bc = FluxBoundaryCondition(w_drag, parameters=Cd, field_dependencies=(:u, :v, :w)). u_boundary_conditions = FieldBoundaryConditions(immersed=u_immersed_bc); v_boundary_conditions = FieldBoundaryConditions(immersed=v_immersed_bc); w_boundary_conditions = FieldBoundaryConditions(immersed=w_immersed_bc); ```. and then under the hood, if we implement fluxes across immersed boundaries correctly, we'll get the right thing? Note the above code assumes that fluxes are along the ""inward facing normal"" --- one of the complications of the user API for this... The corresponding code for no-slip would be. ```julia; u_immersed_bc = ValueBoundaryCondition(0); v_immersed_bc = ValueBoundaryCondition(0); w_immersed_bc = ValueBoundaryCondition(0); ```. Should we work on adapting this PR in the direction of implementing such a user API? What do you recommend?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624:2389,adapt,adapting,2389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2275#issuecomment-1075131624,2,['adapt'],['adapting']
Modifiability,"ry\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9zaG93X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `0.00% <0.00%> (ø)` | |; | [test/test\_time\_stepping\_bcs.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X3RpbWVfc3RlcHBpbmdfYmNzLmps) | `98.46% <ø> (ø)` | |; | [src/BoundaryConditions/boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9ib3VuZGFyeV9jb25kaXRpb24uamw=) | `72.72% <78.57%> (+16.47%)` | :arrow_up: |; | [test/test\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-dGVzdC90ZXN0X2JvdW5kYXJ5X2NvbmRpdGlvbnMuamw=) | `97.86% <90.69%> (+6.95%)` | :arrow_up: |; | [...rc/BoundaryConditions/field\_boundary\_conditions.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9maWVsZF9ib3VuZGFyeV9jb25kaXRpb25zLmps) | `90.00% <93.33%> (+6.00%)` | :arrow_up: |; | [...daryConditions/parameterized\_boundary\_condition.jl](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree#diff-c3JjL0JvdW5kYXJ5Q29uZGl0aW9ucy9wYXJhbWV0ZXJpemVkX2JvdW5kYXJ5X2NvbmRpdGlvbi5qbA==) | `100.00% <100.00%> (ø)` | |; | ... and [13 more](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894/diff?src=pr&el=tree-more) | |. ------. [Continue to review full report at Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=continue).; > **Legend** - [Click here to learn more](https://docs.codecov.io/docs/codecov-delta); > `Δ = absolute <relative> (impact)`, `ø = not affected`, `? = missing data`; > Powered by [Codecov](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=footer). Last update [fbbb5f8...1503288](https://codecov.io/gh/CliMA/Oceananigans.jl/pull/894?src=pr&el=lastupdated). Read the [comment docs](https://docs.codecov.io/docs/pull-request-comments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190:2983,parameteriz,parameterized,2983,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/894#issuecomment-685006190,1,['parameteriz'],['parameterized']
Modifiability,"s of partial cells). To ensure that a stratified ocean remains at rest, implement the technique in [Lin](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs) for partial cells. . 2. Implement two-dimensional cut cells in the y-z plane:. (a) Implement `CutCellBottom` in ImmersedBoundary module similar to PartialCellBottom;; (b) Implement a special compute_w_from_continuity for `CutCellBottom`. ; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/HydrostaticFreeSurfaceModels/compute_w_from_continuity.jl#L15-L16. (c) Implement the ""algorithm"" for partial cells to compute the hydrostatic pressure for `CutCellBottom`.; https://github.com/CliMA/Oceananigans.jl/blob/8e6b5cd540b7a710955edf9846959966efbb6ea0/src/Models/NonhydrostaticModels/update_hydrostatic_pressure.jl#L24. 3. Extend the cut cell implementation to 3D and consider improving the pressure gradient calculation. . # References. [Advection on Cut-Cell Grids for an Idealized Mountain of Constant Slope](https://journals.ametsoc.org/view/journals/mwre/145/5/mwr-d-16-0308.1.xml?tab_body=abstract-display); [A finite-volume integration method for computing pressure gradient force in general vertical coordinates](https://rmets.onlinelibrary.wiley.com/doi/abs/10.1002/qj.49712354214?casa_token=4s6PejUyFLMAAAAA:RtWYxrnbDlgN8ZzMepSndBPomZX_nlXMFUWhU5nCMDE6qeyN2fWb5fb2QxQFUPYTCqZVjzG2jtpGPFs); [A fourth-order Cartesian grid embedded boundary method for Poisson's equation](https://msp.org/camcos/2017/12-1/camcos-v12-n1-p03-s.pdf); [A New Terrain-Following Vertical Coordinate Formulation for Atmospheric Prediction Models](https://journals.ametsoc.org/view/journals/mwre/130/10/1520-0493_2002_130_2459_antfvc_2.0.co_2.xml); [Comparison of Terrain-Following and Cut-Cell Grids Using a Nonhydrostatic Model](https://journals.ametsoc.org/view/journals/mwre/144/6/mwr-",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3123:1824,Extend,Extend,1824,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3123,1,['Extend'],['Extend']
Modifiability,"s of strong stratification). A fully general GVC typically also requires a ""Lagrangian remapping"" step to avoid extreme grid distortions in regions of persistent vertical velocities. The implementation of GVC is likely a major refactoring of `HydrostaticFreeSurfaceModel` because it will change the equations of motion and could even potentially change the nature of its prognostic variables. For time-dependent GVC, tracer equations must be reformulated in terms of the ""thickness-weighted"" tracer concentration, which in our case means the tracer concentration normalized by the local grid spacing. This could mean either using the thickness-weighted tracer conservation as a state variable, or it could mean rewriting the time-stepping algorithm so that unweighted tracer conservation can be updated according to the conservation of thickness-weighted tracer. A preliminary roadmap towards GVC in `HydrostaticFreeSurfaceModel` is. 1. Introduce `AbstractVerticalCoordinate` and refactor the `HydrostaticFreeSurfaceModel` to integrate thickness-weighted equations. When using `ZCoordinate`, the resulting model produces identical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during ste",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:1748,refactor,refactor,1748,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,1,['refactor'],['refactor']
Modifiability,"s without waiting for the communication to complete.; - the `only_local_halos::Bool` keyword argument, which fills only the halo in case of a local (i.e., Flux, Value, Gradient, Periodic, and, temporarily, MultiRegionCommunication) boundary condition. This is required for having explicit boundary conditions (like Value or Flux) for turbulent diffusivities (we directly calculate diffusivities in the halos in the case of distributed BC). This PR allows hiding MPI passing of barotropic auxiliary variables behind the implicit vertical solver and prognostic variables behind the tendency calculations. The latter is done by splitting the tendency kernels into an interior kernel that calculates tendencies between, e.g., `i = Hx` and `i = Nx - Hx`, and a boundary kernel, executed once communication is complete, that calculates tendencies adjacent to boundaries.; Before computing tendencies near the boundaries, boundary-adjacent auxiliary diagnostic variables are recalculated (hydrostatic pressure, vertical velocity and diffusivities for the hydrostatic model, hydrostatic pressure and diffusivities for the non-hydrostatic model). Also, this PR introduces ; - 8-way halo passing for distributed grids (west, east, north, south, southwest, southeast, northwest, northeast), something that we will want to implement also for `MultiRegion`); - Non uniform partitioning for distributed grids; - the `KernelParameters(size, offset)` to be passed to the `launch!` function to start a kernel of size ```size::Tuple``` offset by ```offset::Tuple```. todo:; - [ ] Implement Offsets in KernelAbstractions (at the moment implemented a fix in `src/Utils/kernel_launching.jl` to remove when offsets will be implemented); - [x] Adapt that implementation in this PR; - [x] Generalize the current implementation of kernel offsets for Diffusivities, Pressures and W-velocity; - [x] Find a general way to tag MPI requests to allow large number of cores (currently `Nranks < 100`); - [x] Remove `views` halo passi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125:1304,variab,variables,1304,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125,1,['variab'],['variables']
Modifiability,"s); * the gradient between the interior node of a field and the associated boundary where the boundary condition is prescribed (for `Value` boundary conditions). `calculate_boundary_source_terms!` is still a part of the algorithm and is used to enforce `Flux` boundary conditions. This function may also prove useful in the future for more sophisticated boundary conditions and for enforcing boundary conditions associated with irregular boundaries. This algorithm permits the gradients of fields to be computed accurately on the boundary both in time stepping and post processing (which is useful, for example, for computing nonlinear diffusivities on the boundary when `Value` or `Gradient` boundary conditions are prescribed), and the code is more mathematically correct as a result. It also means that diffusivities are never involved in enforcing boundary conditions, which is an important simplification. Previously, the diffusivity of a field (or some proxy for diffusivity) on the boundary was used to add the flux associated with a `Value` or `Gradient` boundary condition. . This PR also adds special boundary conditions for tendency terms (sometimes called 'source terms' in the code), and for the pressure field. Finally, we introduce the boundary condition `BoundaryCondition{Flux, Nothing}` as a synonym for a no-flux boundary condition that does not require the calculation of boundary source terms, to save a few accesses to global memory. Right now there is a bit left to do:. - [x] adapt the checkpointer for the new `timestepper` structure (checkpointer tests currently fail); - [ ] decide whether pressure boundary conditions should be precomputed and stored in `poisson_solver` (currently they are computed at the beginning of a time-stepping cycle inside `time_step!`). If we add pressure boundary conditions to `poisson_solver`, we can also get rid of the special `PoissonBCs` types, since the pressure fields now have explicit bcs associated with them. But this is not urgent.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/389:1829,adapt,adapt,1829,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/389,1,['adapt'],['adapt']
Modifiability,"s.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Center,Center,Face,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,Array{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{NormalFlow,Nothing},BoundaryCondition{NormalFlow,Nothing}}}}}}}; filepath::String, schedule::TimeInterval, array_type::Type{T} where T, field_slicer::FieldSlicer{Colon,Colon,Colon}, global_attributes::Dict{Any,Any}, output_attributes::Dict{Any,Any}, dimensions::Dict{Any,Any}, mode::String, compression::Int64, verbose::Bool) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:318; [4] top-level scope at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:38; [5] include(::String) at ./client.jl:457; [6] top-level scope at REPL[21]:1; in expression starting at /home/tomas/repos2/Oceananigans.jl/sandbox/stretch.jl:34; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013:17418,sandbox,sandbox,17418,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1466#issuecomment-799790013,2,['sandbox'],['sandbox']
Modifiability,"sBashforth2] with y Periodic on vertically stretched grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically uniform grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo ; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, QuasiAdamsBashforth2] with y Flat on vertically stretched grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Flat y; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5 ; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically uniform grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] regularly spaced with Δz=0.4; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Periodic on vertically stretched grid ...; grid = 5×5×5 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [-1.0, 1.0) regularly spaced with Δx=0.4; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.4; └── Bounded z ∈ [-1.0, 1.0] variably spaced with min(Δz)=0.3, max(Δz)=0.5; [ Info: Testing Lagrangian particle tracking [CPU, RungeKutta3] with y Flat on vertically uniform grid ...; grid = 5×1×5 RectilinearGrid{Float64, Periodic, Flat, Bounded} on CPU with 3×0×3 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232:2444,variab,variably,2444,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3550#issuecomment-2063314232,1,['variab'],['variably']
Modifiability,"se information (replaced with zero bits -> redundancies) then lossless compression to remove redundancies. I've looked into the bitwise real information content for a single checkpoint in Simone's OMIP simulations and I got this with the orange line denothing the 99.9% of real information . ![image](https://github.com/CliMA/Oceananigans.jl/assets/25530332/9a211dce-08dc-41aa-adb2-1d4c2c7d99d1). So ; - u, v have 0-2 mantissa bits of information (=keepbits) with more information in the surface layer (k=60); - w has 0 keepbits (exponent bits though!); - tempreture T (in ˚C) has 7 keepbits (that's 3-4 digits) relatively independent of depth; - salinity S has 12 at the surface which however increases to 16 in the deep ocean; - sea surface height $\eta$ is at 6 keepbits; - tendencies are generally lower but maybe then shouldn't be stored anyway (use single Euler forward instead). The checkpoint file Simone provided had; - 18GB total file size, single time step; - including 7 halo points in all directions; - 400MB are grid; - u,v,w,T,S,$\eta$ variables and 2x tendencies (AB2) for all but w, all in Float64. #### Compression options. The 18GB can be compressed into. - Only lossless: 6.9GB (2.6x), removes redundancies from halo and immersed boundaries; - Only Float32: 9GB (2x), removes only some false information in tailing bits; - Float32 then lossless: 3.25GB (5.5x); - Bitrounded then lossless: 1GB (18x); - Bitrounded, zero tendencies, then lossless: 350MB (51x), with lossy compression saving the tendencies becomes eventually pointless as restarting with a single Euler forward step might just do the job anyway. This currently uses Zstd (https://github.com/facebook/zstd), a modern yet already widely available lossless compressor through its commandline interface `zstd`. With JLD2 at the moment `compress=true` uses `ZlibCompressor` from https://github.com/JuliaIO/CodecZlib.jl which is similarly good but 2-3x slower. I'm working on getting CodecZstd supported in JLD2: https://g",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3599:1486,variab,variables,1486,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3599,1,['variab'],['variables']
Modifiability,"solves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Can you try running the code on the GPU? I think it would be enlightening to see if there's a slowdown in that case. We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. > because presumably the advection of the background state by the background state is zero. I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. The idea being that if there is a valid way to decompose a flow into background and perturbation components, then the equation that governs the background component is completely neglected (this includes both the nonlinear terms and any linear terms involving the background flow). _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ideally I think we would include these because the above argument doesn't justify neglecting them, but the implementation seemed too complicated the last time I thought about it so I put it off. I think it's a solvable problem but requires a bit of thought to integrate into the current algorithm seamlessly. > Mu understanding is that it is required for GPU runs, but it also helps optimize CPU runs. This is correct --- if you're missing a `const` on a variable that's used in a kernel, that kernel will fail to compile on the GPU (it won't just be slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623:2557,variab,variable,2557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623,1,['variab'],['variable']
Modifiability,"sonally quite picky about specifying outputs and output file names, so I might always end up with verbose boilerplate for output writing (and I'm personally fine with that). But I'd support reducing boilerplate and maybe just a bit of flexibility would work even for picky people! I remember having this conversation in #1171 actually!. One-line flexible output writing would be especially great for examples, new user friendliness, and quick iteration. Some thoughts:; 1. I think the name `output!` is a bit vague in what it does. Does it just output the current state of the simulation? Would `add_output_writers!` be clearer and align more closely with existing Oceananigans nomenclature? For the same reason, I'd suggest keeping `add_callback!` over renaming to `callback!`.; 2. I frequently output both JLD2 and NetCDF versions of the exact same data. So ideally subsequent calls to `add_output_writers!` with `JLD2Format()` and `NetCDFFormat()` would add both.; 3. Would definitely support extending this to NetCDF as well!. > First, we need to default `with_halos=true` for JLD2OutputWriter. The time has come because `FieldTimeSeries` is mature. We do, in fact, want halos. Sounds good! Will be nice for derivatives to work by default. Although `FieldTimeSeries` could do with a bit more maturing, e.g. issues #3144 and #3750. > The other conundrum is `overwrite_existing` which is discussed on #3543. In short I am wondering whether the best course of action is simply to make default `overwrite_existing=true` and solve so much boilerplate. Is the ""so much boilerplate"" just the extra one line `overwrite_existing = true` for each output writer? Maybe I'm too conservative here but I think the default should be `overwrite_existing = false` just because the cost of overwriting and losing data can be very high. But I really like the suggestions in #3543 of having the option to save output in unique directories be easily specifiable. If we want an easy default, then maybe it could do som",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875:1059,extend,extending,1059,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3793#issuecomment-2375865875,2,['extend'],['extending']
Modifiability,"step is when this happens?I'm wondering if it has to do with using a very small time-step, leading to a round-off error issue. That would also explain why it doesn't affect dynamics, because huge pressure gradient integrated over a machine epsilon duration may not have an impact.; > ; > Are you referring to the fact that sometimes `model` has to use a very tiny time-step to bridge the gap between the current time and the output time? If so, that's an interesting possibility that I hadn't considered. Although in the example above I'm fixing the time-step at `25`, while the output time interval is `200`, so I wouldn't expect any issues there. Can you check just to be sure? Because having an output interval that's some multiple of the time step is exactly when we expect to see miniscule time-steps due to round off error. The pressure source term is the divergence of the predictor velocity divided by time-step. As the time-step vanishes, the divergence of the predictor velocity also vanishes (because the flow has not evolved from its previous, non-divergent solution). We get a situation tending to 0/0. I think there's a few things we could do to solve this. First of all if we take a very small time-step, I think we can actually just re-set the model time rather than taking a time-step. Second I am wondering if we want to implement a time type that has finite resolution (ie there is a smallest time increment one can take). For example, datetimes have a smallest unit (micro or nanoseconds). A non-dimensional or dimensional-agnostic time type could also be designed analogously (eg every time is the multiple of an integer by the fundamental unit). This would eliminate round off error but it's a bit of work and also we have to put some thought into how best to accomplish it. There might also be a simpler solution by adjusting how we increment time. I'm not sure. > Also wouldn't that also affect simulations with `buoyancy=nothing` if the pre-output time-step were to blame?. I",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025:1091,evolve,evolved,1091,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3593#issuecomment-2103013025,2,['evolve'],['evolved']
Modifiability,"t I'm opening it to make the future design of the pressure solver module more transparent as we will be adding some new pressure solvers soon, including a conjugate-gradient solver by @christophernhill. # Motivation. In PR #290 I implemented a pressure solver for the `(Periodic, Bounded, Bounded)` channel topology using the 2D fast cosine transform algorithm described by Makhoul (1982) as CUFFT does not provide cosine transforms for the GPU and does not support FFTs along non-batched dimensions (see https://github.com/JuliaGPU/CUDA.jl/issues/119). This has been a very unpopular decision for good reasons. The 2D DCT algorithm is quite slow (channels are ~2x slower than doubly periodic on GPUs) and is quite complicated. Due to my inexperience, I didn't realize that transposing the array to do the FFT was the way forward. The pressure solver module is also quite out of date, it hasn't been updated since topologies were introduced (#614) almost exactly a year ago. This PR refactors the pressure solver module to:; 1. Support all topologies on the CPU and GPU performing transposes and index permutations as needed by each transform.; 2. Use the fastest transforms as allowed by the topology. This means batching dimensions when possible.; 3. Consolidating all pressure solvers into a single solver for all topologies. This should simplify the code and make it easier to extend. Resolves #586; Resolves #593; Resolves #594; Resolves #1007. # To batch or not to batch for FFTW on CPUs?. TODO:; - [x] Benchmark 1D {FFT, IFFT}{x, y, z}.; - [x] Benchmark 3D {FFT, IFFT}; - [x] Benchmark 1D {DCT, IDCT}{x, y, z}.; - [x] Benchmark 3D {DCT, IDCT}; - [x] Try N = 16, 64, 256; - [x] Is it faster to do 3 1D transforms or 1 3D transform? Answer: 1 3D transform. To see whether we should just do 1D transforms for everything or whether batching is faster I ran some 1D and 3D FFT benchmarks. The results for triply-periodic are posted below. Based on the benchmarks, it seems that for 256^3 doing three",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338:1021,refactor,refactors,1021,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338,1,['refactor'],['refactors']
Modifiability,"t place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The presence of the open boundary is unphysical by definition... I personally don't need much convincing that a matching scheme of some kind is needed. I'm just confused about how all of the different pieces that seem to enter into nesting interact with one another --- sponge layers, matching scheme, and also the particular physics of the flow in question (idealized in and outflows vs true nesting). With so many degrees of freedom and complexity I think a systematic approach is absolutely essential. I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching scheme, or a combination of matching scheme and sponge layer) which is supported by unequivocal and rationally presented evidence.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291:2271,layers,layers,2271,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291,2,['layers'],['layers']
Modifiability,"t regard the power method algorithm as predicated on a hypothesis (not an exact theory), which we provide empirical evidence for. This is one of the advantages of the power method that uses the full original system, I think, over more brute force approaches that forcefully remove nonlinear terms.; > ; > It is possible to replace the approx with an `=` and also include all of the nonlinear terms what one would get from the manipulations that lead to the equation for `Phi`. This is precisely what you would do if you were interested in continuing the asymptotic expansion _that linearization implies_ to investigate things like saturation, etc. So there's also a neat pedagogical power in the approx symbol in that it provides a hint for further learning and exploration of the mathematics of the system. I agree with **all** of the above. However, you missed one of my points... my disagreement was mostly of the phrasing. You suggested writing:. > Linear instabilities such as the Kelvin-Helmholtz instability, are described by equations of the form ∂_t Φ + L Φ ≈ 0 ... This statement is wrong --- that was my only objection. When accompanied with the messages you posted above it makes absolutely sense! But would you expect users to infer all these just from the ≈ symbol?. Reading your post made me think. I now suggest the following restructure (I'll present here a skeleton). - first discuss linear instabilities... the fact that Oceananigans.jl won't give you the linear operator but will evolve the full nonlinear system and the ""hack"" to get _approximately linear dynamics_ (I'll use ≈ here ;)) by utilizing `BackgroundFields`+**small amplitude**; - next discuss how we do eigenanalysis of the linear operator (without having the `L` in hand in the first place): here describe the power method and how we use the `simulation` of the ""approximately linear dynamics"" for `Δτ`described above as a way to ""apply `L`... How do you like this? (I'll work on this refactoring tomorrow probably.)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282:2410,evolve,evolve,2410,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1125#issuecomment-720166282,2,"['evolve', 'refactor']","['evolve', 'refactoring']"
Modifiability,"t; > writers as being logically separate from the main code. As a stand alone; > package, OceananigansOutput.jl doesn't do anything useful. Something like; > TurbulenceClosures.jl could though.; >; > Keeping things in tidy submodules within a single repository increases; > code visibility, which I think is important. When I see a package or; > framework spread across multiply small packages I find it hard to get an; > idea about what it can do.; >; > Another nice thing is we currently have ""unified versioning"" so when; > releases occur we know everything works together. We don't have to worry; > about running with Oceananigans v0.x with OceananigansPlotting v0.y and; > OceananigansOutput#master to fix some issue.; >; > From a development perspective, issues and pull requests are now spread; > across multiple repositories and we can end up with pull requests that; > depend on other pull requests in other repositories, e.g. when adding in; > halo regions the main code got refactored but so did the output writers and; > plotting code would change as well. We can also end up with multiple test; > suites that need to pass, plus possibly multiple CI pipelines to manage. So; > right now it's easy to make atomic changes that touch upon multiple pieces; > of code (and we'll probably be in this stage where we need to refactor; > frequently for a while).; >; > I also don't have to git clone a bunch of repositories just to work on a; > simple example.; >; > But this is getting off-topic.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/284?email_source=notifications&email_token=AA27DYA55SSJKHXQBFUSJDLP2OVODA5CNFSM4HXEYRJ2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODXXAHFI#issuecomment-502137749>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/AA27DYEHNERHN4MHAGJQZH3P2OVODANCNFSM4HXEYRJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049:1640,refactor,refactored,1640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/284#issuecomment-502146049,2,['refactor'],"['refactor', 'refactored']"
Modifiability,"tead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the output writer constructor to another function that gets called after `run!(simulation)`. Not very hard, but something to ponder. Here's a few other random ideas that would also address this issue in slightly different ways. 1. Implement a ""pickup mode"" specified with an environment variable like `OCEANANIGANS_PICKUP=true` (rather than something we write in a script). Then output writer constructors can search for this environment variable and override `overwrite_existing` (with a warning?) in the output writer constructor. ""pickup mode"" has other usability benefits (ie it's annoying we have to change the run script / prepare the run script to be ""pickup"" aware: pickup mode avoids this so we can toggle to pickup mode from _outside_ the run script without internal changes) and also obviates the need to separate output writer constructor from output writer ""initialization"". 2. If we ""delay"" output writer construction, we can also extract the option ""overwrite_existing"" and p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:1902,refactor,refactoring,1902,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,1,['refactor'],['refactoring']
Modifiability,"th gravity tilted at 45 degrees; >; > [image: tilted_gravity_plume]; > <https://user-images.githubusercontent.com/20099589/100940093-5ab5d600-34c5-11eb-918e-f574f284f024.gif>; >; > This is an experimental feature since it needs more rigorous testing and; > because full support for tilted gravity may require more work, e.g.; >; > 1. Should AMD use z_dot_g_b now?; > 2. Should ∂x_b return a vector or should it be split up into x_dot_∂x_b,; > etc.? The Leith closure uses ∂x_b.; > 3. We may want to clean up and refactor the implementation, taking; > some suggestions from #1151; > <https://github.com/CliMA/Oceananigans.jl/issues/1151>.; >; > cc @tomchor <https://github.com/tomchor>; >; > Resolves #1151 <https://github.com/CliMA/Oceananigans.jl/issues/1151>; > ------------------------------; > You can view, comment on, or merge this pull request online at:; >; > https://github.com/CliMA/Oceananigans.jl/pull/1242; > Commit Summary; >; > - Make room for tuple gravity; > - Some `{x,y,z}_dot_g_b`; > - Tilted gravity plume sandbox; >; > File Changes; >; > - *A* sandbox/tilted_gravity_plume.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-9f5abd06fd694cf6f0d35019ea409e07e100a801fbfcd9a2a8d3737801a341b0>; > (53); > - *M* src/Buoyancy/Buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-55d14f16043b022b6a286fd9881d334208e6b6251d122555d3ede4014ea59e55>; > (10); > - *A* src/Buoyancy/gravitational_acceleration.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-bb73385a8b574af8f9b259bd480acf1bdd913e8969bb440833342c0fba3f1150>; > (7); > - *M* src/Buoyancy/linear_equation_of_state.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-f3c384915af5bdd55a7a9cb929dee20fcca1682630706def515ed65b5a3cb490>; > (42); > - *M* src/Buoyancy/seawater_buoyancy.jl; > <https://github.com/CliMA/Oceananigans.jl/pull/1242/files#diff-17b154b6d4fa0d986ee4ef99715cced4bc7eac3c93690c52239d83745090c334>; > (56); > - *M* src/Models/Incom",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819:1604,sandbox,sandbox,1604,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-737549819,2,['sandbox'],['sandbox']
Modifiability,"thanks for the explanation. On Mon, Oct 12, 2020 at 8:25 PM Gregory L. Wagner <notifications@github.com>; wrote:. > Greg, Doesn't Ali have a version of immersed boundary layers going?; >; > @johncmarshall54 <https://github.com/johncmarshall54>, Ali experimented; > with a simple immersed boundary implemented via Oceananigans's user-defined; > forcing functions. The code is these 9 lines:; >; >; > https://github.com/CliMA/Oceananigans.jl/blob/a921fc3edbf795bf4a2193cca84cad41ebdd5625/verification/flow_around_cylinder/flow_around_cylinder.jl#L18-L27; >; > This implementation damps the velocity field to zero on a very fast; > time-scale (specified by the parameter K) within the immersed boundary.; > This is certainly a nice, simple immersed boundary implementation for; > Dirichlet / Value boundary conditions and could a good starting point.; > However, I also think there's some good reasons to pursue an alternate; > immersed boundary implementation to what @ali-ramadhan; > <https://github.com/ali-ramadhan> has done for the following reasons:; >; > 1. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > doesn't obviously extend to other boundary conditions, like prescribed; > gradients or fluxes (the latter being crucial for the geophysical problems; > we're interested in). So, even if we use a continuous forcing method; > similar to @ali-ramadhan <https://github.com/ali-ramadhan>'s; > implementation, we need to figure out how to enforce boundary conditions; > other than Dirichlet boundary conditions.; > 2. @ali-ramadhan <https://github.com/ali-ramadhan>'s implementation; > conforms exactly to the grid; however we would like to be able to model; > smoothly-varying boundaries.; > 3. As noted by @whitleyv <https://github.com/whitleyv>, @ali-ramadhan; > <https://github.com/ali-ramadhan>'s ""continuous forcing method""; > implementation introduces a time-step restriction due to the need to; > explicitly resolve the damping time-scale in the forcing function. It se",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052:170,layers,layers,170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1036#issuecomment-707413052,1,['layers'],['layers']
Modifiability,"the Redi tensor and GM for TwoDimensionalLeith so GM-Redi might; > not need too much extra work:; > https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl; > Questions/proposal; >; > 1. Do we make the small-angle approximation? I would say yes.; >; > In Oceananigans.jl right now each component of the tensor diffusivity is; > calculated on-the-fly so the unapproximated tensor could end up being 2-4x; > more expensive to compute. We cannot compute the full tensor in one go; > (reusing the isopycnal slopes) and we may not want to since it takes up a; > lot of memory (9 extra field?). But maybe there's a good reason to not make; > the small-angle approximation? We could eventually support both; > (unapproximated and small-angle approximation).; >; > See; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion; > for a comparison of the two.; >; > 1. Is GM-Redi the main parameterization of interest? Would people use; > the fully symmetric or the fully anti-symmetric diffusivity tensor by; > themselves?; >; > If not then maybe we can save some time by just implementing one new; > closure, GMRedi or GentMcWilliamsRedi. If we take the isopycnal; > diffusivity to be the same for both the symmetric and anti-symmetric tensor; > then we the resulting tensor is quite cheap to compute (only 3 components); > if performance is important:; >; > From; > https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#griffies-skew-flux; > [image: image]; > <https://user-images.githubusercontent.com/20099589/111556957-1abbeb80-8762-11eb-9fb3-870d447efa5f.png>; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/1492>, or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT2T2NK46W7G7ZS5ULTEFFH5ANCNFSM4ZLUCVJQ>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587:1871,parameteriz,parameterization,1871,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492#issuecomment-801541587,1,['parameteriz'],['parameterization']
Modifiability,"the original purpose of `data`. * This PR depends on the arbitrary tracers PR. The arbitrary tracers PR should be merged before this one. * To permit mixing `Function`s in with `Field`s and `Number`s in `AbstractOperations`, we also define a `FunctionField` type that acts like a field, but invokes a function to compute values at its location under the hood. This type probably needs more tests. We should also investigate whether this type can be used to specify things like background fields. A `FunctionField` can either be time-dependent and a function of `x, y, z, t` (achieved by allowing it to possess a reference to `clock`), or a static function of `x, y, z`. * This PR changes the result of a horizontal average to `HorizontalAverage.result` to provide a common terminology with `Computation`, as well as future reductions along other dimensions (previously the result of a horizontal average was called `profile`). * This PR adapts `Field` to work on the GPU (after the hard work of adapting all the `AbstractOperation`s to work on the GPU, this seemed trivial). That this works now should be tested. If it does indeed work and there is no loss of performance, we can eliminate a lot of cruft from our `time_step!`, and also use fields directly in `AbstractOperation`s (right now we extract the underlying `OffsetArray` instead). # In summary. Miraculously, tests pass on the GPU. However, this framework is quite general and powerful, so we need to . - [x] think carefully about the tests we need (and don't need). . And certainly before merging we also need. - [x] docstrings... . Also, it'd be nice to. - [x] use `AbstractOperation` to define useful output in an example. Some discussion may be warranted about what's exported from `AbstractOperations`; we almost always want to have `Face` and `Cell`, for example. Ultimately, I think it'd be nice to write `using Oceananigans.Fields, Oceananigans.AbstractOperators` to get what's needed for this purpose. But that's yet another futur",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:7321,adapt,adapts,7321,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,2,['adapt'],"['adapting', 'adapts']"
Modifiability,"these are if we want to make the particle velocity depend on other _eulerian_ fields (like forcing for our prognostic variables). An example can be the buoyancy field for buoyant particles. If we decide that that role can be undertaken by the `dynamics` kernel, we can remove the `i, j, k` from the signature. We should probably come up with a couple of examples to include in this PR that show the implementation of different particle dynamics. ; I would include:; - buoyant particles (sinking or rising with a density-dependent vertical velocity); - particles with drag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078:118,variab,variables,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3396#issuecomment-1852745078,1,['variab'],['variables']
Modifiability,"this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace it with the ""real"" closure after constructing model by writing `model.closure = real_closure`. It could be fun to try that and see if the code is simpler. I suspect it might not be but it's worth a shot (you might learn something). . > Thinking on a more general way, it would be awesome to give a general function that could depend on any field in the model, including auxiliary. I am thinking that this way it would be easier for users to create and implement their own parameterizations. I guess that's sort of what we're doing here. The main issue is reducing boilerplate / making this as easy as possible. It'd be nice to write parameterizations with more abstract syntax rather than having to write a low-level kernel function.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:2950,parameteriz,parameterizations,2950,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,4,['parameteriz'],['parameterizations']
Modifiability,"this to work seamlessly when a `JLD2OutputWriter` is involved we might need to modify the constructor for `JLD2OutputWriter`. Currently the constructor runs an arbitrary `init(file, model)` function, and saves certain properties identified in the constructor signature:. https://github.com/CliMA/Oceananigans.jl/blob/9cfb568ec3a8e6f7efe8c7c41300ea9673c6b103/src/OutputWriters/jld2_output_writer.jl#L157-L160. This will fail if the output file already exists; thus it's not possible to pickup from a checkpoint with the same script used to initialize the model (without destroying prior output). A simple change could just be to allow `init` and `save_properties!` to fail with `try/catch` (or to avoid running those functions if a file already exists). There are also some shenanigans that'd have to be done for output files split into multiple `part`s. (We could, potentially, require `pickup=true` in the `JLD2OutputWriter` constructor, rather than changing its default behavior to accommodate auto-checkpoint-pickup). Another caveat is that this method of restoring checkpointed data will not work for large CPU models that consume almost all of the CPU memory (such that a single field cannot be loaded from file after `model` has been instantiated). These cases are relatively rare right now, since such large models would typically run very slowly on a typical single node. The basic idea is:. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=true); ```. We could also allow `pickup` to be an iteration number, eg. ```julia; # Model and simulation setup. simulation.output_writers[:checkpointer] = Checkpointer(...). run!(simulation, pickup=10138); ```. It may also be possible to enable this functionality with an environment variable; eg. ```bash; PICKUP=true julia --project run_cool_simulation.jl; ```. Note that this design works even if `model.clock.iteration==0`, since the initial checkpoint can be picked up.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1068:2799,variab,variable,2799,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1068,1,['variab'],['variable']
Modifiability,"thub.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-738870593. There may be other problems that we haven't uncovered. An important additional case that doesn't work right now is operations that have embedded `AveragedField`. I think this is some kind of type inference issue. For `Field` on the GPU we ""throw away"" the wrapper and expose the underlying `OffsetArray` to GPU kernels. So compilation of functions of `Field` is ""no more difficult"" than compilation of functions with `OffsetArray`. This idealization is successful because indexing into the underlying `field.data` is identical indexing into the field itself, and because we don't require field locations _inside_ the kernel (we build expression trees for AbstractOperations on the CPU, prior to launching the kernel). But this idealization doesn't hold for `AveragedField` or any `ReducedField`. In particular, abstract operations index into these objects at all `i, j, k`. However, they don't vary on one or more of these directions; the indexing operation needs to be ""collapsed"" so that reduced indices are translated correctly. Thus when we adapt `AveragedField` for the GPU, we hold onto the wrapper:. https://github.com/CliMA/Oceananigans.jl/blob/98cd4f7a56aa581defc721a01d6e1ab89b534d26/src/Fields/averaged_field.jl#L94-L96. Peeking at the broadcasting code used by julia Base gives a hint. Broadcasting has to solve the same problem: we have to be able to make computations between arrays of size (Nx, Ny, 1) and (Nx, Ny, Nz), for example. In this case, the indices of the first array are ""extruded"" into the third dimension. There are [some shenanigans in `Base.Broadcast`](https://github.com/JuliaLang/julia/blob/e467661f080a1b14ca1a9cf6681a8c713a3ae20c/base/broadcast.jl#L572-L630) that look like they are solving some type instability problem (which would doom GPU compilation for us if it were occurring). So we might be able to learn / borrow code from `Base.Broadcast`. All speculation from a naive julia programmer...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550:2531,adapt,adapt,2531,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1595#issuecomment-821847550,2,['adapt'],['adapt']
Modifiability,"tical results to the current implementation of `HydrostaticFreeSurfaceModel`. I think we will also want a rectilinear grid to use for testing to avoid modifying `RegularRectilinearGrid`, such as a refactored or reimplemented three-dimensionally `StretchedRectilinearGrid` from #1532 which accepts the use of a generalized vertical coordinates. 2. Introduce `ZStarCoordinate` (or maybe `FreeSurfaceWeightedVerticalCoordinate`). ""z-star"" vertical coordinate is a relatively simple GVC, with a small, diagnostic time-dependence. A successful implementation will require integrating thickness-weighted equations, correct vertical derivatives, and ensuring correct horizontal pressure gradients. 3. Implement remapping as an alternative to vertical advection and test using `ZCoordinate` and `ZStarCoordinate`. Of course, steps 3 might evolve depending on our experience during step 2. . An important choice that's part of step 1. is whether to use thickness-weighted variables as state variables rather than unweighted variables (eg `hu` rather than `u`, and `hc` rather than `c`. I suspect it makes sense to use thickness-weighted state variables because this simplifies the underlying implementation (for example, we only need `hⁿ` rather than both `hⁿ⁺¹` and `hⁿ` to evolve a tracer field, and we can evaluate the prognostic equations in the same order that we do now), and because it is easy to provide abstractions for users to compute, inspect, and output unweighted variables `u = hu / h`. The pros and cons of this important choice should be discussed. The discussion on #1549 is related (I decided to start a new issue because GVC are more general than terrain-following coordinates). **Some references**; * [MOM6 description](https://agupubs.onlinelibrary.wiley.com/doi/pdf/10.1029/2019MS001726) (Adcroft et al 2019); * [Primer on “remap” methods](https://agupubs.onlinelibrary.wiley.com/doi/epdf/10.1029/2019MS001954) (Griffies et al, 2019); * [“z-tilde” GVC used by the NEMO ocean model](https",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1679:2856,variab,variables,2856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1679,3,['variab'],['variables']
Modifiability,"time-stepping loop in our wind mixing and convection example:. https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/examples/ocean_wind_mixing_and_convection.jl#L199. This printing produces a stream of messages during the simulation:. ```julia; julia> include(""ocean_wind_mixing_and_convection.jl""); i: 0010, t: 11.000 s, Δt: 1.100 s, wmax = 7.8e-04 ms⁻¹, wall time: 594.383 ms; i: 0020, t: 23.100 s, Δt: 1.210 s, wmax = 1.5e-03 ms⁻¹, wall time: 581.628 ms; i: 0030, t: 36.410 s, Δt: 1.331 s, wmax = 2.3e-03 ms⁻¹, wall time: 567.346 ms; i: 0040, t: 51.051 s, Δt: 1.464 s, wmax = 3.2e-03 ms⁻¹, wall time: 562.455 ms; i: 0050, t: 1.119 min, Δt: 1.611 s, wmax = 4.2e-03 ms⁻¹, wall time: 576.511 ms; i: 0060, t: 1.415 min, Δt: 1.772 s, wmax = 5.2e-03 ms⁻¹, wall time: 571.096 ms; ```. In this case, the information we decide to print is:. * iteration number `i`; * the simulation time `t`; * the time-step (because we are using adaptive time-stepping); * the maximum vertical velocity; * the elapsed wall time for time stepping *only* (not including plotting) between print messages. I think this issue is about a better way to achieve the printing of simulation progress. Two ideas are:. 1. Somehow use a logging package (though I'm not 100% what this would look like --- perhaps this means adding lines to our [time-stepping loop](https://github.com/climate-machine/Oceananigans.jl/blob/ca814dbe608487857c06a51a7383350dcf1e46f4/src/time_steppers.jl#L28)?; 2. Create some types that allow the user to more easily manage the printing of progress messages, expanding on the pattern used in our example. I've thought a bit about 2: I think a generic progress messenger would be both configurable but also include some comforting defaults. A simple way to start could be something like. ```julia; struct ProgressPrinter{DT, M, D}; Δt :: DT; model :: M; diagnostics :: D; end; ```. with some kind of print function, something like. ```julia; pretty_Δt(Δt::Number) =",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221:1200,adapt,adaptive,1200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/71#issuecomment-540828221,1,['adapt'],['adaptive']
Modifiability,"time` is the current simulation time and `clock.iteration` is the current model iteration,; and `model_fields` is a `NamedTuple` with `u, v, w`, the fields in `model.tracers`,; and the fields in `model.diffusivities`, each of which is an `OffsetArray`s (or `NamedTuple`s; of `OffsetArray`s depending on the turbulence closure) of field data. When `discrete_form=true` and `parameters` _is_ specified, `func` must be callable with the signature. `func(i, j, k, grid, clock, model_fields, parameters)`; ; `parameters` is arbitrary in principle, however GPU compilation can place; constraints on `typeof(parameters)`. Examples; =======. ```julia; # Parameterized forcing; parameterized_func(x, y, z, t, p) = p.μ * exp(z / p.λ) * cos(p.ω * t). v_forcing = Forcing(parameterized_func, parameters = (μ=42, λ=0.1, ω=π)). # Field-dependent forcing; growth_in_sunlight(x, y, z, t, P) = exp(z) * P. plankton_forcing = Forcing(growth_in_sunlight, field_dependencies=:P). # Parameterized, field-dependent forcing; tracer_relaxation(x, y, z, t, c, p) = p.μ * exp((z + p.H) / p.λ) * (p.dCdz * z - c) . c_forcing = Forcing(tracer_relaxation,; field_dependencies = :c,; parameters = (μ=1/60, λ=10, H=1000, dCdz=1)). # Unparameterized discrete-form forcing function; filtered_relaxation(i, j, k, grid, clock, model_fields) =; @inbounds - (model_fields.c[i-1, j, k] + model_fields.c[i, j, k] + model_fields.c[i+1, j, k]) / 3. simple_forcing = Forcing(simple_nonlinear_source, discrete_form=true). # Discrete-form forcing function with parameters; masked_damping(i, j, k, grid, clock, model_fields, parameters) = ; @inbounds - parameters.μ * exp(grid.zC[k] / parameters.λ) * model_fields.u[i, j, k]. masked_damping_forcing = Forcing(masked_damping, parameters=(μ=42, λ=π), discrete_form=true); ```. ## New object showing up in discrete-form boundary condition functions and forcing functions. Previously, discrete-form boundary condition functions and forcing functions contained an object called `state`: `state.velocit",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/989:3873,Parameteriz,Parameterized,3873,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/989,1,['Parameteriz'],['Parameterized']
Modifiability,"tions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,; Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}},Field{Cell,Cell,Cell,OffsetArray{Float64,3,CuArray{Float64,3}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}},NamedTuple{(:u, :v, :w, :T, :S),Tuple{ParameterizedForcing{var""#Fu_func#83"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fv_func#84"",NamedTuple{(:τ,),Tuple{Int64}}},ParameterizedForcing{var""#Fw_func#85"",NamedTuple{(:τ,),Tuple{Int64}}},typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},CenteredSecondOrder,PressureSolver{Oceananigans.Solvers.HorizontallyPeriodic,GPU,NamedTuple{(:kx², :ky², :kz²),Tuple{CuArray{Float64,3},CuArray{Float64,3},CuArray{Float64,3}}},CuArray{Complex{Float64},3},NamedTuple{(:FFTxy!, :FFTz!, :IFFTxy!, :IFFTz!),Tuple{CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},-1,true,3},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64},AbstractFFTs.ScaledPlan{Complex{Float64},CUDA.CUFFT.cCuFFTPlan{Complex{Float64},1,true,3},Float64}}},NamedTuple{(:ω_4Nz⁺, :ω_4Nz⁻),Tuple{CuArray{Complex{Float64},3},CuArray{Complex{Float64},3}}}},Nothing}, ::Int64; euler::Bool) at /home/ancellin/.julia/packages/Oceananigans/LW3v4/src/T",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:75138,Parameteriz,ParameterizedForcing,75138,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,3,['Parameteriz'],['ParameterizedForcing']
Modifiability,"tl;dr. 1. Should we change the flux convention in Oceananigans so that `FluxBoundaryCondition` specifies the flux along the _inward pointing normal_? This reverses the convention we use on ""right"" boundaries (west, north, top). For example, a negative buoyancy flux would cause cooling at the surface with this convention. This is a huge change, but I think is necessary to do things like specifying a drag boundary condition on vertical velocity (I can discuss further why this is the case if needed.). 2. How do we feel about wrapping boundary conditions for immersed boundaries in `FieldBoundaryConditions` (this requires refactoring `FieldBoundaryConditions` under the hood, but does not change the API). We can do 2. without 1. In that case we'll be able to support a lot of common cases, including ordinary oceanic cases (where boundaries do not overhang, and we only specify drag on tangential components). It's really LES cases that become tricky because we can't specify drag on vertical velocity components, or on tangential components when the boundary overhangs.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-867684689:625,refactor,refactoring,625,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1720#issuecomment-867684689,1,['refactor'],['refactoring']
Modifiability,"to discuss on what exactly needs to be implemented. My main reference is https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html. It seems that there are three different new closures that could potentially be added:; 1. Redi (symmetric) tensor diffusivity.; 2. Gent-McWilliams (anti-symmetric) tensor diffusivity.; 3. GM-Redi combining the two. Note: @glwagner has already implemented parts of the Redi tensor and GM for `TwoDimensionalLeith` so GM-Redi might not need too much extra work: https://github.com/CliMA/Oceananigans.jl/blob/master/src/TurbulenceClosures/turbulence_closure_implementations/leith_enstrophy_diffusivity.jl. # Questions/proposal. 1. Do we make the small-angle approximation? I would say yes. In Oceananigans.jl right now each component of the tensor diffusivity is calculated on-the-fly so the unapproximated tensor could end up being 2-4x more expensive to compute. We cannot compute the full tensor in one go (reusing the isopycnal slopes) and we may not want to since it takes up a lot of memory (9 extra field?). But maybe there's a good reason to not make the small-angle approximation? We could eventually support both (unapproximated and small-angle approximation). See https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#redi-scheme-isopycnal-diffusion for a comparison of the two. 2. Is GM-Redi the main parameterization of interest? Would people use the fully symmetric or the fully anti-symmetric diffusivity tensor by themselves?. If not then maybe we can save some time by just implementing one new closure, `GMRedi` or `GentMcWilliamsRedi`. If we take the isopycnal diffusivity to be the same for both the symmetric and anti-symmetric tensor then we the resulting tensor is quite cheap to compute (only 3 components) if performance is important:. From https://mitgcm.readthedocs.io/en/latest/phys_pkgs/gmredi.html#griffies-skew-flux; ![image](https://user-images.githubusercontent.com/20099589/111556957-1abbeb80-8762-11eb-9fb3-870d447efa5f.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1492:1561,parameteriz,parameterization,1561,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1492,1,['parameteriz'],['parameterization']
Modifiability,todo. - [x] Implement the preconditioner for free surface Implicit solver; - [x] Allow for flux boundary conditions with `Array` type parameters; - [ ] Implement multi-region output writers (and eventually readers?); - [x] Adapt `AbstractOperations` to `MultiRegionFields`; - [x] Add more tests for implicit solvers; - [x] Benchmark results. Closes #1582 ; Closes #2255 ; closes #2005,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253:223,Adapt,Adapt,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253,1,['Adapt'],['Adapt']
Modifiability,"tradeoff between the stability obtained by a larger $\chi$ and the dissipation introduced by deviating from the AB2 behavior. I wondered if 0.1 is too high, especially when using diffusive methods. ; Did anyone experiment with lower $\chi$, and if yes, with what results?. Would it make sense to exclude $\chi$ from diffusive terms to limit the implicit dissipation of the time-stepping scheme?. Regarding the time integral for variable time-stepping, the correct form of the AB2 with variable step would have to include the time step at $n$ and the time step at $n-1$ to be correct. This might not make a huge impact, but if we want to save time averaged tendencies and the time step changes size every ten iterations or so, the error will compound and the time average will probably be off. ; Would it make sense to implement time-step dependent coefficients for the AB2 scheme?. The problem is that if the time step changes size, the tendency terms at $G^{n-1}$ do not cancel, which is what happens with constant time stepping.; ```math; c^{n+1} = c^{n} + \Delta t (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} = c^{n+1} + \Delta t (1.5 G^{n+1} - 0.5 G^{n}); ```; In the above, between $c^{n+1}$ and $c^{n+2}$ we have added only one $G^{n}$ because the extra tendency we have added in $c^{n+1}$ is removed in the successive timestep.; With variable time steps, this is not the case! Suppose the time-step changes between $n+1$ and $n+2$; ```math; c^{n+1} += \Delta t^n (1.5 G^{n} - 0.5 G^{n-1}) ; ```; ```math; c^{n+2} += \Delta t^{n+1} (1.5 G^{n+1} - 0.5 G^{n}); ```; we remain with a spurious $G^n (1.5\Delta t^{n} - 0.5 \Delta t^{n-1}) - G^n$. . Given [this](https://homepages.math.uic.edu/~jan/mcs471/variablestep.pdf) reference, the correct formualtion might be; ```math; G^{n+1} = \frac{1}{2} \left( \left( 2 + \frac{\Delta t^n}{\Delta t^{n - 1}} \right) G^n - \frac{\Delta t^n}{\Delta t^{n - 1}} G^{n-1} \right); ```; However, also in this form, successive tendencies do not cancel out.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738:2119,variab,variable,2119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738,2,['variab'],"['variable', 'variablestep']"
Modifiability,"ts closer than a; chosen distance from the upper boundary. John. On Mon, Nov 23, 2020, 8:35 PM Ali Ramadhan <notifications@github.com> wrote:. > Some pretty promising Lagrangian particle tracking benchmarks!; >; > Couple of takeaways (all assuming a model with 128^3 grid points and QAB2; > time stepping):; >; > 1. *Low overhead*: You can advect up to ~100,000 particles on the CPU; > and up to ~10,000,000 particles on a (Titan V) GPU before the model slows; > down by more than 30%.; > 2. *Great on GPUs*: Seems that the GPU is great for advecting millions; > of particles. You can advect ~100,000,000 particles and your model only; > slows down by a factor of 4x. In this scenario, the GPU is ~620x faster; > than a single CPU core.; > 3. Calculated using (t_100000000 - t_0) / 100000000, advecting a; > single particle on the CPU takes ~110 ns while on the GPU it only takes; > ~0.127 ns. This seems a little too good to be true but I'll double check; > this.; >; > I'll start refactoring this PR using @glwagner; > <https://github.com/glwagner>'s and @zhenwu0728; > <https://github.com/zhenwu0728>'s feedback, but I think it would be; > really great if we can keep this performance.; > Benchmarks; >; > Oceananigans v0.44.1; > Julia Version 1.5.2; > Commit 539f3ce943 (2020-09-23 23:17 UTC); > Platform Info:; > OS: Linux (x86_64-pc-linux-gnu); > CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; > WORD_SIZE: 64; > LIBM: libopenlibm; > LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); > GPU: TITAN V; >; > Lagrangian particle tracking benchmarks; > ┌───────────────┬─────────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; > │ Architectures │ N_particles │ min │ median │ mean │ max │ memory │ allocs │; > ├───────────────┼─────────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; > │ CPU │ 0 │ 361.749 ms │ 364.041 ms │ 364.293 ms │ 368.854 ms │ 293.44 KiB │ 1876 │; > │ CPU │ 1 │ 375.030 ms │ 376.591 ms │ 377.959 ms │ 385.248 ms │ 29",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982:1181,refactor,refactoring,1181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982,1,['refactor'],['refactoring']
Modifiability,"ttps://www.sciencedirect.com/science/article/pii/S1463500315000967) (see also [Kong and Jansen (2020)](https://journals.ametsoc.org/view/journals/phoc/51/3/JPO-D-20-0142.1.xml)). To implement this PR we add a property to `HydrostaticFreeSurfaceModel` called `auxiliary_prognostic_fields` which provides a container for closure-specific prognostic fields that need to be stepped forward alongside the rest of the model's prognostic state. Another change is that we introduce `AbstractSkewSymmetricDiffusivity` that provides an interface for implementing mesoscale closures with skew and symmetric diffusivities. The ""MEKE"" parameterization has a two-dimensional prognostic eddy kinetic energy variable that this feature supports. It's WIP now, but a few notes are:. * We need a slightly more descriptive name than MEKE or `MesoscaleEddyKineticEnergy` I think (though it does pronounce well ""mee-key"")... maybe `PrognosticMEKEDiffusivity` or something? We may want to distinguish from (or better, combine with?) a similar parameterization with 2D prognostic MEKE called [""GEOMETRIC""](https://journals.ametsoc.org/view/journals/phoc/48/10/jpo-d-18-0017.1.xml). * There's probably a way to improve the `auxiliary_prognostic_fields` design... in particular, I'm wondering if we should use a more hierarchical structure for auxiliary fields that also encompasses `diffusivity_fields`, something like. ```julia; struct AuxiliaryFields; user_defined; diagnostic_closure_fields; prognostic_closure_fields; end; ```. The downside is that eddy diffusivities for LES are then buried in `model.auxiliary_fields.diagnostic_closure_fields`. BUT we can also design an interface for extracting these like `eddy_diffusivity(model)`. Curious what people think about that (@tomchor you've had opinions). Basically it's easier to separate the user API (here, functions that extract properties) from the model struct design (which is motivated more by internal considerations). But it's tradeoffs all the way down so good t",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2431:1112,parameteriz,parameterization,1112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2431,1,['parameteriz'],['parameterization']
Modifiability,"uildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1705; [17] (::Pkg.Operations.var""#115#120""{Dict{String, Any}, Bool, Bool, Bool, Pkg.Operations.var""#130#134""{Bool, Cmd, Cmd, Nothing, Pkg.Types.Context, Vector{Tuple{String, Base.Process}}, String, Pkg.Types.PackageSpec}, Pkg.Types.Context, Pkg.Types.PackageSpec, String, Pkg.Types.Project, String})(tmp::String); @ Pkg.Operations /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1794; [18] mktempdir(fn::Pkg.Operations.var""#115#120""{Dict{String, Any}, Bool, Bool, Bool, Pkg.Operations.var""#130#134""{Bool, Cmd, Cmd, Nothing, Pkg.Types.Context, Vector{Tuple{String, Base.Process}}, String, Pkg.Types.PackageSpec}, Pkg.Types.Context, Pkg.Types.PackageSpec, String, Pkg.Types.Project, String}, parent::String; prefix::String); @ Base.Filesystem ./file.jl:766; [19] mktempdir(fn::Function, parent::String); @ Base.Filesystem ./file.jl:762; [20] mktempdir; @ ./file.jl:762 [inlined]; [21] sandbox(fn::Function, ctx::Pkg.Types.Context, target::Pkg.Types.PackageSpec, target_path::String, sandbox_path::String, sandbox_project_override::Pkg.Types.Project; preferences::Dict{String, Any}, force_latest_compatible_version::Bool, allow_earlier_backwards_compatible_versions::Bool, allow_reresolve::Bool); @ Pkg.Operations /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1752; [22] test(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; coverage::Bool, julia_args::Cmd, test_args::Cmd, test_fn::Nothing, force_latest_compatible_version::Bool, allow_earlier_backwards_compatible_versions::Bool, allow_reresolve::Bool); @ Pkg.Operations /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1955; [23] test; @ /storage5/buildkite-agent/julia-1.10.2/share/julia/stdlib/v1.10/Pkg/src/Operations.jl:1899 [inlined]; [24] test(ctx::Pkg.Types.Context, pkgs::Vector{Pkg.Types.PackageSpec}; coverage::Bool, test_fn::Nothing, jul",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988500458:5965,sandbox,sandbox,5965,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1988500458,1,['sandbox'],['sandbox']
Modifiability,"unctions describing the bottom height. Probably an easy fix?. ---. Minimal working example:. ```julia; using Oceananigans; using Oceananigans.ImmersedBoundaries: PartialCellBottom. underlying_grid = RectilinearGrid(GPU(), topology=(Periodic, Flat, Bounded), size=(4, 4), x=(0, 1), z=(0, 1)); slope(x) = x; grid = ImmersedBoundaryGrid(underlying_grid, PartialCellBottom(slope)). model = HydrostaticFreeSurfaceModel(; grid); time_step!(model, 1); ```. produces this error:. ```; ERROR: type OffsetArray has no field data; Stacktrace:; [1] getproperty; @ .\Base.jl:37 [inlined]; [2] adapt_structure(to::CUDA.KernelAdaptor, ib::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\partial_cell_bottom.jl:80; [3] adapt(to::CUDA.KernelAdaptor, x::PartialCellBottom{OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, Float64}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [4] adapt_structure(to::CUDA.KernelAdaptor, ibg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Oceananigans.ImmersedBoundaries C:\Users\Ali\Home\atdepth\ImmersedShapes.jl\dev\Oceananigans\src\ImmersedBoundaries\ImmersedBoundaries.jl:146; [5] adapt(to::CUDA.KernelAdaptor, x::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ Adapt C:\Users\Ali\.julia\packages\Adapt\7T9au\src\Adapt.jl:40; [6] cudaconvert(arg::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{…}, PartialCellBottom{…}, Nothing, Nothing, Nothing}); @ CUDA C:\Users\Ali\.julia\packages\CUDA\Tl08O\src\compiler\execution.jl:198; [7] map; @ .\tuple.jl:294 [inlined]; [8] map(f::typeof(CUDA.cudaconvert), t::Tuple{…}); @ Base .\tuple.jl:294; [9] macro expansion; @ C:\Users\Ali\.ju",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3681:1278,Adapt,Adapt,1278,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3681,1,['Adapt'],['Adapt']
Modifiability,"underlying issue. I think the issue here is that ""entrainment"" should not occur across low stratification regions. Thus this model for ""entrainment"" assumes the stratification is ""strong"". More generally, we are dividing the boundary layer into a convecting region and an entraining region. We identify the convecting region by `N² < 0`. However, in reality the convecting region should extend further down into regions of stable, but still weak stratification below the unstable region. The ""entraining"" layer is more properly where stratification significantly increases over the weakly stratified lower part of the convecting region. (This analysis is based on LES.) `RiBasedVerticalDiffusivity`'s formulation --- apart from being overly simple --- simply cannot cope with the complexity of real boundary layer structure because it is not truly non-local. Really addressing this issue (eg implementing a more physically accurate model of boundary layer structure) might require using a vertical integral instead of a 3D kernel. (We decided that because CATKE seems like a decent parameterization, it's not worth it to pursue those accuracy improvements). One way to fix the issue but retaining a 3D kernel is to change the way we estimate ""convecting"" and ""entraining"" regions. Those criteria are. https://github.com/CliMA/Oceananigans.jl/blob/94e99e1d5fb3d121a6d801a931987bb6ff59f20e/src/TurbulenceClosures/turbulence_closure_implementations/ri_based_vertical_diffusivity.jl#L247-L248. If we introduce a new parameter, say `minimum_entrainment_buoyancy_frequency`, then we can modify this criteria to read. ```julia; convecting = N² < 0 # applies regardless of Qᵇ . N²_entrainment = minimum_entrainment_buoyancy_frequency; entraining = (N²_above < 0) & (N² > N²_entrainment) (Qᵇ > 0); ```. Now the user can determine `minimum_entrainment_buoyancy_frequency` to stabilize their model. Probably some default like `minimum_entrainment_buoyancy_frequency = 1e-7` would work for Earth-like situations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718:1618,parameteriz,parameterization,1618,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3283#issuecomment-1731439718,2,['parameteriz'],['parameterization']
Modifiability,"ure 1 of Straka et al. (1993) and https://faculty.nps.edu/fxgirald/projects/mesoscale/dc_movie.html. Things we can hopefully share between `IncompressibleModel` and `CompressibleModel:; 1. Operators; 2. Grids; 3. Coriolis; 4. Forcing functions; 5. Boundary conditions; 6. Turbulence closures; 7. Diagnostics; 8. Output writers; 9. Advection schemes; 10. User interface (setting initial conditions, boundary conditions, time stepping, etc.). Atmosphere-specific abstractions that would differentiate compressible from incompressible models:; 1. Prognostic temperature (potential temperature, entropy, enthalpy, etc.); 2. Base state (dry adiabatic, isothermal, analytic sounding, form from initial conditions, etc.); 3. Acoustic time stepper (nothing, fully explicit for regular grids, vertically implicit for stretched grids); 4. Setting fields and initial conditions is more complicated because the density needs to be adjusted when setting the potential temperature. Also because the prognostic variables are ρ, ρu, ρv, ρw, ρθ, etc.; 5. Other atmospheric things like cloud microphysics and radiation but for this there are packages that can be relied on, e.g. [RRTMGP.jl](https://github.com/climate-machine/RRTMGP.jl) and [Cloudy.jl](https://github.com/climate-machine/Cloudy.jl). It would be ideal if we have a single `Model` type and just change the equation between the `CompressibleModel` and `IncompressibleModel` but the numerical methods and abstractions employed are sufficiently different that I think it makes sense to have two separate model types. It might even make sense to keep a separate package for this `CompressibleModel` but I think for now it's better if we keep it all inside the Oceananigans.jl repository (see https://github.com/climate-machine/Oceananigans.jl/issues/284 for some previous discussion) until the code is more stable and also for extra visibility while the package is young. References:; Bannon (1995): https://doi.org/10.1175/1520-0469(1995)052%3C1743:HALP%3E",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/605:2273,variab,variables,2273,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/605,1,['variab'],['variables']
Modifiability,"ures, such as sinking/rising velocities, or reaction systems for biological/chemical tracer systems. When I have talked to various people about this, there was a concern that this system would be 'inelegant' or 'complex'. However I believe an equation abstraction system provides the opposite: with an abstraction system, equations are 'written down' in some logical place (like a file `equations.jl` in the `src` directory where they can be easily read and modified, rather than buried inside a time-stepping loop. Correspondly, our time-stepping code becomes shorter and more concise. Using multiple dispatch correctly, we avoid the `infinite if-statement` problem. This abstraction may also make the code more modular such that we move closer to supporting multiple time-steppers. Below I provide one example of an implementation that would solve some of the problems I listed. However, *this is not the only solution*, and I think we should expend some intellectual effort and have a discussion about what the best solution might be, so that we design something that is nice, easy to extend, performant, and powerful. ## A list of kernel equations in a named tuple. The simplest solution for this abstraction is probably just to add new fields to `Model` (`model.equations.velocities` and `model.equations.tracers`) that are named tuples of kernel equations. An example of how this might work while demonstrating hierarchical multiple dispatch is:. ```julia; forcing(i, j, k, grid, F::Function, u, v, w, T, S) = F(grid, u, v, w, T, S, i, j, k); forcing(i, j, k, grid, F::AbstractArray, u, v, w, T, S) = F[i, j, k]. u_eqn(i, j, k, grid, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i, j, k); - δx_c2f(grid, pHY′, i, j, k) / (Δx * ρ₀); + ∂ⱼ_2ν_Σ₁ⱼ(i, j, k, grid, closure, eos, grav, u, v, w, T, S); + forcing(i, j, k, grid, F, u, v, w, T, S); ). # Note omission of pressure term here; u_eqn(i, j, k, grid, pHY::Nothing, etc...) = (-u∇u(grid, u, v, w, i, j, k); + fv(grid, v, fCor, i,",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:2072,extend,extend,2072,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['extend'],['extend']
Modifiability,"urface!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/implicit_free_surface.jl:120 [inlined]; [19] ab2_step!; @ ~/.julia/packages/Oceananigans/AlhRd/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl:17 [inlined]; [20] time_step!(model::HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S), Tu$; @ Oceananigans.TimeSteppers ~/.julia/packages/Oceananigans/AlhRd/src/TimeSteppers/quasi_adams_bashforth_2.jl:93; [21] time_step!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:122; [22] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:97; [23] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :N, :P, :Z, :D, :T, :S),$; @ Oceananigans.Simulations ~/.julia/packages/Oceananigans/AlhRd/src/Simulations/run.jl:85; [24] top-level scope; @ /rds/user/js2430/hpc-work/ClimaOcean.jl-private/examples/one_degree_near_global_simulation.jl:246; ```; Downgrading to `0.84.1` resolves this, but I can't see any relevant changes between the two versions. . I'm not sure if there's been some change to the configuration of the nodes I'm running on which might explain all of the recent errors, but if anyone else has experienced similar we might be able to hunt the problem down. I'll work on creating an MWE because the script I'm running is quite a heavily modified version of the ClimaOcean examples, I think the most relevant changes are changes to the dependency versions.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:4461,config,configuration,4461,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,1,['config'],['configuration']
Modifiability,"user perspective my opinion is that it would have been better to throw a ""method not found"" error or a warning then have the code fail silently. So I propose we either get rid of that general default behavior and just let the code fail with an error for the unimplemented cases, or at least add a warning to the lines above. Thoughts?. A follow-up question/comment regards the organization of the `TurbulenceClosure` module. Part of the reason for my delay in catching the `calc_κᶜᶜᶜ()` issue is that I often get confused about the organizational aspect in that module. For example, there are several functions that, based on name, appear to do the same thing (`νᶜᶜᶜ`, `calc_νᶜᶜᶜ`, `getdiffusivity`; there's also a `calc_κᶜᶜᶜ` but no `κᶜᶜᶜ` function) and often the naming of the variables also doesn't help much. For example in these lines:. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L138. https://github.com/CliMA/Oceananigans.jl/blob/56c70fb07eeeb8171958dc62ed7948ff2617cf7a/src/TurbulenceClosures/turbulence_closure_implementations/anisotropic_minimum_dissipation.jl#L160. it's not clear to me what's `c`, `C`, `U`. It takes some amount of digging for me (who, admittedly, am not super familiar with the code) to conclude that `c` is the `tracer` and `U` is the `velocities` tuple. (I'm still not 100% sure what `C` is). I understand that, again, I'm not super familiar with the code, so most Oceananigans developers would understand that module faster than me, but I think it's advantageous to make the code in general more easily understandable for people like me, who aren't experts in the code. . I also understand that that is an incredibly complicated module, with no obvious way to organize it concisely. But I think using more verbose names would make it a lot more clear. So I propose we make variable and function names more verbose there. Thoughts?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2751:2866,variab,variable,2866,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2751,1,['variab'],['variable']
Modifiability,"using Oceananigans. grid = RectilinearGrid(size=(8,8,8,), extent=(1,1,1)); model = NonhydrostaticModel(grid=grid). u, v, w = model.velocities; u_mean = Field(Average(u)); outputs = (; u_mean,). filename = ""mwe.nc""; writer_nc = NetCDFOutputWriter(model, outputs;; filename = ""avgnc.nc"",; schedule = IterationInterval(1),; overwrite_existing = true,). simulation = Simulation(model, Δt=1, stop_iteration=5); simulation.output_writers[:fields] = writer_nc. run!(simulation); ```. produces this error:. ```; ERROR: LoadError: MethodError: no method matching Float32(::Array{Float32, 0}); Closest candidates are:; (::Type{T})(::AbstractChar) where T<:Union{AbstractChar, Number} at char.jl:50; (::Type{T})(::Base.TwicePrecision) where T<:Number at twiceprecision.jl:266; (::Type{T})(::Complex) where T<:Real at complex.jl:44; ...; Stacktrace:; [1] setindex!(v::NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/variable.jl:308; [2] setindex!(v::NCDatasets.CFVariable{Float32, 1, NCDatasets.Variable{Float32, 1, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, data::Array{Float32, 0}, indexes::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/dXXHC/src/cfvariable.jl:765; [3] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Nothing, Nothing, Nothing, Reduction{typeof(Statistics.mean!), Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetAr",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2857:1151,variab,variable,1151,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2857,1,['variab'],['variable']
Modifiability,"utflow speed may have caused some confusion here as it is neither the specified outflowing velocity, the outflowing velocity at the boundary point, or the outflowing velocity in the interior, but an approximation of bulk velocity advecting the interior solution to the boundary point (and its approximation is case specific).**. The next problem is that if the interior solution is outflowing and then switches to inflow it may have deviated from the external solution causing oscillations near the boundary. This is why we might want relaxation rather than specifying as described before. . What I have been calling the ""inflow_speed"" is $1/\tau$ because I don't see why the ""relaxation"" should be fixed and the user might want to change it. For example it seems to me it would be reasonable to pretend that the specified external velocity is a further halo point and upwind it into the actual boundary point. I believe sponge layers are both a different solution to over-specifying at the boundary, and a way to dampen the residual reflection/oscillation from the unwinding approximation. In the first case, the sponge has to be large enough to fully restore the interior solution to the external solution before the boundary, but in the latter, it can be smaller (so having a complicated boundary saves computational expense). . > 2. Constant or idealized inflows and outflows. I think the only real difference for these idealised cases is that you normally know that information will only travel away from one of the boundaries and so can specify the halo point with `Open`. With both of the cases shown above we also know that the mean outflowing velocity will be the same as the inflow so can approximate the ""bulk velocity"" as a constant instead of having to compute it (but we still can't specify the boundary points of the outflow because otherwise, perturbations generated in the interior wouldn't be able to escape). The other difference in this case is that we don't know the external sol",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1980880295:2076,layers,layers,2076,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1980880295,1,['layers'],['layers']
Modifiability,"ution using Oceananigans, and then illustrate embedding a high resolution domain inside that solution. A two-dimensional turbulent case would be sufficient. > To resolve this PR I could tidy up a simple matching scheme where we compute the mean outflow on the boundary and do a 1D advection for the boundary point, or relax to the external state if there is inflow. I think this shows how to use all parts of the new infrastructure, and is a satisfactory boundary condition for some cases. Would this be okay?. A simple matching scheme is a great place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The presence of the open boundary is unphysical by definition... I personally don't need much convincing that a matching scheme of some kind is needed. I'm just confused about how all of the different pieces that seem to enter into nesting interact with one anoth",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291:1300,layers,layers,1300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291,2,['layers'],['layers']
Modifiability,"uts are constructed appropriately now, but the outputs still can't be written to NetCDF because the writer creates the variables with a different size:. ```julia; ERROR: LoadError: NetCDF error: size mismatch for variable 'op_sliced2' in file './sliced.nc'. Trying to write (2, 1, 6) elements while [2, 1, 4, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:943; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float32, 3}); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/netcdf_c.jl:954; [3] setindex!; @ ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:457 [inlined]; [4] setindex!(::NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/variable.jl:490; [5] setindex!(::NCDatasets.CFVariable{Float32, 4, NCDatasets.Variable{Float32, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float32, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets ~/.julia/packages/NCDatasets/XVX8L/src/cfvariable.jl:732; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Face, Center, Center, Oceananigans.AbstractOperations.BinaryOperation{Face, Center, Center, typeof(*), Int64, Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Periodic, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655:1083,variab,variable,1083,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2508#issuecomment-1131970655,1,['variab'],['variable']
Modifiability,"veUtils]]; deps = [""Markdown""]; uuid = ""b77e0a4c-d291-57a0-90e8-8db25a27a240"". [[IteratorInterfaceExtensions]]; git-tree-sha1 = ""a3f24677c21f5bbe9d2a714f95dcd58337fb2856""; uuid = ""82899510-4779-5014-852e-03e436cf321d""; version = ""1.0.0"". [[JLD2]]; deps = [""DataStructures"", ""FileIO"", ""MacroTools"", ""Mmap"", ""Pkg"", ""Printf"", ""Reexport"", ""Requires"", ""TranscodingStreams"", ""UUIDs""]; git-tree-sha1 = ""d4962712594ec5d39e0b10745e44e3a06abec0d2""; uuid = ""033835bb-8acc-5ee8-8aae-3f567f8a3819""; version = ""0.4.4"". [[JLLWrappers]]; deps = [""Preferences""]; git-tree-sha1 = ""642a199af8b68253517b80bd3bfd17eb4e84df6e""; uuid = ""692b3bcd-3c85-4b1f-b108-f13ce0eb3210""; version = ""1.3.0"". [[JSON3]]; deps = [""Dates"", ""Mmap"", ""Parsers"", ""StructTypes"", ""UUIDs""]; git-tree-sha1 = ""65798ad6ddb0d7068f2b1885e0b0d876efca16f5""; uuid = ""0f8b85d8-7281-11e9-16c2-39a750bddbf1""; version = ""1.8.1"". [[KernelAbstractions]]; deps = [""Adapt"", ""CUDA"", ""Cassette"", ""InteractiveUtils"", ""MacroTools"", ""SpecialFunctions"", ""StaticArrays"", ""UUIDs""]; git-tree-sha1 = ""f16c8dfdd75ae4fa927fcf3aa71e1dbbd195befb""; uuid = ""63c18a36-062a-441e-b654-da1e3ab1ce7c""; version = ""0.5.5"". [[LLVM]]; deps = [""CEnum"", ""Libdl"", ""Printf"", ""Unicode""]; git-tree-sha1 = ""b616937c31337576360cb9fb872ec7633af7b194""; uuid = ""929cbde3-209d-540e-8aea-75f648917ca0""; version = ""3.6.0"". [[LazyArtifacts]]; deps = [""Pkg""]; git-tree-sha1 = ""4bb5499a1fc437342ea9ab7e319ede5a457c0968""; uuid = ""4af54fe1-eca0-43a8-85a7-787d91b784e3""; version = ""1.3.0"". [[LibCURL_jll]]; deps = [""LibSSH2_jll"", ""Libdl"", ""MbedTLS_jll"", ""Pkg"", ""Zlib_jll"", ""nghttp2_jll""]; git-tree-sha1 = ""897d962c20031e6012bba7b3dcb7a667170dad17""; uuid = ""deac9b47-8bc7-5906-a0fe-35ac56dc84c0""; version = ""7.70.0+2"". [[LibGit2]]; deps = [""Printf""]; uuid = ""76f85450-5226-5b5a-8eaa-529ad045b433"". [[LibSSH2_jll]]; deps = [""Libdl"", ""MbedTLS_jll"", ""Pkg""]; git-tree-sha1 = ""717705533148132e5466f2924b9a3657b16158e8""; uuid = ""29816b5a-b9ab-546f-933c-edad1886dfa8""; version = ""1.9.0+3"". [[Libdl]]; uuid = ""8f399da",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838:7453,Adapt,Adapt,7453,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613#issuecomment-827235838,1,['Adapt'],['Adapt']
Modifiability,"verdub.jl:0; # I truncated the huge error message here; ```. However, the nested calculation appears to work!:. ```julia; julia> dwpdz_nested = nested_calc(); BinaryOperation at (Center, Center, Center); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); │ └── domain: x ∈ [0.0, 150.0], y ∈ [0.0, 6000.0], z ∈ [-80.0, 0.0]; └── tree: ; * at (Center, Center, Center) via identity;    ├── 0.0009765625;    └── ∂zᵃᵃᶜ at (Center, Center, Center) via identity;       └── ComputedField located at (Center, Center, Face) of BinaryOperation at (Center, Center, Face); ComputedField located at (Center, Center, Center) of BinaryOperation at (Center, Center, Center); ├── data: OffsetArrays.OffsetArray{Float64,3,CUDA.CuArray{Float64,3}}, size: (3, 514, 10); ├── grid: RegularRectilinearGrid{Float64, Periodic, Bounded, Bounded}(Nx=1, Ny=512, Nz=8); ├── operand: BinaryOperation at (Center, Center, Center); └── status: time=0.0. julia> compute!(dwpdz_nested). julia> using Adapt. julia> adapt(Array, interior(dwpdz_nested)); 1×512×8 view(OffsetArray(::Array{Float64,3}, 0:2, 0:513, 0:9), [1], [1, 2, 3, 4, 5, 6, 7, 8, 9, 10 … 503, 504, 505, 506, 507, 508, 509, 510, 511, 512], [1, 2, 3, 4, 5, 6, 7, 8]) with eltype Float64:; [:, :, 1] =; 0.0262775 0.014948 0.00902569 0.00559831 0.00351427 0.00221792 0.00140318 0.000888719 … 0.000263472 0.000420913 0.000674128 0.00108572 0.00177041 0.00296775 0.00528696. [:, :, 2] =; 0.0156731 0.0110235 0.00720451 0.00461103 0.00293129 0.00185902 0.00117792 0.00074609 … 0.000915116 0.00144732 0.00229007 0.00362638 0.0057484 0.00911035 0.0143023. [:, :, 3] =; 0.00844536 0.00652392 0.00451369 0.00297425 0.00191676 0.00122263 0.000776137 0.000491594 … 0.00126331 0.00199147 0.00313408 0.00491472 0.00764863 0.0117137 0.0173591. [:, :, 4] =; 0.00263363 0.0021138 0.00150181 0.00100316 0.000649705 0.000414395 0.000262323 0.00016544 … 0.00117766 0.00185426 0.00291374 0.00455993 0.00707827 0.0108175 0.0160812. [:, :, 5] =; -0.002765",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011:6088,Adapt,Adapt,6088,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1241#issuecomment-786777011,1,['Adapt'],['Adapt']
Modifiability,"y `validate_buoyancy` in the `Model` constructor. For `BuoyancyTracer`, the user must specify a tracer named `:b`. For `SeawaterBuoyancy`, the user must specify tracers named `:T` and `:S`. (In the future, we could also allow the names of these buoyancy, temperature, and salinity tracers to be specified in the constructor for the respective buoyancy models, eg `SeawaterBuoyancy(temperature=:T, salinity=:S)`.). 2. The constructor for `ModelForcing` (which will have to be merged with #444 when it is approved) now allows the user to specify forcing for any of the tracer fields. If the user specifies a forcing for a tracer field that does not exist, an error is thrown. If a user does not specify a forcing for some tracer field, a default zero forcing is applied. 3. The same logic for `ModelForcing` applies to `BoundaryConditions` / `SolutionBoundaryConditions`. When boundary conditions for a tracer field are unspecified, a default tracer boundary condition is inferred from the x-velocity field: tracers either inherit `Periodic` boundary conditions, or are given a `Flux, Nothing` boundary condition for all other cases. 4. For closures, all tracer-diffusivity-related fields permit users to specify either:. * a constant (applied to all tracers), or ; * a `NamedTuple` with fields for *every* tracer. . In the future, we could possibly implement some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusiv",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452:1430,inherit,inherit,1430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452,1,['inherit'],['inherit']
Modifiability,"y conditions so PRs like #601 won't be necessary again. The only change in user interface is that you pass a named tuple to the model constructor now instead of an instance of `SolutionBoundaryConditions`. This also works for LES diffusivities so the amount of convoluted scripting gymnastics is much reduced (see test from #601). Setting a diffusivity BC is now almost as easy as a tracer BC. ```julia; grid = RegularCartesianGrid(FT, size=(16, 16, 16), length=(1, 1, 1)). buoyancy_bcs = TracerBoundaryConditions(grid, bottom=BoundaryCondition(Gradient, bz)); κₑ_bcs = DiffusivityBoundaryConditions(grid, bottom=BoundaryCondition(Value, κ₀)); model_bcs = (b=buoyancy_bcs, κₑ=(b=κₑ_bcs,)). model = IncompressibleModel(; grid=grid, architecture=arch, float_type=FT, tracers=:b, buoyancy=BuoyancyTracer(),; closure=AnisotropicMinimumDissipation(), boundary_conditions=model_bcs; ); ```. Internally: No surprise, this change ended up being pretty invasive. But note that we now have a more flexible and easier to use package with fewer lines of code!. I'm happy to discuss and iterate over the choices that were made in this PR. But glad that I was able to make these changes. Development of the compressible model can continue based on this branch. Changes:; 1. Fields has a new property: `field.boundary_conditions`. 2. Better pretty printing for fields:; ```; Field located at (Cell, Cell, Cell); ├── data: OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, size: (18, 18, 18); ├── grid: RegularCartesianGrid{Float64, Periodic, Periodic, Bounded}(Nx=16, Ny=16, Nz=16); └── boundary conditions: x=(west=Periodic, east=Periodic), y=(south=Periodic, north=Periodic), z=(bottom=NoFlux, top=NoFlux); ```. 3. Field tuple constructors have two versions now. One that accepts boundary conditions (useful in model constructors) and another that accepts full fields (useful for checkpoint restoration and other custom functionality). 4. ~~You can pass anything into `VelocityFields` and `TracerFields`. Perha",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/631:1335,flexible,flexible,1335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/631,1,['flexible'],['flexible']
Modifiability,"y=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> . julia> . julia> const H_deep = H = underlying_grid.Lz; 2.9999999999999996. julia> const H_shelf = h = 0.5; 0.5. julia> const width_shelf = 100; 100. julia> . julia> shelf(x, y) = -(H + h)/2 - (H - h)/2 * tanh(y / width_shelf); shelf (generic function with 1 method). julia> bathymetry(x, y) = shelf(x, y); bathymetry (generic function with 1 method). julia> . julia> grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo:; ├── immersed_boundary: GridFittedBottom(min(h)=-2.99e+00, max(h)=0.00e+00); ├── underlying_grid: 128×128×64 RectilinearGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── Periodic x ∈ [-250.0, 250.0) regularly spaced with Δx=3.90625; ├── Bounded y ∈ [-300.0, 300.0] regularly spaced with Δy=4.6875; └── Bounded z ∈ [-3.0, 0.0] variably spaced with min(Δz)=0.0106134, max(Δz)=0.12559. julia> u = XFaceField(grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 136×136×72 OffsetArray(::CUDA.CuArray{Float64, 3, CUDA.Mem.DeviceBuffer}, -3:132, -3:132, -3:68) with eltype Float64 with indices -3:132×-3:132×-3:68; └── max=0.0, min=0.0, mean=0.0. julia> u = Field((Face, Center, Center), grid); 128×128×64 Field{Face, Center, Center} on ImmersedBoundaryGrid on GPU; ├── grid: 128×128×64 ImmersedBoundaryGrid{Float64, Periodic, Bounded, Bounded} on GPU with 4×4×4 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: ZeroFlux, north: ZeroFlux, bottom: ZeroFlux, top: ZeroFlux, immersed:",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152:1435,variab,variably,1435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2744#issuecomment-1255658152,1,['variab'],['variably']
Modifiability,"you need to extend the same functions specifically for `scheme::AbstractUpwindBiasedAdvectionScheme` because of. https://github.com/CliMA/Oceananigans.jl/blob/74ce7d2248792560ea0c9286a3274c2dbacfabea/src/Advection/upwind_biased_reconstruction.jl#L92-L98. ```suggestion; @inline symmetric_interpolate_xᶠᵃᵃ(i, j, k, grid::XFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, c) = @inbounds c[i, j, k]; @inline symmetric_interpolate_yᵃᶠᵃ(i, j, k, grid::YFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, c) = @inbounds c[i, j, k]; @inline symmetric_interpolate_zᵃᵃᶠ(i, j, k, grid::ZFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, c) = @inbounds c[i, j, k]. @inline symmetric_interpolate_xᶜᵃᵃ(i, j, k, grid::XFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, u) = @inbounds c[i, j, k]; @inline symmetric_interpolate_yᵃᶜᵃ(i, j, k, grid::YFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, v) = @inbounds c[i, j, k]; @inline symmetric_interpolate_zᵃᵃᶜ(i, j, k, grid::ZFlatGrid, scheme::AbstractUpwindBiasedAdvectionScheme, w) = @inbounds c[i, j, k]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1279818970:12,extend,extend,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2757#issuecomment-1279818970,1,['extend'],['extend']
Modifiability,"y}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/memory.jl:539; [7] unsafe_convert; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:434 [inlined]; [8] #pointer#1123; @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:392 [inlined]; [9] pointer (repeats 2 times); @ ~/.julia/packages/CUDA/Tl08O/src/array.jl:384 [inlined]; [10] unsafe_convert(::Type{CUDA.CuDeviceArray{Float64, 3, 1}}, a::CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}); @ CUDA ~/.julia/packages/CUDA/Tl08O/src/array.jl:454; [11] adapt_storage; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:162 [inlined]; [12] adapt_structure; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:57 [inlined]; [13] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [14] #1; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [15] parent_call; @ ~/.julia/packages/OffsetArrays/hwmnB/src/OffsetArrays.jl:315 [inlined]; [16] adapt_structure; @ ~/.julia/packages/OffsetArrays/hwmnB/ext/OffsetArraysAdaptExt.jl:9 [inlined]; [17] adapt; @ ~/.julia/packages/Adapt/7T9au/src/Adapt.jl:40 [inlined]; [18] cudaconvert; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:198 [inlined]; [19] map; @ ./tuple.jl:294 [inlined]; [20] map(f::typeof(CUDA.cudaconvert), t::Tuple{KernelAbstractions.CompilerMetadata{…}, OffsetArrays.OffsetArray{…}, Nothing, Nothing, Tuple{…}, ImmersedBoundaryGrid{…}, Tuple{}}); @ Base ./tuple.jl:294; [21] macro expansion; @ ~/.julia/packages/CUDA/Tl08O/src/compiler/execution.jl:110 [inlined]; [22] (::KernelAbstractions.Kernel{…})(::OffsetArrays.OffsetArray{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ CUDA.CUDAKernels ~/.julia/packages/CUDA/Tl08O/src/CUDAKernels.jl:103; [23] (::KernelAbstractions.Kernel{CUDA.CUDAKernels.CUDABackend, KernelAbstractions.NDIteration.StaticSize{…}, KernelAbstractions.NDIteration.StaticSize{…}, typeof(Oceananigans.BoundaryConditions.gpu__no_fill!)})(::OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{…}}, ::Vararg{Any}); @ CUDA.CUDAKernels ~/.j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464:2426,adapt,adapt,2426,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3682#issuecomment-2318319464,1,['adapt'],['adapt']
Modifiability,"|; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms. But I'd like to keep the five initial goals in mind. This issue will probably be open for a while.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586:2785,refactor,refactoring,2785,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586,1,['refactor'],['refactoring']
Modifiability,"~I've been getting the following error right at the end of docs on buildkite that I can't reproduce locally (and therefore have not been able to solve):~. ```julia; ┌ Error: 4 docstrings not included in the manual:; │ ; │ Oceananigans.TurbulenceClosures.Smagorinskys.DynamicCoefficient :: Union{Tuple{}, Tuple{Any}}; │ Oceananigans.TurbulenceClosures.Smagorinskys.SmagorinskyLilly :: Union{Tuple{}, Tuple{Any}, Tuple{Any, Any}}; │ Oceananigans.TurbulenceClosures.Smagorinskys.LillyCoefficient :: Union{Tuple{}, Tuple{Any}}; │ Oceananigans.TurbulenceClosures.Smagorinskys.Smagorinsky :: Union{Tuple{}, Tuple{TD}, Tuple{TD, Any}} where TD; │ ; │ These are docstrings in the checked modules (configured with the modules keyword); │ that are not included in canonical @docs or @autodocs blocks.; └ @ Documenter /storage5/buildkite-agent/.julia-18496/packages/Documenter/C1XEF/src/utilities/utilities.jl:44; ```. ~Anyone know what that's about? Those are the 4 new docstrings that I added, all in the `Smagorinskys` module.~. Nevermind, it appears I have solved it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449552734:689,config,configured,689,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2449552734,1,['config'],['configured']
Modifiability,"~~This PR adapts `BetaPlane` coriolis implementation for curvilinear grids (following #1371 and [MITgcm docs](https://mitgcm.readthedocs.io/en/latest/algorithm/algorithm.html#id8)).~~. ~~Note that the MITgcm docs specify averaging the Coriolis parameter / planetary vorticity (from corner / vorticity nodes, ffc, to the velocity nodes fcc and cfc). However, because the variation in the planetary vorticity is linear, I think the implementation in this PR is correct for beta planes? @jm-c please advise.~~. I would ~~also~~ like to add a Coriolis term valid for the sphere and hydrostatic models (which amounts to the ""traditional approximation""). ~~I'll do this once #1380 is merged.~~ This PR depends on #1380. Some feedback on what to call this object is certainly welcome! I have preliminary proposed ""`HydrostaticSphericalCoriolis` because it was the first silly thing I could think of. To do:. - [x] Add `HydrostaticSphericalCoriolis` plus unit tests",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1384:10,adapt,adapts,10,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1384,1,['adapt'],['adapts']
Modifiability,🕵️ https://github.com/JuliaGPU/Adapt.jl/pull/88,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445743138:31,Adapt,Adapt,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870#issuecomment-2445743138,1,['Adapt'],['Adapt']
Performance," ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &nbsp; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:2785,load,load,2785,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['load']
Performance," ./Base.jl:386; [2] include(x::String); @ Oceananigans.Models.ShallowWaterModels ~/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:1; [3] top-level scope; @ ~/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:15; [4] include(mod::Module, _path::String); @ Base ./Base.jl:386; [5] include(x::String); @ Oceananigans.Models ~/software/Oceananigans.jl/src/Models/Models.jl:1; [6] top-level scope; @ ~/software/Oceananigans.jl/src/Models/Models.jl:20; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ Oceananigans ~/software/Oceananigans.jl/src/Oceananigans.jl:1; [9] top-level scope; @ ~/software/Oceananigans.jl/src/Oceananigans.jl:179; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/shallow_water_model.jl:16; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/ShallowWaterModels/ShallowWaterModels.jl:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Models/Models.jl:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/fpoulin/.julia/compiled/v1.6/Oceananigans/jl_cnHalv.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _r",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843316815:1568,load,loading,1568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-843316815,1,['load'],['loading']
Performance," ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/o",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:2933,Load,LoadError,2933,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['Load'],['LoadError']
Performance, /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 26236174 (Pool: 26209699; Big: ,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:5338,cache,cache,5338,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance," 1, true, 3, Vector{Int64}}, Float64}, Oceananigans.Solvers.Backward, CPU, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Vector{Int64}, Vector{Periodic}, Int64, Nothing, Nothing}, Oceananigans.Solvers.DiscreteTransform{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}}}, Nothing, NamedTuple{(:velocities, :tracers), Tuple{NamedTuple{(:u, :v, :w), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}, NamedTuple{(:T, :S), Tuple{Oceananigans.Fields.ZeroField, Oceananigans.Fields.ZeroField}}}}, Nothing, Nothing, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:4; [4] jldopen; @ /glade/work/tomasc/.julia_bkp/packages/JLD2/DcnTD/src/loadsave.jl:2 [inlined]; [5] set!; @ /glade/work/tomasc/.julia_bkp/packages/Oceananigans/52CTk/src/OutputWriters/checkpointer.jl:193 [inlined]; [6] run!(sim::Simulation{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceanan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:28328,load,loadsave,28328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['load'],['loadsave']
Performance," 35.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 2.42923 │ 3.01676 │ 3.07534 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.95419 │ 2.0581 │ 2.19521 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.94553 │ 2.0648 │ 2.21575 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## System info. ```; Oceananigans v0.50.0; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; `",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:12412,perform,performance,12412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance, : 3; Device Max : 3; Host Max : 3; Link Width; Max : 16x; Current : 16x; Bridge Chip; Type : N/A; Firmware : N/A; Replays Since Reset : 0; Replay Number Rollovers : 0; Tx Throughput : 0 KB/s; Rx Throughput : 0 KB/s; Atomic Caps Inbound : N/A; Atomic Caps Outbound : N/A; Fan Speed : N/A; Performance State : P0; Clocks Throttle Reasons; Idle : Active; Applications Clocks Setting : Not Active; SW Power Cap : Not Active; HW Slowdown : Not Active; HW Thermal Slowdown : Not Active; HW Power Brake Slowdown : Not Active; Sync Boost : Not Active; SW Thermal Slowdown : Not Active; Display Clock Setting : Not Active; FB Memory Usage; Total : 32768 MiB; Reserved : 267 MiB; Used : 0 MiB; Free : 32500 MiB; BAR1 Memory Usage; Total : 32768 MiB; Used : 2 MiB; Free : 32766 MiB; Compute Mode : Default; Utilization; Gpu : 0 %; Memory : 0 %; Encoder : 0 %; Decoder : 0 %; Encoder Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; FBC Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; Ecc Mode; Current : Enabled; Pending : Enabled; ECC Errors; Volatile; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Aggregate; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Retired Pages; Single Bit ECC : 0; Double Bit ECC : 0; Pending Page Blacklist : No; Remapped Rows : N/A; Temperature; GPU Current Temp : 41 C; GPU Shutdown Temp : 90 C; GPU Slowdown Temp : 87 C; GPU Max Operating Temp : 83 C; GPU Target Temperature : N/A; Memory Current Temp : 44 C; Memory Max Operating Temp : 85 C; Power Readings; Powe,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:21269,Latency,Latency,21269,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Latency'],['Latency']
Performance," ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there may not be a need for using explicit dissipation right now, so we might as well do the easy thing and avoid it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:1624,perform,perform,1624,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226,2,['perform'],['perform']
Performance," AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:47; [17] hipcompile(job::GPUCompiler.CompilerJob); @ AMDGPU.Compiler ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:139; [18] actual_compilation(cache::Dict{Any, AMDGPU.H",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:1827,optimiz,optimize,1827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['optimiz'],['optimize']
Performance," D] + \delta_j V}^i \right)\frac{\boldsymbol{i}}{b_u} +v\left( \overline{ \delta_i U + [\delta_j V; D] }^j \right)\frac{\boldsymbol{j}}{b_v}$; - kinetic energy gradient: $\left(\overline{[\delta_i u^2; u]}^i + \delta_i \overline{v^2}^j \right)\frac{\boldsymbol{i}}{\Delta x_u} + \left(\delta_j \overline{u^2}^i + \overline{[\delta_j v^2; v]}^j\right) \frac{\boldsymbol{j}}{\Delta y_v}$. #### `CrossAndSelfUpwinding`. - divergence flux: $u \overline{[D; D]}^i \frac{\boldsymbol{i}}{b_u}+ v \overline{ [D; D] }^j\frac{\boldsymbol{j}}{b_v}$; - kinetic energy gradient: $\left(\overline{[\delta_i u^2; u]}^i + \delta_i \overline{v^2}^j\right) \frac{\boldsymbol{i}}{\Delta x_u} + \left(\delta_j \overline{u^2}^i + \overline{[\delta_j v^2; v]}^j\right) \frac{\boldsymbol{j}}{\Delta y_v}$. #### `VelocityUpwinding`. - divergence flux: $u \left( \delta_i \overline{[U; U]}^i + \overline{\delta_j V}^i \right)\frac{\boldsymbol{i}}{b_u}+ v\left( \overline{ \delta_i U} + \delta_j\overline{[V; V] }^j \right) \frac{\boldsymbol{j}}{b_v}$; - kinetic energy gradient: $\left(\delta_i \overline{[u^2; u^2]}^i + \delta_i \overline{v^2}^j\right)\frac{\boldsymbol{i}}{\Delta x_u}+ \left(\delta_j \overline{u^2}^i + \delta_j \overline{[v^2; v^2]}^j\right) \frac{\boldsymbol{j}}{\Delta y_v}$. #### For all three formulations; - vertical advection: $\delta_k \left(\overline{W}^i \overline{[u; u]}^k \right)\frac{\boldsymbol{i}}{b_u} + \delta_k \left( \overline{W}^j \overline{[v; v]}^k\right) \frac{\boldsymbol{j}}{b_v}$. where $D = \delta_i U + \delta_j V$, $U = Ax \cdot u$, $V = Ay \cdot v$, $W = Az \cdot w$ and $b = \Delta x \cdot \Delta y \cdot \Delta z$. $[u; v]$ refers to a WENO biased reconstruction of $u$ using $v$ as a smoothness measure. Upwinding is always performed with respect to the velocity corresponding to the reconstruction direction. ; i.e.: reconstructions in $i$ upwind with respect to $u$, reconstructions in $j$ upwind with respect to $v$ and reconstructions in $k$ upwind with respect to $w$",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1577285777:1925,perform,performed,1925,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3091#issuecomment-1577285777,1,['perform'],['performed']
Performance," GPU (see below). At 256^3, `cfl(model)` takes as long as ~5 time steps. Is this something we want to merge? If we don't want to slow down adaptive time-stepping for existing models we could just export `accurate_cell_advection_timescale` so that adaptive time-stepping with accurate CFL is opt-in, e.g. via an `AccurateTimeStepWizard` or something. Motivation for using Tullio.jl:. Originally I tried just using `mapreduce` but couldn't get it to work without a nested `mapreduce` which would trigger tons of kernel launches: https://discourse.julialang.org/t/is-it-possible-to-do-a-mapreduce-with-multiple-arrays-while-broadcasting-over-so/57433. Then I found out about Tullio.jl (super neat package we might want to use more) which allows us to compute CFL and reduce it down elegantly, however, reducing to one scalar does not currently work so I have to reduce the 3D CFL calculation to a 1D vector: https://github.com/mcabbott/Tullio.jl/issues/91. Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... ```; julia> model.architecture; CPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 5.977 ms (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 127.870 μs (10 allocations: 2.36 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid); (32, 32, 32). julia> @btime time_step!(model, 1); 2.632 ms (7058 allocations: 820.19 KiB). julia> @btime cfl(model); 1.294 ms (257 allocations: 25.36 KiB); ```. ```; julia> model.architecture; CPU(). julia> size(grid); (256, 256, 256). julia> @btime time_step!(model, 1); 3.378 s (2090 allocations: 343.97 KiB). julia> @btime cfl(model); 134.737 ms (10 allocations: 4.16 KiB); ```. ```; julia> model.architecture; GPU(). julia> size(grid);",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497:1372,optimiz,optimizing,1372,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497,1,['optimiz'],['optimizing']
Performance," LLVMTargetMachineEmitToMemoryBuffer(::Ptr{LLVM.API.LLVMOpaqueTargetMachine}, ::Ptr{LLVM.API.LLVMOpaqueModule}, ::LLVM.API.LLVMCodeGenFileType, ::Base.RefValue{Cstring}, ::Base.RefValue{Ptr{LLVM.API.LLVMOpaqueMemoryBuffer}}) at /home/ancellin/.julia/packages/LLVM/KITdB/lib/libLLVM_h.jl:3512; [4] emit(::LLVM.TargetMachine, ::LLVM.Module, ::LLVM.API.LLVMCodeGenFileType) at /home/ancellin/.julia/packages/LLVM/KITdB/src/targetmachine.jl:42; [5] mcgen at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/mcgen.jl:73 [inlined]; [6] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [7] macro expansion at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:254 [inlined]; [8] macro expansion at /home/ancellin/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [9] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:250; [10] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [11] compile at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [12] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHoo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:2003,optimiz,optimize,2003,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,2,['optimiz'],['optimize']
Performance," MPI ~/.julia/packages/MPI/08SPr/src/MPI.jl:1; [13] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:36; [14] include; @ ./Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.jul",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:4599,load,loading,4599,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance," PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField`s are fused into one, we overlap memory accesses for different computations. Our computations are usually memory-limited... so its possible this strategy could produce significant speed ups. For example, for two `ComputedField`s we might have something like. ```julia; function compute!(field1, field2); # calls _compute_two(field1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:1411,optimiz,optimization,1411,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837,1,['optimiz'],['optimization']
Performance," Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: LoadError: UndefVarError: NFBC not defined; Stacktrace:; [1] top-level scope; @ ~/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; [2] include(mod::Module, _path::String); @ Base ./Base.jl:386; [3] include(x::String); @ Oceananigans.BoundaryConditions ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; [4] top-level scope; @ ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:45; [5] include(mod::Module, _path::String); @ Base ./Base.jl:386; [6] include(x::String); @ Oceananigans ~/Research/OC/src/Oceananigans.jl:1; [7] top-level scope; @ ~/Research/OC/src/Oceananigans.jl:173; [8] include; @ ./Base.jl:386 [inlined]; [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [10] top-level scope; @ none:1; [11] eval; @ ./boot.jl:360 [inlined]; [12] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [13] top-level scope; @ none:1; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; in expression starting at /Users/navid/Research/OC/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_fSB7qw.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334:1840,load,loading,1840,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334,5,['load'],['loading']
Performance," StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing}}}, Nothing}, NamedTuple{(), Tuple{}}}, String}, ::String, ::Vararg{String, N} where N; kws::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ JLD2 /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:4; [8] jldopen; @ /g/data/v45/nc3020/.julia/packages/JLD2/5iijr/src/loadsave.jl:2 [inlined]; [9] set!; @ /g/data/v45/nc3020/.julia/packages/Oceananigans/Bks9B/src/OutputWriters/checkpointer.jl:199 [inlined]; [10] run!(sim::Simulation{HydrostaticFreeSurfaceModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :η, :b, :e, :c), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, GPU}, Float64, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3}}, FieldBoundaryConditions{BoundaryCondition{Oceananigan",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2223:80311,load,loadsave,80311,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2223,1,['load'],['loadsave']
Performance," [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [19] top-level scope; @ none:1; during initialization of module AMGX; in expression starting at /Users/navid/Research/OC.jl/src/Solvers/multigrid_so",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2433,load,loading,2433,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['load'],['loading']
Performance," [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays; [10745b16] Statistics. (Oceananigans) pkg> precompile; Precompiling project...; ✗ Oceananigans; 0 dependencies successfully precompiled in 11 seconds (99 already precompiled). ERROR: The following 1 direct dependency failed to precompile:. Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]. Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_Z5b4Xf.; ERROR: LoadError: LoadError: LoadError: InitError: UndefVarError: libamgxsh not defined; Stacktrace:; [1] getproperty; @ ./Base.jl:26 [inlined]; [2] __init__(); @ AMGX ~/.julia/packages/AMGX/GFHHN/src/AMGX.jl:30; [3] _include_from_serialized(path::String, depmods::Vector{Any}); @ Base ./loading.jl:696; [4] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String); @ Base ./loading.jl:782; [5] _require(pkg::Base.PkgId); @ Base ./loading.jl:1020; [6] require(uuidkey::Base.PkgId); @ Base ./loading.jl:936; [7] require(into::Module, mod::Symbol); @ Base ./loading.jl:923; [8] include(mod::Module, _path::String); @ Base ./Base.jl:384; [9] include(x::String); @ Oceananigans.Solvers ~/Research/OC.jl/src/Solvers/Solvers.jl:1; [10] top-level scope; @ ~/Research/OC.jl/src/Solvers/Solvers.jl:48; [11] include(mod::Module, _path::String); @ Base ./Base.jl:384; [12] include(x::String); @ Oceananigans ~/Research/OC.jl/src/Oceananigans.jl:5; [13] top-level scope; @ ~/Research/OC.jl/src/Oceananigans.jl:195; [14] include; @ ./Base.jl:384 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1235; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:360 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [19] top-level scope; @",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987:2308,load,loading,2308,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1217694987,1,['load'],['loading']
Performance," [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5530,Load,LoadError,5530,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['Load'],['LoadError']
Performance," `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI>; > .; > You are receiving this because you commented.Message ID:; > ***@***.***>; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:1085,load,loading,1085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,6,['load'],['loading']
Performance," ```; ERROR: LoadError: Enzyme cannot deduce type; Current scope:; ; Function Attrs: mustprogress nofree readonly willreturn; define ""enzyme_type""=""{[0]:Integer, [1]:Integer, [2]:Integer, [3]:Integer, [4]:Integer, [5]:Integer, [6]:Integer, [7]:Integer, [8]:Integer, [9]:Integer, [10]:Integer, [11]:Integer, [12]:Integer, [13]:Integer, [14]:Integer, [15]:Integer, [16]:Integer, [17]:Integer, [18]:Integer, [19]:Integer, [20]:Integer, [21]:Integer, [22]:Integer, [23]:Integer, [24]:Integer, [25]:Integer, [26]:Integer, [27]:Integer, [28]:Integer, [29]:Integer, [30]:Integer, [31]:Integer, [32]:Integer, [33]:Integer, [34]:Integer, [35]:Integer, [36]:Integer, [37]:Integer, [38]:Integer, [39]:Integer, [40]:Integer, [41]:Integer, [42]:Integer, [43]:Integer, [44]:Integer, [45]:Integer, [46]:Integer, [47]:Integer, [48]:Float@double, [56]:Float@double, [64]:Float@double, [72]:Float@double, [80]:Float@double, [88]:Float@double, [96]:Float@double, [104]:Float@double, [112]:Float@double, [120]:Integer, [121]:Integer, [122]:Integer, [123]:Integer, [124]:Integer, [125]:Integer, [126]:Integer, [127]:Integer, [128]:Integer, [129]:Integer, [130]:Integer, [131]:Integer, [132]:Integer, [133]:Integer, [134]:Integer, [135]:Integer, [136]:Integer, [137]:Integer, [138]:Integer, [139]:Integer, [140]:Integer, [141]:Integer, [142]:Integer, [143]:Integer, [144]:Float@double, [152]:Float@double, [160]:Float@double, [168]:Float@double, [176]:Integer, [177]:Integer, [178]:Integer, [179]:Integer, [180]:Integer, [181]:Integer, [182]:Integer, [183]:Integer, [184]:Integer, [185]:Integer, [186]:Integer, [187]:Integer, [188]:Integer, [189]:Integer, [190]:Integer, [191]:Integer, [192]:Integer, [193]:Integer, [194]:Integer, [195]:Integer, [196]:Integer, [197]:Integer, [198]:Integer, [199]:Integer, [200]:Float@double, [208]:Float@double, [216]:Float@double, [224]:Float@double, [232]:Float@double, [240]:Float@double, [248]:Integer, [249]:Integer, [2",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140:78,Load,LoadError,78,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3867#issuecomment-2436402140,1,['Load'],['LoadError']
Performance," `max_change` or no; # less than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= 10minute, iteration_interval = 10,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_GPU.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],file[""grid/Lz""]. # Extract a vector of iterations; iterations = parse.(Int, keys(file[""timeseries/t""])). @info ""Making a neat movie of verticle velocity and Temperature..."". anim = @animate for (i, iteration) in enumerate(iterations). @info ""Plotting frame $i from iteration $iteration..."". t = file[""timeseries/t/$iteration""]; u_snapshot = file[""timeseries/u/$iteration""][:, :, 60]; v_snapshot = file[""timeseries/v/$iteration""][:, :, 60]; w_snapshot = file[""timeseries/w/$iteration""][:, 128, :]; speed_snapshot = sqrt.(u_snapshot.*u_snapshot + v_snapshot.*v_snapshot); # T_snapshot = file[""timeseries/T/$iteration""][:, 128, :]; . ulims = 0.0025; ; ulevels = range(-ulims, stop=ulims, length=50); ; slims = 0.025; ; slevels = range(0, stop=slims, length=50); ; Tlims ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1613:5662,load,load,5662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1613,1,['load'],['load']
Performance," a multiple packages approach but for ancillary features. # Tests and validation experiments. We spent quite some time ensuring the `CompressibleModel` can simulate some known atmospheric test cases. Following recent trials and tribulations I also decided to add some simple 1D tests. Here I list the tests but will post a followup comment for each test with a figure or animation. Hopefully together these tests act as a starting point to start believing that the `CompressibleModel` indeed does work as expected. 1. Periodic advection of a square waveform; 2. Inviscid Burgers equation developing a shock; 3. Shock tube problem (Sod, 1978); 4. Rising thermal bubble with entropy and energy (Wicker & Skamarock, 1998); 5. Rising thermal bubble with 3 different gas species (entropy and energy); 6. Density current (Straka et al., 1993); 7. Dry convection. See comments below for movies and eyeball norms. The four dry rising thermal bubble simulations are used for regression testing. # GPU performance benchmarks. Preliminary benchmarks show a 75~80x speedup for large models when comparing a single CPU core to a single Titan V GPU on Tartarus. Not as good as the incompressible model as some of the functions that diagnose temperature and pressure need some optimizing, especially in the case of multiple gases. ```; Compressible model benchmarks ; ┌──────┬──────┬───────────┬───────────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Arch │ Size │ Gases │ ThermoVar │ min │ median │ mean │ max │ memory │ allocs │; ├──────┼──────┼───────────┼───────────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ 32³ │ DryEarth │ Energy │ 37.682 ms │ 38.012 ms │ 37.982 ms │ 38.199 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth │ Entropy │ 32.325 ms │ 32.920 ms │ 32.928 ms │ 33.628 ms │ 646.33 KiB │ 4499 │; │ CPU │ 32³ │ DryEarth3 │ Energy │ 52.473 ms │ 52.815 ms │ 52.896 ms │ 53.413 ms │ 816.50 KiB │ 5635 │; │ CPU │ 32³ │ DryEarth3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1079:7289,perform,performance,7289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1079,1,['perform'],['performance']
Performance," adapt the y-boundary ( or x or both) to Bounded. grid = RegularRectilinearGrid(topology=(Periodic, Bounded, Flat),size=(128, 128),extent=(2π, 2π)). I get the following error (I included a show to show the grid and its size). ```julia; grid = RegularRectilinearGrid{Float64, Periodic, Bounded, Flat}; domain: x ∈ [0.0, 6.283185307179586], y ∈ [-1.2810265668750775e-18, 6.283185307179586], z ∈ [0.0, 0.0]; topology: (Periodic, Bounded, Flat); resolution (Nx, Ny, Nz): (128, 128, 1); halo size (Hx, Hy, Hz): (1, 1, 0); grid spacing (Δx, Δy, Δz): (0.04908738521234052, 0.04908738521234052, 0.0); ┌ Warning: Inflating model grid halo size to (3, 3, 0) and recreating grid. The model grid will be different from the input grid. To avoid this warning, pass halo=(3, 3, 0) when constructing the grid.; └ @ Oceananigans.Grids C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Grids\automatic_halo_sizing.jl:41; size(model.grid) = (128, 128, 1); ERROR: LoadError: DimensionMismatch(""array could not be broadcast to match destination""); Stacktrace:; [1] check_broadcast_shape at .\broadcast.jl:520 [inlined]; [2] check_broadcast_shape at .\broadcast.jl:521 [inlined]; [3] check_broadcast_axes at .\broadcast.jl:523 [inlined]; [4] instantiate(::Base.Broadcast.Broadcasted{Base.Broadcast.DefaultArrayStyle{3},Tuple{Base.OneTo{Int64},Base.OneTo{Int64},Base.OneTo{Int64}},typeof(identity),Tuple{Array{Float64,3}}}) at .\broadcast.jl:269; [5] materialize! at .\broadcast.jl:848 [inlined]; [6] materialize! at C:\Users\jmbeckers\.julia\packages\Oceananigans\zj42o\src\Fields\broadcasting_abstract_fields.jl:19 [inlined]; [7] set!(::Field{Center,Face,Center,CPU,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Bounded,Flat,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Float64,NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodi",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1656:1082,Load,LoadError,1082,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1656,1,['Load'],['LoadError']
Performance, advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/a,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2501,cache,cache,2501,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance," allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 1.34309 │ 1.46266 │ 1.48014 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 1.25281 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.05249 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.07645 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.0409 │ 1.30927 │ 1.30084 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 0.938853 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.17749 │ 1.14247 │ 1.08664 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. ## GPU slowdown (vs. triply-periodic). ```; Topologies relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬──────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼──────────┼─────────┤; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.22277 │ 0.965821 │ 1.70133 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 1.82308 │ 0.980729 │ 1.496 │; │ GPU │ 192 │ (Bounded, Periodic, Bounded) │ 1.82349 │ 0.984497 │ 1.4736 │; │ GPU │ 192 │ (Bounded, Periodic, Periodic) │ 2.26462 │ 0.989389 │ 1.24018 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 1.82237 │ 0.984695 │ 1.47467 │; │ GPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.54676 │ 0.992331 │ 1.25653 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.30183 │ 0.99405 │ 1.22631 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴──────────┴─────────┘; ```. # Performance vs. main branch. ## Main branch. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────┬─",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:9976,perform,performance,9976,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296,2,['perform'],['performance']
Performance," based on latitude easily.; > ; > Questions:; > ; > * Should we keep the original `FPlane`? I think we could scrap it and only keep this one (which would then be renamed `FPlane`); > * I didn't see any tests that `FPlane` or any other Coriolis implementation is dynamically correct. Should we implement a test to see if our rotation implementations are actually doing what they're supposed to?. For API this is what I suggest:. Three ""modes"":. 1. A ""primitive"" mode whereby fx, fy, fz are all explicitly provided.; 2. A ""general rotation"" mode whereby `rotation_axis` and `rotation_rate` are provided. `fx`, `fy`, and `fz` are then calculated as a convenience.; 3. A ""tangent plane"" mode whereby `latitude` and `rotation_rate` are provided. This mode calculates `rotation_axis` based on `latitude` (and assuming that `y` is north-south). The code might look something like. ```julia; zero_if_nothing(f) = f; zero_if_nothing(::Nothing) = 0. function ConstantBackgroundRotation(FT=Float64; fx=nothing, fy=nothing, fz=nothing, rotation_rate=Ω_Earth, rotation_axis=nothing, latitude=nothing). if latitude !=nothing; isnothing(rotation_axis) && throw(ArgumentError(""Cannot specify latitude and rotation axis."")); all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify latitude and (fx, fy, fz)."")); # calculate rotation axis; end. if rotation_axis != nothing; all(isnothing.((fx, fy, fz)) || throw(ArgumentError(""Cannot specify rotation_axis and (fx, fy, fz)."")); # calculate fx, fy, fz; end. fx, fy, fz = zero_if_nothing.((fx, fy, fz)) # set default fx, fy, fz. return ConstantBackgroundRotation(FT(fx), FT(fy), FT(fz)); end; ```. There's also the possibility of a somewhat minor optimization by keeping the possibility that `fx, fy, fz` might be `nothing`, and eliding the associated Coriolis operations in kernel functions for that case. This requires the struct to accomodate different types for each of them. I think `GeneralFPlane` is ambiguous, so I propose using a more specific name.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990:2335,optimiz,optimization,2335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1892#issuecomment-887527990,2,['optimiz'],['optimization']
Performance," example:. ```julia; julia> a, b, c = (CenterField(GPU(), grid) for i = 1:3); Base.Generator{UnitRange{Int64}, var""#5#6""}(var""#5#6""(), 1:3). julia> @time a .= b + c; 0.929868 seconds (180.70 k allocations: 11.424 MiB, 99.79% compilation time). julia> @time a .= b + c; 0.924904 seconds (159.14 k allocations: 10.031 MiB, 99.79% compilation time); ```. Note that if we avoid constructing an `AbstractOperation` we get. ```julia; julia> @time a .= b .+ c; 1.339598 seconds (2.24 M allocations: 127.662 MiB, 2.91% gc time, 47.98% compilation time). julia> @time a .= b .+ c; 0.000280 seconds (180 allocations: 41.109 KiB); ```. Then I noticed this:. ```julia; julia> a_plus_1 = a + 1; BinaryOperation at (Center, Center, Center); ├── grid: RegularLatitudeLongitudeGrid{Float64, Bounded, Bounded, Bounded}; domain: longitude λ ∈ [-10.0, 10.0], latitude ∈ [0.0, 45.0], z ∈ [-1000.0, 0.0]; topology: (Bounded, Bounded, Bounded); size (Nx, Ny, Nz): (512, 512, 32); halo (Hx, Hy, Hz): (1, 1, 1); grid spacing (Δλ, Δφ, Δz): (0.0390625, 0.087890625, 31.25); │ └── domain: longitude λ ∈ [-10.0, 10.0], latitude ∈ [0.0, 45.0], z ∈ [-1000.0, 0.0]; └── tree: ; + at (Center, Center, Center);    ├── Field located at (Center, Center, Center);    └── 1. julia> a .= a_plus_1. julia> @time a .= a_plus_1; 1.674752 seconds (2.22 M allocations: 127.371 MiB, 2.18% gc time, 56.65% compilation time). julia> @time a .= a_plus_1; 0.280226 seconds (17.11 k allocations: 1.104 MiB, 99.87% compilation time). julia> @time a .= a_plus_1; 1.525796 seconds (2.22 M allocations: 127.356 MiB, 2.15% gc time, 51.88% compilation time). julia> @time a .= a_plus_1; 0.294972 seconds (17.11 k allocations: 1.104 MiB, 99.88% compilation time). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB). julia> @time a .= a_plus_1; 0.000274 seconds (170 allocations: 35.438 KiB); ```. Basically the compiler is ""stubborn"" and only caches our method after many tries... might be worth an issue on `KernelAbstractions.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853:2060,cache,caches,2060,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958603853,1,['cache'],['caches']
Performance," functions:; > ; > * `external_cell` identifies whether a _tracer cell_ (or perhaps the ""reference cell"" --- the one located at center, center, center) is outside the `Bounded` domain (this has no effect in `Periodic` directions); > * `external_node` identifies whether a _location_ is external to the `Bounded` domain. We use the term ""node"" because this can be used for cells _or_ cell interfaces. `external_node` is `false` for locations that ""touch"" wet cells. So `external_cell` is just a special case `external_node`, correct? It also seems to me that this for now assumes a full-step grid-fitted IBM, no?. > * `peripheral_node` identifies whether a location is either _on or external_ to the `Bounded` domain. So this intersects with `external_node` in the exterior, but additionally contains locations that touch wet cells. Not sure I understand this. Is this trying to check whether a location is _adjacent_ to an IBM in addition to a location that's far (i.e. more than one grid point away) from an IBM?. > * `immersed_peripheral_node` identifies locations that are on or external to the immersed domain, but _not_ external to the underlying grid domain (we need this so that we don't apply immersed boundary conditions at all peripheral nodes). Also a bit confused. Sounds to me that this is the same as the previous one but excluding halo regions, which probably isn't right... > * `immersed_cell` is now the name of the function `is_immersed` --- immersed boundary implementations define this to obtain correct logic for boundary conditions. We then extend `external_cell` to cover both the external cells of the underlying bounded domain and the immersed cells.; > ; > I think there's still a fair amount of work to do on this interface but hopefully this is a good step forward. Here's a few more thoughts:. Quick question: Have you checked the performance here? I ask because the model was running pretty slowly when I was testing https://github.com/CliMA/Oceananigans.jl/pull/2275...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847:2247,perform,performance,2247,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100732847,2,['perform'],['performance']
Performance," important changes:. * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition.; * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Minor changes:. * Update style to be consistent with other examples / source code (commas, spaces, etc); * Reorganized the script to read like the other examples / tutorials (like a paper, parameters are introduced when they are used rather than at the top); * Reorganized a few other misc stuff for pedagogical reasons, like building buoyancy + coriolis together; * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; * Change tilting angle to 3 degrees rather than 0.05 radians; * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated); * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity; * Plotting fewer contours makes the animation faster (the most expensive part of this example); * We don't need to form `Field`s any more for the output writers any more. Idle thoughts:. * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?; * Can we tilt the visualization? It's disorienting to be looking at the flow at an angle of 3 ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449:1201,perform,perform,1201,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065127449,1,['perform'],['perform']
Performance," infrastructure, and is a satisfactory boundary condition for some cases. Would this be okay?. A simple matching scheme is a great place to start to justify changing the `Open` classification. > For example, in a nested case, this would prevent higher resolution eddies from exiting the domain without un-physically modifying the upstream solution. I apologize if this is just a problem with communication style, but I don't think this statement can possibly be correct. The above example seems to demonstrate, for example, that the cylinder wake can be represented well by _either_ making the domain large enough (with sponge layers), _or_ by using a better numerical method with a smaller domain. Basically this allows us to exclude statements like ""we can't model X flow"". The question is not whether or not we can represent the physics of a flow. The question is rather about representing the flow in a domain that is as small as possible / with optimal computational expense. We're pursuing performance optimization. Our language has to take the form ""this scheme allows us to reduce the sponge layer thickness by XX%"", or ""this scheme reduces the width of the near-boundary region where the interior physics are modified"". The statement ""this scheme does not unphysically modify the solution"" makes no sense to me. The presence of the open boundary is unphysical by definition... I personally don't need much convincing that a matching scheme of some kind is needed. I'm just confused about how all of the different pieces that seem to enter into nesting interact with one another --- sponge layers, matching scheme, and also the particular physics of the flow in question (idealized in and outflows vs true nesting). With so many degrees of freedom and complexity I think a systematic approach is absolutely essential. I really hope that the outcome of this work are a set of solid recommendations for nesting (better yet, a recipe that does not have to be changed --- a recommended matching sc",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291:1669,perform,performance,1669,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2033120291,4,"['optimiz', 'perform']","['optimization', 'performance']"
Performance," is of type Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}} which is not isbits.; .field_dependencies is of type Tuple{Symbol} which is not isbits.; .1 is of type Symbol which is not isbits. Passing non-isbits types is only allowed if they they are unused by the kernel. Stacktrace:; [1] check_invocation(::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}, ::LLVM.Function) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/validation.jl:75; [2] macro expansion at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:240 [inlined]; [3] macro expansion at /home/ptuckman/.julia/packages/TimerOutputs/dVnaw/src/TimerOutput.jl:206 [inlined]; [4] codegen(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:239; [5] compile(::Symbol, ::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget,CUDA.CUDACompilerParams}; libraries::Bool, deferred_codegen::Bool, optimize::Bool, strip::Bool, validate::Bool, only_entry::Bool) at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:39; [6] compile at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/driver.jl:35 [inlined]; [7] _cufunction(::GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:4554,optimiz,optimize,4554,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['optimiz'],['optimize']
Performance," makes some significant source code changes for what I think is a rather narrow application, which is disproportional compared to most of the other features we have I think. > If for some reason we cannot use a forcing function approach, we'll have to think carefully about how to design a flexible user API for ""particle-induced tracer forcing"". I think if we are going to add this then it should be more general than just a source/sink calculation --- ie, we should attempt to have a small source code addition that makes a wide range of new behavior possible, if we can. I've reconsidered this now and think we may not even need any source code change to properly implement this behaviour and integrate some particle induced tracer forcing. If we have a model with some tracers `(:A, :B)` which we want to force with some particles, we can define an auxiliary field `G\_p=TracerFields((:A, :B), grid)`. We can then have a particle dynamics function that modifies `model.auxiliary_fields.G\_p`, for example sets the points surrounding the particles to `-A[i, j, k]` for `A`, and `+A[i, j, k]` for `B` like in my example above. You can then define a discrete forcing function for each of the tracers like `a_forcing(i, j, k, grid, clock, model_fields) = model_fields.G\_p.A[i, j, k]` etc. (this would only work with my other PR #2733 added so that the `auxiliary_fields` are available). > It seems the memory requirement of the forcing function approach is proportional to the number of tracers, not the number of particles --- right? We would nee an ""auxiliary tendency"" for every tracer; the memory requirement doesn't change based on the number of particles. My reservation with this was that if there's e.g. 1 particle effecting loads of tracers you have to store lots more fields, but I see now that this is much less of an issue. Sorry about making this much more complicated than it should have been!. Edit: updated the gist example with how this can be implemented (requires PR #2733 branch)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312:1958,load,loads,1958,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2724#issuecomment-1249434312,1,['load'],['loads']
Performance," mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_ag",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:3260,load,loading,3260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance," mostly a matter of choice (if the reconstruction is performed correctly for all stencils!). The general way to do this is to make them functions of a ""local smoothness indicator"" <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> which is calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=\beta_{r} = \sum_{l=1}^k \int_{x_{i-1/2}}^{x_{i %2B 1/2}} \Delta x^{2l -1} \left( \frac{\partial^l p_r(x)}{\partial x^l} \right)^2 dx""> . These <img src=""https://render.githubusercontent.com/render/math?math=\beta_r""> simplify quite nicely for uniform grids. the `streched_smoothness=true` option calculates the coefficients of these smoothness indicators for a stretched grid, by assuming that (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Then the weights are calculated as such; <img src=""https://render.githubusercontent.com/render/math?math=w_{r} = \frac{\alpha_r}{\alpha_0 %2B \alpha_1 %2B \alpha_2}""> . where <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r""> depends on the scheme used and differs between JS-WENO and Z-WENO. In the former; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = \frac{d_r}{(\beta_r %2B \varepsilon)^2}"">; In the latter ; <img src=""https://render.githubusercontent.com/render/math?math=\alpha_r = d_r \left[ 1 %2B \left( \frac{ \left |\beta_2 - \beta_0 \right|}{\beta_r %2B \varepsilon} \right)^2 \right] "">; <img src=""https://render.githubusercontent.com/render/math?math=d_r""> are optimized constants equal in both the schemes. the `zweno = true` flag just switches between these two formulations. Now, I believe that `stretched_smoothness` does not have a such big impact because if you assure that the reconstruction is correct, then all stencil correctly interpolate to the face and weights will still be between 0 and 1. This might be more impactful for grids that are much more non-uniform (or ""irregular"") than what we usually use.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:3530,optimiz,optimized,3530,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397,2,['optimiz'],['optimized']
Performance," of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:3526,load,load,3526,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,3,"['Load', 'load']","['LoadError', 'load']"
Performance," runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:1521,optimiz,optimize,1521,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['optimiz'],['optimize']
Performance," search: plan_fft plan_fft! plan_rfft plan_ifft plan_bfft plan_ifft! plan_bfft! plan_irfft plan_brfft. plan_fft(A [, dims]; flags=FFTW.ESTIMATE, timelimit=Inf). Pre-plan an optimized FFT along given dimensions (dims) of arrays matching the shape and type of A. (The first two arguments have the same meaning as for fft.) Returns an object P which; represents the linear operator computed by the FFT, and which contains all of the information needed to compute fft(A, dims) quickly. To apply P to an array A, use P * A; in general, the syntax for applying plans is much like that of matrices. (A plan can only be applied to arrays of the same size as the A for which; the plan was created.) You can also apply a plan with a preallocated output array Â by calling mul!(Â, plan, A). (For mul!, however, the input array A must be a complex floating-point; array like the output Â.) You can compute the inverse-transform plan by inv(P) and apply the inverse plan with P \ Â (the inverse plan is cached and reused for subsequent calls to inv or; \), and apply the inverse plan to a pre-allocated output array A with ldiv!(A, P, Â). The flags argument is a bitwise-or of FFTW planner flags, defaulting to FFTW.ESTIMATE. e.g. passing FFTW.MEASURE or FFTW.PATIENT will instead spend several seconds (or more) benchmarking; different possible FFT algorithms and picking the fastest one; see the FFTW manual for more information on planner flags. The optional timelimit argument specifies a rough upper bound on; the allowed planning time, in seconds. Passing FFTW.MEASURE or FFTW.PATIENT may cause the input array A to be overwritten with zeros during plan creation. plan_fft! is the same as plan_fft but creates a plan that operates in-place on its argument (which must be an array of complex floating-point numbers). plan_ifft and so on are similar; but produce plans that perform the equivalent of the inverse transforms ifft and so on. help?> plan_fft!; search: plan_fft! plan_ifft! plan_bfft! plan_fft plan",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179127:1066,cache,cached,1066,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/119#issuecomment-471179127,1,['cache'],['cached']
Performance," second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If we use short-circuiting logic, then I guess many optimizations are not possible, because execution on one branch or another must be completely excluded. Some of this is discussed here: https://discourse.julialang.org/t/multiplying-by-booleans-faster-than-if-else/64117. > What about @inline?. This a little hazier. The compiler decides based on a heuristic whether or not to ""inline"" a function (meaning, rather than compiling code for a function independently and jumping to that code at the right moment, it combines the function code with the code that calls the function). We want to inline everything basically, so that every tendency evaluation involves evaluating one giant function. Inlining lets LLVM magic optimize our code to the highest degree (at least that's my impression). For whatever reason the compiler often decides _not_ to inline our functions unless we spec",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:1866,optimiz,optimize,1866,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['optimiz'],['optimize']
Performance," simulation which is failing now. This was working a few days ago.; ```; # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4). # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them when calculating hot_bubble_perturbation.; xC, yC, zC = model.grid.xC, model.grid.yC, model.grid.zC; xC, yC, zC = reshape(xC, (Nx, 1, 1)), reshape(yC, (1, Ny, 1)), reshape(zC, (1, 1, Nz)). # Set heating flux at the bottom.; Q = 9200 # W/m^2; Rp = 50 # plume radius [m]. r = @. sqrt((xC - Lx/2)^2 + (yC - Ly/2)^2). bottom_flux = zeros(Nx, Ny, 1); bottom_flux[r .< Rp] .= g * ɑ * Q / (ρ₀ * cₚ); bottom_flux = CuArray(bottom_flux). model.boundary_conditions.T.z.right = BoundaryCondition(Flux, bottom_flux); ```. This now fails with:; ```; ERROR: LoadError: TypeError: in setfield!, expected BoundaryCondition{Flux,Int64}, got BoundaryCondition{Flux,CuArray{Float64,3}}; Stacktrace:; [1] setbc!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Val{:right}, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:81; [2] setproperty!(::CoordinateBoundaryConditions{BoundaryCondition{Flux,Int64},BoundaryCondition{Flux,Int64}}, ::Symbol, ::BoundaryCondition{Flux,CuArray{Float64,3}}) at /home/betaeffect/.julia/packages/Oceananigans/wiEvh/src/boundary_conditions.jl:80; [3] top-level scope at none:0; [4] include at ./boot.jl:326 [inlined]; [5] include_relative(::Module, ::String) at ./loading.jl:1038; [6] include(::Module, ::String) at ./sysimg.jl:29; [7] include(::String) at ./client.jl:403; [8] top-level scope at none:0; in expression starting at /home/betaeffect/oceananigans/hydrothermal_plume/nukappa1em4/plume.jl:37; ```. I am not fully proficient in Julia yet, so wasn't able to figure out from the code how to fix this issue. Is there a simple fix?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/314:1043,Load,LoadError,1043,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314,2,"['Load', 'load']","['LoadError', 'loading']"
Performance," slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼──────────┼────────┤; │ CPU │ 192 │ (Bounded, Bounded, Bounded) │ 2.76522 │ 1.0 │ 1.0 │; │ CPU │ 192 │ (Bounded, Bounded, Periodic) │ 2.14077 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Bounded, Periodic, Bounded) │ 2.32425 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Bounded, Periodic, Periodic) │ 1.64349 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Bounded, Bounded) │ 2.44462 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Bounded, Periodic) │ 1.79278 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Periodic, Bounded) │ 1.72073 │ 0.833333 │ 0.5 │; │ CPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴──────────┴────────┘; ```. ## GPU slowdown (vs. triply-periodic). ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 192 │ (Bounded, Bounded, Bounded) │ 4.83605 │ 76.8 │ 29.1613 │; │ GPU │ 192 │ (Bounded, Bounded, Periodic) │ 3.90501 │ 52.5714 │ 21.0 │; │ GPU │ 192 │ (Bounded, Periodic, Bounded) │ 3.91006 │ 52.4 │ 20.8065 │; │ GPU │ 192 │ (Bounded, Periodic, Periodic) │ 5.59024 │ 25.4571 │ 9.48387 │; │ GPU │ 192 │ (Periodic, Bounded, Bounded) │ 3.88581 │ 52.5714 │ 21.0 │; │ GPU │ 192 │ (Periodic, Bounded, Periodic) │ 2.96267 │ 28.0 │ 12.4516 │; │ GPU │ 192 │ (Periodic, Periodic, Bounded) │ 2.03389 │ 25.4571 │ 9.48387 │; │ GPU │ 192 │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. # Static ocean benchmarks for all topologies. ## Raw numbers. ```; Topologies benchmarks; ┌───────────────┬─────┬────────────────────────────────┬───────────┬───────────┬───────────┬───────────",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296:4731,perform,performance,4731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1338#issuecomment-773394296,2,['perform'],['performance']
Performance," some mixed behavior where the user specifies both a default *and* particular values for tracer diffusivity. This would be useful in the (possibly rare) use-case of a large number of tracers with the same diffusivity, but where one or two of them require a special, different diffusivity. I am not sure this API is necessary so I left it for future work. Diffusivity-like fields include:. * `κ` (constant component of tracer diffusivity) for `ConstantIsotropicDiffusivity`, `AnisotropicMinimumDissipation`, and `ConstantSmagorinsky`; * `Pr` (turbulent Prandtl number) for `ConstantSmagorinsky`; * `κh` and `κv` for `ConstantAnisotropicDiffusivity`. ## Internal algorithmic considerations. This implementation includes a major refactor of the time-stepping algorithm. In particular, kernels are launched for *each* tracer for all operations that involve tracers. This differs from the previous pattern, in which a single kernel was called in some cases (for example, to update the velocity and tracer fields, or to store previous source terms). The reason for this change is because I ran into some issues (dynamic function invocations) using `ntuple` to unroll a loop over tracers inside the kernel. In addition, I think that with a large number of tracers the kernels may become too large and their performance could degrade (but I'm not sure). This refactoring of the algorithm means we need to . - [ ] benchmark the changes in this PR to see if there are any significant changes in model performance. . @ali-ramadhan, can you help with this?. If there are changes in model performance, we can work on unrolling loops over the tracer fields *inside* our kernels. This is probably possible; it just requires some debugging. We would probably also want to make sure that this doesn't lead to poor performance for up to O(10) tracers. If any of this PR is not satisfactory, I'm happy to work on it and iterate until the PR is in mergeable shape. Resolves #25 ; Resolves #430 ; Partially addresses #448",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/452:3066,perform,performance,3066,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/452,4,['perform'],['performance']
Performance," than `min_change` from the previous `Δt`, and to be no greater in absolute magnitude; # than `max_Δt` and no less than `min_Δt`. # wmax = FieldMaximum(abs, model.velocities.w) ##not working due to update, It has been renamed into other func. start_time = time_ns() ; # so we can print the total elapsed wall time. # Print a progress message; progress_message(sim) =; @printf(""i: %04d, t: %s, Δt: %s, wmax = %.1e ms⁻¹, wall time: %s\n"",; sim.model.clock.iteration, prettytime(model.clock.time),; prettytime(wizard.Δt), maximum(abs, sim.model.velocities.w),; prettytime((time_ns() - start_time) * 1e-9)). simulation = Simulation(model, Δt=wizard, stop_time= stop_time_info, iteration_interval = iteration_interval_info,; progress=progress_message). simulation.output_writers[:fields] =; JLD2OutputWriter(model, merge(model.velocities, model.tracers),; prefix = Name_of_simulation,; schedule = TimeInterval(0.2minute),; force = true). run!(simulation). using JLD2. using Plots. # load(""modified_open_ocean_convection_Fplane_GPU.jld2""). file = jldopen(""ocean_convection_Fplane_Vertical_strecthed_grid.jld2""). # Coordinate arrays; xC, yC, zC = file[""grid/xC""][1:256],file[""grid/yC""][1:256],file[""grid/zC""][1:65]; Lx, Ly, Lz = file[""grid/Lx""],file[""grid/Ly""],file[""grid/Lz""]. # Extract a vector of iterations; iterations = parse.(Int, keys(file[""timeseries/t""])). @info ""Making a neat movie of verticle velocity and Temperature..."". anim = @animate for (i, iteration) in enumerate(iterations). @info ""Plotting frame $i from iteration $iteration..."". t = file[""timeseries/t/$iteration""]; u_snapshot = file[""timeseries/u/$iteration""][:, :, 60]; v_snapshot = file[""timeseries/v/$iteration""][:, :, 60]; w_snapshot = file[""timeseries/w/$iteration""][:, 128, :]; speed_snapshot = sqrt.(u_snapshot.*u_snapshot + v_snapshot.*v_snapshot); # T_snapshot = file[""timeseries/T/$iteration""][:, 128, :]; . ulims = 0.0025; ; ulevels = range(-ulims, stop=ulims, length=50); ; slims = 0.025; ; slevels = range(0, stop=slims, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999:5903,load,load,5903,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1571#issuecomment-819158999,1,['load'],['load']
Performance," this might be useful to people if its more visible. > Why you need to define f², wouldn't work simply using ∂zᶠᶜᶠ and squaring the operation?. Because we need to interpolate `∂zᶠᶜᶠ` using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1322,optimiz,optimized,1322,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,2,['optimiz'],['optimized']
Performance," tridiagonal solver in the pure FFT solver. You might argue that we just put nothing if we don't need it, but then we have more ""ambiguous"" fields like eigenvalues that are not needed in the tridiagonal solver and source_term that is not needed in the FFT. I am not convinced that a single solver would lead to less (or cleaner) code. Mostly because the underlying code (constructor and `solve!` functions) is compact and slender enough to justify writing individual functions for different grids (the number of lines in the docstring for the `DistributedFourierTridiagonalPoissonSolver` is comparable to the code related to the solver). I think this improves the interpretability of the algorithm. Maybe an improvement would be writing a unified constructor that would spit out the different solvers. > 2. It might make sense to split the constructor into two parts, so that we can build a tridiagonal solver even when all three directions are regular. That could be useful for testing, for example. . I have added this capability by passing the `stretched_direction` kwarg. > Also note that in terms of operation count the tridiagonal solve is cheaper than FFT... I think, all things considered, the mixed FFT / tridiagonal solve will have basically the same computational cost as the pure FFT solve only for a stretched x direction. The additional transposes required for a y or stretched z direction will completely dominate the cost of the actual operations. As an example, this is a slab decomposition with a fairly big grid (512 x 256^2) split on 2 GPUs on Tartarus; ![311333172-43dba752-a91f-4b33-8ade-5a6ec57c982b](https://github.com/user-attachments/assets/1a376c1e-9912-4e00-8dca-91deb46338f8); The AlltoAllv is the dominant cost, while the FFT (in between the two transposes) is quite irrelevant. In the near future, I'll perform scaling tests on Perlmutter, which has a much better network, so it might be that (even if I think it's unlikely) the cost is not all communication after all.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3689#issuecomment-2276030073:2336,perform,perform,2336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3689#issuecomment-2276030073,1,['perform'],['perform']
Performance," using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: LoadError: UndefVarError: NFBC not defined; Stacktrace:; [1] top-level scope; @ ~/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; [2] include(mod::Module, _path::String); @ Base ./Base.jl:386; [3] include(x::String); @ Oceananigans.BoundaryConditions ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; [4] top-level scope; @ ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:45; [5] include(mod::Module, _path::String); @ Base ./Base.jl:386; [6] include(x::String); @ Oceananigans ~/Research/OC/src/Oceananigans.jl:1; [7] top-level scope; @ ~/Research/OC/src/Oceananigans.jl:173; [8] include; @ ./Base.jl:386 [inlined]; [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [10] top-level scope; @ none:1; [11] eval; @ ./boot.jl:360 [inlined]; [12] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [13] top-level scope; @ none:1; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; in expression starting at /Users/navid/Research/OC/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_fSB7qw.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334:1085,load,loading,1085,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334,1,['load'],['loading']
Performance," using `ℑxzᶜᵃᶜ`. Note that Oceananigans operators (derivatives, interpolation, differences) are _composable_. The function `f²` is used in this composition --- it squares a _function_, rather than a _field_. So `ℑxzᶜᵃᶜ(i, j, k, grid, f², ∂zᶠᶜᶠ, U.u)` represents a stencil that interpolates `∂zᶠᶜᶠ(i, j, k, grid, u)^2` from `Face` to `Center` in both x and z. > For instance, you could first create the model, define Ri and closure and then set! the model with this new closure and auxiliary field. Yes, your question makes a lot of sense! The reason we can't do that is because _type_ of any of the properties of `model` cannot change. This means we need to know the type of `model.closure` _before_ we build it. Another way to say this is that `HydrostaticFreeSurfaceModel` is _concretely typed_, which means that functions of `model` can be optimized based on the types of _every_ property of `HydrostaticFreeSurfaceModel`. This gives us performance advantages / reduces overhead, but also creates some limitations like: we have to define a `closure` before building model. Here's a simple example:. ```julia; julia> mutable struct Test{T}; a :: T; end. julia> t = Test(1.0); Test{Float64}(1.0). julia> t.a = 2.0; 2.0. julia> t.a = ""hi""; ERROR: MethodError: Cannot `convert` an object of type String to an object of type Float64; Closest candidates are:; convert(::Type{T}, ::T) where T<:Number at number.jl:6; convert(::Type{T}, ::Number) where T<:Number at number.jl:7; convert(::Type{T}, ::Base.TwicePrecision) where T<:Number at twiceprecision.jl:250; ...; Stacktrace:; [1] setproperty!(x::Test{Float64}, f::Symbol, v::String); @ Base ./Base.jl:34; [2] top-level scope; @ REPL[6]:1; ```. Here, `t` is `Test{Float64}`. We can change `a` as long as the new value can be converted to `Float64` via `convert(Float64, new_value)`. Otherwise we can't and we just have to write `s = Test(""hi"")` instead. Another possible solution is to build a ""dummy"" closure with the correct type, and then replace i",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513:1419,perform,performance,1419,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2337#issuecomment-1066113513,2,['perform'],['performance']
Performance, v0.5.23; [bdfc003b] TimesDates v0.3.1; ⌅ [76a88914] CUDA_Runtime_jll v0.11.1+0; ⌅ [fe0851c0] OpenMPI_jll v4.1.6+0; [ade2ca70] Dates; [b77e0a4c] InteractiveUtils; [37e2e46d] LinearAlgebra; [56ddb016] Logging; [44cfe95a] Pkg v1.10.0; [de0858da] Printf; [9a3f8284] Random; [2f01184e] SparseArrays v1.10.0; [10745b16] Statistics v1.10.0; [8dfed614] Test; Status `/private/tmp/jl_p57glG/Manifest.toml`; [621f4979] AbstractFFTs v1.5.0; ⌃ [79e6a3ab] Adapt v4.0.2; ⌃ [4fba245c] ArrayInterface v7.8.0; [a9b6321e] Atomix v0.1.0; ⌃ [ab4f0b2a] BFloat16s v0.4.2; [6e4b80f9] BenchmarkTools v1.5.0; [d1d4a3ce] BitFlags v0.1.8; [fa961155] CEnum v0.5.0; [179af706] CFTime v0.1.3; [052768ef] CUDA v5.2.0; [1af6417a] CUDA_Runtime_Discovery v0.2.3; [944b1d66] CodecZlib v0.7.4; [35d6a980] ColorSchemes v3.24.0; [3da002f7] ColorTypes v0.11.4; [c3611d14] ColorVectorSpace v0.10.0; [5ae59095] Colors v0.12.10; [1fbeeb36] CommonDataModel v0.3.5; [34da2185] Compat v4.14.0; [a216cea6] CompoundPeriods v0.5.1; [f0e56b4a] ConcurrentUtilities v2.4.0; [187b0558] ConstructionBase v1.5.4; [d38c429a] Contour v0.6.2; [a2441757] Coverage v1.6.0; [c36e975a] CoverageTools v1.3.0; [a8cc5b0e] Crayons v4.1.1; [7445602f] CubedSphere v0.2.5; [9a962f9c] DataAPI v1.16.0; [124859b0] DataDeps v0.7.13; [a93c6f00] DataFrames v1.6.1; [864edb3b] DataStructures v0.18.18; [e2d170a0] DataValueInterfaces v1.0.0; [8bb1440f] DelimitedFiles v1.9.1; ⌅ [3c3547ce] DiskArrays v0.3.23; [b4f34e82] Distances v0.10.11; [ffbed154] DocStringExtensions v0.9.3; [b305315f] Elliptic v1.0.1; [7da242da] Enzyme v0.11.19; ⌅ [f151be2c] EnzymeCore v0.6.5; [460bff9d] ExceptionUnwrapping v0.1.10; [e2ba6199] ExprTools v0.1.10; [c87230d0] FFMPEG v0.4.1; [7a1cc6ca] FFTW v1.8.0; [5789e2e9] FileIO v1.16.2; [53c48c17] FixedPointNumbers v0.8.4; [1fa38f19] Format v1.3.6; [0c68f7d7] GPUArrays v10.0.2; [46192b85] GPUArraysCore v0.1.6; ⌅ [61eb1bfa] GPUCompiler v0.25.0; [28b8d3ca] GR v0.73.3; [c27321d9] Glob v1.3.1; [42e2da0e] Grisu v1.0.2; [cd3eb016] HTTP v1.10.3; [615,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3511:2585,Concurren,ConcurrentUtilities,2585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3511,1,['Concurren'],['ConcurrentUtilities']
Performance,"""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718744032:106,perform,performance,106,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718744032,3,"['optimiz', 'perform']","['optimization', 'performance', 'performant']"
Performance,"""Iteration: $(sim.model.clock.iteration), time: $(round(Int, sim.model.clock.time))""; simulation = Simulation(model, Δt=1, stop_time=10, progress=progress); simulation.output_writers[:chk_writer] = Checkpointer(model;; dir=""."",; prefix = ""mwe"",; schedule = TimeInterval(2),; force = false,; cleanup = true,; ). run!(simulation). simulation.stop_time = 20. run!(simulation, pickup=true); ```. This fails with:. ```; [ Info: Updating model auxiliary state before the first time step...; [ Info: ... updated in 400.714 μs.; [ Info: Executing first time step...; [ Info: Iteration: 1, time: 1; [ Info: Iteration: 2, time: 2; [ Info: Iteration: 3, time: 3; [ Info: Iteration: 4, time: 4; [ Info: Iteration: 5, time: 5; [ Info: Iteration: 6, time: 6; [ Info: Iteration: 7, time: 7; [ Info: Iteration: 8, time: 8; [ Info: Iteration: 9, time: 9; [ Info: Iteration: 10, time: 10; [ Info: Simulation is stopping. Model time 10 seconds has hit or exceeded simulation stop time 10 seconds.; ERROR: LoadError: The grid associated with ./mwe_iteration10.jld2 and model.grid are not the same!; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] (::Oceananigans.OutputWriters.var""#52#53""{NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w, :T, :S), Tuple{Field{Face, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, VerticallyStretchedRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.Boundar",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018:1351,Load,LoadError,1351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018,1,['Load'],['LoadError']
Performance,"# Introduction. This PR introduces `AbstractOperation`s for constructing 3D expressions with a friendly syntax (eg, not writing kernels), which can then be evaluated online during a simulation for diagnostics / output purposes. This PR introduces four kinds of `AbstractOperation`s:. 1. `Derivative` (things like `∂x`, `∂y`); 2. `BinaryOperation` (things like `a-b`, `a^b`); 3. `UnaryOperation` (things like `sqrt`, `sin`, `cos`); 4. `PolynaryOperation` (things like `a + b + c + d` or `a * b * c * d`). All of these act on combinations of `Field`, `Function`, and `Number`. `. `AbstractOperation`s arise from what appears to be ordinary arithmetic and calculus performed on `Field`s. Consider this example:. ```julia; julia> using Oceananigans; using Oceananigans: Face, Cell; using Oceananigans.AbstractOperations. grid = RegularCartesianGrid((16, 16, 16), (16, 16, 16));; a = Field(Cell, Cell, Cell, CPU(), grid);; b = Field(Cell, Cell, Cell, CPU(), grid);; a_times_b = a * b;. julia> typeof(a_times_b).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation; ```. Here, the object `a_times_b` is of the type `BinaryOperation`. `a_times_b` can be indexed into like an array or field, however:. ```julia; julia> a_times_b[8, 8, 8]; 0.0. set!(a, rand(size(grid)...)); set!(b, rand(size(grid)...)). julia> a_times_b[8, 8, 8]; 0.5342645056606357; ```. # Staggered grids, interpolation, and operation ""location"". Operations can also be defined between fields at different locations in the staggered grid:. ```julia; julia> u, v, w = Oceananigans.VelocityFields(CPU(), grid);. julia> u_times_v = u * v;. julia> Oceananigans.location(u_times_v); (Face, Cell, Cell); ```. Note that the location of an operation defaults to the location of the *first* field involved. . This submodule also exports a macro `@at` for specifying the location of an operation. Therefore we can write. ```julia; julia> kinetic_energy = @at (Cell, Cell, Cell) (u^2 + v^2 + w^2) / 2;. julia> Oceananigans.location(kinetic_en",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:662,perform,performed,662,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['perform'],['performed']
Performance,"## A generic error when picking up a simulation that has high-frequency output. If we save data at high frequency but checkpoint at low frequency, then pickup the checkpoint and attempt to write data to the same JLD2 file, we can obtain the error:. ```; ERROR: LoadError: ArgumentError: a group or dataset named 12015 is already present within this group; ```. because the _first_ simulation ran past the checkpointed time and saved more data. Thus when we _pickup_ from the checkpoint, we start a little bit in the past, and have to run past the point that was already saved. I think the simplest way to solve this is just to wrap `write_output!` in try/catch, so that we can try to continue even if we can't write output (perhaps emitting a warning). This is probably nice for other reasons too (ie in a very complex simulation with tons of output, some necessary, some not, we might prefer a very annoying, persistent, and obvious warning that one of the outputs doesn't work instead of an outright error). We _could_ also add a property to control this behavior with an innocuous default (ie `catch_errors=false` or something). ## The dangerous overwrite_existing. Another usability issue I noticed is that it's easy to make mistakes with `overwrite_existing`. It's convenient to toggle this on when starting from 0 (sometimes there's an iterative process involved in starting a simulation: fiddling with time-steps, an error in the output writer, error in a callback, blah blah). But when running with `pickup=true` we definitely do _not_ want to overwrite an existing output file. I'm wondering if we should implement behavior where `pickup=true` _overrides_ `overwrite_existing=true`. This would mean that if we pickup we _cannot_ overwrite an existing file (if for some reason we do want that, we'd have to delete it manually). I think this is really the behavior we want. However, it requires refactoring the output writers, because we have to move output writer initialization from the outpu",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2535:261,Load,LoadError,261,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2535,1,['Load'],['LoadError']
Performance,"## From Slack:; Why Julia? I think I know the answer, but I thought it would be nice to have a session answering this question on the documentation. What do you guys think?. @glwagner discussion:; That’s a great idea! I also think a little statement about our goals / mission would be good. My short answer is that achieving all our goals (script based API, cpu/gpu polymorphism, user code injection into the model, DSL for high performance diagnostics, etc) can be achieved in python but we think would probably be a lot more difficult and require a lot more engineering.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2308:429,perform,performance,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2308,1,['perform'],['performance']
Performance,"################# 100.0%; &nbsp; | Downloading artifact: MPICH; &nbsp; | ######################################################################## 100.0%; &nbsp; | Downloading artifact: LibCURL; &nbsp; | ######################################################################## 100.0%; &nbsp; | Building MPI ─→ `/storage7/buildkite-agent/.julia-2581/packages/MPI/b7MVG/deps/build.log`; &nbsp; | [ Info: using default MPI jll; &nbsp; | Building FFTW → `/storage7/buildkite-agent/.julia-2581/packages/FFTW/G3lSO/deps/build.log`; &nbsp; | Precompiling project...; &nbsp; | WARNING: Error during initialization of module GMP:; &nbsp; | ErrorException(""could not load library ""libgmp""; &nbsp; | libgmp.so: ELF load command past end of file""); &nbsp; | WARNING: Error during initialization of module LinearAlgebra:; &nbsp; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_wri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:2579,load,load,2579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,2,['load'],['load']
Performance,"&nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.ju",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:4142,load,loading,4142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,"(::JLD.JldFile, ::HDF5.HDF5Datatype) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:701; [6] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [7] read_ref(::JLD.JldFile, ::HDF5.HDF5ReferenceObj) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:502; [8] jlconvert(::Type{Model}, ::JLD.JldFile, ::Ptr{UInt8}) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\jld_types.jl:387; [9] read_scalar(::JLD.JldDataset, ::HDF5.HDF5Datatype, ::Type) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:398; [10] read(::JLD.JldDataset) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:370; [11] read(::JLD.JldFile, ::String) at C:\Users\Ali\.julia\packages\JLD\1BoSz\src\JLD.jl:346; [12] restore_from_checkpoint(::String) at D:\Home\Git\Oceananigans.jl\src\output_writers.jl:77; [13] run_basic_checkpointer_tests() at D:\Home\Git\Oceananigans.jl\test\test_output_writers.jl:34; [14] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [15] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [16] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:247; [17] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [18] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:244; [19] top-level scope at C:\cygwin\home\Administrator\buildbot\worker\package_win64\build\usr\share\julia\stdlib\v1.1\Test\src\Test.jl:1083; [20] top-level scope at D:\Home\Git\Oceananigans.jl\test\runtests.jl:243; [21] include at .\boot.jl:326 [inlined]; [22] include_relative(::Module, ::String) at .\loading.jl:1038; [23] include(::Module, ::String) at .\sysimg.jl:29; [24] include(::String) at .\client.jl:403; [25] top-level scope at none:0; [26] eval(::Module, ::Any) at .\boot.jl:328; [27] exec_options(::Base.JLOptions) at .\client.jl:243; [28] _start() at .\client.jl:436; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/141:3215,load,loading,3215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/141,1,['load'],['loading']
Performance,"(and better boundary conditions API). This PR adds two scripts to the sandbox for performing large eddy simulation of:. - [ ] a 'simple flux' scenario of a ~100 m square ocean forced by constant surface fluxes, and; - [ ] stratified Couette flow. We may also want to add an example based on one of these scripts. Addresses #310.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/315:82,perform,performing,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/315,1,['perform'],['performing']
Performance,"(as discussed with @simone-silvestri); I encountered this bug when trying to upgrade to julia 1.10.0. What happens is `maximum(abs, v)` doesn't work for grids larger than (10, 10, 10). However `maximum(abs, u)`, `maximum(abs, w)`, `maximum(abs, b)`, `maximum(u)`, `maximum(v)`, `maximum(w)`, and `maximum(b)` work just fine. Here's a MWE tested on Supercloud and Tartarus:. ```julia; using Oceananigans. grid = RectilinearGrid(GPU(),; size = (16, 16, 16),; x = (0, 1),; y = (0, 1),; z = (-1, 0),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid). u, v, w = model.velocities. maximum(u); maximum(w); maximum(v). maximum(abs, u); maximum(abs, w); maximum(abs, v); ```. ```; ERROR: LoadError: CUDA error: too many resources requested for launch (code 701, ERROR_LAUNCH_OUT_OF_RESOURCES); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuLaunchKernel; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] (::CUDA.var""#863#864""{Bool, Int64, CUDA.CuStream, CUDA.CuFunction, CUDA.CuDim3, CUDA.CuDim3})(kernelParams::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:69; [5] macro expansion; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:33 [inlined]; [6] macro expansion; @ ./none:0 [inlined]; [7] pack_arguments(::CUDA.var""#863#864""{…}, ::CUDA.KernelState, ::CartesianIndices{…}, ::CartesianIndices{…}, ::CUDA.CuDeviceArray{…}, ::Oceananigans.AbstractOperations.ConditionalOperation{…}); @ CUDA ./none:0; [8] launch(f::CUDA.CuFunction, args::Vararg{…}; blocks::Union{…}, threads::Union{…}, cooperative::Bool, shmem::Integer, stream::CUDA.CuStream) where N; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:62 [inlined]; [9] #868; @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/execution.jl:136 [inlined]; [10] macro expansion; @ CUDA ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427:709,Load,LoadError,709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427,1,['Load'],['LoadError']
Performance,(fyi I stopped the tests because everything was clogged... all tests in PRs have been running for 6-7 hrs... so perhaps restart when there is less load),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2890#issuecomment-1416674470:147,load,load,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2890#issuecomment-1416674470,3,['load'],['load']
Performance,"); dz = 1 .+ 5000 ./ (1 .+ exp.(- (k .- 100)/10 )); zf = [0; -cumsum(dz)]; zf = reverse(zf); Lz = zf[1]; #; grid = RectilinearGrid(GPU(), size = (Nx, Ny, Nz),x = (0, Lx), y = (0, Ly), z = zf). # Turbulence closures; kappaV = 1e-5; kappaH = 5e5; turb_leith = TwoDimensionalLeith(;C=0.3, C_Redi=1, C_GM=1,isopycnal_model=SmallSlopeIsopycnalTensor()); vertical_closure = VerticalScalarDiffusivity(ν=kappaV, κ=kappaV); horizontal_closure = turb_leith; closures = (vertical_closure, horizontal_closure). # Setting up model; model = NonhydrostaticModel(advection = CenteredFourthOrder(),; timestepper = :RungeKutta3,; grid = grid,; tracers = (:T, :S),; coriolis = FPlane(f=1e-4),; buoyancy = SeawaterBuoyancy(equation_of_state=TEOS10EquationOfState()),; closure = closures,; ). # Setting up simulation; Δt = 5.; stop_time = 20.; simulation = Simulation(model, Δt=Δt, stop_time=stop_time). # Running model; run!(simulation). ```. but get the following error. . ```; ERROR: LoadError: InvalidIRError: compiling kernel #gpu_calculate_Gc!(KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 42)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(8, 8, 42)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, Val{1}, CenteredFourthOrder, Tuple{TwoDimensionalLeith{Float64, NamedTuple{(:T, :S), Tuple{Float64, Float64}}, ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2660:1657,Load,LoadError,1657,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2660,1,['Load'],['LoadError']
Performance,"* ones(Np)),; y = on_architecture(arch, -1.5 * ones(Np)),; z = on_architecture(arch, -H/10 .* ones(Np)); ). model = HydrostaticFreeSurfaceModel(;; grid,; particles; ). for n in 1:100; @info ""Iteration $n...""; time_step!(model, 0.1); end; ```. CPU segfault:. ```; [ Info: Iteration 1...; [ Info: Iteration 2... [503062] signal (11.1): Segmentation fault; in expression starting at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:35; advect_particle at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:0 [inlined]; macro expansion at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:177 [inlined]; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2075,cache,cache,2075,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8765,cache,cache,8765,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,", 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Int64,NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/alir/.julia/packages/CUDA/h38pe/src/compiler/execution.jl:308; [8] #87 at /home/alir/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [9] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.Solvers.gpu_calculate_pressure_right_hand_side!),CUDA.CuDeviceArray{Complex{Float64},3,CUDA.AS.Global},Oceananigans.Solvers.HorizontallyPeriodic,GPU,RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePreci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/828:6998,cache,cache,6998,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/828,1,['cache'],['cache']
Performance,", Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, SubArray{Float64, 1, OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Tuple{UnitRange{Int64}}, true}}}}}); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/driver.jl:76; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/DfvRa/src/compiler/execution.jl:346; [10] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/jVY4I/src/cache.jl:90; [11] cufunction(f::typeof(Oceananigans.Fields.gpu__regrid!), tt::Type{Tuple{KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{2, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, KernelAbstractions.NDIteration.StaticSize{(1, 1)}, Nothing, Nothing}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Flat, Flat, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetVector{Float64, StepRange",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574:6644,cache,cache,6644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221177574,1,['cache'],['cache']
Performance,", Bounded) │ 23.479 ms │ 23.727 ms │ 23.792 ms │ 24.619 ms │ 771.44 KiB │ 1115 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 30.863 ms │ 30.990 ms │ 31.205 ms │ 31.858 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 31.041 ms │ 31.521 ms │ 31.982 ms │ 33.815 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 25.631 ms │ 26.845 ms │ 26.749 ms │ 28.206 ms │ 837.97 KiB │ 1154 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 31.354 ms │ 31.398 ms │ 31.477 ms │ 32.215 ms │ 771.44 KiB │ 1115 │ 10 │; └───────────────┴───────────────┴────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; [2022/05/03 00:56:15.050] INFO Writing Topologies_benchmarks.html...; Topologies relative performance (CPU); ┌───────────────┬───────────────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼───────────────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 0.865858 │ 1.45702 │ 1.14257 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 1.01269 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Bounded) │ 0.760326 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 0.999539 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 0.765277 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 1.01667 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Bounded) │ 0.756078 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴───────────────┴────────────────────────────────┴──────────┴─────────┴─────────┘; ```. # This PR. ## Modest 3D model (128x128x128). ```; Topologies benchmarks; ┌───────────────┬",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:5129,perform,performance,5129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728,1,['perform'],['performance']
Performance,", Nothing, Nothing, Nothing}}:; ERROR: KernelException: exception thrown during kernel execution on device Tesla V100-SXM2-32GB; Stacktrace:; [1] check_exceptions(); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/src/compiler/exceptions.jl:34; [2] nonblocking_synchronize; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:331 [inlined]; [3] device_synchronize(); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/context.jl:319; [4] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:41; [5] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/fAEDi/lib/cudadrv/module.jl:23 [inlined]; [6] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/fAEDi/src/compiler/execution.jl:479; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/XyxTy/src/cache.jl:95; [8] cufunction(f::typeof(CUDA.partial_mapreduce_grid), tt::Type{Tuple{typeof(identity), typeof(max), Nothing, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, CartesianIndices{3, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}}, Val{true}, CUDA.CuDeviceArray{Float64, 4, 1}, Oceananigans.AbstractOperations.ConditionalOperation{Face, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, typeof(identity), ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}, OffsetArrays.OffsetVector{Float64",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871:5688,cache,cache,5688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2582#issuecomment-1142637871,1,['cache'],['cache']
Performance,", Periodic, Bounded) │ 23.208 ms │ 23.282 ms │ 23.646 ms │ 24.667 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 23.736 ms │ 24.691 ms │ 24.854 ms │ 26.482 ms │ 771.44 KiB │ 1115 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 31.277 ms │ 32.486 ms │ 32.212 ms │ 32.999 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 30.844 ms │ 30.903 ms │ 31.003 ms │ 31.769 ms │ 703.45 KiB │ 1081 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 23.704 ms │ 23.832 ms │ 24.042 ms │ 25.055 ms │ 837.97 KiB │ 1154 │ 10 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 31.354 ms │ 31.632 ms │ 31.816 ms │ 32.916 ms │ 772.19 KiB │ 1131 │ 10 │; └───────────────┴───────────────┴────────────────────────────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘; [2022/05/03 00:42:25.915] INFO Writing Topologies_benchmarks.html...; Topologies relative performance (CPU); ┌───────────────┬───────────────┬────────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼───────────────┼────────────────────────────────┼──────────┼─────────┼─────────┤; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Bounded) │ 0.669516 │ 1.45702 │ 1.14257 │; │ CPU │ (256, 256, 1) │ (Bounded, Bounded, Periodic) │ 0.888622 │ 1.34264 │ 1.1198 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Bounded) │ 0.665425 │ 1.34264 │ 1.1198 │; │ CPU │ (256, 256, 1) │ (Bounded, Periodic, Periodic) │ 0.912619 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Bounded) │ 0.693639 │ 1.34134 │ 1.10396 │; │ CPU │ (256, 256, 1) │ (Periodic, Bounded, Periodic) │ 0.868158 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Bounded) │ 0.654046 │ 1.22313 │ 1.0703 │; │ CPU │ (256, 256, 1) │ (Periodic, Periodic, Periodic) │ 1.0 │ 1.0 │ 1.0 │; ```. The fastest is fully bounded for whatever reason.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728:10798,perform,performance,10798,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2477#issuecomment-1115745728,1,['perform'],['performance']
Performance,", like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadmath.0.dylib; Referenced from: /Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib; Reason: tried: '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/./libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/lib/julia/libquadmath.0.dylib' (no such file), '/Applications/Julia-1.7.app/Contents/Resources/julia/bin/../lib/libquadmath.0.dylib' (no such file), '/usr/local/lib/libquadmath.0.dylib' (no such file), '/usr/lib/libquadmath.0.dylib' (no such file); Stacktrace:; [1] dlopen(s::String, flags::UInt32; throw_error::Bo",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:1713,Load,LoadError,1713,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,2,"['Load', 'load']","['LoadError', 'load']"
Performance,", no need to modify existing code. This way MPI does not invade the core code base making it easier to maintain, and there will be a very clear boundary between ""core Oceananigans"" and ""distributed parallelism functionality"" which I think will serve us well in the future as MPI seems to permeate deeply into other codes, making them hard to modify. The big thing that is missing is of course the distributed pressure solver, the hard thing to implement. This is where [DistributedTranspose.jl](https://github.com/leios/DistributedTranspose.jl) will come in handy. I also recently found [PencilFFTs.jl](https://github.com/jipolanco/PencilFFTs.jl) which also looks interesting. cc @leios. For testing purposes, I'm tempted to do the pressure solve via an `MPI.Gather` onto rank 0 where it can be solved locally then an `MPI.Scatter` to pass the pressure to all ranks. Super inefficient but might be good to ensure that the `DistributedModel` can reproduce existing regression tests. Performance issues:; * Right now `MPI.Isend`, `MPI.Recv!`, and `MPI.SendRecv!` all expect send and receive buffers to be contiguous in memory I believe. To get around this I allocate memory for these buffers, but this is definitely not performant. @vchuravy suggested that we may be able to send and receive into strided buffers, so will look into this. cc @simonbyrne maybe you know more about this?. Quality of life features we may want in the future (which might effect design choices):; * Distributed diagnostics: these will be pretty expensive no matter how we implement them due to the extra reduction step (`MPI.Gather`) required across all ranks. I wonder if it's even worth thinking about them much. If we really need things like a `DistributedHorizontalAverage` then we can look into that.; * Distributed output writers: I wonder if we should add e.g. a distributed NetCDF output writer or if each rank just writes out its own output and we have a utility function that post-processes the output files and mer",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590:2248,Perform,Performance,2248,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590,1,['Perform'],['Performance']
Performance,", v, w)];. julia> kinetic_energy[8, 8, 8]; 0.789860912635921; ```. # Special considerations. There are a few special rules to how operations are handled:. * A `BinaryOperation` between two fields at the same location is always performed at their common location;. * a `BinaryOperation` between a field and a number always takes place at the location of the field. These special rules override the specification of operator location via `@at`. Thus, for example, in the operation. ```julia; uv = @at (Cell, Cell, Cell) u * v + v^2; ```. the product `u*v` is computed at the cell center, while `v^2` is computed at the `v`-point `Cell, Face, Cell`, and afterwards interpolated to cell centers. This functionality is achieved by endowing `BinaryOperation` with three interpolation operators: two interpolation operators applied to each field prior to interpolation, and an interpolation operator that is applied to the result. Special cases can then be handled by defining operators for cases in which a computation should be performed at the location of one or both of the fields. Furthermore, we do not provide `PolynaryOperation`s with default locations. In other words, a `PolynaryOperation` only arises when location is specified, eg:. ```julia; julia> op1 = u + v + w;. julia> op2 = @at (Cell, Cell, Cell) u + v + w;. julia> typeof(op1).name.wrapper; Oceananigans.AbstractOperations.BinaryOperation. julia> typeof(op2).name.wrapper; Oceananigans.AbstractOperations.PolynaryOperation; ```. This also means that all fields in a `PolynaryOperation` are interpolated *prior* to computation. # Computations. This PR also adds a type for making ""computations"" with an `AbstractOperation`. We call this a `Computation`. From the tests:. ```julia; T, S = model.tracers; computation = Computation(S + T, model.pressures.pHY′); compute!(computation); ```. which launches a 3D kernel to compute the result of an `AbstractOperation` at every grid point, storing the result in `computation.result` (which here h",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/463:4758,perform,performed,4758,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/463,1,['perform'],['performed']
Performance,"--:|:-------------:|; | Triply periodic | Regular | FFT³ | |; | | Vertically stretched | FFT²×TRI? | |; | Doubly periodic | Regular | FFT²×TRI | FFT²×DCT |; | | Vertically stretched | FFT²×TRI | |; | Channel | Regular | FFT×DCT×TRI | FFT²×DCT |; | | Vertically stretched | FFT×DCT×TRI | |; | Box | Regular | DCT²×TRI | DCT³ |; | | Vertically stretched | DCT²×TRI | |. Essentially we need an FFT for periodic dimensions and we have the choice of using either a DCT or a TRIdiagonal solve for wall-bounded dimensions, although TRI may only be used once. . Some notes:; 1. Multiple wall-bounded dimensions will require the use of a DCT somewhere.; 2. Solvers for vertically stretched grids need to use TRI in the vertical.; 3. For stretched grids in multiple dimensions I believe that a direct solve is no longer possible and an iterative method such as conjugate gradient must be used. I do not consider this case.; 4. We have the option of using a DCT or a TRI. Which one we pick will depend on performance benchmarks between the two solvers. We should pick the faster one. This could depend on the number of vertical levels.; 5. Unfortunately I don't think we can get rid of the in-place DCT algorithm that employs permutations on the GPU as it will be needed for channels and boxes at least. It may also turn out to be more efficient for regular grids in some cases.; 6. We should reuse solvers as much as possible.; 7. While it looks like we have many solvers to implement, I think if we abstract away the steps then each solver just needs to implement something like a `forward_x_transform`, `forward_y_transform`, `forward_z_transform`, `backward_z_transform`, etc. then we can implement many solvers without repeating code. For now, I will first just focus on getting Poisson solvers working for vertically stretched grids in doubly periodic domains on the CPU and GPU. This will offer a chance to do some refactoring and benchmarking. We also need to try out faster tridiagonal matrix algorithms",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586:1868,perform,performance,1868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586,1,['perform'],['performance']
Performance,"-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro exp",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2586,load,loading,2586,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-a,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8054,cache,cache,8054,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5839,cache,cache,5839,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/sean/.julia/compiled/v1.7/Oceananigans/jl_sx8KhM.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997. Any help would be greatly appreciated. Thanks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:6091,load,loading,6091,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,5,['load'],['loading']
Performance,".OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/validation.jl:111; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:319 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/ZQ0rt/src/TimerOutput.jl:236 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/e9hrk/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:317; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/e9hrk/src/cache.jl:89; [8] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Base.Broadcast.Extruded{SubArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}, Tuple{UnitRange{Int64}, Base.Slice{Base.OneTo{Int64}}, Base.Slice{Base.OneTo{Int64}}}, false}, Tuple{Bool, Bool, Bool}, Tuple{Int64, Int64, Int64}}}}, Int64}}; name::Nothing, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:288; [9] cufunction; @ ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:282 [inlined]; [10] macro expansion; @ ~/.julia/packages/CUDA/lwSps/src/compiler/execution.jl:102 [inlined]; [11] #launch_heuri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1995:3556,cache,cache,3556,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1995,1,['cache'],['cache']
Performance,".PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); │ @ Base ./loading.jl:2468; │ [3] compilecache; │ @ ./loading.jl:2340 [inlined]; │ [4] (::Base.var""#968#969""{Base.PkgId})(); │ @ Base ./loading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2186,load,loading,2186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,".c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Inf",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8566,cache,cache,8566,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,.jl/src/DistributedComputations/halo_communication.jl:317; #fill_south_and_north_halo!#50 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:263; fill_south_and_north_halo! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:250; unknown function (ip: 0x2aaac8afa8b6); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_event!#40 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:208; fill_halo_event! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:193; unknown function (ip: 0x2aaac8aefb2e); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #fill_halo_regions!#38 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:114; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:101 [inlined]; #fill_halo_regions!#37 at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:90 [inlined]; fill_halo_regions! at /orcd/data/raffaele/001/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:3081,cache,cache,3081,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,".jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/j",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:5223,Load,LoadError,5223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['Load'],['LoadError']
Performance,"/3VnCC/src/device/intrinsics.jl:22; [7] include(mod::Module, _path::String); @ Base ./Base.jl:386; [8] include(x::String); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; [9] top-level scope; @ ~/.julia/packages/CUDA/3VnCC/src/CUDA.jl:46; [10] include; @ ./Base.jl:386 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:1804,Load,LoadError,1804,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['Load'],['LoadError']
Performance,"/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | 🚨 Error: The command exited with status 1. ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:6302,load,load,6302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,9,['load'],['load']
Performance,"/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:86 [inlined]; [11] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:129; [12] codegen; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:110 [inlined]; [13] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:106; [14] compile; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:98 [inlined]; [15] #40; @ ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:140 [inlined]; [16] JuliaContext(f::AMDGPU.Compiler.var""#40#41""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:47; [17] hipcompile(job::GPUCompiler.CompilerJob); @ AMDGPU.Compiler ~/.julia/packages/AMDGPU/FdIJi/src/compiler/codegen.jl:139; [18] actual_compilation(cache::Dict{Any, AMDGPU.HIP.HIPFunction}, src::Core.MethodInstance, world::UInt64, cfg::GPUCompiler.CompilerConfig{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}, compiler::typeof(AMDGPU.Compiler.hipcompile), linker::typeof(AMDGPU.Compiler.hiplink)); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/execution.jl:125; [19] cached_co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273:2169,optimiz,optimize,2169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935971273,2,['optimiz'],['optimize']
Performance,/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #run_repl#59 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; run_repl at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; jfptr_run_repl_91805.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_i,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:6816,cache,cache,6816,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"/gf.c:3077; #1013 at ./client.jl:432; jfptr_YY.1013_82772.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iterati",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8675,cache,cache,8675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; jl_f__call_latest at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:812; #invokelatest#2 at ./essentials.jl:892 [inlined]; invokelatest at ./essentials.jl:889 [inlined]; run_main_repl at ./client.jl:416; exec_options at ./client.jl:333; _start at ./client.jl:552; jfptr__start_82798.1 at /home/alir/.julia/juliaup/julia-1.10.5+0.x64.linux.gnu/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:731; main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/cli/loader_exe.c:58; unknown function (ip: 0x7c00f758ce07); __libc_start_main at /usr/lib/libc.so.6 (unknown line); unknown function (ip: 0x4010b8); Allocations: 67298744 (Pool: 67235612; Big: 63132); GC: 66; fish: Job 1, 'julia --project' terminated by signal SIGSEGV (Address boundary error); ```. GPU illegal memory access:. ```; [ Info: Skipping precompilation since __precompile__(false). Importing Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09].; [ Info: Iteration 1...; [ Info: Iteration 2...; [ Info: Iteration 3...; [ Info: Iteration 4...; [ Info: Iteration 5...; [ Info: Iteration 6...; [ Info: Iteration 7...; [ Info: Iteration 8...; [ Info: Iteration 9...; [ Info: Iteration 10...; [ Info: Iteration 11...; [ Info: Iteration 12...; [ Info: Iteration 13...; [ Info: Iteration 14...; [ Info: Iteration 15...; [ Info: Iteration 16...; [ Info: Iteration 17..",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:8971,cache,cache,8971,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"/li>; <li>1.9.6 and compat bump for node semver package by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/221"">julia-actions/setup-julia#221</a></li>; </ul>; <h2>New Contributors</h2>; <ul>; <li><a href=""https://github.com/benlorenz""><code>@​benlorenz</code></a> made their first contribution in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/220"">julia-actions/setup-julia#220</a></li>; </ul>; <p><strong>Full Changelog</strong>: <a href=""https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6"">https://github.com/julia-actions/setup-julia/compare/v1.9.5...v1.9.6</a></p>; <h2>v1.9.5: Maintain mtime of julia build to avoid re-precompilation</h2>; <p>A big part of fixing <a href=""https://redirect.github.com/JuliaLang/julia/issues/50667"">JuliaLang/julia#50667</a> for julia &lt;1.11 as maintaining the mtime of the julia source files means cached <code>/compiled</code> caches won't be invalidated in new runs where julia has been reinstalled.</p>; <h2>What's Changed</h2>; <ul>; <li>add test for julia install and mtime maintenance by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/200"">julia-actions/setup-julia#200</a></li>; <li>extract julia directly to tool path to maintain mtimes by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/196"">julia-actions/setup-julia#196</a></li>; <li>v1.9.5 by <a href=""https://github.com/IanButterworth""><code>@​IanButterworth</code></a> in <a href=""https://redirect.github.com/julia-actions/setup-julia/pull/201"">julia-actions/setup-julia#201</a></li>; </ul>; <h3>Dep updates</h3>; <!-- raw HTML omitted -->; </blockquote>; <p>... (truncated)</p>; </details>; <details>; <summary>Commits</summary>; <ul>; <li><a href=""htt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3544:5765,cache,cached,5765,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3544,2,['cache'],"['cached', 'caches']"
Performance,"/loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1746; │ [34] eval; │ @ ./boot.jl:385 [inlined]; │ [35] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; │ [36] repl_backend_loop(backend::REPL.REPLBacke",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:3182,load,loading,3182,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; error in running finalizer: CUDA.CuError(code=CUDA.cudaError_enum(0x000002bc), meta=nothing); throw_api_error at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; check at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; cuStreamDestroy_v2 at /home/js2430/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; #834 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:86 [inlined]; #context!#887 at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170; unknown function (ip: 0x7f08bc0a0880); context! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; unsafe_destroy! at /home/js2430/.julia/packages/CUDA/35NC6/lib/cudadrv/stream.jl:85; unknown function (ip: 0x7f08bc0a0622); _jl_invoke at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2758 [inlined]; ijl_apply_generic at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gf.c:2940; run_finalizer at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:417; jl_gc_run_finalizers_in_list at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:507; run_finalizers at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/gc.c:553; ijl_atexit_hook at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/init.c:299; jl_repl_entrypoint at /cache/build/default-amdci5-2/julialang/julia-release-1-dot-9/src/jlapi.c:718; main at julia (unknown line); __libc_start_main at /lib64/libc.so.6 (unknown line); unknown function (ip: 0x401098); ```; </details>; </summary>",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129:4390,cache,cache,4390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267#issuecomment-1721310129,7,['cache'],['cache']
Performance,"/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:4084,load,loading,4084,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,0 │; │ CPU │ TEOS10EquationOfState │ 2.270 s │ 2.401 s │ 2.378 s │ 2.464 s │ 372.53 KiB │ 2090 │; │ GPU │ LinearEquationOfState │ 10.058 ms │ 13.161 ms │ 12.856 ms │ 13.215 ms │ 1022.19 KiB │ 7154 │; │ GPU │ RoquetEquationOfState │ 10.688 ms │ 13.236 ms │ 12.991 ms │ 13.322 ms │ 1.00 MiB │ 7054 │; │ GPU │ TEOS10EquationOfState │ 10.204 ms │ 13.463 ms │ 13.145 ms │ 13.504 ms │ 1017.58 KiB │ 7154 │; └───────────────┴───────────────────────┴───────────┴───────────┴───────────┴───────────┴─────────────┴────────┘; ```. ```; Equation of state CPU -> GPU speedup; ┌───────────────────────┬─────────┬─────────┬─────────┐; │ EquationsOfState │ speedup │ memory │ allocs │; ├───────────────────────┼─────────┼─────────┼─────────┤; │ LinearEquationOfState │ 154.965 │ 2.74298 │ 3.42297 │; │ RoquetEquationOfState │ 133.062 │ 2.74052 │ 3.37512 │; │ TEOS10EquationOfState │ 178.317 │ 2.73152 │ 3.42297 │; └───────────────────────┴─────────┴─────────┴─────────┘; ```. ```; Equation of state relative performance (CPU); ┌───────────────┬───────────────────────┬──────────┬──────────┬────────┐; │ Architectures │ EquationsOfState │ slowdown │ memory │ allocs │; ├───────────────┼───────────────────────┼──────────┼──────────┼────────┤; │ CPU │ LinearEquationOfState │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ RoquetEquationOfState │ 0.863549 │ 1.00298 │ 1.0 │; │ CPU │ TEOS10EquationOfState │ 1.17707 │ 0.999665 │ 1.0 │; └───────────────┴───────────────────────┴──────────┴──────────┴────────┘; ```. ```; Equation of state relative performance (GPU); ┌───────────────┬───────────────────────┬──────────┬──────────┬──────────┐; │ Architectures │ EquationsOfState │ slowdown │ memory │ allocs │; ├───────────────┼───────────────────────┼──────────┼──────────┼──────────┤; │ GPU │ LinearEquationOfState │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ RoquetEquationOfState │ 1.00569 │ 1.00208 │ 0.986022 │; │ GPU │ TEOS10EquationOfState │ 1.02292 │ 0.995491 │ 1.0 │; └───────────────┴───────────────────────┴──────────┴──────────┴──────────┘. ```,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099:1965,perform,performance,1965,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1242#issuecomment-800720099,2,['perform'],['performance']
Performance,"00; [3] compilecache; @ ./loading.jl:2167 [inlined]; [4] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1805; [5] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1660; [6] macro expansion; @ ./loading.jl:1648 [inlined]; [7] macro expansion; @ ./lock.jl:267 [inlined]; [8] require(into::Module, mod::Symbol); @ Base ./loading.jl:1611; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; ```; The versioninfo gave me the following as output:; ```; Julia Version 1.9.2; Commit e4ee485e90 (2023-07-05 09:39 UTC); Platform Info:; OS: Linux (x86_64-suse-linux); ""openSUSE Leap 15.4""; uname: Linux 5.14.21-150400.24.46-default #1 SMP PREEMPT_DYNAMIC Thu Feb 9 08:38:18 UTC 2023 (2d95137) x86_64 x86_64; CPU: Intel(R) Xeon(R) Gold 6240 CPU @ 2.60GHz: ; speed user nice sys idle irq; #1-72 2600 MHz 922553194 s 727867 s 363212152 s 5414020342 s 0 s; Memory: 370.290340423584 GB (301775.56640625 MB free); Uptime: 9.37897786e6 sec; Load Avg: 13.61 25.96 27.94; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-14.0.6 (ORCJIT, cascadelake); Threads: 1 on 72 virtual cores; Environment:; LD_LIBRARY_PATH = /glade/u/apps/casper/23.10/spack/opt/spack/openmpi/4.1.6/oneapi/2023.2.1/dgcv/lib:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/nvvm/lib64:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/extras/CUPTI/lib64:/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/extras/Debugger/lib64:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib/x64:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/lib/oclfpga/host/linux64/lib:/glade/u/apps/common/23.08/spack/opt/spack/intel-oneapi-compilers/2023.2.1/compiler/2023.2.1/linux/compiler/lib/intel64_lin:/glade",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720:1635,Load,Load,1635,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233740720,1,['Load'],['Load']
Performance,00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; eval_user_input at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; repl_backend_loop at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; #start_repl_backend#46 at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; start_repl_backend at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:228; _jl_invoke at /cache/build/builder-amdc,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:5947,cache,cache,5947,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,01/glwagner/Oceananigans.jl/src/DistributedComputations/halo_communication.jl:87; unknown function (ip: 0x2aaac8ad0ee5); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 a,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:4585,cache,cache,4585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['cache'],['cache']
Performance,"09""{Bool,Bool,Bool,Bool})(::Module) at ./client.jl:399; │ [30] #invokelatest#1 at ./essentials.jl:710 [inlined]; │ [31] invokelatest at ./essentials.jl:709 [inlined]; │ [32] run_main_repl(::Bool, ::Bool, ::Bool, ::Bool, ::Bool) at ./client.jl:383; │ [33] exec_options(::Base.JLOptions) at ./client.jl:313; │ [34] _start() at ./client.jl:506; └ @ CUDA ~/.julia/packages/CUDA/0p5fn/src/initialization.jl:101; ERROR: InitError: CUDA.jl did not successfully initialize, and is not usable.; If you did not see any other error message, try again in a new session; with the JULIA_DEBUG environment variable set to 'CUDA'.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] libcuda() at /home/fpoulin/.julia/packages/CUDA/0p5fn/src/initialization.jl:51; [3] (::CUDA.var""#697#cache_fptr!#11"")() at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:31; [4] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:39 [inlined]; [5] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/libcuda.jl:35 [inlined]; [6] macro expansion at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/error.jl:102 [inlined]; [7] cuDeviceGetCount(::Base.RefValue{Int32}) at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/utils/call.jl:93; [8] length at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:111 [inlined]; [9] iterate at /home/fpoulin/.julia/packages/CUDA/0p5fn/lib/cudadrv/devices.jl:106 [inlined] (repeats 2 times); [10] iterate at ./iterators.jl:139 [inlined]; [11] iterate at ./iterators.jl:138 [inlined]; [12] __init__() at /home/fpoulin/software/Oceananigans.jl/src/Oceananigans.jl:178; [13] _include_from_serialized(::String, ::Array{Any,1}) at ./loading.jl:697; [14] _require_search_from_serialized(::Base.PkgId, ::String) at ./loading.jl:782; [15] _require(::Base.PkgId) at ./loading.jl:1007; [16] require(::Base.PkgId) at ./loading.jl:928; [17] require(::Module, ::Symbol) at ./loading.jl:923; during initialization of module Oceananigans",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1189:4940,load,loading,4940,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1189,5,['load'],['loading']
Performance,0a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_call at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:126; eval_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:4996,cache,cache,4996,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"1.6. I attach the start of the error message. @glwagner, do you know of any particularity of the immersed boundary that might cause this?. ```; [ Info: Initializing simulation...; [ Info: [0.00%], iteration: 0, time: 0.000; [ Info: ... simulation initialization complete (1.209 seconds); [ Info: Executing initial time step...; ERROR: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] query; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:102 [inlined]; [3] synchronize(stream::CUDA.CuStream; blocking::Bool); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117; [4] synchronize (repeats 2 times); @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/stream.jl:117 [inlined]; [5] top-level scope; @ ~/.julia/packages/CUDA/DL5Zo/src/initialization.jl:54. caused by: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:105; [2] macro expansion; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/error.jl:115 [inlined]; [3] cuCtxSynchronize(); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/utils/call.jl:26; [4] device_synchronize; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/context.jl:319 [inlined]; [5] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:41; [6] CuModule; @ ~/.julia/packages/CUDA/DL5Zo/lib/cudadrv/module.jl:23 [inlined]; [7] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA ~/.julia/packages/CUDA/DL5Zo/src/compiler/execution.jl:442; [8] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2479:1268,Load,LoadError,1268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2479,1,['Load'],['LoadError']
Performance,10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:124; time_step! at /home/alir/atdepth/Oceananigans.jl/src/TimeSteppers/quasi_adams_bashforth_2.jl:76; unknown function (ip: 0x7c00a0f12fbd); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; top-level scope at /home/alir/atdepth/Oceananigans.jl/particles_error.jl:37; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:925; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./client.jl:489; unknown function (ip: 0x7c00f54ff855); _jl_invoke at /cache/build/builder-amdci4-4/julia,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:4026,cache,cache,4026,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"110 ms │ 57.56 KiB │ 641 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 13.975 ms │ 30.948 ms │ 29.250 ms │ 30.985 ms │ 57.75 KiB │ 647 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 7.257 ms │ 15.907 ms │ 15.044 ms │ 15.927 ms │ 27.97 KiB │ 292 │; └───────────────┴─────┴───────────────────────────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘; ```. ### CPU to GPU speedup. ```; FFT-based Poisson solver CPU -> GPU speedup; ┌─────┬───────────────────────────────┬─────────┬────────┬────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼───────────────────────────────┼─────────┼────────┼────────┤; │ 256 │ (Bounded, Bounded, Bounded) │ 35.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤;",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:11727,perform,performance,11727,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance,"111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwop",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:2467,load,loading,2467,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [11] maybe_cachefile_lock; @ ./loading.jl:2980 [inlined]; [12] _require(pkg::Base.PkgId, env::String); @ Base ./loading.jl:1970; [13] __require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1812; [14] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [15] invoke_in_world; @ ./essentials.jl:923 [inlined]; [16] _require_prelocked(uuidkey::Base.PkgId, env::String); @ Base ./loading.jl:1803; [17] macro expansion; @ ./loading.jl:1790 [inlined]; [18] macro expansion; @ ./lock.jl:267 [inlined]; [19] __require(into::Module, mod::Symbol); @ Base ./loading.jl:1753; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceananigans/M82LU/src/Oceananigans.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/Oceananigans/jl_k7YOZN"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:5048,load,loading,5048,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,"1; &nbsp; | [12] top-level scope at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | [13] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [14] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [15] top-level scope at none:2; &nbsp; | [16] eval at ./boot.jl:347 [inlined]; &nbsp; | [17] eval(::Expr) at ./client.jl:467; &nbsp; | [18] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/Pencils/Pencils.jl:7; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilArrays/DTEhf/src/PencilArrays.jl:12; &nbsp; | ERROR: LoadError: Failed to precompile PencilArrays [0e08944d-e94e-41b1-9406-dcf66b6a9d2e] to /storage7/buildkite-agent/.julia-2581/compiled/v1.5/PencilArrays/yKKUy_zV1Ut.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] error(::String) at ./error.jl:33; &nbsp; | [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1305; &nbsp; | [3] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [4] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [5] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [6] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [7] include(::Module, ::String) at ./Base.jl:368; &nbsp; | [8] top-level scope at none:2; &nbsp; | [9] eval at ./boot.jl:347 [inlined]; &nbsp; | [10] eval(::Expr) at ./client.jl:467; &nbsp; | [11] top-level scope at ./none:3; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2581/packages/PencilFFTs/Xwxei/src/PencilFFTs.jl:11; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:5516,load,loading,5516,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,"2.561] INFO Warming up distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:45.955] INFO Benchmarking distributed nonhydrostatic model on rank 0...; [2022/03/13 19:04:50.814] INFO Done benchmarking on rank 0. Median time: 72.806 ms; [2022/03/13 19:04:57.400] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; [2022/03/13 19:05:21.386] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 1...; [2022/03/13 19:05:21.430] INFO Setting up distributed nonhydrostatic model with N=(128, 128, 32) grid points and ranks=(1, 2, 1) on rank 0...; [2022/03/13 19:06:04.003] INFO Warming up distributed nonhydrostatic model on rank 1...; [2022/03/13 19:06:04.004] INFO Warming up distributed nonhydrostatic model on rank 0...; ERROR: ERROR: LoadError: LoadError: DimensionMismatch(DimensionMismatch(""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] ""arrays could not be broadcast to a common size; got a dimension with lengths 128 and 64""); Stacktrace:; [1] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs1; @ ./broadcast.jl:501 [inlined]; [2] _bcs(_bcs(shape::shape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, newshape::Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}); @ Base.Broadcast ./broadcast.jl:495; [3] broadcast_shape; @ ./broadcast.jl:489 [inlined]; [4] combine_axes; @ ./broadcast.jl:484 [inlined]; [5] _axes; @ ./broadcast.jl:209 [inlined]; [6] axes; @ ./broadcast.jl:207 [inlined]; [7] _unwrap_pa(bc::Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(/), Tuple{Base.Broadcast.Broadcasted{PencilArrays.PencilArrayStyle{3}, Nothing, typeof(-), Tuple{PencilArrays.PencilArrayBroadcastable{ComplexF64, 3",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347:1812,Load,LoadError,1812,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347,2,['Load'],['LoadError']
Performance,"213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/tomas/repos/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/tomas/.julia/compiled/v1.6/Oceananigans/jl_psrPk0.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:2359,load,loading,2359,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['load'],['loading']
Performance,"4, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}}, GPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.Mem.DeviceBuffer}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, GPU}); Closest candidates are:; min_Δx(::RectilinearGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/rectilinear_grid.jl:463; min_Δx(::OrthogonalSphericalShellGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/orthogonal_spherical_shell_grid.jl:937; min_Δx(::LatitudeLongitudeGrid) at /nfs/cnhlab001/ssilvest/julia_pkg/packages/Oceananigans/KTw3g/src/Grids/latitude_longitude_grid.jl:653; ```; `min_Δx` is not defined for immersed boundary grid anymore. ```; ERROR: LoadError: Scalar indexing is disallowed.; Invocation of getindex resulted in scalar indexing of a GPU array.; This is typically caused by calling an iterating implementation of a method.; Such implementations *do not* execute on the GPU, but very slowly on the CPU,; and therefore are only permitted from the REPL for prototyping purposes.; If you did intend to index this array, annotate the caller with @allowscalar.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] assertscalar(op::String); @ GPUArraysCore /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArraysCore/HaQcr/src/GPUArraysCore.jl:103; [3] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/GPUArrays/XR4WO/src/host/indexing.jl:9 [inlined]; [4] getindex; @ /nfs/cnhlab001/ssilvest/julia_pkg/packages/OffsetArrays/TcCEq/src/OffsetArrays.jl:436 [inlined]; [5] getindex; @ ./subarray.jl:315 [inlined]; [6] mapreduce_impl(f::typeof(identity), op::typeof(min), A::SubArray{Float64, 1, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3038:1491,Load,LoadError,1491,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3038,1,['Load'],['LoadError']
Performance,4/julialang/julia-release-1-dot-10/src/interpreter.c:223; eval_stmt_value at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:174 [inlined]; eval_body at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:617; jl_interpret_toplevel_thunk at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/interpreter.c:775; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:934; jl_toplevel_eval_flex at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:877; ijl_toplevel_eval_in at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/toplevel.c:985; eval at ./boot.jl:385 [inlined]; include_string at ./loading.jl:2076; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; _include at ./loading.jl:2136; include at ./Base.jl:495; jfptr_include_46447.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; exec_options at ./client.jl:318; _start at ./client.jl:552; jfptr__start_82798.1 at /orcd/data/raffaele/001/glwagner/Software/julia-1.10.5/lib/julia/sys.so (unknown line); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; true_main at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/jlapi.c:582; jl_repl_entrypoint at /cache/build/builder-amdci4-4/julialang/julia-release-1-,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878:5167,load,loading,5167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878,1,['load'],['loading']
Performance,"4x 64x 64 static ocean (CPU, Float64) 10 635ms 0.19% 63.5ms 13.5KiB 0.49% 1.35KiB; 128x128x128 static ocean (GPU, Float64) 10 80.2ms 0.02% 8.02ms 332KiB 12.0% 33.2KiB; 128x128x128 static ocean (GPU, Float32) 10 77.0ms 0.02% 7.70ms 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (CPU, Float32) 10 72.3ms 0.02% 7.23ms 13.1KiB 0.47% 1.31KiB; 32x 32x 32 static ocean (CPU, Float64) 10 45.1ms 0.01% 4.51ms 13.5KiB 0.49% 1.35KiB; 64x 64x 64 static ocean (GPU, Float64) 10 8.30ms 0.00% 830μs 332KiB 12.0% 33.2KiB; 64x 64x 64 static ocean (GPU, Float32) 10 8.05ms 0.00% 805μs 329KiB 11.9% 32.9KiB; 32x 32x 32 static ocean (GPU, Float64) 10 3.63ms 0.00% 363μs 332KiB 12.0% 33.2KiB; 32x 32x 32 static ocean (GPU, Float32) 10 3.45ms 0.00% 345μs 329KiB 11.9% 32.9KiB; ──────────────────────────────────────────────────────────────────────────────────────────────────. CPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 0.623; 64x 64x 64 static ocean: 0.614; 128x128x128 static ocean: 0.723; 256x256x256 static ocean: 0.841. GPU Float64 -> Float32 speedups:; 32x 32x 32 static ocean: 1.052; 64x 64x 64 static ocean: 1.031; 128x128x128 static ocean: 1.042; 256x256x256 static ocean: 1.038. CPU -> GPU speedsup:; 32x 32x 32 static ocean (Float32): 20.923; 32x 32x 32 static ocean (Float64): 12.402; 64x 64x 64 static ocean (Float32): 128.536; 64x 64x 64 static ocean (Float64): 76.582; 128x128x128 static ocean (Float32): 161.689; 128x128x128 static ocean (Float64): 112.144; 256x256x256 static ocean (Float32): 195.877; 256x256x256 static ocean (Float64): 158.772; ```. Some comments:; * Switching to `Float32` actually slowed things down on my CPU (and on the cluster).; * No surprise: GPU does better with bigger problems. Running another benchmark with 512x512x512 to see if we can break 200x!; * When I did this kind of timing a couple of weeks ago I only saw CPU->GPU speedups of ~90x but now we're getting ~195x for the largest model with `Float32`. We've improved performance without even knowing it!",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/116:3973,perform,performance,3973,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/116,1,['perform'],['performance']
Performance,"5.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 2.42923 │ 3.01676 │ 3.07534 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.95419 │ 2.0581 │ 2.19521 │; │ GPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.94553 │ 2.0648 │ 2.21575 │; │ GPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴─────────┴─────────┘; ```. ---. ## System info. ```; Oceananigans v0.50.0; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:12464,perform,performance,12464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance,"520 ms │ 20.519 ms │ 5.56 MiB │ 17974 │ 10 │; │ GPU │ (2, 5) │ 15.824 ms │ 21.211 ms │ 21.064 ms │ 24.897 ms │ 7.86 MiB │ 23938 │ 10 │; │ GPU │ (2, 10) │ 22.085 ms │ 27.236 ms │ 28.231 ms │ 38.295 ms │ 15.02 MiB │ 31086 │ 10 │; └───────────────┴─────────┴───────────┴───────────┴───────────┴───────────┴────────────┴────────┴─────────┘. Arbitrary tracers CPU to GPU speedup; ┌─────────┬─────────┬─────────┬─────────┐; │ tracers │ speedup │ memory │ allocs │; ├─────────┼─────────┼─────────┼─────────┤; │ (0, 0) │ 112.881 │ 1.78792 │ 7.44022 │; │ (0, 1) │ 112.761 │ 1.77743 │ 7.36045 │; │ (0, 2) │ 109.618 │ 1.6627 │ 6.96945 │; │ (1, 0) │ 110.717 │ 1.77723 │ 7.35221 │; │ (2, 0) │ 111.678 │ 1.66267 │ 6.91569 │; │ (2, 3) │ 118.737 │ 1.55043 │ 4.57587 │; │ (2, 5) │ 133.803 │ 1.5155 │ 4.87734 │; │ (2, 10) │ 137.615 │ 1.44535 │ 4.0466 │; └─────────┴─────────┴─────────┴─────────┘. Arbitrary tracers relative performance (CPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ CPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ (0, 1) │ 1.09293 │ 1.39873 │ 1.17271 │; │ CPU │ (0, 2) │ 1.15948 │ 1.99019 │ 1.38345 │; │ CPU │ (1, 0) │ 1.06409 │ 1.39873 │ 1.17271 │; │ CPU │ (2, 0) │ 1.17887 │ 1.99054 │ 1.38949 │; │ CPU │ (2, 3) │ 1.55493 │ 4.04677 │ 2.37198 │; │ CPU │ (2, 5) │ 1.97115 │ 5.84537 │ 2.96377 │; │ CPU │ (2, 10) │ 2.6031 │ 11.7179 │ 4.63889 │; └───────────────┴─────────┴──────────┴─────────┴─────────┘. Arbitrary tracers relative performance (GPU); ┌───────────────┬─────────┬──────────┬─────────┬─────────┐; │ Architectures │ tracers │ slowdown │ memory │ allocs │; ├───────────────┼─────────┼──────────┼─────────┼─────────┤; │ GPU │ (0, 0) │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ (0, 1) │ 1.0941 │ 1.39053 │ 1.16013 │; │ GPU │ (0, 2) │ 1.19399 │ 1.85081 │ 1.29592 │; │ GPU │ (1, 0) │ 1.08489 │ 1.39037 │ 1.15883 │; │ GPU │ (2, 0) │ 1.19157 │ 1.85109 │ 1.29153 │; │ GPU │ (2, 3)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1722:10237,perform,performance,10237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1722,1,['perform'],['performance']
Performance,"558 │; > │ 100000000 │ 618.565 │ 3.01714 │ 6.04355 │; > └─────────────┴─────────┴─────────┴─────────┘; >; > Lagrangian particle tracking relative performance (CPU); > ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; > │ Architectures │ N_particles │ slowdown │ memory │ allocs │; > ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; > │ CPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; > │ CPU │ 1 │ 1.03447 │ 1.01267 │ 1.01599 │; > │ CPU │ 10 │ 1.04601 │ 1.01267 │ 1.01599 │; > │ CPU │ 100 │ 1.04712 │ 1.01267 │ 1.01599 │; > │ CPU │ 1000 │ 1.05514 │ 1.01267 │ 1.01599 │; > │ CPU │ 10000 │ 1.05397 │ 1.01267 │ 1.01599 │; > │ CPU │ 100000 │ 1.07213 │ 1.01267 │ 1.01599 │; > │ CPU │ 1000000 │ 1.34006 │ 1.01267 │ 1.01599 │; > │ CPU │ 10000000 │ 4.09045 │ 1.01267 │ 1.01599 │; > │ CPU │ 100000000 │ 31.6534 │ 1.01267 │ 1.01599 │; > └───────────────┴─────────────┴──────────┴─────────┴─────────┘; >; > Lagrangian particle tracking relative performance (GPU); > ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; > │ Architectures │ N_particles │ slowdown │ memory │ allocs │; > ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; > │ GPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; > │ GPU │ 1 │ 1.02262 │ 1.01395 │ 1.0135 │; > │ GPU │ 10 │ 1.02786 │ 1.01314 │ 1.00947 │; > │ GPU │ 100 │ 1.02347 │ 1.01314 │ 1.00947 │; > │ GPU │ 1000 │ 1.02548 │ 1.01395 │ 1.0135 │; > │ GPU │ 10000 │ 1.0309 │ 1.01314 │ 1.00947 │; > │ GPU │ 100000 │ 1.02327 │ 1.01314 │ 1.00947 │; > │ GPU │ 1000000 │ 1.03536 │ 1.01395 │ 1.0135 │; > │ GPU │ 10000000 │ 1.31966 │ 1.01391 │ 1.01332 │; > │ GPU │ 100000000 │ 4.20799 │ 1.01317 │ 1.00964 │; > └───────────────┴─────────────┴──────────┴─────────┴─────────┘; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQS3WD4CLJSVF23H433SRME",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982:5392,perform,performance,5392,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982,1,['perform'],['performance']
Performance,"64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiffusivity{Float64,NamedTuple{(:T, :S),Tuple{Float64,Float64}}},NamedTuple{(:u, :v, :w),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},NamedTuple{(:T, :S),Tuple{OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}}}},Nothing,NamedTuple{(:u, :v, :w, :T, :S),Tuple{var""#Fu#80"",var""#Fv#81"",var""#Fw#82"",typeof(Oceananigans.Forcing.zeroforcing),typeof(Oceananigans.Forcing.zeroforcing)}},OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration),Tuple{Float64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ancellin/.julia/packages/CUDA/d6WNR/src/compiler/execution.jl:310; [13] #87 at /home/ancellin/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [14] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(16, 16, 16)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(1, 1, 16)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArray{Float64,3,CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},CenteredSecondOrder,Nothing,Nothing,IsotropicDiff",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/882:4300,cache,cache,4300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/882,1,['cache'],['cache']
Performance,"7-10x performance difference between 2D models in ""xy"" versus ""xz""",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919:6,perform,performance,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919,1,['perform'],['performance']
Performance,7.22 KiB │ 11561 │; > │ GPU │ 100000000 │ 4.910 ms │ 18.629 ms │ 17.245 ms │ 18.757 ms │ 896.56 KiB │ 11519 │; > └───────────────┴─────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; >; > Lagrangian particle tracking CPU -> GPU; > speedup; > ┌─────────────┬─────────┬─────────┬─────────┐; > │ N_particles │ speedup │ memory │ allocs │; > ├─────────────┼─────────┼─────────┼─────────┤; > │ 0 │ 82.2319 │ 3.01565 │ 6.08156 │; > │ 1 │ 83.1848 │ 3.01946 │ 6.06663 │; > │ 10 │ 83.6845 │ 3.01704 │ 6.0425 │; > │ 100 │ 84.1322 │ 3.01704 │ 6.0425 │; > │ 1000 │ 84.6106 │ 3.01946 │ 6.06663 │; > │ 10000 │ 84.072 │ 3.01704 │ 6.0425 │; > │ 100000 │ 86.1581 │ 3.01704 │ 6.0425 │; > │ 1000000 │ 106.432 │ 3.01946 │ 6.06663 │; > │ 10000000 │ 254.889 │ 3.01935 │ 6.06558 │; > │ 100000000 │ 618.565 │ 3.01714 │ 6.04355 │; > └─────────────┴─────────┴─────────┴─────────┘; >; > Lagrangian particle tracking relative performance (CPU); > ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; > │ Architectures │ N_particles │ slowdown │ memory │ allocs │; > ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; > │ CPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; > │ CPU │ 1 │ 1.03447 │ 1.01267 │ 1.01599 │; > │ CPU │ 10 │ 1.04601 │ 1.01267 │ 1.01599 │; > │ CPU │ 100 │ 1.04712 │ 1.01267 │ 1.01599 │; > │ CPU │ 1000 │ 1.05514 │ 1.01267 │ 1.01599 │; > │ CPU │ 10000 │ 1.05397 │ 1.01267 │ 1.01599 │; > │ CPU │ 100000 │ 1.07213 │ 1.01267 │ 1.01599 │; > │ CPU │ 1000000 │ 1.34006 │ 1.01267 │ 1.01599 │; > │ CPU │ 10000000 │ 4.09045 │ 1.01267 │ 1.01599 │; > │ CPU │ 100000000 │ 31.6534 │ 1.01267 │ 1.01599 │; > └───────────────┴─────────────┴──────────┴─────────┴─────────┘; >; > Lagrangian particle tracking relative performance (GPU); > ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; > │ Architectures │ N_particles │ slowdown │ memory │ allocs │; > ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; > │ GPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; > │ GPU │ 1 │ 1.022,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982:4594,perform,performance,4594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732535982,1,['perform'],['performance']
Performance,7.22 KiB │ 11561 │; │ GPU │ 100000000 │ 4.910 ms │ 18.629 ms │ 17.245 ms │ 18.757 ms │ 896.56 KiB │ 11519 │; └───────────────┴─────────────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Lagrangian particle tracking CPU -> GPU; speedup; ┌─────────────┬─────────┬─────────┬─────────┐; │ N_particles │ speedup │ memory │ allocs │; ├─────────────┼─────────┼─────────┼─────────┤; │ 0 │ 82.2319 │ 3.01565 │ 6.08156 │; │ 1 │ 83.1848 │ 3.01946 │ 6.06663 │; │ 10 │ 83.6845 │ 3.01704 │ 6.0425 │; │ 100 │ 84.1322 │ 3.01704 │ 6.0425 │; │ 1000 │ 84.6106 │ 3.01946 │ 6.06663 │; │ 10000 │ 84.072 │ 3.01704 │ 6.0425 │; │ 100000 │ 86.1581 │ 3.01704 │ 6.0425 │; │ 1000000 │ 106.432 │ 3.01946 │ 6.06663 │; │ 10000000 │ 254.889 │ 3.01935 │ 6.06558 │; │ 100000000 │ 618.565 │ 3.01714 │ 6.04355 │; └─────────────┴─────────┴─────────┴─────────┘; ```. ```; Lagrangian particle tracking relative performance (CPU); ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; │ Architectures │ N_particles │ slowdown │ memory │ allocs │; ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; │ CPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; │ CPU │ 1 │ 1.03447 │ 1.01267 │ 1.01599 │; │ CPU │ 10 │ 1.04601 │ 1.01267 │ 1.01599 │; │ CPU │ 100 │ 1.04712 │ 1.01267 │ 1.01599 │; │ CPU │ 1000 │ 1.05514 │ 1.01267 │ 1.01599 │; │ CPU │ 10000 │ 1.05397 │ 1.01267 │ 1.01599 │; │ CPU │ 100000 │ 1.07213 │ 1.01267 │ 1.01599 │; │ CPU │ 1000000 │ 1.34006 │ 1.01267 │ 1.01599 │; │ CPU │ 10000000 │ 4.09045 │ 1.01267 │ 1.01599 │; │ CPU │ 100000000 │ 31.6534 │ 1.01267 │ 1.01599 │; └───────────────┴─────────────┴──────────┴─────────┴─────────┘; ```. ```; Lagrangian particle tracking relative performance (GPU); ┌───────────────┬─────────────┬──────────┬─────────┬─────────┐; │ Architectures │ N_particles │ slowdown │ memory │ allocs │; ├───────────────┼─────────────┼──────────┼─────────┼─────────┤; │ GPU │ 0 │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ 1 │ 1.02262 │ 1.01395 │ 1.0135 │; │ GPU │ 10 │ 1.02786 │ 1.01314 │ ,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975:4056,perform,performance,4056,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1091#issuecomment-732529975,1,['perform'],['performance']
Performance,"7.257 ms │ 15.907 ms │ 15.044 ms │ 15.927 ms │ 27.97 KiB │ 292 │; └───────────────┴─────┴───────────────────────────────┴────────────┴────────────┴────────────┴────────────┴───────────┴────────┘; ```. ### CPU to GPU speedup. ```; FFT-based Poisson solver CPU -> GPU speedup; ┌─────┬───────────────────────────────┬─────────┬────────┬────────┐; │ Ns │ Topologies │ speedup │ memory │ allocs │; ├─────┼───────────────────────────────┼─────────┼────────┼────────┤; │ 256 │ (Bounded, Bounded, Bounded) │ 35.4428 │ 450.0 │ 224.5 │; │ 256 │ (Bounded, Periodic, Bounded) │ 36.8697 │ 368.4 │ 320.5 │; │ 256 │ (Periodic, Bounded, Bounded) │ 37.0953 │ 369.6 │ 323.5 │; │ 256 │ (Periodic, Periodic, Bounded) │ 53.4034 │ 179.0 │ 146.0 │; └─────┴───────────────────────────────┴─────────┴────────┴────────┘; ```. ### CPU relative performance. ```; FFT-based Poisson solver relative performance (CPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬────────┬────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼────────┼────────┤; │ CPU │ 256 │ (Bounded, Bounded, Bounded) │ 1.61224 │ 1.2 │ 2.0 │; │ CPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.34917 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Bounded, Bounded) │ 1.35141 │ 1.0 │ 1.0 │; │ CPU │ 256 │ (Periodic, Periodic, Bounded) │ 1.0 │ 1.0 │ 1.0 │; └───────────────┴─────┴───────────────────────────────┴──────────┴────────┴────────┘; ```. ### GPU relative performance. ```; FFT-based Poisson solver relative performance (GPU); ┌───────────────┬─────┬───────────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Ns │ Topologies │ slowdown │ memory │ allocs │; ├───────────────┼─────┼───────────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ 256 │ (Bounded, Bounded, Bounded) │ 2.42923 │ 3.01676 │ 3.07534 │; │ GPU │ 256 │ (Bounded, Periodic, Bounded) │ 1.95419 │ 2.0581 │ 2.19521 │; │ GPU │ 256 │ (Periodic, Bounded, Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050:11779,perform,performance,11779,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1403#issuecomment-786398050,1,['perform'],['performance']
Performance,"8317561045]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:93 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters: Test Failed at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94; Expression: (parent(ensemble_model.velocities.v))[i, j, :] == (parent((models[i, j]).velocities.v))[1, 1, :]; Evaluated: [-0.6195339590035019, -0.6195339590035019, -0.6198905867106752, -0.6198905867106752] == [-0.6196089458774533, -0.6196089458774533, -0.6198120687060368, -0.6198120687060368]; Stacktrace:; [1] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:464 [inlined]; [2] macro expansion; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:94 [inlined]; [3] macro expansion; @ ~/julia-1.8/usr/share/julia/stdlib/v1.8/Test/src/Test.jl:1357 [inlined]; [4] top-level scope; @ ~/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:56; Test Summary: | Pass Fail Total Time; Ensembles of `HydrostaticFreeSurfaceModel` with different Coriolis parameters | 6 8 14 14.9s; ERROR: LoadError: Some tests did not pass: 6 passed, 8 failed, 0 errored, 0 broken.; in expression starting at /Users/navid/Research/OC.jl/test/test_ensemble_hydrostatic_free_surface_models.jl:54; ```. I figured that if I put a `@show ""hi""` _either before_ or _just after_ this line:. https://github.com/CliMA/Oceananigans.jl/blob/99ad4c151095835c21ca899561429be30e8181cb/src/Models/HydrostaticFreeSurfaceModels/hydrostatic_free_surface_ab2_step.jl#L63. then tests pass! Does this give us a clue for where the problem might be?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809:13219,Load,LoadError,13219,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809,1,['Load'],['LoadError']
Performance,"90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl`; I haven't gotten around to test performance for non-weno schemes but I should do it.... I ll guess I ll dedicate today to searching the issue, so we can merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185584632:139,perform,performance,139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185584632,1,['perform'],['performance']
Performance,"9d6e9a09]; ERROR: LoadError: LoadError: too many parameters for type; Stacktrace:; [1] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; [2] include(::Function, ::Module, ::String) at ./Base.jl:380; [3] include at ./Base.jl:368 [inlined]; [4] include(::String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:1159,Load,LoadError,1159,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['Load'],['LoadError']
Performance,": `ImmersedBoundaryGrid(grid, ib, active_cells_map = true)`; - added a `required_halo_size::Int ` keyword argument to `ScalarDiffusivity` (defaults to 1) and `ScalarBiharmonicDiffusivity` (defaults to 2) to be specified by the user which sets the required halo for the specific `ν` or `κ` function (closures have now an explicitly required number of halos); #### **Major** internals change; 1) The tendencies are calculated at the **end** of a time step. Therefore at the end of a simulation `model.timestepper` will hold tendencies for the last time step completed . 2) Removed `fill_halo_regions!` for hydrostatic pressure in both the non-hydrostatic and the hydrostatic model and for w-velocity in the hydrostatic model. The halos are filled by enlarging the size of the kernels in `update_hydrostatic_pressure!` and `compute_w_from_continuity!` to incorporate the needed ghost points. 2) Removed `fill_halo_regions!` for diffusivities **only for halo-passing BC**; the halo calculation is now performed by launching the `calculate_diffusivity!` kernel inside the ghost nodes before recomputing the tendencies. This requires knowing how many halos each closure requires. 3) Added a _required_halo_ parameter to `AbstractTurbulenceClosure`. This means that each parameterization will have to specify explicitly the number of halos required to calculate the diffusivity: ; e.g ; ```julia; abstract type AbstractTurbulenceClosure{TimeDiscretization, BoundaryBuffer} end; abstract type AbstractScalarDiffusivity{TD, F, N} <: AbstractTurbulenceClosure{TD, N} end; struct TwoDimensionalLeith{FT, CR, GM, M} <: AbstractScalarDiffusivity{ExplicitTimeDiscretization, ThreeDimensionalFormulation, 2}; ``` ; Where Leith closure requires 2 halos (one for the vorticity calculation and an additional one for the vorticity derivative). #### **Minor** internals change; removed the general `calculate_nonlinear_viscosity!` and `calculate_nonlinear_diffusivity!` kernels (to each turbulence closure their own kerne",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3125:3996,perform,performed,3996,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3125,1,['perform'],['performed']
Performance,"::String); │ @ Base ./loading.jl:1812; │ [25] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [26] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [27] _require_prelocked(uuidkey::Base.PkgId, env::String); │ @ Base ./loading.jl:1803; │ [28] macro expansion; │ @ ./loading.jl:1790 [inlined]; │ [29] macro expansion; │ @ ./lock.jl:267 [inlined]; │ [30] __require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1753; │ [31] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [32] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [33] require(into::Module, mod::Symbol); │ @ Base ./loading.jl:1746; │ [34] eval; │ @ ./boot.jl:385 [inlined]; │ [35] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:150; │ [36] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:246; │ [37] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:231; │ [38] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:389; │ [39] run_repl(repl::REPL.AbstractREPL, consumer::Any); │ @ REPL ~/julia-1.10/usr/share/julia/stdlib/v1.10/REPL/src/REPL.jl:375; │ [40] (::Base.var""#1013#1015""{Bool, Bool, Bool})(REPL::Module); │ @ Base ./client.jl:432; │ [41] #invokelatest#2; │ @ ./essentials.jl:892 [inlined]; │ [42] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [43] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); │ @ Base ./client.jl:416; │ [44] exec_options(opts::Base.JLOptions); │ @ Base ./client.jl:333; │ [45] _start(); │ @ Base ./client.jl:552; └ @ Base loading.jl:1301; ```. perhaps some compat entry is needed? I get this w GLMakie v0.10.5 in my main Julia env....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:5213,load,loading,5213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:360 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [15] top-level scope; @ none:1; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics/math.jl:5; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/device/intrinsics.jl:22; in expression starting at /home/tomas/.julia/packages/CUDA/3VnCC/src/CUDA.jl:1; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /home/tomas/.julia/compiled/v1.6/CUDA/jl_q4lPlx.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:914; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:901; [7] include; @ ./Base.jl:386 [inlined]; [8] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1213; [9] top-level scope; @ none:1; [10] eval; @ ./boot.jl:360 [inlined]; [11] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [12] top-level scope; @ none:1; in expression starting at /home/tomas/repos/Oceananigans.jl/src/Oceananigans.jl:1; ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /home/tomas/.julia/compiled/v1.6/Oceananigans/jl_psrPk0.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, in",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371:2177,load,loading,2177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1707#issuecomment-849206371,1,['load'],['loading']
Performance,":String) at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:1; [5] top-level scope at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/host/abstractarray.jl:24; in expression starting at /Users/truedichotomy/.julia/packages/GPUArrays/PkHCM/src/GPUArrays.jl:25; ERROR: LoadError: Failed to precompile GPUArrays [0c68f7d7-f131-5f86-a1c3-88cf8149b2d7] to /Users/truedichotomy/.julia/compiled/v1.5/GPUArrays/v5u0T_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [10] eval(::Expr) at ./client.jl:467; [11] top-level scope at ./none:3; in expression starting at /Users/truedichotomy/.julia/packages/CUDA/7vLVC/src/CUDA.jl:5; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to /Users/truedichotomy/.julia/compiled/v1.5/CUDA/oWw5k_IyCmP.ji.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] compilecache(::Base.PkgId, ::String) at ./loading.jl:1290; [3] _require(::Base.PkgId) at ./loading.jl:1030; [4] require(::Base.PkgId) at ./loading.jl:928; [5] require(::Module, ::Symbol) at ./loading.jl:923; [6] include(::Function, ::Module, ::String) at ./Base.jl:380; [7] include(::Module, ::String) at ./Base.jl:368; [8] top-level scope at none:2; [9] eval at ./boot.jl:331 [inlined]; [",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/854:1506,load,loading,1506,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/854,1,['load'],['loading']
Performance,"; > > ; > > ; > > But for one layer, WENO vector invariant plus WENO for mass flux may be sufficient, and we don't need any other dissipation (which is nice, less work for us).; > ; > I agree. If we try using whatever closure here that is used in the hydrostatic model, I would think that it should yield a similar result. But that's maybe better saved for a future PR?. Let me clarify. We've never run the hydrostatic model with a single layer on the sphere, but this is a good idea. Most of our runs have been with 50 vertical levels. In the 3D configuration with 50 vertical levels, we smooth results with 1) WENO5 vector invariant advection and 2) biharmonic ""divergence damping"" of the divergence component of the flow. If we are going to compare the shallow water on a sphere to they hydrostatic model, we will have to produce additional runs with just 1 vertical level. In other words, there are no results to compare with right now. When we perform additional runs, we may choose to include divergence damping, or another kind of closure, if we want to. The results presented in #2317 also use a single layer hydrostatic model, and these did not require any explicit dissipation. Therefore, there is reason to believe that divergence damping is only required for 3D simulations. An additional point is that in the shallow water equations we can introduce a WENO reconstruction of the mass flux. This reconstruction may provide divergence damping (whether or not we need it!). In summary, if we would like to perform a comparison, we can choose to either 1) produce a comparison between the shallow water model and one layer hydrostatic model with no explicit closure on the sphere or 2) run new 1 layer hydrostatic simulations with some closure (of our choosing) and then _also_ implement that closure in the shallow water model. My opinion is that with these nice WENO5 numerics there may not be a need for using explicit dissipation right now, so we might as well do the easy thing and avoid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226:1057,perform,perform,1057,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119959226,2,['perform'],['perform']
Performance,; GPU Link Info; PCIe Generation; Max : 3; Current : 3; Device Current : 3; Device Max : 3; Host Max : 3; Link Width; Max : 16x; Current : 16x; Bridge Chip; Type : N/A; Firmware : N/A; Replays Since Reset : 0; Replay Number Rollovers : 0; Tx Throughput : 0 KB/s; Rx Throughput : 0 KB/s; Atomic Caps Inbound : N/A; Atomic Caps Outbound : N/A; Fan Speed : N/A; Performance State : P0; Clocks Throttle Reasons; Idle : Active; Applications Clocks Setting : Not Active; SW Power Cap : Not Active; HW Slowdown : Not Active; HW Thermal Slowdown : Not Active; HW Power Brake Slowdown : Not Active; Sync Boost : Not Active; SW Thermal Slowdown : Not Active; Display Clock Setting : Not Active; FB Memory Usage; Total : 32768 MiB; Reserved : 267 MiB; Used : 0 MiB; Free : 32500 MiB; BAR1 Memory Usage; Total : 32768 MiB; Used : 2 MiB; Free : 32766 MiB; Compute Mode : Default; Utilization; Gpu : 0 %; Memory : 0 %; Encoder : 0 %; Decoder : 0 %; Encoder Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; FBC Stats; Active Sessions : 0; Average FPS : 0; Average Latency : 0; Ecc Mode; Current : Enabled; Pending : Enabled; ECC Errors; Volatile; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Aggregate; Single Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : N/A; Total : 0; Double Bit; Device Memory : 0; Register File : 0; L1 Cache : 0; L2 Cache : 0; Texture Memory : N/A; Texture Shared : N/A; CBU : 0; Total : 0; Retired Pages; Single Bit ECC : 0; Double Bit ECC : 0; Pending Page Blacklist : No; Remapped Rows : N/A; Temperature; GPU Current Temp : 41 C; GPU Shutdown Temp : 90 C; GPU Slowdown Temp : 87 C; GPU Max Operating Temp : 83 C; GPU Target Temperature : N/A; Memory Curre,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895:21199,Latency,Latency,21199,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2922#issuecomment-1437515895,1,['Latency'],['Latency']
Performance,"; [20] #invoke_in_world#3; @ ./essentials.jl:926 [inlined]; [21] invoke_in_world; @ ./essentials.jl:923 [inlined]; [22] require(into::Module, mod::Symbol); @ Base ./loading.jl:1746; [23] include; @ ./Base.jl:495 [inlined]; [24] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt128}}, source::String); @ Base ./loading.jl:2222; [25] top-level scope; @ stdin:3; in expression starting at /glade/u/home/knudsenl/.julia/packages/CUDA/Tl08O/src/CUDA.jl:1; in expression starting at stdin:3; ERROR: LoadError: Failed to precompile CUDA [052768ef-5323-5732-b1bb-66c8b64840ba] to ""/glade/u/home/knudsenl/.julia/compiled/v1.10/CUDA/jl_zRopeZ"".; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); @ Base ./loading.jl:2468; [3] compilecache; @ ./loading.jl:2340 [inlined]; [4] (::Base.var""#968#969""{Base.PkgId})(); @ Base ./loading.jl:1974; [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; [6] #mkpidlock#6; @ /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); @ FileWatching.Pidfile /glade/u/apps/casper/23.10/spack/opt/spack/julia/1.10.2/gcc/7.5.0/apod/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; [8] #invokelatest#2; @ ./essentials.jl:894 [inlined]; [9] invokelatest; @ ./essentials.jl:889 [inlined]; [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); @ Base ./loading.jl:2983; [1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812:3299,load,loading,3299,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2231635812,1,['load'],['loading']
Performance,; cpu__advect_particles! at /home/alir/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; cpu__advect_particles! at ./none:0; __thread_run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; unknown function (ip: 0x7c0090512182); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; __run at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; unknown function (ip: 0x7c009050feb3); _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; #_#16 at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; jl_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/julia.h:1982 [inlined]; do_apply at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/builtins.c:768; Kernel at /home/alir/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; _jl_invoke at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:2895 [inlined]; ijl_apply_generic at /cache/build/builder-amdci4-4/julialang/julia-release-1-dot-10/src/gf.c:3077; advect_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/lagrangian_particle_advection.jl:193; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/LagrangianParticleTracking/LagrangianParticleTracking.jl:143 [inlined]; step_lagrangian_particles! at /home/alir/atdepth/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/HydrostaticFreeSurfaceModels.jl:107 [inlined]; #time_step!#8 at /h,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3852:2778,cache,cache,2778,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3852,1,['cache'],['cache']
Performance,"; | ErrorException(""could not load library ""libopenblas64_""; &nbsp; | libopenblas64_.so: ELF load command past end of file""); &nbsp; | ┌ Error: Error during initialization of module CHOLMOD; &nbsp; | │ exception =; &nbsp; | │ could not load library ""libcholmod""; &nbsp; | │ libopenblas64_.so.0: ELF load command past end of file; &nbsp; | │ Stacktrace:; &nbsp; | │ [1] dlopen(::String, ::UInt32; throw_error::Bool) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109; &nbsp; | │ [2] dlopen at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Libdl/src/Libdl.jl:109 [inlined] (repeats 2 times); &nbsp; | │ [3] __init__() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:90; &nbsp; | └ @ SuiteSparse.CHOLMOD /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/SuiteSparse/src/cholmod.jl:187; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/bin/julia: error while loading shared libraries: libLLVM-9jl.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: LoadError: IOError: write: broken pipe (EPIPE); &nbsp; | Stacktrace:; &nbsp; | [1] uv_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:951; &nbsp; | [2] unsafe_write(::Base.PipeEndpoint, ::Ptr{UInt8}, ::UInt64) at ./stream.jl:1005; &nbsp; | [3] write(::Base.PipeEndpoint, ::String) at ./strings/io.jl:183; &nbsp; | [4] create_expr_cache(::String, ::String, ::Array{Pair{Base.PkgId,UInt64},1}, ::Base.UUID) at ./loading.jl:1194; &nbsp; | [5] compilecache(::Base.PkgId, ::String) at ./loading.jl:1286; &nbsp; | [6] _require(::Base.PkgId) at ./loading.jl:1030; &nbsp; | [7] require(::Base.PkgId) at ./loading.jl:928; &nbsp; | [8] require(::Module, ::Symbol) at ./loading.jl:923; &nbsp; | [9] include(::Function, ::Module, ::String) at ./Base.jl:380; &nbsp; | [10] include at ./Base.jl:368 [inlined]; &nbsp; | [11] include(::String) at /storage7/buildkite-agent/.julia-2581/packages/PencilA",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731:3480,load,loading,3480,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843325731,1,['load'],['loading']
Performance,"; │ @ ./loading.jl:2340 [inlined]; │ [4] (::Base.var""#968#969""{Base.PkgId})(); │ @ Base ./loading.jl:1974; │ [5] mkpidlock(f::Base.var""#968#969""{Base.PkgId}, at::String, pid::Int32; kwopts::@Kwargs{stale_age::Int64, wait::Bool}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:93; │ [6] #mkpidlock#6; │ @ ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:88 [inlined]; │ [7] trymkpidlock(::Function, ::Vararg{Any}; kwargs::@Kwargs{stale_age::Int64}); │ @ FileWatching.Pidfile ~/julia-1.10/usr/share/julia/stdlib/v1.10/FileWatching/src/pidfile.jl:111; │ [8] #invokelatest#2; │ @ ./essentials.jl:894 [inlined]; │ [9] invokelatest; │ @ ./essentials.jl:889 [inlined]; │ [10] maybe_cachefile_lock(f::Base.var""#968#969""{Base.PkgId}, pkg::Base.PkgId, srcpath::String; stale_age::Int64); │ @ Base ./loading.jl:2983; │ [11] maybe_cachefile_lock; │ @ ./loading.jl:2980 [inlined]; │ [12] _require(pkg::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1970; │ [13] __require_prelocked(uuidkey::Base.PkgId, env::Nothing); │ @ Base ./loading.jl:1812; │ [14] #invoke_in_world#3; │ @ ./essentials.jl:926 [inlined]; │ [15] invoke_in_world; │ @ ./essentials.jl:923 [inlined]; │ [16] _require_prelocked; │ @ ./loading.jl:1803 [inlined]; │ [17] _require_prelocked; │ @ ./loading.jl:1802 [inlined]; │ [18] run_extension_callbacks(extid::Base.ExtensionId); │ @ Base ./loading.jl:1295; │ [19] run_extension_callbacks(pkgid::Base.PkgId); │ @ Base ./loading.jl:1330; │ [20] run_package_callbacks(modkey::Base.PkgId); │ @ Base ./loading.jl:1164; │ [21] _tryrequire_from_serialized(modkey::Base.PkgId, path::String, ocachepath::String, sourcepath::String, depmods::Vector{Any}); │ @ Base ./loading.jl:1487; │ [22] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt128); │ @ Base ./loading.jl:1574; │ [23] _require(pkg::Base.PkgId, env::String); │ @ Base ./loading.jl:1938; │ [24] __require_prelocked(uuidkey::Base.PkgId, env::S",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528:2324,load,loading,2324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3686#issuecomment-2272432528,1,['load'],['loading']
Performance,"= (:b, :τ1, :τ2),; closure = SmagorinskyLilly(C=0.1),; background_fields = (b=B_field,),; forcing = (u=Fᵤ, v=Fᵥ, w=Fw, b=Fb),; ); @info model. simulation = Simulation(model, Δt=1, stop_iteration=10). run!(simulation); ```. This (and way more complex examples) runs fine on the CPU but when I run that on the GPU I get:. ```; [ Info: Executing initial time step...; ERROR: LoadError: CUDA error: device kernel image is invalid (code 200, ERROR_INVALID_IMAGE). Stacktrace:; [1] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:58; [2] CuModule; @ /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/lib/cudadrv/module.jl:23 [inlined]; [3] cufunction_link(job::GPUCompiler.CompilerJob, compiled::NamedTuple{(:image, :entry, :external_gvars), Tuple{Vector{UInt8}, String, Vector{String}}}); @ CUDA /glade/work/tomasc/.julia/packages/CUDA/Ey3w2/src/compiler/execution.jl:481; [4] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /glade/work/tomasc/.julia/packages/GPUCompiler/qdoh1/src/cache.jl:95; [5] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.var""##PassType#312"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.NonhydrostaticModels.gpu_calculate_Gu!), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(8, 8, 6)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 6)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuDeviceArray{Float64, 3, 1}}, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CUDA.CuDeviceVector{Float",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869:2165,cache,cache,2165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869,1,['cache'],['cache']
Performance,"= RegularRectilinearGrid(size = (512, 512, 1), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); xz_grid = RegularRectilinearGrid(size = (512, 1, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)); yz_grid = RegularRectilinearGrid(size = (1, 512, 512), extent = (2π, 2π, 2π), topology = (Periodic, Periodic, Bounded)). function ten_steps!(model); for i = 1:10; time_step!(model, 1e-6); end; return nothing; end. for arch in (CPU(), GPU()); for grid in (; xy_grid,; xz_grid,; yz_grid,; ). model = NonhydrostaticModel(architecture = arch,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; grid = grid,; buoyancy = nothing,; tracers = nothing). @info ""Benchmarking $model...""; @btime ten_steps!($model); end; end; ```. The results are alarming: on the CPU we find. * `xy_grid`: 616.285 ms (429912 allocations: 114.29 MiB); * `xz_grid`: 4.638 s (944291 allocations: 2.63 GiB); * `yz_grid`: 3.240 s (405223 allocations: 2.60 GiB). Notice the `xz` configuration is 7 times slower than the `xy` configuration. In addition to that, allocations are through the roof --- 200 MiB of allocation per time-step?? (the benchmark tests 10 time-steps). On the GPU we find. * `xy_grid`: 48.438 ms (128139 allocations: 45.68 MiB); * `xz_grid`: 531.077 ms (637499 allocations: 53.51 MiB); * `yz_grid`: 147.963 ms (166797 allocations: 46.33 MiB). and therefore an even larger (10x) performance difference, though allocations are more under control. I ran the benchmarks for a few different topologies to see if the pressure solver was the culprit. But I noticed similar behavior whether or not `y` or `z` was `Periodic` or `Bounded`. I also tested whether the vertical integral for hydrostatic pressure was a problem by updating and then running code from #1910 . This didn't fix the problem either. I'm perplexed, so I think we should drill into this a bit more. Or --- am I misinterpreting or setting up the benchmarks incorrectly?. @ali-ramadhan @christophernhill",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919:2170,perform,performance,2170,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919,1,['perform'],['performance']
Performance,"> ""Done"" isn't very precise since the cubed sphere will never be ""done"". But perhaps we can put a number on performance for the first milestone, which will allow us to conclude whether we need this optimization or not. True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. . > Can you explain where the gut feeling comes from? Will filling halos be so expensive even on just one GPU, or is this a distributed problem? Currently, 1/4 degree is performant on one GPU. Well at least some gut feeling comes from that am pretty sure that it can be reduced in half by getting done in a single pass. But you are on point, I don’t have a gut feeling regarding how much impact the two passes have on performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478:108,perform,performance,108,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1718757478,5,"['optimiz', 'perform']","['optimization', 'performance', 'performant']"
Performance,"> * I removed the `BackgroundField` v-velocity, which had no effect on the solution because the domain is `Flat` in y. The only effect of the background flow is through the bottom drag boundary condition. The docs preview hasn't updated yet, so I can't see the video, but I suspect removing `v` as a background creates oscillations. @glwagner have you checked? If not, let's wait for the video to see what happens... > * I reduced the domain aspect ratio to 400 x 100 because based on the visualization it seemed the domain didn't need to be so wide. This lets us increase the resolution and reduce the diffusivity, which is neat. It's a bit more turbulent now. Good move :+1: . > * Note using a tuple for `ĝ` rather than `Array` means it can be used as a parameter on the GPU, so that's probably preferred. Arrays are needed only if we need to mutate elements or perform linear algebra.; > * Don't import CUDA because the example wasn't GPU friendly anyways (if you like, we can make it GPU friendly but I don't think it should be ""partially"" GPU friendly since it just makes the code more complicated). I tried to make it 100% GPU friendly actually (although I didn't test it). You already pointed out one flaw, which is the use of an array instead of a tuple for the unit vertical vector. > * When I try to run the example multiple times I get `ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13)`. How can we avoid this error? I think it's important that users can easily change parameters and re-run without having to manually delete a file; this is key to productivity. This only happens with me when the NetCDF file is open by another program (generally python in my case) while Julia is trying to write to it. Was that the case? If so, that's the usual behavior afaik and I don't think we can do anything on our end except inform users about it. > * This is a great inexpensive example. I do wonder if we should make it 3D with an LES closure?. If we can get away with t",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138:865,perform,perform,865,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2333#issuecomment-1065266138,1,['perform'],['perform']
Performance,"> 90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl` I haven't gotten around to test performance for non-weno schemes but I should do it....; > ; > I ll guess I ll dedicate today to searching the issue, so we can merge. `@inbounds` in . https://github.com/CliMA/Oceananigans.jl/blob/91dfb119917f33514dbf8cd833778c44f6cea9b3/src/Advection/weno_interpolants.jl#L45-L46",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185611545:140,perform,performance,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185611545,1,['perform'],['performance']
Performance,"> === means that ""no program can distinguish"" between the objects. For arrays this basically means they point to the same space in memory; changes to one imply changes in another. == is a weaker statement, usually about numerical equality. What's counter intuitive?. Oh yeah I know about `===`. What I mean is that you test two grids with `==`, but Julia then tests each property with `===`. So the user is actually performing a much stricter operation than what it seems at first sight. That's the un-intuitive part to me. Although I may be missing something.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255:416,perform,performing,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2018#issuecomment-945862255,2,['perform'],['performing']
Performance,"> > 90% sure, but if it's not there it's in `centered_reconstruction.jl` or `upwind_biased_reconstruction.jl` I haven't gotten around to test performance for non-weno schemes but I should do it....; > > I ll guess I ll dedicate today to searching the issue, so we can merge; > ; > `@inbounds` in; > ; > https://github.com/CliMA/Oceananigans.jl/blob/91dfb119917f33514dbf8cd833778c44f6cea9b3/src/Advection/weno_interpolants.jl#L45-L46. I'm not sure that this is the deal breaker... I should have phrased is as a ""perhaps add @inbounds in.... ???""",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185612738:142,perform,performance,142,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1185612738,1,['perform'],['performance']
Performance,"> > > > @glwagner any idea why `gpu-simulations-tests` fail?; > > > ; > > > ; > > > Which grid points are specifically failing in the test?; > > ; > > ; > > How does one go about and answers this question? The log is not informative... Shall I run the tests myself online and then printout the two arrays?; > ; > Yeah, that's what you have to do to determine it... not urgent though... I tried to do that but the HPC at ANU when I use a queue with GPU access it does not have internet access. So it stops at `include(""data_dependencies.jl"")` line...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330:437,queue,queue,437,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1988#issuecomment-928225330,1,['queue'],['queue']
Performance,"> > > The preview isn't showing for me. But we can fix any issues later, so I say merge away.; > > ; > > ; > > Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter.; > > But if you're okay with it, I'll merge it and we can fix any problems later.; > ; > It looks like it works for PRs that I submit, but not others. It may have to do with repo privileges. I think, for some reason whatsoever, the preview is not pushed just from the first commit. I think it's because there is a test whether that was a commit on a PR. And unless you first open the PR and then made the first commit that test returns false...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963656757:131,load,loading,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963656757,1,['load'],['loading']
Performance,> > @TZTsai thanks for this! I'm wondering whether this worths your time and effort since after we [removed](https://github.com/CliMA/Oceananigans.jl/pull/3052) the multigrid pressure solver from the code perhaps this is not so much needed.; > ; > Alright. But is `compute_matrix_for_linear_operation` still used in this project? If so it may still provide some optimization. @navidcy can you answer @TZTsai's question?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1708642106:362,optimiz,optimization,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1708642106,1,['optimiz'],['optimization']
Performance,> > @TZTsai thanks for this! I'm wondering whether this worths your time and effort since after we [removed](https://github.com/CliMA/Oceananigans.jl/pull/3052) the multigrid pressure solver from the code perhaps this is not so much needed.; > ; > Alright. But is `compute_matrix_for_linear_operation` still used in this project? If so it may still provide some optimization. Sorry I missed the question!. I think in principle it could be used for the construction of the Heptadiagonal solver matrix (cc @simone-silvestri) but even for that the matrix is actually hardcoded for the particular free-surface problem. Right @simone-silvestri?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1711066770:362,optimiz,optimization,362,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1711066770,1,['optimiz'],['optimization']
Performance,"> > @siddharthabishnu, `CUDA.@allowscalar` introduced by [3cdd470](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/3cdd4705fedf3238d8858bb0f56e9b27b01ba34a) is detrimental for performance. Like it induces O(10-100x) slowdown I think....; > > Is this a temporary solution?; > > cc @glwagner, @simone-silvestri; > ; > I think it is. We can try to see if this works on one GPU. If it does we can keep the allowscalar for the moment otherwise we can remove them. In the end all this will have to live in a kernel. Note that this will still not work on multiple GPUs as you cannot explicitly access one region from another one on a different GPU without switching to the device that holds the data. @simone-silvestri and @navidcy, I totally agree. I only introduced CUDA.@allowscalar under the impression it was necessary for certain GPU tests to pass. However, now understanding that isn’t the case, I've removed it in commit [7f54c3c](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/7f54c3c451c9753524056d45c6578a9cf865be68).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2035930379:187,perform,performance,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2035930379,1,['perform'],['performance']
Performance,"> > @siddharthabishnu, how do we know that now the metrics are filled correctly? you were comparing with a grid from MITgcm?; > ; > Yes. Consider the following sources for the grid metrics:; > ; > 1. the `cs32` grid with one halo layer, used by:; > ; > * Ali for the Rossby-Haurwitz test case in Oceananigans v0.82.0; and; > * yourself to check the interior coordinates and grid metrics of the Oceananigans `cc32` grid;; > 2. the `cs32` grid with 4 halo layers created by @jm-c using MITgcm;; > 3. the `cc32` grid created by Oceananigans.; > ; > In the validation scripts for solid body rotation and the Rossby-Haurwitz wave within the `ncc-glw/cubed-sphere-dynamics` branch associated with PR #3306, I compared the metrics of grid (3) against both (1) and (2), and plotted their absolute and relative differences. With the latest modifications, these differences have been minimized though not entirely eliminated. OK, so the benchmark is the `cs32` grid by MITgcm. Can we do the comparison in this PR? I'd like to see a test ideally because otherwise how do we assess that the changes we are suggesting here are correct. I can also do that, just give me a code snippet that loads the two grids?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025:1176,load,loads,1176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-1978039025,1,['load'],['loads']
Performance,"> > @simone-silvestri will the changes here impact CATKE on [CliMA/ClimaOcean.jl#17](https://github.com/CliMA/ClimaOcean.jl/pull/17) ?; > ; > not on the GPU, this PR affects only CPU performance. sorry, I was not clear... I was asking whether any syntax for adding parametrization with additional tracers changed. (But I think, no, right?)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1487536293:183,perform,performance,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1487536293,2,['perform'],['performance']
Performance,"> > As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).; > ; > I agree, but this patch-up will not work for immersed boundaries anyway. What do you mean? What patch-up?. > I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. I agree I think that would be nice. It means that operators need to know about boundary conditions though, which is a major refactor... > As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries. We support values and gradients on non-immersed boundaries, but we do _not_ support evaluating them across immersed boundaries. We have to support what we claim / say that we support, that is the only issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786:434,perform,performance,434,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690226786,1,['perform'],['performance']
Performance,"> > Average reduction with conditional expressions, e.g., like; > > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > > ; > > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > > ```julia; > > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Only mentioning this here in case it might something in the source code that could be affecting code performance.; > ; > The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans.; > ; > We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; > ; > ```; > condition = T > 3 # This should be a boolean AbstractOperation; > @compute Txyz = Field(Average(T; condition)) ; > ```; > ; > at the moment the best way to specify a condition is through a function; > ; > ```; > @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; > @compute Txyz = Field(Average(T; condition)) ; > ```. Agree with this. What is `T .> 3`? Is that a field? Either way, what we really want is to pass `T > 3` as @simone-silvestri says.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1239601022:559,perform,performance,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1239601022,1,['perform'],['performance']
Performance,"> > Average reduction with conditional expressions, e.g., like; > > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > > ; > > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > > ```julia; > > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > Only mentioning this here in case it might something in the source code that could be affecting code performance.; > ; > The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans.; > ; > We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; > ; > ```; > condition = T > 3 # This should be a boolean AbstractOperation; > @compute Txyz = Field(Average(T; condition)) ; > ```; > ; > at the moment the best way to specify a condition is through a function; > ; > ```; > @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; > @compute Txyz = Field(Average(T; condition)) ; > ```. I get an error... ```Julia; navidcy@tartarus:~/Oceananigans.jl$ julia-1.8 --project; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.8.1 (2022-09-06); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> using Oceananigans; [ Info: Oceananigans will use 4 threads. julia> using Oceananigans.Fields: CenterField, @compute. julia> trilinear(x, y, z) = x + y + z; trilinear (generic function with 1 method). julia> arch = GPU(); GPU(). julia> grid = RectilinearGrid(arch, size = (2, 2, 2),; x = (0, 2), y = (0, 2), z = (0, 2),; topology = (Periodic, Periodic, Bounded)); 2×2×2 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on GPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 2.0) regularly spaced with Δx=1",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568:559,perform,performance,559,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1242894568,1,['perform'],['performance']
Performance,"> > Can't we just plot a fixed-color shape on top on the mount on all panels? [`Makie.poly`](https://docs.makie.org/stable/reference/plots/poly/) seems to be able to do that.; > ; > We can.; > ; > We can also mask the output after we load it, e.g, via; > ; > using something like; > ; > ```julia; > using Oceananigans.ImmersedBoundaries: mask_immersed_field!; > ; > function mask_and_get_interior(φ_t, n; value=NaN); > mask_immersed_field!(φ_t[n], value); > return interior(φ_t[n], :, 1, :); > end; > ; > u′ₙ = @lift mask_and_get_interior(u′_t, $n); > ```; > ; > which gives; > ; > internal_tide.mp4 ; > But either of these solutions complicate the example a bit. Ideally, `mask_immersed_field!` should not be user-facing. And plotting a mountain on top of the mountain is a bit of a hack and would require a bit of explaining and justifying why we do that. I think we should mask the solution during visualization in the script. This is actually what users will need to do currently to make decent visualizations, so it is good to illustrate how to do it --- even if, hopefully, we will eventually have a better solution. As for plotting a shape on top, I'm inclined to encourage visualization that directly represents the domain / data for the purposes of an Oceananigans example. I think its ok if people want to incorporate visualizations like that in their own work but we may not want to promote it as ""the best"" way to visualize complex domains in this example.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358:234,load,load,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1986381358,1,['load'],['load']
Performance,"> > I think something like you're proposing would have added to my confusion.; > ; > Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory). The confusion is that I wasn't aware that that a `Field` has `data`, and therefore takes up memory, which allows it to store values. While an `AbstractOperation` is just instructions on how to compute things. This extended to the output writers, but I wouldn't say output writers were the source of confusion. If we make it so that users don't have to know what a `Field` is and we can use abstract operations everywhere, then my comment is moot.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591:388,perform,performed,388,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036795591,1,['perform'],['performed']
Performance,"> > I think to preserve the work in this PR, we should add a `Float32` test which will fail if a spurious promotion undermines performance; > ; > Agreed. I'll revisit this PR later to see if I can find where the conversion happens. The test I added only checks to see if we can take a time step. But I should be able to also add a test to ensure no spurious promotion occurred. Ah, that will work as a test if we remove the `convert`. The `convert` is a good sanity check to find where the problem is, but its not a solution since it merely allows the code to run without error --- it doesn't actually allow us to realize the benefits of using `Float32`. Arguably with this it is actually worse to use `Float32`, since the numerics are degraded bbut the perfrmance benefit is not fully realized",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445330720:127,perform,performance,127,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445330720,1,['perform'],['performance']
Performance,"> > I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors.; > ; > That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed. 🤦 there's already Using GPUs of course, silly me...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200:118,perform,performance,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818368200,2,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"> > If our objective purely regards broadcasting, then we could probably generalize broadcasting so that `Fields` with singleton indices and/or `Nothing` location act more like reduced-dimensionality arrays. Is that what you would like to see?; > ; > Yes, it would be nice to have that feature. Do you want to have a crack at it? I don't use broadcasting with fields so much personally. It's a bit slow for some reason, which we have never quite figured out. Convenient for some things but not to be relied on unless we can solve the performance issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038969357:534,perform,performance,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3361#issuecomment-2038969357,1,['perform'],['performance']
Performance,"> > The preview isn't showing for me. But we can fix any issues later, so I say merge away.; > ; > Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter.; > ; > But if you're okay with it, I'll merge it and we can fix any problems later. It looks like it works for PRs that I submit, but not others. It may have to do with repo privileges.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963592320:119,load,loading,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963592320,1,['load'],['loading']
Performance,"> > To use python, we'd have to invoke `PyCall` right? Running python directly in the CI is possible but a bit of work and might be a pain to maintain.; > > I think its ""good"" to illustrate python usage, but also building and maintaining that example requires work that might be put to better use elsewhere... I'd shy away from doing this until there's either a more compelling need, or we have more resources for code development / maintenance...; > ; > Yes I think we'd need to use `Pycall`. I agree that's hard to maintain so let's not pursue that now.; > ; > I still think it'd be good to show one example with `NetCDF` writer though. Here's a question: is post-processing results directly in julia (making animations, plots, etc.) using the `NetCDF` output as easy as with the `jld2` output?. There's currently one example with NetCDF: https://clima.github.io/OceananigansDocumentation/stable/generated/shallow_water_Bickley_jet/. I'm not totally sure what's meant by easy. If plotting arrays, then the tasks are identical. If using `FieldTimeSeries` (to perform non-trivial finite volume calculations in post-processing for example) then that isn't supported with `NetCDFOutputWriter` (this is possible, but requires someone passionate about NetCDF to put in the effort there).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-954122449:1060,perform,perform,1060,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1498#issuecomment-954122449,1,['perform'],['perform']
Performance,"> > Very nice work @glwagner , and thanks for making this. Lots of good stuff here.; > > In your calculations, you find that there is saturation at 16 threads. I might guess that you have 16 cores on one node? I would think that this should be node dependent.; > > Also, in the table, might it be possible to compute the efficiency as well? I think that's more standard than speed up.; > ; > Ah, this machine has 48 cores. Since threading has an overhead cost, we expect saturation at some point. It's surprising that this happens at just 16 cores for such a large problem (512^3) though.; > ; > We can calculate more metrics for sure.; > ; > I think it would be worthwhile to investigate whether other threading paradigms scale differently for the same problem. Numba + parallel accelerator might be a good test case. @hennyg888 would you be interested in that?; > ; > Here are some docs:; > ; > https://numba.pydata.org/numba-doc/latest/user/parallel.html. You run out of memory bandwidth at some point - usually before you get to saturate all the cores for something; like diffusion. So some of 16 thread drop off could be that. . I guess we could get even more minimalist and check a multi-threaded stream benchmark to see that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304:1188,multi-thread,multi-threaded,1188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886090304,1,['multi-thread'],['multi-threaded']
Performance,"> > When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > > ```julia; > > ERROR: LoadError: UndefVarError: `settings` not defined; > > ```; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > ; > > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > > ```julia; > > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > > ```; > ; > Do you need help fixing these?. @glwagner thanks for your help on Zoom yesterday. @navidcy thanks for creating a new PR #3305 to fix the second issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712:220,Load,LoadError,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1747159712,2,['Load'],['LoadError']
Performance,"> > Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?; > ; > I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; > ; > ```julia; > transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; > solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.forward.x!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ; > # Perform the implicit vertical solve here on storage.zfield...; > ; > transpose_z_to_y!(storage); > solver.plan.backward.y!(parent(storage.yfield), buffer.y); > transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; > solver.plan.backward.y!(parent(storage.xfield), buffer.x); > transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; > transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; > ```; > ; > This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538. Can you just say, you are planning to implement the algorithm in #2538? The way you describe it, I can't figure out if you are coming up with something new or not.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925:837,Perform,Perform,837,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197393925,1,['Perform'],['Perform']
Performance,"> > Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck.; > ; > It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?. I did try with a different advection scheme (and `halo_size=(1, 1, 1)`) and the allocations were mitigated. This and @tomchor's result suggests that halo filling for periodic directions is a likely culprit. Profiling is a good idea. I also had the thought of commenting out much of the time-stepping loop and building up to try to pinpoint which functions trigger allocations as @christophernhill suggests.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891521065:281,bottleneck,bottleneck,281,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891521065,2,['bottleneck'],['bottleneck']
Performance,"> > the time integral when we use variable time stepping that is a feature we use quite often; > ; > What do you mean by this?. Actually, I should probably say that I use the wizard quite often to change the time step. In my opinion, AB2 is a good compromise between accuracy, stability, and performance. RK3 is better only when you can achieve a CFL 3 times larger. We should fix the variable AB2 time stepper or discourage the use of frequent updates of the time step when using AB2. The first option is probably better in my opinion. I ll look into fixing AB2 and what it entails",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313376167:292,perform,performance,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3738#issuecomment-2313376167,1,['perform'],['performance']
Performance,> @TZTsai thanks for this! I'm wondering whether this worths your time and effort since after we [removed](https://github.com/CliMA/Oceananigans.jl/pull/3052) the multigrid pressure solver from the code perhaps this is not so much needed. Alright. But is `compute_matrix_for_linear_operation` still used in this project? If so it may still provide some optimization.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1703878093:353,optimiz,optimization,353,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3229#issuecomment-1703878093,1,['optimiz'],['optimization']
Performance,> @ali-ramadhan why not broadcast over CuArrays? Is there a Performance hit?; > ; > _Originally posted by @glwagner in https://github.com/climate-machine/Oceananigans.jl/issues/104#issuecomment-469749450_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/108:60,Perform,Performance,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/108,1,['Perform'],['Performance']
Performance,"> @glwagner : I agree that the major savings would be the lack of vertical grid points, but having a full free-surface will likely force a smaller time step because of CFL. There would be two ways to reduce this constraint (in the future).; > ; > 1. Rigid lid (solve for the surface pressure); > 2. Implicit free-surface (treat the free-surface implicitly in the time-stepping); > ; > Both of these would borrow from the hydrostatic model, but the ingrediants are there, and would make it a lot faster. I would vote for implementing a rigid lid / vertically-`Flat` mode for the hydrostatic model instead, in order to keep the shallow water model as simple as possible (generalizing to multiple layers as an alternative direction would be nice I think). Have you benchmarked this? It is true that vertically `Flat` avoids a few vertical operations in the vertical advection term but since the kernel sizes are the same I'd be surprised if the performance differences are huge in terms of cost per time step.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736:942,perform,performance,942,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1119195736,2,['perform'],['performance']
Performance,"> @glwagner CUDA aware MPI is supported for 11.2 but it is only built against OpenMPI 4.1.0 and 4.1.1, I think we had previously 4.0.4. Also julia 1.6.2 is available. good beta, I'll upgrade, thanks!. > looks like maybe some more race conditions on different hardware?. Heh yeah, pretty interesting. sverdrup is running on Quadro P6000 with CUDA 11; tartarus (where we sometimes run tests for development) has a Titan V, also I think with CUDA 11. These are running on a P100? With this new CI I'll need to make sure I can log in to central to debug.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484:230,race condition,race conditions,230,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906751484,1,['race condition'],['race conditions']
Performance,"> @glwagner I also ran into some problems using `StatProfilerHTML.jl` to make flame graphs for CPU profiles. This is from the same script used to obtain the results above and shown in #1914 and it's a 128^3 nonhydrostatic model. The flame graphs don't display the function names, and all I can see is ""overdub"". By hovering my mouse over the slabs and going up each flame stack I can usually find a function name that makes sense somewhere but that prevents us from making at-a-glance analysis of the profile flame graph.; > ![image](https://user-images.githubusercontent.com/45054739/128443657-7b18d4f9-0168-4bee-b85b-2ade021165d3.png); > I thought that this might have something to do with profiling `run(simulation, 10)` instead of a for loop of `time_step!(model,1)` but apparently the result is the same for both cases. I believe this is inevitable, because all our kernels are compiled through `Cassette.jl`, which ""overdubs"" the julia compiler when compiling functions tagged with `@kernel` (the majority of our expensive kernels). This is part of the design of `KernelAbstractions.jl`... Really great work @hennyg888. Perhaps the complexity of our function calls via `KernelAbstractions.jl` argues for a better profiling approach? Is there a way to ""filter"" the profiled output to remove data? . I think the next step towards improving performance is to figure out how to optimize the tendency calculations for CPU or GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894239292:1344,perform,performance,1344,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-894239292,2,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,"> @glwagner I'm not sure whats causing these tests to fail now?. @jagoosw afaik sometimes we get errors of the kind. `ERROR: LoadError: SystemError: opening file ""/data5/glwagner/.julia-10703/compiled/v1.8/Oceananigans/hU93i_Y0P9A.ji"": No such file or directory`. on the gpu tests. Which is what's hapenning now. It's now clear to me at least what the cause is, but restarting the tests generally makes them pass. I just restarted them so it be fine. I should note that we got an error of the kind. `Expression: all(test_fields.v .≈ truth_fields.v)`. in the GPU shallow water tests, which I thought were corrected. Is this something we need to worry about?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1481364658:125,Load,LoadError,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2912#issuecomment-1481364658,1,['Load'],['LoadError']
Performance,"> @glwagner, regarding the; > ; > ```julia; > ERROR: LoadError: UndefVarError: bc not defined; > ```; > ; > in the Docs, is it related to; > [JuliaDocs/Documenter.jl#228](https://github.com/JuliaDocs/Documenter.jl/issues/228); > perhaps?. Nice find!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879849296:53,Load,LoadError,53,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879849296,1,['Load'],['LoadError']
Performance,"> @matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. For the moment those two elements are part of this PR.; > ; > This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft, the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult. Nice, thanks for that explanation. Why are we following 2decomp? PencilArrays has some benchmarking that shows it can compete with the fastest codes out there. I don't see anything similar for 2decomp, so I can't figure out what the motivation for following that strategy would be. I'm not sure if they are different, either. Something we do not previously support (but which is implemented in https://github.com/CliMA/Oceananigans.jl/pull/2538) was an algorithm that could support any topology with vertically-stretched grids. What is the relationship between this PR and https://github.com/CliMA/Oceananigans.jl/pull/2538, and does this PR support vertically stretched grids?. One of the main limitations of PencilArrays from our perspective is that it could not distribute an array along the first dimension. Since we almost always would like to use vertically stretched grids (and for various reasons, we may want to also compute the hydrostatic pressure with a vertical integral), ocean LES are typically distributed in x and y. Therefore, in order to support 2D domain decompositions, we were faced with somehow ch",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859:49,perform,performant,49,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1728278859,2,['perform'],['performant']
Performance,"> @navidcy thanks for the commits. I am now testing the script against a free-explicit free surface and a MultiRegionGrid. @navidcy, as you may have anticipated, a MultiRegionGrid does not result in this error. Code Modification:; ```julia; #=; grid = ConformalCubedSphereGrid(; panel_size = (Nx, Ny, Nz),; z = (-1, 0),; radius = R,; horizontal_direction_halo = 6,; partition = CubedSpherePartition(; R = 1)); =#. latlongrid = LatitudeLongitudeGrid(size=(Nx, Ny, Nz),; longitude = (-90, 90),; latitude = (-45, 45),; z = (-1, 0)); grid = MultiRegionGrid(latlongrid, partition = XPartition(2)); ```; Terminal Output:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); ┌ Warning: MultiRegion functionalities are experimental: help the development by reporting bugs or non-implemented features!; └ @ Oceananigans.MultiRegion /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/MultiRegion/multi_region_grid.jl:102; [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 7.722 days, wall time: 0 seconds; [ Info: ... simulation initialization complete (111.288 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (994.424 ms).; [ Info: Simulation is stopping after running for 0 seconds.; [ Info: Simulation time 628.319 ms equals or exceeds stop time 628.319 ms.; [ Info: Making an animation from the saved data...; ```; When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; ```julia; ERROR: LoadError: UndefVarError: `settings` not defined; ```; When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; ```julia; ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155:1675,Load,LoadError,1675,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1743475155,2,['Load'],['LoadError']
Performance,> @sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan. Perhaps a regression test would work for this... and it'd be nice to have a regression test for the hydrostatic model too.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971:84,race condition,race condition,84,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926695971,2,['race condition'],['race condition']
Performance,"> @sangeethasankar01 are you trying to get this to run on the GPU for some specific purpose? Or is this merely an educational exercise?. I am a research scholar at IIT Madras, working under the supervision of Dr. Arjun Jagannathan. Currently, I'm exploring various problems related to flow instabilities. However, my current focus on this Kelvin-Helmholtz instability problem is purely for educational practice. I aim to understand the architecture of the code and optimize it for GPU execution.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2029214744:465,optimiz,optimize,465,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3522#issuecomment-2029214744,1,['optimiz'],['optimize']
Performance,"> @siddharthabishnu, `CUDA.@allowscalar` introduced by [3cdd470](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/3cdd4705fedf3238d8858bb0f56e9b27b01ba34a) is detrimental for performance. Like it induces O(10-100x) slowdown I think....; > ; > Is this a temporary solution?; > ; > cc @glwagner, @simone-silvestri. I think it is. We can try to see if this works on one GPU. If it does we can keep the allowscalar for the moment otherwise we can remove them.; In the end all this will have to live in a kernel.; Note that this will still not work on multiple GPUs as you cannot explicitly access one region from another one on a different GPU without switching to the device that holds the data.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2034043615:185,perform,performance,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2034043615,1,['perform'],['performance']
Performance,"> @simone-silvestri will the changes here impact CATKE on [CliMA/ClimaOcean.jl#17](https://github.com/CliMA/ClimaOcean.jl/pull/17) ?. not on the GPU, this PR affects only CPU performance",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486715558:175,perform,performance,175,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3030#issuecomment-1486715558,1,['perform'],['performance']
Performance,"> @xkykai do you think you could run some immersed boundary tests with this branch to make sure this change doesn’t affect your work? I think we’re interested in both performance and making sure the solution is high quality. Do you mean using the immersed pressure solver in this branch, and comparing the solution this produces with the one before this change?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1582859937:167,perform,performance,167,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1582859937,1,['perform'],['performance']
Performance,"> A more hierarchical organization of the docs is; > ; > 1. Introduction; > ; > * What's Oceananigans?; > * Installation; > * Writing your first script; > 2. Examples; > 3. Model setup; > ; > * Fields, BoundaryCondition, and AbstractOperations; > * IncompressibleModel; > * HydrostaticFreeSurfaceModel; > * ShallowWaterModel; > * Setting initial conditions; > * Diffusion, viscosity, and TurbulenceClosures; > * Forcing functions; > * Coriolis forces; > * Buoyancy forces; > 4. Simulations and post processing; > ; > * Simulation; > * OutputWriters; > * OutputReaders, post-processing, and plotting; > 5. Useful tips; > ; > * Using Graphics Processing Units (GPUs); > * Common errors and performance pitfalls; > 6. Contributor's guide; > 7. Gallery (this should be way higher eventually, but we need more recent content to motivate that...); > 8. Physics and numerical implementation; > 9. Appendix. I wholeheartedly agree with this structure :)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116:688,perform,performance,688,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879265116,2,['perform'],['performance']
Performance,"> Ah interesting. Does this work because broadcasting over GPU subarray views is a little rough around the edges?; > ; > Also, is it worth adding the MWE from [#1767 (comment)](https://github.com/CliMA/Oceananigans.jl/issues/1767#issuecomment-868793917) as a test?. Certainly _something_ is rough... I think it's ""broadcasting over ReducedField"" that's the issue here. Prior to this PR, `mean!` used a broadcast over `R::AbstractReducedField` to compute the normalization. For some reason this has data synchronicity issues on the GPU (I'm at a loss to explain why). This PR just changes that broadcast operation to compute over all members of `R`. The halo regions of `R` (presumably) aren't touched during `sum!`, so doing some extra normalization in the halos doesn't really matter, I guess... (if we want halos to be right we should probably fill them after executing `mean!` in `compute!`, or something). But the _reason_ why this change fixes the issue isn't at all obvious to me. Maybe there's a bad interaction between `KernelAbstractions` (which gets used for the broadcast) and `sum!`? Not sure. Maybe another solution would wrap `sum!` in `CUDA.@sync` (eg the solution here could _implicitly_ synchronize in order to perform the broadcast correctly; otherwise CUDA wouldn't work generally... ?!?). Might be worth testing that, though I don't know which solution we should prefer (if any). In fact, it seems better to avoid using custom broadcasting machinery if possible (which is the current solution)...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-868839671:1228,perform,perform,1228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1769#issuecomment-868839671,1,['perform'],['perform']
Performance,> Also I found it quite cumbersome in scripts when I wanted to load these constants I had to load one from `Grids` and one from `Coriolis` and one from `BuoyancyModels`.... That's a bit counterintuitive from a user's perspective. Shouldn't you be defining and setting constants in the scripts if you are doing that?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492624226:63,load,load,63,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492624226,2,['load'],['load']
Performance,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. @francispoulin thanks. I think we probably just want to do some buffer. I looked at LazyArrays.jl and I could imagine how that could maybe also be included, but I suspect the main thing is having a buffer (which https://github.com/eth-cscs/ImplicitGlobalGrid.jl has). I don't see any sign of LazyArrays in https://github.com/eth-cscs/ImplicitGlobalGrid.jl code! We can check with Ludovic though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885972875:185,optimiz,optimize,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885972875,2,['optimiz'],['optimize']
Performance,"> Another thought for @christophernhill; > ; > At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have. We think that we cannot send non-contiguous data over MPI between GPUs (only CPUs). Thus certain `view`s will not work. Possibly in this case the data is transferred to CPU, sent over MPI, and then copied back to the GPU (slow).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885935875:185,optimiz,optimize,185,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885935875,2,['optimiz'],['optimize']
Performance,"> Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?; > ; > ```julia; > wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; > ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; > └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; > ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); > Stacktrace:; > [1] check; > @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; > [2] nc_create(path::String, cmode::UInt16); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; > [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); > @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; > [4] NCDataset; > @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; > [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Per",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839:601,Load,LoadError,601,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747420839,1,['Load'],['LoadError']
Performance,"> Apparently optimizing reductions on the GPU is non-trivial but can be done: https://developer.download.nvidia.com/compute/cuda/1.1-Beta/x86_website/projects/reduction/doc/reduction.pdf Not sure if an optimized reduction kernel is available in Julia/CUDA.jl but maybe they will be in the future. @maleadt or @vchuravy might know... The CUDA.jl implementation is such an implementation: https://github.com/JuliaGPU/CUDA.jl/blob/2310b88738c11449867e6f37c5acbfcd453dc2c8/src/mapreduce.jl#L60-L69. It probably needs to be profiled and optimized if you really want to squeeze out performance, but it isn't a naive implementation either. It's exposed via `Base.mapreducedim` and friends.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152:13,optimiz,optimizing,13,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1497#issuecomment-802599152,4,"['optimiz', 'perform']","['optimized', 'optimizing', 'performance']"
Performance,> Are we making AMDGPU an extension?. I was asked to keep the PR minimal. I have a good deal of follow up work related to performance coming. You'll need to make AMDGPU a package extension after.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936969288:122,perform,performance,122,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936969288,1,['perform'],['performance']
Performance,"> As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models). I agree, but this patch-up will not work for immersed boundaries anyway. I still advocate for (maybe not now but later down the line) a general line of thought that ensures consistency between immersed boundaries and ""regular"" boundaries (a la MITgcm) treating them always the same way. As an example, this issue could have been brought up for immersed boundaries, which would have required a (definitely more lengthy) rework of boundaries in abstract operations but would have solved the issue in both boundaries and immersed boundaries.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113:432,perform,performance,432,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689967113,1,['perform'],['performance']
Performance,"> Average reduction with conditional expressions, e.g., like; > ; > https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107; > ; > induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,; > ; > ```julia; > @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); > ```; > ; > Only mentioning this here in case it might something in the source code that could be affecting code performance. The condition should be a function of `f(i, j, k, grid, args...)` returning a boolean, or an `AbstractArray` of booleans. . We should implement boolean operations with fields to return boolean fields, so we will be able to pass an `AbstractOperation`; ```; condition = T > 3 # This should be a boolean AbstractOperation; @compute Txyz = Field(Average(T; condition)) ; ```. at the moment the best way to specify a condition is through a function; ```; @inline condition(i, j, k, grid, T) = T[i, j, k] > 3; @compute Txyz = Field(Average(T; condition)) ; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1224162912:489,perform,performance,489,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1224162912,1,['perform'],['performance']
Performance,"> Billy mentioned it in some other comments but while we do splat args for some of the function calls, the function definitions use Varargs instead. This should avoid the catastrophic slowdown we saw with splatting earlier, but I agree that it should be tested. Do you have any good CPU performance tests set up @glwagner ?. Any simple test will do, for example one of the examples",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681:287,perform,performance,287,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150416681,2,['perform'],['performance']
Performance,"> Bonus, also the `mask_immersed_field` was missing. I don't expect it will be ever used (why using an immersed boundary grid in a single column?), however I have added a test for it. We can remove it if not needed. Good to have because it might be useful for testing and also, its definitely best if the single column mode is identical (except for performance) to 3D mode.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3756#issuecomment-2326759623:349,perform,performance,349,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3756#issuecomment-2326759623,1,['perform'],['performance']
Performance,"> By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection. I just tried with the latest commit and got this error:. ```julia; ERROR: LoadError: TaskFailedException. nested task error: UndefVarError: coeff_β_2_0 not defined; Stacktrace:; [1] left_biased_β(::Tuple{Float64, Float64}, ::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Val{0}); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [2] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:115 [inlined]; [3] beta_loop(::WENO{2, Float64, Nothing, Nothing, Tuple{OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}, OffsetArrays.OffsetVector{Tuple{Float64, Float64}, Vector{Tuple{Float64, Float64}}}}, Nothing, true, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, ::Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}}, ::typeof(Oceananigans.Advection.left_biased_β)); @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; [4] overdub; @ /glade/work/tomasc/.julia/packages/Oceananigans/dgCcB/src/Advection/weno_interpolants.jl:163 [inlined]; ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132:265,Load,LoadError,265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186215132,1,['Load'],['LoadError']
Performance,"> By the way, i didn't use the scheme described in #1704 because it didn't give great results when implemented. I have implemented the ENO coefficients as derived before the assumption of uniform grid to the stencil interpolation (tomorrow I'll go back and check the report which describes them) . The smoothness functions are kept the same. That's interesting. Does that mean you were not able to reproduce the results reported in ""[A simple algorithm to improve the performance of the WENO scheme on non-uniform grids](https://link.springer.com/article/10.1007/s10409-017-0715-2)""?. > > By the way, it would be quite easy to modify the type to include the order of the WENO scheme which we could change at will. What do you think? Would it be usefull to do that?; > ; > If it's easy, then I definitely vote that we do that! A lower order, faster WENO scheme may be a good compromise between computational cost and accuracy. If that's true, we could use it as the default scheme for models. I think a higher order WENO scheme is more important than lower-order scheme. However, a low-order WENO method is proposed [here](https://link.springer.com/article/10.1007/s10915-020-01164-6). I think the 3rd order scheme may be quite diffusive and runs the risk of limiting to 1st order (?!). #995 attempts to implement nth order WENO but I think failed to achieve good CPU performance / compilation on the GPU. But @simone-silvestri perhaps you're able to achieve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093:468,perform,performance,468,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969290093,4,['perform'],['performance']
Performance,"> Can you put @inline in front of sponge_u_disc, etc?. Done. Same result. I also tried `ContinuousForcing` with `bottom_mask(x, y, z) = 1` and it's slower than its discrete counterpart. Apparently `DiscreteForcing` is a bit faster than `ContinuousForcing`, everything else being the same. > Again unsure if it affects performance but since rate is referenced as global it needs to be const; eg const rate = 1/10. Yes! That makes a big difference! I feel silly that I forgot that. With `const rate=1/10` and `DiscreteForcing` things are as fast as with no forcing. Using the same ""trick"" with `ContinuousForcing` doesn't change things though. So it does seem like the source of the issue is `ContinuousForcing`. I should say though, I'm having some trouble securing a GPU right now, so I haven't been able to run these tests on a GPU. Would a MWE help here?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875702050:318,perform,performance,318,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875702050,1,['perform'],['performance']
Performance,"> Can you try this branch and see if it goes better? `ss/fix-memory-issue`. It seems to solve the memory issue! But I do get an error when writing to disk:. ```; ERROR: LoadError: NetCDF error: size mismatch for variable 'dbdz' in file './data/out.PPN-R02F02A01.nc'. Trying to write (1022, 1022, 106) elements while [1014, 1014, 98, 1] are expected (NetCDF error code: -57); Stacktrace:; [1] _nc_check_size_put_vars(ncid::Int32, varid::Int32, countp::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:973; [2] nc_put_vars(ncid::Int32, varid::Int32, startp::Vector{Int64}, countp::Vector{Int64}, stridep::Vector{Int64}, op::Array{Float64, 3}); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/netcdf_c.jl:984; [3] setindex!; @ /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:460 [inlined]; [4] setindex!(::NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/variable.jl:493; [5] setindex!(::NCDatasets.CFVariable{Float64, 4, NCDatasets.Variable{Float64, 4, NCDatasets.NCDataset{Nothing}}, NCDatasets.Attributes{NCDatasets.NCDataset{Nothing}}, NamedTuple{(:fillvalue, :missing_values, :scale_factor, :add_offset, :calendar, :time_origin, :time_factor), Tuple{Nothing, Tuple{}, Nothing, Nothing, Nothing, Nothing, Nothing}}}, ::Array{Float64, 3}, ::Colon, ::Colon, ::Colon, ::Int64); @ NCDatasets /glade/work/tomasc/.julia/packages/NCDatasets/ipGBH/src/cfvariable.jl:765; [6] save_output!(ds::NCDatasets.NCDataset{Nothing}, output::Field{Center, Center, Face, Oceananigans.AbstractOperations.Derivative{Center, Center, Face, typeof(∂zᶜᶜᶠ), Field{Center, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuArray{Fl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165:169,Load,LoadError,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300963165,1,['Load'],['LoadError']
Performance,"> Can't we just plot a fixed-color shape on top on the mount on all panels? [`Makie.poly`](https://docs.makie.org/stable/reference/plots/poly/) seems to be able to do that. We can. We can also mask the output after we load it, e.g, via. using something like. ```Julia; using Oceananigans.ImmersedBoundaries: mask_immersed_field!. function mask_and_get_interior(φ_t, n; value=NaN); mask_immersed_field!(φ_t[n], value); return interior(φ_t[n], :, 1, :); end. u′ₙ = @lift mask_and_get_interior(u′_t, $n); ```. which gives. https://github.com/CliMA/Oceananigans.jl/assets/7112768/a402bfcd-ef72-42d8-bbb9-97fb98be4fe3. But either of these solutions complicate the example a bit. Ideally, `mask_immersed_field!` should not be user-facing. And plotting a mountain on top of the mountain is a bit of a hack and would require a bit of explaining and justifying why we do that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983782339:218,load,load,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1983782339,1,['load'],['load']
Performance,"> Copied below.; > ; > ```; > ERROR: LoadError: `makedocs` encountered an error. Terminating build; > --; >   | Stacktrace:; >   | [1] error(s::String); >   | @ Base ./error.jl:33; >   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document); >   | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255; >   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document); >   | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170; >   | [4] #2; >   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined]; >   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String); >   | @ Base.Filesystem ./file.jl:106; >   | [6] #makedocs#1; >   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined]; >   | [7] top-level scope; >   | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155; >   | 🚨 Error: The command exited with status 1; >   | user command error: exit status 1; > ```. This is only the top of the error. Farther down, we see. ```; ┌ Warning: failed to run `@example` block in src/generated/shallow_water_Bickley_jet.md:70-77; --;   | │ ```@example shallow_water_Bickley_jet;   | │ model = ShallowWaterModel(architecture = GPU(),;   | │ timestepper = :RungeKutta3,;   | │ advection = WENO5(),;   | │ grid = grid,;   | │ gravitational_acceleration = g,;   | │ coriolis = FPlane(f=f));   | │ ```;   | │ c.value = CUDA error (code 100, CUDA_ERROR_NO_DEVICE);   | └ @ Documenter.Expanders /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Expanders.jl:563; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390:37,Load,LoadError,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-887500390,1,['Load'],['LoadError']
Performance,"> Could you explain why using ifelse has better performance?; Is this because the ternary ? : is an alias for ifelse?. No, the ternary operator `a ? b : c` is shorthand for . ```julia; if a; b; else; c; end; ```. This `if`-statement (as well as the logicals `&&` and `||`) are _short-circuiting_. That is, `c` is guaranteed _not_ to run if `a === true`. For example. ```; julia> f(a, first) = first ? a[1] : a[2]; f (generic function with 1 method). julia> a = rand(1); 1-element Vector{Float64}:; 0.6018054291910822. julia> f(a, true); 0.6018054291910822. julia> f(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] f(a::Vector{Float64}, first::Bool); @ Main ./REPL[7]:1; [3] top-level scope; @ REPL[10]:1; ```. The first call to `f(a, true)` executes without problems, because the second _branch_ isn't executed at all. On the other hand. ```julia; julia> g(a, first) = ifelse(first, a[1], a[2]); g (generic function with 1 method). julia> g(a, true); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[12]:1. julia> g(a, false); ERROR: BoundsError: attempt to access 1-element Vector{Float64} at index [2]; Stacktrace:; [1] getindex; @ ./array.jl:805 [inlined]; [2] g(a::Vector{Float64}, first::Bool); @ Main ./REPL[11]:1; [3] top-level scope; @ REPL[13]:1; ```. `ifelse` is _not_ short-circuiting --- _both_ branches are executed, even though only the correct value is returned:. ```julia; julia> b = rand(2); 2-element Vector{Float64}:; 0.5340042876487958; 0.7031634999748222. julia> g(b, true); 0.5340042876487958. julia> g(b, false); 0.7031634999748222; ```. It's easier for the compiler to optimize code that involves `ifelse`, especially on the GPU. The reason is that it's allowed to execute all code on both branches. If w",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583:48,perform,performance,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066115583,1,['perform'],['performance']
Performance,"> Distributed IO is not supported yet and will require a lot of work and refactor so for the time being we have to do with the rank in the output writers. Distributed IO is not necessary to solve this problem. We can introduce a convention for filenames whereby the rank number is automatically inserted into the filename for distributed simulations. Similarly the convention can be reversed for `FieldTimeSeries` to make the process seamless for users. There are probably plenty of other possible solutions. The first step is recognizing that a problem or deficiency exists, and having the desire to fix it. Then we can do the fun part, which is to design solutions to an important problem. Note that distributed IO is unlikely to ever be supported for JLD2. So to provide a seamless experience with JLD2, we really do require a filename convention to solve the problem. (For NetCDF, we could envision providing a choice between file splitting or distributed IO.). Filename conventions also seem preferred to me for many cases in a world of GPUs where each rank likely needs to hold a substantial portion of the computation for performance. Splitting files by rank will limit the filesize, which makes it easier to transfer data when the simulations are very large --- which will probably often be the case when doing distributed simulations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029:1129,perform,performance,1129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895891029,1,['perform'],['performance']
Performance,"> For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). Just `storage` is an array; `plan` is a `CUFFT` object, not an array. If we use `cufftxt` would this happen be default?. ie with `cufftxt` we have to build a unified `storage` (and maybe unified eigenvalues). Then provided we can fill up storage correctly, and empty it correctly at the end, the thing that's left is to ""just do"" the fft (transposes etc handled under the hood). Does broadcasting work with unified memory arrays?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119868092:99,perform,performed,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119868092,1,['perform'],['performed']
Performance,"> Hello, @amontoison. Nice work. Do you see a performance improvement when switching to this package? There should be some benchmarks in the `benchmark` folder that we can test (probably we need to update that folder a bit, let me know if you have problems with it). Hi @simone-silvestri, `cg` is not too hard to implement, so I don't think we will see a significant performance improvement on CPU. ; However, for other methods like `gmres`, `Krylov.jl` easily outperforms `IterativeSolvers.jl`.; On GPU, though, we might see a difference because I try to dispatch to the BLAS/LAPACK routines of the GPU vendors as much as possible, whereas `IterativeSolvers.jl` relies on some broadcast. Also, to the best of my knowledge, only `cg` works on (NVIDIA) GPUs for `IterativeSolvers.jl`, while all solvers in `Krylov.jl` work on the GPUs of any vendor. I'll try to run some benchmarks before the end of the week.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2373076041:46,perform,performance,46,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2373076041,2,['perform'],['performance']
Performance,"> Hmm. I believe that scalar operations are (or were) _specifically_ allowed globally in our `runtests.jl`, overriding any default. I was considering deprecating that option though, so that scalar iteration would be disabled by default and can only be allowed for a limited number of statements using `@allowscalar` or `allowscalar() do ... end`, because it's such a performance trap. Is there so much scalar iteration being triggered by the Oceananigans tests?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863772729:367,perform,performance,367,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1740#issuecomment-863772729,1,['perform'],['performance']
Performance,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. At least that is what @siddharthabishnu told me, I am not sure about the timings, can you confirm @siddharthabishnu?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353979984:99,perform,performance,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353979984,1,['perform'],['performance']
Performance,"> I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators. For example, if the boundary is fixed and not dependent on the interior variables, it might be possible just to fix the BC once before the sub stepping and just iterate without needing to use any update",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319:99,perform,performance,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353997319,1,['perform'],['performance']
Performance,"> I believe in this case that the function d.▶ from the above is identity, which could fail because it's also called in the calculation of the binary operation w * v?. I gotta be honest that whole discussion went right over my head, haha. I think mostly because I don't really understand what's the exact use of `identities` and what the functions `d.▶` actually do. . Am I correct in assuming that if I specify where each calculation is performed (by using `@at`) I can decrease the computational complexity and maybe make `ComputedField`s easier to compile on GPUs?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786854048:438,perform,performed,438,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1401#issuecomment-786854048,1,['perform'],['performed']
Performance,"> I don't know exactly what to do, so we'll need help. I've started with a post to the julia slack: https://julialang.slack.com/archives/C67910KEH/p1635909337281400; > ; > On the other hand, it may not be a huge issue if it only affects diagnostics that are evaluated fewer than 5 times. For long running simulations, our methods do eventually get cached? Do you have an example of a method that doesn't get cached after 5 evaluations?. ~When I was running an actual simulation this issue seemed to persist after many evaluations (i.e. writings to disk), and not just the first few times. So it may be that doing it 5 times consecutively on the REPL is different from the simulation behavior. That said, I didn't pay a ton a attention to that, so I may have been wrong.~. ~I'll try to investigate this further tomorrow on my end if I have time.~",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958632710:348,cache,cached,348,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958632710,2,['cache'],['cached']
Performance,"> I don't think we ever used `power_by_squaring`, because the ""pre 1.6"" Oceananigans kernels were defined via`KernelAbstractions`, which in turn translated `^(a, b)` to `CUDA.pow(a, b)`:. I know, I was thinking about what would be a good ""new"" default behavior. CUDA.jl used to truncate Int64 exponents to Int32, resulting in `powi` use, but although that was good for Oceananigans it's a bad default. Using `pow` after casting the exponent to Float64 seemed like a good idea, but is apparently slow in your use case. `Base.power_by_squaring` is slow in microbenchmarks, but may perform better in a realistic application? If that's the case, I could change the implementation of `^` in CUDA.jl. But I also realize now that exponentation by a small constant, which you seem to be doing here, should probably be handled differently. Base has `literal_pow`, not sure why that isn't kicking in here. Feel free to file an issue about that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870021086:579,perform,perform,579,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870021086,1,['perform'],['perform']
Performance,"> I guess I also see timers as a debugging tool for users. Totally agree since simulation performance can depend entirely on performance of forcing functions, boundary conditions, and diagnostics; not just code that ships in src.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027:90,perform,performance,90,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-888341027,2,['perform'],['performance']
Performance,"> I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:; > ; > `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`; > ; > Then it returns the following error:; > ; > Error output:; > Any idea what it could be, @simone-silvestri ?. That's related with #3374 and the warning comes from Julia v1.10 (wasn't there with Julia v1.9).; The PR #3403 will deal with these warnings.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561:235,optimiz,optimizer,235,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1895005561,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"> I never understood why a `CFL` object had to be pre-constructed, but I always assumed there was a good (probably GPU-related) reason for that. I guess it's helpful if we have competing functions for computing time-scales (for performance reasons). But if we have just one fast function then it doesn't seem like there's a good reason.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958584552:228,perform,performance,228,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2037#issuecomment-958584552,1,['perform'],['performance']
Performance,"> I over-simplified. FFTs are efficient when there are a small number of prime divisors --- 2, 3, 5, 7 --- of the length of the sample. 100 may actually be ok because it is 2*2*5*5. I don't feel strongly, but you will find that most people running simulations are using powers of 2 and 3 (128, 192, 256, 384, 512, 768, 1024) --- even when their code has no FFTs! Perhaps the purpose of this convention is so people who _do_ use codes that rely _heavily_ on FFTs are able to run code comparisons. I find the convention to be an appropriate best practice. An 1D FFT of length 257, for example, is 4 times slower than an FFT of length 256 on my machine. For tests, of course, using small numbers of prime divisors is completely irrelevant; I just want to encourage best practices and promote awareness of them, and also implicitly emphasize to users that this code uses FFTs, and don't want random person X to read the tests and scratch their head and ask ""doesn't this code rely on FFTs?"" (like I did when I saw the examples). I don't disagree with anything here. I just think users should be able to run using whatever resolution they want and know that the code has been tested and works with weird inefficient resolutions. To encourage users maybe we can print a ""performance warning"" if the grid resolution is not the product of a small number of prime divisors?. > I certainly prefer that. It may be academic because the architecture should probably be a parameter of `Model`. That makes sense. I think we should just be wary of having too many parametric types but architecture probably warrants being one as we'll dispatching on it so frequently.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468537451:1265,perform,performance,1265,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468537451,1,['perform'],['performance']
Performance,"> I see that one of the errors is `UndefVarError: device_event not defined`, which I suppose means we need to load it?. Indeed, I'll fix that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890028428:110,load,load,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1913#issuecomment-890028428,1,['load'],['load']
Performance,"> I share here a double drake experiment that makes full use of this PR; > ; > #### Grid setup; > * latitude longitude grid from 75 S to 75 N; > * 1/3 of a degree in the horizontal (1080 points in longitude, 450 in latitude); > * 150 exponentially stretched vertical levels for a 3km deep ocean; > * double drake bathymetry (https://doi.org/10.1175/2009JCLI3197.1); > ; > #### Top BC:; > * temperature: restoring to reference profile (cosine shape); > * salinity: prescribed latitudinally dependent surface flux; > * zonal velocity: prescribed latitudinally dependent wind stress; > ; > #### Bottom BC:; > * velocities: linear bottom drag with a drag coefficient of 0.003 ms⁻¹; > ; > #### Initial conditions; > * zero velocities; > * exponentially stratified temperature with SST equal to the reference temperature; > * constant salinity; > ; > #### Model setup; > * linear equation of state; > * Richardson-based diffusivity for BL mixing; > * vertical background viscosity and diffusivity of 5e-4 and 3e-5, respectively; > * vector invariant momentum advection with WENO for vorticity and divergence flux as well as vertical transport (no horizontal viscosity); > * WENO for tracer advection (no horizontal diffusivity); > * Split explicit free surface using an averaging shape function and a CFL of 0.7 (23 substeps per time step); > ; > #### Simulation setup; > * time step of 10 minutes; > * ran on 2 MPI processes with CUDA-aware MPI; > * performs about 10 simulated years per day; > ; > On the left, there is the free surface evolution, on the right the surface vertical vorticity (evolved for 9 years). This would be a good setup to add to `ClimaOcean.jl`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342:1445,perform,performs,1445,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2888#issuecomment-1431581342,1,['perform'],['performs']
Performance,"> I think prior to the changes we grouped into our ""upgrade to julia 1.6"" we were using the function `CUDA.pow` (from an ancient `CUDA.jl` version). Ah, in that case we were doing something pretty bad: https://github.com/JuliaGPU/CUDAnative.jl/blob/199f9b8ebb1f2fc9d7c14547efa9bcc14f4130c3/src/device/cuda/math.jl#L209. The new default, converting Int64 exponents to Float64, seems better. Unless `power_by_squaring` performs better in realistic applications?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869833684:417,perform,performs,417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869833684,1,['perform'],['performs']
Performance,"> I think something like you're proposing would have added to my confusion. Isn't the confusion a problem with the output writers API? I think it sounds like a great idea to support `AbstractOperation` output. It's kind of logical. Doing this even allows us to do some clever stuff behind the scenes, like using one underlying array to store the results of multiple computations performed serial (thus saving memory).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036767779:379,perform,performed,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2235#issuecomment-1036767779,1,['perform'],['performed']
Performance,"> I think that should be revisited when we decide to take on the more challenging issue of checkpointing partially-accumulated time-averages so that windowed_time_average always works as intended when picking up from checkpoints. good point!. There is a possibility that it is not very hard. It will require reshuffling code (which I can do), but with Julia we can serialize objects to disk and then load them back seamlessly in a single line... which might be all we need. The only limitation of serialization is that we haven't yet figured out how to serialize _methods_ (eg functions) which prevents us from serializing entire models. When functions are not involved things can be pretty simple.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379890956:400,load,load,400,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3721#issuecomment-2379890956,2,['load'],['load']
Performance,> I think the new diffusion/cosine tests? Can't think of something else... Ah indeed. It's also possible that some PRs caused a compile-time regression. Hopefully not a performance regression though. We should test that.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062527828:169,perform,performance,169,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2324#issuecomment-1062527828,1,['perform'],['performance']
Performance,"> I think this makes things more intuitive, no? Are there any downsides besides a slightly longer building time for `model`?. There's no downside. `update_state!` has to be efficient for the model to run so I don't think there's a performance issue. I think it's more ""correct"", since without that call the auxiliary state may be wrong initially.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708:231,perform,performance,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1889#issuecomment-885340708,2,['perform'],['performance']
Performance,> I think to do this cleanly we might want to follow up with what @vchuravy was doing here #3042. I tried experimenting with this on the OceanBioME tests and it seems to be preventing it from segfaultinig https://github.com/OceanBioME/OceanBioME.jl/pull/190 (and testing running them both at the same time here https://github.com/OceanBioME/OceanBioME.jl/pull/196). But it does also seem to run quite a bit slower so I'm going to see how much I can get it to cache without it causing problems. And then I can copy the implementation over to here.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2265916968:459,cache,cache,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3662#issuecomment-2265916968,1,['cache'],['cache']
Performance,"> I think to preserve the work in this PR, we should add a `Float32` test which will fail if a spurious promotion undermines performance. Agreed. I'll revisit this PR later to see if I can find where the conversion happens. The test I added only checks to see if we can take a time step. But I should be able to also add a test to ensure no spurious promotion occurred.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445251168:125,perform,performance,125,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3876#issuecomment-2445251168,1,['perform'],['performance']
Performance,"> I think we should distinguish between output we need when we run the model, and output we may eventually provide to the broader community. Ideally, formats for both would be the same, but this may not be the best solution. E.g., netCDF has obvious disadvantages but is still widely used. That does not mean it should be the output format we use by default (although we may want to provide model statistics in netCDF in the end, if a few years from now this is still what everyone uses). So: separate the discussion of what is best for us now from what we should provide (e.g., in any CMIPx archive down the line). Zarr and HDF both seem worth discussing.; > ; > Also important to keep in mind in this discussion: Our workflow will be different from most standard models, which write out instantaneous output that then is post-processed to get statistics etc. We will have to accumulate statistics on the fly, and we can (and should) forgo most instantaneous output, at least for the atmosphere. The model will learn from the accumulated statistics. Otherwise, with instantaneous output, the data volume, especially with embedded LES, will create an I/O and data transfer bottleneck that will limit us, and, e.g., will limit our ability to use distributed computing platforms. I agree. Ideally we'd support different formats (e.g. NetCDF, JLD2, HDF, Zarr, etc.) and have the option to use the best format for your application. We can already switch between output writers and choose which field(s)/diagnostics to output but we only do binary, NetCDF, and JLD for now. We were just focusing on NetCDF for our short-term needs, but this will definitely be a challenge for large problems.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476303978:1173,bottleneck,bottleneck,1173,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-476303978,1,['bottleneck'],['bottleneck']
Performance,"> I think you may need @inline in front of most of those functions (only matters for CPU). ~That was my first attempt, but I get an error saying `ERROR: LoadError: LoadError: -(grid.Lz) + grid.Δz * (k - 1 / 2) is not a function expression`. I guess I need to choose between `@inline` or `@inbounds`?~. Nevermind, I was doing something very dumb. Inlining gives me exact same performance as not inlining (0.20% of the simulation). I guess the compiler is getting smarter about inlining. > If the slow down is the same for DiscreteForcing then the problem may really just be evaluating exp, sadly... You could try @inline bottom_mask(k) = 1 to test... I'll try that. Although I have tried non-exponential masks in the past with a similar slowdown, so I'm not sure if that's the issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875673783:153,Load,LoadError,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875673783,3,"['Load', 'perform']","['LoadError', 'performance']"
Performance,"> I would advocate again for moving both CUDA and AMDGPU support into package extensions (see #3066 for an outdated start); > ; > Having the user install both AMDGPU and CUDA unconditionally is both space and time consuming, loading them both should be unnecessary on most systems and they may at times be incompatible with each other since both are developed independently from each other. That's a good idea. Maybe we can start by developing AMD support (this PR) in an extension, and then move CUDA after that (just to relieve some pressure on @fluidnumerics-joe).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935396471:225,load,loading,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1935396471,1,['load'],['loading']
Performance,"> I'll explain quickly what is happening to document it. In this new PR I added a new way to check boundary stencils for advection so that the correct reconstruction method is always used.; > ; > This entails checking differently for `Face` reconstructions (where we have to ensure that `Center` locations are active) and vice versa for `Center` reconstructions where `Face` locations have to be active.; > ; > The problem occurs when checking the last cell for `Center` reconstructions (on a `Periodic` direction) let's say the advection is centered order 4 so hypothetically it requires two halo points. We then need to ensure that the nodes at `N + 1` and `N + 2` are active. A `Face` node (i) is active if either centered cell (i) or (i+1) is active, which means that the check will be performed on cells `N+1`, `N+2` and `N+3` (one more than the required halo size = 2!).; > ; > This is not a problem for a underlying grid where the `inactive_node` function can check out-of-bounds locations and will just return a `true`. On the other hand, it is a problem for an `ImmersedBoundary` where a conditional has to be evaluated against an AbstractArray.; > ; > My first solution was to increase by one the halo under the hood in the `ImmersedBoundaryGrid` constructor. This bug with `set!` demonstrated that this is probably not the best solution as this can have a lot of unwanted repercussions. The way I implemented it now is that, when performing the halo checking in the model constructor, if the grid is an `ImmersedBoundaryGrid`, the `required_halo` is incremented by one, and an appropriate warning message is displayed. This was the problem. So in the end I decided to just require one additional halo for the immersed boundary grid",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144:790,perform,performed,790,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1181806144,2,['perform'],"['performed', 'performing']"
Performance,"> I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my profiling. I didn't know this was a KA.jl-based GPU workload when commenting on Slack. The dependency/event model of KernelAbstractions.jl also uses stream queries (i.e. `cuStreamQuery`) when selecting a new stream. Maybe that's the source of these calls. It'd be good to figure out where they come from: if it's from CUDA.jl, and thus presumably because of calling the `synchronize` function, (1) why are you synchronizing that much [1], and if it's for good reasons (2) does it hurt performance and should we tweak our `synchronize` implementation to perform fewer stream queries?. [1]: some synchronization happens implicitly, e.g. when copying memory to or from the CPU (https://github.com/JuliaGPU/CUDA.jl/blob/6758fcab7ae0d72659a1ca0d56ad2c86d3b451f1/src/array.jl#L385-L399). One way to avoid some of those synchronizations, is by using pinned memory, but that's up to the application.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869:637,perform,performance,637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-900059869,2,['perform'],"['perform', 'performance']"
Performance,> I'm not sure if we've tested but I've assumed there is a performance benefit to the simpler version for regularly spaced grids rather than using the binary search. @simone-silvestri have you ever benchmarked this?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546:59,perform,performance,59,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775545546,2,['perform'],['performance']
Performance,"> I'm wondering if we should provide a separate page on ""Using GPUs""? While the simulation tips for CPUs are really performance optimizations that are optional, the GPU simulation tips are mostly required to run without errors. That's a good point. Although I think we could avoid creating another page and put that information in the [""Using GPUs""](https://clima.github.io/OceananigansDocumentation/stable/using_gpus/) page, so that things are more condensed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275:116,perform,performance,116,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-818364275,2,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"> If I understand correctly this would make the `field_slicer` argument for output writers obsolete, no?. I missed this! Yes, that's correct. We _could_ keep it, however I think it's nicer to remove because it's one of the best ways to ensure that the ""windowing infrastructure"" implemented in this PR is performant and easy to use. In place of `field_slicer`, we will add some convenience arguments (`indices` and `with_halos`) that allow output fields to be ""constructed"" from what's given to `OutputWriter`. This will also allow us to close #2242 (but I haven't implemented that yet here).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2246#issuecomment-1044762888:305,perform,performant,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2246#issuecomment-1044762888,1,['perform'],['performant']
Performance,"> If forcing functions are expensive there may be simpler ways to do performance optimization though. For example, we can recommend piecewise linear masking functions for sponge layers instead of tanh or exp. From my tests I think this optimization can shave off 10% of time on the CPU and 25% on the GPU. This isn't bad, but I anticipate launching `Forcing` only where necessary would shave of much more in the situations I mentioned. Although when I originally posted the issue I thought it could be directly implemented in `Forcing`, but you make a good point that it can't, so it might not be worth the effort (at least not right now). I'll close this for now but feel free to re-open it if you think it's worth discussing.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092:69,perform,performance,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3525#issuecomment-2033489092,6,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"> If we assume that reduced fields ""lives"" nowhere in the reduced direction, then we can remove the k index and just perform an ""immersed-boundary-unaware"" derivative. > On the other hand, if the reduced field lives on the whole reduced column (like for example an integral) then we need to be aware of the ""immersed column"", because if the whole column is immersed then the derivative should return a zero. What is the difference between ""living nowhere"" and ""living on the whole column""?. I think the point of reduced fields is that they are derived from a reduction over one or more dimensions. Since they are derived from a reduction, they invoke values from every element in the column / reduced direction. I don't understand what it means to ""live nowhere"".",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099199410:117,perform,perform,117,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588#issuecomment-2099199410,1,['perform'],['perform']
Performance,"> Implement a multi GPU pressure solver. This can be achieved in a couple of different ways. (1) transpose local memory and perform one direction FFT at the time (at we do now in the Distributed module through PencilArrays). (2) exploit the multi GPU capabilities of cuda through the cufftxt library that can perform single node distributed FFT to up to 16 GPUs. (3) Allocate storage and plan in Unified memory and perform the FFT in only one GPU. Ideally we would implement (3) only if we are desperate. The best solution would be to go with method (2), as (1) incurs in hefty memory transfer costs (I am not sure as to how the cufftxt implements multi GPU FFT though). I think (but am not 100% sure) that PencilArrays is tied to MPI. So I guess for 1 we are either ""borrowing"" (but not using directly) the transpose algorithm from PencilArrays, or we are extending the code so that it works ""without MPI"" -- and also with GPUs, which is work in progress: https://github.com/jipolanco/PencilFFTs.jl/pull/37. Another reason to focus on 2 is that we can use PencilFFTs for _distributed_ (but _not_ `MultiRegion`) nonhydrostatic model. So even if PencilFFTs had support for CuArray now (and if `Distributed` were performant for multi GPU --- both of which may not be too close), using cufftxt could still _potentially_ be motivated by performance reasons. In other words, if we develop a capability with cufftxt, then in the future we can also support multi GPU via PencilFFT and `Distributed`, and we have two options (one perhaps performant on single node, multi GPU, and another to use when you need GPUs spread across multiple nodes).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852:124,perform,perform,124,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1118680852,6,['perform'],"['perform', 'performance', 'performant']"
Performance,"> In particular, this PR introduces the async keyword argument to fill_halo_regions! that allows launching MPI operations without waiting for the communication to complete. Would `blocking=true/false` be a better word to describe how we are controlling `fill_halo_regions!`?. I think ""async"" isn't quite the right word. ""async"" describes the overall algorithm (eg performing some computation while the communication is taking place), but does not describe what is happening specifically within `fill_halo_regions`. It's possible to write `async=true` without overlapping communication and computation. https://github.com/CliMA/Oceananigans.jl/pull/2881 introduces the kwarg `blocking` for `mask_immersed_field!`, which means the same thing:. https://github.com/CliMA/Oceananigans.jl/blob/4a71c834cbc057fcc27061a1d22b4a7cc3eb38fe/src/ImmersedBoundaries/mask_immersed_field.jl#L13. so either way let's use one word.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452252842:364,perform,performing,364,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2953#issuecomment-1452252842,1,['perform'],['performing']
Performance,"> Instead of saying that trig functions should be avoided on gpus, which seems very strong, I suggest pointing out that there have been some examples where trig functions have performed much slower, and include this example.; > ; > This clearly problem needs further exploration but I don't want people to be scared to use sin and cos because sometimes they just make a lot of sense. My two cents worth. I think there may be a bug in the setup that produces 100x slowdown. (@tomchor if you supply the whole script, we can investigate.) We've run many successful problems with trig functions. Some recent work by @simone-silvestri suggests we can get 2x speed up for _some_ problems by precomputing grid metrics for the `RegularLatitudeLongitudeGrid` rather than computing them on the fly:. https://github.com/CliMA/Oceananigans.jl/blob/da9c53ddd9e28d123b40726cfac2fad835284879/src/Operators/spacings_and_areas_and_volumes.jl#L178-L179. But I don't think we've definitely shown that we _always_ will get 2x speed up. Thus we are going to retain the option to compute metrics on the fly in #2025 so we can continue to investigate it. 2x is a long way from 100x though. If used in a boundary conditions, its basically irrelevant whether one uses a trig function or not. Even a forcing function is only evaluated once per grid point compared to 15x (or more?) for a `BackgroundField` velocity component with high-order advection. Some of these thoughts might be distilled into useful advice in this section of the docs. But we should definitely focus on _approaches_ to performance optimization rather than advice for specific scenarios.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050:176,perform,performed,176,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951555050,6,"['optimiz', 'perform']","['optimization', 'performance', 'performed']"
Performance,"> Interesting idea @christophernhill . For the last results that @hennyg888 posted in #1722, I did some calculations and found the following.; > ; > ```; > GPU; > N=256 3.0e9; > N=128 2.6e9; > N=64 6.6e8; > ; > CPU; > N=256 8.6e6; > N=128 9.1e6; > N=64 9.0e6; > ```; > ; > In an article that @ali-ramadhan referenced on the slack channel recently, a paper using a shallow water model in python, Roullet and Gaillard (2021), said they were getting 2 TFlops per second using a thousand cores. We are getting 3 GigaFlops on GPU and 9 MegaFlops.; > ; > Certainly very good speedup since we have O(400) with `WENO5`, but this makes me wonder whether we could do better?; > ; > But to answer your question, when @hennyg888 has the data, we can certainly produce these plots easily enough (unless there is a problem that I'm missing). We have to do more work to compare with Roullet and Gaillard (2021). First of all, there are typos in the paper: sometimes the performance is listed as 2 GFlops, other times as 2 TFlops. Second --- if I understand the situation correctly --- I don't think we've ever measured floating point operations per second. The numbers you've calculated are grid points per second; however we do many floating point operations per grid point. Roullet and Gaillard (2021) estimate their code performs something like 700-800 Flops per grid point. ![image](https://user-images.githubusercontent.com/15271942/126053492-345154c2-22e2-4af8-a898-ac68e889733d.png)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881986070:955,perform,performance,955,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-881986070,2,['perform'],"['performance', 'performs']"
Performance,"> Interesting, thanks for those details! That's odd that there are changes in memory allocation associated with building diagnostics. I don't think there's been changes to `Field` between 0.77.5 and 0.78.0. @navidcy might be able to say more. I think 0.78.0 only upgraded the tests to julia 1.8?; ; Maybe this indicates that the changes are due to changes in the dependencies when upgrading to 1.8?. > I'm also curious why the diagnostics consume so much memory. Are you producing a lot of 3D time averages (which can't be constructed in post-processing?) We've attempted to design the code so that reductions can be performed with minimal memory allocation. 3D diagnostics can simply be calculated from snapshots of the model state, so there's no need to allocate memory (assuming that static memory greatly exceeds GPU memory, this would be preferred). Are we missing a feature to help reduce memory requirements of diagnostics perhaps?. That's interesting. I'm actually also performing a significant amount of 3D averages, as you picked up on. The reason for that is because I want them at a higher frequency than the 3D snapshots that I'm outputting. I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800:617,perform,performed,617,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1300682800,4,['perform'],"['performed', 'performing']"
Performance,"> Is that what you recommend?. That wouldn't solve your problem here. KA gives you reasonable performance on the CPU, but since KA 0.8 it is execution story on the CPU much closer to the rest of Julia and it doesn't play special tricks.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481565094:94,perform,performance,94,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1481565094,1,['perform'],['performance']
Performance,"> It is what the right panel shows, if I am not mistaken. But the simulation crashed after thousands of iterations. I heard that the PCG solver in Oceananigans has not been widely tested, so that is why I turned to the HeptadiagonalIterativeSolver. Both of those solvers actually use the preconditioned conjugate gradient method. It's also not true --- the `PreconditionedConjugateGradientSolver` has been validated. I'm not even sure it's possible to use the FFT-based preconditioner with the heptadiagonal solver, they have different interfaces. Maybe you worked on that. It's not obvious how to generalize the `HeptadiagonalIterativeSolver` to support `Distributed` architecture, and its also likely more difficult to optimize for immersed boundary methods using an active cells map. We shouldn't waste our time with the `HeptadiagonalIterativeSolver`. If the `PreconditionedConjugateGradientSolver` has issues, we should fix them. It's a waste of energy to work on both.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835:721,optimiz,optimize,721,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2071221835,1,['optimiz'],['optimize']
Performance,"> It returns a int with the value of the number of files or file divisions already performed and the file name. if files are file_part_1.nc, file_part_2.nc, file_part_3.nc, the output will be: `3 file_part_3.nc`. How about calling it `split_files` or `number_of_split_files`?. Could also improve clarity to split it into two functions. One to return the number of split files, and the other to return `current_split_filename`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2414761941:83,perform,performed,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2414761941,1,['perform'],['performed']
Performance,> It seems that you have not performed a convergence test of your numerical model (based on analytical known solutions or manufactured solutions). I suggest that you add this (for instance based on the Taylor Green example); >; > _Originally posted by @funsim in https://github.com/openjournals/joss-reviews/issues/2018#issuecomment-580286479_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/611:29,perform,performed,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/611,1,['perform'],['performed']
Performance,"> It seems very strange to me that evaluating trig functions is slow on GPUs. Is this we problem known to CUDA.jl?; > ; > The information you have here seems good to me. ""slow"" is ill-defined. We recently found that precomputing grid metrics for the latitude-longitude grid leads to a 2x speed up for simple 2D cases (less for more complex cases, probably). But it's all relative to other calculations that are being performed. For many ocean codes the limiting step is evaluating the nonlinear equation of state (a 55 term polynomial) at various locations on the grid. For these cases, the cost of trigonometric functions may not be noticeable.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085:417,perform,performed,417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2029#issuecomment-951425085,2,['perform'],['performed']
Performance,"> It'd be nice to state in writing the justification for writing a separate CPU solver for certain problems. In general, I think that any algorithm that works on the GPU will also work on the CPU. Thus at least in principle the simplest choice is presumably to use the same solver on both architectures. Good point, I've been meaning to set up a script for benchmarking the different pressure solvers. We should use performance benchmarking results to make decisions. > Also, I'd encourage writing this code into as self-contained a submodule as possible. I think there are other codes in the julia ecosystem (not least FourierFlows.jl!) that would benefit from fast and multi-architecture Poisson solvers. We don't have to break this into a separate package just yet, but we do want to ensure this is easy to do in the future. Another good point. As you pointed out some of these solvers depend on the `grid` but if we take that out (which would be trivial) then I think the solvers in PR #589 would be pretty reusable by other packages. Although right now they're pretty specific to staggered grids (except for `BatchedTridiagonalSolver`).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204:416,perform,performance,416,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/586#issuecomment-572303204,1,['perform'],['performance']
Performance,"> Just a quick update, zero-viscosity Bicklet jet test case for `VectorInvariant`, `WENOVectorInvariant` (smoothness calculated based on `ζ`), modified VectorInvariant WENO with smoothness based on 2D stencils of `u` and `v`, here called `WENOVectorInvariantZVEL`; > ; > `VectorInvariant` https://user-images.githubusercontent.com/33547697/157745561-a8e5f128-2f4e-42e3-9305-3f624498590b.mp4; > ; > `WENOVectorInvariant` https://user-images.githubusercontent.com/33547697/157745569-41c52e2d-c80b-4d43-b2bf-8a914e8856a2.mp4; > ; > `WENOVectorInvariantZVEL` https://user-images.githubusercontent.com/33547697/157745571-725ea604-8dec-44bd-bd08-dcd70d9ed4b1.mp4; > ; > `WENOVectorInvariantZVEL` seems to perform actually very well compared to a (somewhat) standard ""vorticity-reconstruction"" `WENOVectorInvariant` and compared to the very noisy standard `VectorInvariant` in lie of the fact that; > ; > * Noise is reduced significantly despite dissipation not being too high; > * Agreement between different resolutions is much higher. Both the WENO vector invariant forms look great, and much less noisy than the non-WENO version. Why do you say the third is better than the second? I don't doubt that it us but my eyes don't see much of a difference. . Out of curiosity, have you computed a time series of the energy?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000:699,perform,perform,699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1064467000,1,['perform'],['perform']
Performance,"> Nah…; > ; > Every preview is 200MB of load on the repo I then have to clean and it’s not that easy to clean up a repository’s history. I’d rather I make the PR twice or built the docs locally :). Oof, didn't know that. Sounds fair :). I'll approve it, although we probably have to restart the failed GPU tests",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2886#issuecomment-1409061309:40,load,load,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2886#issuecomment-1409061309,1,['load'],['load']
Performance,"> Naively, I would think that if one term is computed with WENO5 then 4 terms would be 4 times the cost. Okay, I understand what you're saying and I agree. Assuming that the advection term dominates the cost of a time-step, we could count the number of times the advection term is evaluated and calculate a multiplicative slowdown based on that assumption. One issue with that assumption is that the advection terms compile to different code when using a `BackgroundField`. With a `BackgroundField` the velocity field is stored as a `FunctionField` (with almost no additional memory allocation) rather than raw data. Calling `getindex` on a `FunctionField` resolves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Can you try running the code on the GPU? I think it would be enlightening to see if there's a slowdown in that case. We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. > because presumably the advection of the background state by the background state is zero. I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. The idea being that if there is a valid way to decompose a flow into background and perturbation components, then the equation that governs the background component is completely neglected (this includes both the nonlinear terms and any linear terms involving the background flo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623:1015,optimiz,optimize,1015,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816760623,1,['optimiz'],['optimize']
Performance,"> New log level should be enough if we just need flat per-iteration timings to time a few blocks for a few iterations. Are you thinking of just logging raw `@time` data?; > ; > I'm not sure if we need anything more than a new log level, but I imagine some of the benefits of using a package like TimerOutputs.jl would make the timer blocks much more useful for debugging and for users. It allows for nested timers and produces a very nice table summary at the end which includes number of calls and average time/memory allocations.; > ; > This could also be useful for users wishing to time their simulations to figure out how much time is being spent on I/O vs. in kernels vs. solvers vs. callbacks, etc. I guess I also see timers as a debugging tool for users. Could help be figure out cluster filesystem issues or figure out whether Oceananigans or my coupled model (via callback) is the bottleneck.; > ; > Otherwise if the timers are just a developer debugging tool that dumps timing information, that's useful but it might not be useful for timing real-world scripts/simulations since the log would fill up with a huge number of lines that can't be interpreted without further processing.; > ; > Here's an example of it in use: [JuliaGPU/CUDA.jl#149 (comment)](https://github.com/JuliaGPU/CUDA.jl/issues/149#issuecomment-461943376) (CUDA.jl has been using TimerOutputs.jl for a long time I think); > ; > TimerOutputs.jl is easy to use since you just add `@timeit` blocks but that does add some noise to the code (not sure if more or less than using a timing log level). @ali-ramadhan I was thinking timing would be useful for general use around figuring out where time is going in day-to-day modeling - so some summary table as in TimerOutputs.jl would be a great thing to aim for - I think?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029:891,bottleneck,bottleneck,891,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1862#issuecomment-887967029,1,['bottleneck'],['bottleneck']
Performance,> Nice one. Should we benchmark anything just to make sure this hasn't affected performance?. That's a good idea!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-971712282:80,perform,performance,80,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2063#issuecomment-971712282,1,['perform'],['performance']
Performance,"> No flux are the default for immersed boundary. It looks like you are explicitly setting an immersed boundary condition for a non-immersed field. What is `b`s grid?. The same as `model`s: a MultiRegion grid. I'm not yet using the IB grid since apparently `MultiRegionGrid` isn't working with IBs yet. When I use it, I get this error. ```julia; ERROR: LoadError: MethodError: no method matching PressureSolver(::CPU, ::MultiRegionGrid{Float64, Periodic, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}); Closest candidates are:; PressureSolver(::Any, ::ImmersedBoundaryGrid) at ~/.julia/packages/Oceananigans/Kq8xW/src/Models/NonhydrostaticModels/NonhydrostaticMod",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1309394728:352,Load,LoadError,352,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1309394728,1,['Load'],['LoadError']
Performance,"> Okay finally tests passed!; > ; > @navidcy I tried restarting the tests over and over (honestly more than 10 times over the past few days) and they always failed. I could only make them pass this morning when I restarted them one at a time. That is, starting one, and only restarting the next failed test when the previous one had fully run.; > ; > So maybe the variability we see in tests has to do with different processes trying to access the same resources... ?. Yes it is a race condition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307:481,race condition,race condition,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3648#issuecomment-2223710307,1,['race condition'],['race condition']
Performance,> On Satori using stupidly large meshes gives 85% - 89% efficiency going from 1 to 2 GPU for the `multi_region_turbulence.jl` benchmark (Note `1440×600×48` is the size of the 1/4 degree simulation) Unfortunately the efficiency decreases on a larger number of GPUs... we definitely have to fix the scaling; > ; > #### Strong Scaling; > Grid size	Grid	GPUs	wall time	efficiency; > `1024×1024×100`	`RectilinearGrid`	1	3.4 minutes	100%; > `1024×1024×100`	`MultiRegionGrid`	2	1.9 minutes	89.5%; > `1440×600×48`	`RectilinearGrid`	1	1.4 minutes	100%; > `1440×600×48`	`MultiRegionGrid`	2	49.2 seconds	85.4%; > `1440×600×48`	`MultiRegionGrid`	3	38.8 seconds	72.2%; > Going to smaller meshes than these hampers the efficiency incredibly. I think there might be a lot of low hanging fruits to optimize multi GPU. Nice results though! Is this for implicit or explicit free surface?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116681325:782,optimiz,optimize,782,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116681325,1,['optimiz'],['optimize']
Performance,"> One issue with that assumption is that the advection terms compile to different code when using a `BackgroundField`. With a `BackgroundField` the velocity field is stored as a `FunctionField` (with almost no additional memory allocation) rather than raw data. Calling `getindex` on a `FunctionField` resolves to calling a function, whereas calling `getindex` on a `Field` / `Array` fetches data from memory. So they are different. Good to know. Thanks for explaining. > Naively I would expect that evaluating a complicated advection term involving `BackgroundField` would be cheaper than one that involved two concrete `Array`. But sometimes unexpected things happen (the compiler might decide to optimize the code differently...). Agreed! Often unexpected things happen, which keeps us on our toes. > We could potentially implement an interface whereby `Field`s can be used as `BackgroundField` rather than functions. That might give us some insight, because then the ""additional"" advection terms associated with `BackgroundField` would truly be identical to the ""original"" advection term. I don't pretend to understand the details of this and don't know the potential pay off so not sure whether I think this will bear fruit or not. > I would say that the background self-interaction terms are _neglected_ rather than presumed to be zero. Linear terms associated with the background fields are also neglected. . Good. > _Side note:_ some nonlinear terms are additionally neglected in the case of nonlinear viscosity. Ah, I don't think I'm getting into that now but it's something to be aware of.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816780988:699,optimiz,optimize,699,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1564#issuecomment-816780988,1,['optimiz'],['optimize']
Performance,"> One thing to note is that the current implementation appears to be very slow. While the simulation with the `SmagorinskyLilly` closure runs on my laptop in 10 seconds, it takes 4 minutes for the simulation with the `ScaleInvariantSmagorinsky`. I know the dynamic model will be slower given the extra computations, but such a difference seems large to me, so I'm hoping something can be changed here to improve performance:. Avoided recomputation of the strain rate at `ccc` and sped things up a bit more. Now it runs in 2.9 minutes. A lot more to go...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2241696460:412,perform,performance,412,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2241696460,1,['perform'],['performance']
Performance,"> Perhaps we could convert to this: https://github.com/DTolm/VkFFT which supports hardware-accelerated FFT on CUDA, Metal and lots of others. It looks like that library is more performant than `cuFFT` as well. Why do we have to convert? Can we use that only for Metal?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734543134:177,perform,performant,177,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3288#issuecomment-1734543134,1,['perform'],['performant']
Performance,"> Point taken, but I think there are still Oceananigans-relevant applications where Value / Gradient boundary conditions on non-immersed boundaries are useful enough to be a ""core"" feature (e.g. imposing observed SST patterns rather than observed air-sea heat fluxes), but there is always the workaround of strongly restoring boundary-adjacent sponge regions. I think this is what many ocean modelers do to implement such boundary conditions anyway. True! I'm not aware that has ever been done, but since it's not difficult to support (notwithstanding @simone-silvestri's concerns about parallel performance) it's interesting to allow it --- agree. For future readers I want to point out that SST restoring (and similar models) are typically be implemented as a `FluxBoundaryCondition` using a piston velocity model, rather than using `ValueBoundaryCondition` (which implies a flux mediated by some diffusivity / viscosity, possibly derived from a parameterization). (`FluxBoundaryCondition` is mathematically identical to restoring in the surface grid point, though it would be a slightly different model to distribute the restoring over some depth). It could be an interesting project to explore using some parameterization-derived diffusivity together with `ValueBoundaryCondition` to predict surface fluxes, though, I'm not sure what the implications would be.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452:596,perform,performance,596,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1690278452,1,['perform'],['performance']
Performance,"> Possibly, we should start using a merge queue that would disallow PRs from being merged unless tests pass. Yeap. I added these in https://github.com/CliMA/Oceananigans.jl/settings/branches. <img width=""905"" alt=""Screenshot 2023-12-23 at 1 10 26 pm"" src=""https://github.com/CliMA/Oceananigans.jl/assets/7112768/3137d7ef-2f34-4f05-86fa-c759177ac164"">. How does this sound?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868271224:42,queue,queue,42,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3413#issuecomment-1868271224,1,['queue'],['queue']
Performance,"> Seems like we have to ensure that types are correct... I ll take a look. This is really a compiler issue... I guess we ""shouldn't"" have to enforce types, but maybe it helps with inlining (which we need for performant code and GPU compilation)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128949553:208,perform,performant,208,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2558#issuecomment-1128949553,1,['perform'],['performant']
Performance,"> Shoudn't we write a kernel? Presumably that explicit 3D loop is incredibly slow?. Indeed! Unfortunately it's not embarrassingly parallel so my kernel skills are no longer sophisticated enough :) I don't know how to gather `count`, `rowval` or `colval`. The conditional preseumably also leads to poor performance (but no where near as poor as it is now!).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1248734171:302,perform,performance,302,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1248734171,1,['perform'],['performance']
Performance,"> Should we also try things like; > ; > ```julia; > node(i, j, k, grid, ::Nothing, ℓy, ℓz) = _node(i, j, k, grid, nothing, ℓy, ℓz)[1:2]; > ```; > ; > I think we determined there could be a tiny performance loss but it would make the code a little simpler and also easier to read since we don't have to define every combination of locations for `_node`. Hmm this is more annoying than I thought so I'll leave it for later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960:194,perform,performance,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3355#issuecomment-1775509960,2,['perform'],['performance']
Performance,"> Since the aim is to work with abstract operations, FieldTimeSeries right now only work with JLD2 data that includes halos. Do we want to support loading data without halos?. We generally need to support `SlicedField` so I suggest we implement such support in that context. Until then, I think users need to be aware that they need `field_slicer=nothing` to use this experimental feature. Once this feature is mature, I think that `field_slicer=nothing` should be the default. Some of the most important calculations we do are on boundaries. The reason to omit halos that contain useful information about boundary conditions is only for ""convenience"" --- this feature eliminates that concern so that more science can be done.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835434572:147,load,loading,147,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1641#issuecomment-835434572,1,['load'],['loading']
Performance,"> Since we need the performance provided by KA 0.7, and we need to use KA 0.8+ on GPU, does that mean that we should invest in developing our own CPU infrastructure (replicating what KA 0.7 offered) to achieve that performance?; > ; > Another possibility is that we re-write much of the code base to avoid the performance pitfalls we are currently facing in order to get back to the level of performance we have with current code + KA 0.7. I believe the issue is basically an interaction between some of the abstractions / indirection we have developed and the compiler, so possibly rolling back that abstraction / indirection will bring us back to where we were previously. To follow up with @vchuravy, it seems that rewriting just _some_ of the code was sufficient, so we are (probably) in the clear! The lesson learned is that we cannot slurp / splat `@kernel` function arguments, because it prevents the kernel code from being inlined.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741:20,perform,performance,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1482198741,8,['perform'],['performance']
Performance,"> So it appears that there are two competing bug here, which kinda cancel out in the case where gravity aligned with the vertical direction. I also think that back in #1910 when we saw some weird effects when not separating the pressure, this might have been it. No, I don't think so. We reconstructed correctly previously when performing the hydrostatic pressure integral. The only bug was for tilted gravity, or not using the pressure integral.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518046160:328,perform,performing,328,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3079#issuecomment-1518046160,1,['perform'],['performing']
Performance,"> So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`.; > ; > This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward...; > ; > Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation.; > ; > I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case... I also prefer the copy/paste method (that's what I used in https://github.com/CliMA/Oceananigans.jl/pull/3111). If I understand correctly these two functions are the only ones that need to be generalized, no?: . https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L74-L83. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L88. if so, that's not too bad. Is duplicating one of the tests in [test_batched_tridiagonal_solver.jl](https://github.com/CliMA/Oceananigans.jl/blob/main/test/test_batched_tridiagonal_solver.jl) but rotating everything to two different directions enough to test this new functionality?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584:583,perform,performs,583,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1560271584,1,['perform'],['performs']
Performance,"> Sorry I don't quite understand: Is this potentially affecting the calculations right now, or will it only be an issue if we upgrade to CUDA 3.5+?. CUDA 3.8 includes features that may allow us to decrease register pressure or implement performance optimizations that would otherwise be difficult or impossible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025963063:237,perform,performance,237,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2202#issuecomment-1025963063,2,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"> Sorry for not following, but I don't see what breaks here for the end user! Could someone give a quick example/explanation?. Apologies that my explanation was not clear. It's a breaking change because the same user input, such as. ```julia; tke = @at (Center, Center, Center) ((u - U)^2 + (v - V)^2 + w^2) / 2; ```. produces a different object after this update:. * Before this PR, `u - U` would be interpolated to `(Center, Center, Center)`, and then the binary operation `^(2, u - U)` would be calculated at `(Center, Center, Center)`.; * After this PR, both `u - U` and `^(2, u - U) = (u - U)^2` are calculated at `(Face, Center, Center)`. Interpolation is then performed to `(Center, Center, Center)` _after_ the exponentiation to form the three-part sum. Let me know if that makes sense or if another example would be useful.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1599#issuecomment-823698116:667,perform,performed,667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1599#issuecomment-823698116,2,['perform'],['performed']
Performance,> Testing with validation/mesoscale/baroclinic_adjustment.jl seems to indicate that the race condition is eliminated from the changes to the fill_halo_region! function. Was there a race condition there?. Could you please point to the relevant issue describing the condition just for completeness?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136:88,race condition,race condition,88,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-920113136,2,['race condition'],['race condition']
Performance,"> That probably shouldn't have changed, can you file an issue on CUDA.jl/GPUArrays.jl? I'll have a look next week. The only change to `@allowscalar` that comes to mind is task/thread-safety, which does come at a certain performance cost (it now does a TLS lookup instead of a simple pointer check, but the cost of that should be negligible compared to the subsequent memory transfer). Seems I can't reproduce the supposed error so, sorry, my bad... Something else must have been the issue. 😔",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393:220,perform,performance,220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-817385393,2,['perform'],['performance']
Performance,"> That said, I wasn't aware that 3D averages in particular were memory-intensive, so I might rethink that rationale. 3D averages require scratch space for accumulating the average; this is why they are memory intensive. It's possible to compute averages just on slices or windowed regions of the domain. If this works for your application, you can consider it to reduce memory allocation. > I'd need a lot of disk-space to output the 3D fields at such high frequencies, so it's a storage limitation issue. . In principle, you can use a callback to accumulate an average on the CPU from data on disk, and then delete the data periodically as the simulation runs. You can also accumulate the time-average on the CPU. These methods may not be performant, however, depending on the balance between the cost of CPU-GPU data transfer, and other costs in your simulation. If you have to accumulate a 3D time-average for performance reasons, then you have no choice but to allocate a 3D field on the GPU for this purpose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685:740,perform,performant,740,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2794#issuecomment-1301417685,2,['perform'],"['performance', 'performant']"
Performance,"> The Roquet’s approximation is perfectly sufficient for Oceananigans, because it will never be used for global calculations where local approximations are an issue. However I agree with everybody else that it would be best to use the same EOS in Ocenanigans and Climate_Ocean. in that case we should adopt TEOS-10. Be warned that it is quite inefficient through. So we may be hit performance-wise. Hard to tell without trying. Thanks for the feedback @rafferrari. I talked to @leios earlier today and we think it shouldn't be a problem on the GPU. It's just straight up number crunching so it might benefit from being run on a GPU. But we can make sure by doing a quick benchmark.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596868076:381,perform,performance-wise,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/692#issuecomment-596868076,1,['perform'],['performance-wise']
Performance,"> The main issues are when the entirety of a heavy kernel (like one that calculates a tendency) may be promoted to higher precision. `fill(var, 0)` is cheap and unlikely to affect performance.; > ; > That said it's just more precise to write `fill(var, zero(eltype(var)))` (this is _exactly_ what you are trying to do) and therefore the preferred way to write it. You were meant to write `fill!` not `fill` right? For `fill!(::AbstractArray,0)` this is what happens. ```julia; julia> a = Float32[1,2,3]; 3-element Vector{Float32}:; 1.0; 2.0; 3.0. julia> @code_llvm fill!(a,0); ; @ array.jl:346 within `fill!`; define nonnull {}* @""julia_fill!_127""({}* noundef nonnull align 16 dereferenceable(40) %0, i64 signext %1) #0 {; top:; ; @ array.jl:347 within `fill!`; ; ┌ @ number.jl:7 within `convert`; ; │┌ @ float.jl:159 within `Float32`; %2 = sitofp i64 %1 to float; ; └└; ```. So the very first thing is that if `eltype` of the array and type of second argument aren't the same then it's converted (the `%2 ...` line); Using `fill!(var, zero(eltype(var)))` then can skip this conversion (it's compiled away) but the result is the same. You can make and educated guess of the type of the zero, but honestly, I wouldn't even bother. It has probably zero impact on performance for any larger than a few elements and I find `fill!(A,0)` very clear to read too, so that's what I now always try to write.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023:180,perform,performance,180,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3271#issuecomment-1723777023,4,['perform'],['performance']
Performance,> The new commit follows the suggestion of overloading the compute! method to apply it on a tuple of ComputedField. Good point that we may not need an independent type (except for the very minor performance optimization of precomputing the compatibility between fields -- which probably doesn't matter),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1696117967:195,perform,performance,195,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3234#issuecomment-1696117967,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"> The new default, converting Int64 exponents to Float64, seems better. Unless `power_by_squaring` performs better in realistic applications?. I don't think we ever used `power_by_squaring`, because the ""pre 1.6"" Oceananigans kernels were defined via`KernelAbstractions`, which in turn translated `^(a, b)` to `CUDA.pow(a, b)`:. https://github.com/JuliaGPU/KernelAbstractions.jl/blob/fdb7415b6f6083c23451cc526b0637144322b1cb/lib/CUDAKernels/src/CUDAKernels.jl#L289. This means that ""pre 1.6"" we were exponentiating with `nv_powi`... In ""current"" Oceanagnians (before this PR), changes to KernelAbstractions and CUDA seem to imply that we invoke `nv_pow` instead. And for some reason this can slow down our code by 10-15x (!!) as discussed on #1764 . Does CUDA C do special transformations for `powi(x, Int32(2))`? Eg, does it convert `powi(x, Int32(2))` to `x*x` (or something like that)? I've no idea but maybe there are some massive algebra reductions / expression eliminations that occur for our weird WENO5 code when we ask for `x*x` versus `x^2.0` ... ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870014674:99,perform,performs,99,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-870014674,1,['perform'],['performs']
Performance,> The performance plots on the README.md file show that the single precision speed up for CPUs is below 1. This is surprising and should be commented on.; >; > _Originally posted by @funsim in https://github.com/openjournals/joss-reviews/issues/2018#issuecomment-580286479_,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/607:6,perform,performance,6,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/607,1,['perform'],['performance']
Performance,"> The preview isn't showing for me. But we can fix any issues later, so I say merge away. Yeah, It's also not loading for me. It feels like whenever I try to check PR previews it's kinda hit or miss. I wonder if this is an issue with Documenter. But if you're okay with it, I'll merge it and we can fix any problems later.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963566951:110,load,loading,110,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2045#issuecomment-963566951,1,['load'],['loading']
Performance,"> The problem is not only with the `Nothing`, it's that the reduced fields are effectively launched with a reduced grid size; > ; > for example the west boundary kernel launch for a `(Center, Center, Center)` field will be of size `Ny*Nz` for a `(Center, Center, Nothing)` it will be of size `Ny`; > ; > For the moment I just filter the reduced fields and do them individually. I don't think it will create too much problem. This is only an optimization for time-stepping where we do not have too many reduced fields (only free surface I think). Ah indeed, I see now.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029:441,optimiz,optimization,441,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2335#issuecomment-1065529029,1,['optimiz'],['optimization']
Performance,"> The tests use a lot of scalar indexing that's why they fail on the GPU:; > ; > https://buildkite.com/clima/oceananigans/builds/15604#018f40ed-787d-4e74-a5f4-ae1656fa3043/18-724; > ; > I think if we are comparing single numbers it makes sense to use `@allowscalar`.; > ; > If we are comparing vectors it could be nice to figure out how to get the tests to run without `@allowscalar` since presumably this is possible. Given that we're comparing elements of vectors with a maximum length of 6, I opted to use `CUDA.@allowscalar`. The impact on performance in this situation is minimal when running on a GPU.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2103388821:544,perform,performance,544,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3573#issuecomment-2103388821,1,['perform'],['performance']
Performance,"> There was a bug in some recent updates to KernelAbstractions.jl that caused Enzyme to break on broadcasting arrays in Oceananigans. This PR includes a test to make sure this bug doesn't occur again. Interesting! I think it's ok to add a broadcasting test. But it will be confusing to future developers if the test is explained / written as somehow testing a bug in _another_ package. If there's a bug somewhere else, we need a test in that packge (presumably that has been added). . This test also seems a little complicated. Why not just write a simple function that does a broadcast, and then try to autodiff that? Why do we need initial conditions, models, etc?. For example. ```julia; function times_c!(a, b, c); a .= b .* c # c is a number; return sum(a) # or whatever we gotta return; end. grid = RectilinearGrid(arch, size=(1, 1, 1), extent=(1, 1, 1)); a = CenterField(grid); b = CenterField(grid); c = 2; @test try ; autodiff(times_c!, a, b, c... # or something); true; catch; false; end; ```. It's super important for tests to be as short and easy to understand as possible, because maintaining test code is one of the main bottlenecks on development.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2105014020:1135,bottleneck,bottlenecks,1135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3598#issuecomment-2105014020,2,['bottleneck'],['bottlenecks']
Performance,"> Thinking of revamping this, I think `T` is a good notation; we do not need to specify `U` and `C` since probably (in the future) we will need to refactor these a little to pass through boundary conditions. Hopefully we don't have to pass boundary conditions 🥺 . Not all complexity is justified by the performance gains...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236:303,perform,performance,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2329666236,1,['perform'],['performance']
Performance,"> This PR removes the PencilFFT library from Oceananigans and builds a distributed FFT solver using Oceananigans' inhouse transforms. This allows us to run on GPUs both periodic and bounded domains. No stretched mesh is supported at the moment (that will come in a later PR); > ; > The transposition is performed through a custom `transpose` routine built for Oceananigans' fields that assumes; > ; > * the starting configuration is always a _z-free_ configuration.; > * the transpose directions are _z-free_ -> _y-free_ -> _x-free_ -> _y-free_ -> _x-free_; > * the y-direction is integer divisible by the number of ranks that divide the x-direction; > * the z-direction is integer divisible by the number of ranks that divide the y-direction; > ; > An additional assumption is that:; > ; > * if TY is Bounded, also TZ needs to be Bounded; > * if TX is Bounded, also TY needs to be Bounded; > ; > All these assumptions can be relaxed in following PRs. Are these statements still accurate?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850:303,perform,performed,303,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197303850,1,['perform'],['performed']
Performance,"> This is super exciting! Out of curiosity is there any/which Krylov solver is compatible on multiple GPUs? Seems to be an important bottleneck for our current `PreconditionedConjugateGradientSolver` approach. Also to be clear about what this can do --- with Krylov, we can still use the FFT preconditioner. When we do that the parallelism issues are identical to the issues with our current CG solver, it's just that tweaking the solver method might allow us to do fewer iterations. So there are two things going on in this discussion which are independent. First is whether conjugate gradient is optimal or whether we should use a different method. The second issue is the preconditioner, which is the more uncertain part but where we might have more gains.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387264231:133,bottleneck,bottleneck,133,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3803#issuecomment-2387264231,2,['bottleneck'],['bottleneck']
Performance,"> This is the same benchmark performed with `ImplicitFreeSurface`, by imposing a divergent velocity `u(x, y, z) = x / 10` to make sure the implicit solver iterates. Looking at the results it seems like it doesn't iterate too much... (probably WENO cleans up?) And it is very weird that the `RectilinearGrid` version is not affected by the FreeSurface calculation? (I have double checked that the free surface solver is correct); > ; > #### Strong Scaling; > Grid size	Grid	GPUs	wall time	efficiency; > `1440×600×48`	`RectilinearGrid`	1	1.37 minutes	100%; > `1440×600×48`	`MultiRegionGrid`	2	1.05 minutes	65.2%. THATS CALLED A SPEED UP 🍻 . I think bathymetry interferes with the solver more. When the velocity field is _purely_ divergent + barotropic, it just produces waves that dissipate nearly instantly ?. It'd be good to come up with a reliable 3D initial condition for benchmarking iterative solver stuff....",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626:29,perform,performed,29,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1116787626,1,['perform'],['performed']
Performance,"> True. Ideally we want to be close to the scalings/performance we got with lat-lon grid? That’s perhaps not feasible..? I don’t know how close is good enough tho. We expect to be at lower performance. For that reason we have dedicated two independent milestones to the cubed sphere. The first milestone is rather susinct ""complete the cubed sphere implementation"". The second milestone pertain to performance: ""achieve 10 SYPD at 25 km resolution"". I think this is nice, because we want to separate tasks into ones that are _required_ for correct functionality, versus tasks that are oriented towards performance rather than correctness.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468:52,perform,performance,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201#issuecomment-1719389468,4,['perform'],['performance']
Performance,"> We need some PlotRecipes for fields...; > ; > (In general, not for this PR!). We need that badly... I think we should take the approach in `ClimaCore.jl` which is to develop an ""external"" package that lives in `/lib`. Perhaps `Makinanigans.jl` or `Vizinanigans.jl`. Performing new releases is a little more arduous with that setup but its probably worth it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034179606:268,Perform,Performing,268,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2238#issuecomment-1034179606,1,['Perform'],['Performing']
Performance,"> We won't reduce computations, because these operators are not short-circuiting (this is what we want to maximize performance for these inner functions).; > ; > Evaluating booleans isn't expensive. Short-circuiting logic can be expensive (or rather, prevent compiler optimizations) in hot inner loops. We've written the code so we don't use short-circuiting logic (`ifelse` rather than `if`, `&` rather than `&&`). Ah, I see. I hadn't noticed that. . > Either way we need both `east_bounded` _and_ `solid_interface` so the question is just how we shuffle logic between the two. We can consider changing `solid_interface`. If we change its behavior I would recommend calling it `fluid_solid_interface`. I think changing `solid_interface` to `fluid_solid_interface` (along with it's definition of course) is clearer. Especially because `solid_interface` confused me at first; I thought it effectively was supposed to test for the fluid-solid interface. But at this point I don't feel strongly about it.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281:115,perform,performance,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2263#issuecomment-1047193281,4,"['optimiz', 'perform']","['optimizations', 'performance']"
Performance,"> What if we get rid of `parameters` and `computed_dependencies`, and call `compute!` on all the arguments?. That'd work for me. Would that have the same performance or would it add some overhead?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1068561902:154,perform,performance,154,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2340#issuecomment-1068561902,1,['perform'],['performance']
Performance,"> What if you edit the forcing functions into the discrete form, e.g. invoking `Forcing` with `discrete_form=true`?. It helps! But doesn't solve the problem. In particular the MWE above (with two tracer) in discrete form compiles for me. But when I add more tracers (I need at least 6 tracers for my simulations) it fails again. Sometimes with a different error:. ```; ERROR: LoadError: Failed to compile PTX code (ptxas exited with code 255); Invocation arguments: --generate-line-info --verbose --gpu-name sm_60 --output-file /glade/scratch/tomasc/jl_hs9AZo7IJq.cubin /glade/scratch/tomasc/jl_XSJ4P4z47a.ptx; ptxas /glade/scratch/tomasc/jl_XSJ4P4z47a.ptx, line 5136; error : Entry function '_Z23julia_gpu_calculate_Gu_7ContextI14__CUDACtx_Namevv14__PassType_312v12DisableHooksE18_gpu_calculate_Gu_16CompilerMetadataI10StaticSizeI9_8__8__6_E12DynamicCheckvv7NDRangeILi3ES5_I9_1__1__6_ES5_I11_16__16__1_EvvEE11OffsetArrayI7Float64Li3E13CuDeviceArrayIS9_Li3ELi1EEE15RectilinearGridIS9_8PeriodicS12_7BoundedS9_S9_S8_IS9_Li1ES10_IS9_Li1ELi1EEES8_IS9_Li1E12StepRangeLenIS9_14TwicePrecisionIS9_ES15_IS9_E5Int64EES8_IS9_Li1ES14_IS9_S15_IS9_ES15_IS9_ES16_EES8_IS9_Li1ES10_IS9_Li1ELi1EEEvE4WENOILi3ES9_vv5TupleIS8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEES8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEES8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEES8_IS18_IS9_S9_S9_ELi1ES10_IS18_IS9_S9_S9_ELi1ELi1EEEELitrueEvS17_ILi2ES9_vvS18_IS8_IS18_IS9_S9_ELi1ES10_IS18_IS9_S9_ELi1ELi1EEES8_IS18_IS9_S9_ELi1ES10_IS18_IS9_S9_ELi1ELi1EEES8_IS18_IS9_S9_ELi1ES10_IS18_IS9_S9_ELi1ELi1EEEELitrueEv12UpwindBiasedILi1ES9_vvvv8CenteredILi1ES9_vvvvEES20_ILi1ES9_vvvvEES20_ILi2ES9_vvvS20_ILi1ES9_vvvvEEEvv16SmagorinskyLillyI26ExplicitTimeDiscretizationS9_10NamedTupleI34__b____1____2____3____4____5____6_S18_IS9_S9_S9_S9_S9_S9_S9_EEE17BoundaryConditionI4FluxvEvS23_I23__velocities___tracers_S18_IS23_I12__u___v___w_S18_I9ZeroFieldIS16_Li3EES26_IS16_Li3EES26_IS16_Li3EEEES23_I34__b____1____2____3____4____5____6",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112:376,Load,LoadError,376,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2869#issuecomment-1401133112,1,['Load'],['LoadError']
Performance,"> What parallelism strategy makes sense? One particle per thread?. I think that makes sense, and we just queue up a huge amount of blocks like we already do with 3D kernels. Although if we use DifferentialEquations.jl then maybe we won't have to worry about parallelism here?. > Do we use linear interpolation between velocity nodes or assume a constant velocity within each cell (nearest neighbor interpolation)?. Yeah I'm not super sure what's a good approach here. We're on a regular Cartesian grid right now so maybe the difference isn't huge?. The [Parcels v2.0 paper by Delandmeter & van Sebille (2019)](https://www.geosci-model-dev.net/12/3571/2019/) discusses interpolation schemes for curvilinear C-grids using mostly Lagrange polynomials. But on a rectilinear grid like ours, it seems that it just reduces down to linear interpolation [see Eq. (3)]. Maybe a good question for @jm-c. > Obtaining prognostic quantities within particles (like reacting chemical species with reaction rates that depend on ambient temperature) may be challenging and probably requires a careful design. Agreed. It may not even be clear what a good solution is. Apparently DARWIN has a similar problem I think where many plankton species may be uptaking nutrients so the question of what to do when a nutrient are depleted is hard to solve, especially as having nutrients go below zero can be bad for the model.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399:105,queue,queue,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/511#issuecomment-547215399,1,['queue'],['queue']
Performance,> When I ran this locally I got a load of `@test_broken` passing for computed fields which is quite strange. We don't test those regularly --- it might be a new compiler etc. You can feel free to convert those to `@test` if you want to be a hero 💪,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2181261472:34,load,load,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2181261472,1,['load'],['load']
Performance,"> When utilizing a split-explicit free surface, additional errors arise. For instance, for MultiRegionGrid and ConformalCubedSphereGrid (when specifying the number of substeps), we encounter:; > ; > ```julia; > ERROR: LoadError: UndefVarError: `settings` not defined; > ```; > ; > When specifying both grid and cfl for ConformalCubedSphereGrid, the following error occurs:; > ; > ```julia; > ERROR: LoadError: type OrthogonalSphericalShellGrid has no field Lz; > ```. Do you need help fixing these?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276:218,Load,LoadError,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1744978276,2,['Load'],['LoadError']
Performance,"> Where does this PR leave #2538? As I understand it we do not treat vertically stretched grids here (or a mixed FFT/tridiagonal solver). So this moves laterally compared to #2538 and perhaps the algorithm implemented there can be adapted once this is merged?. I was planning was to implement the tridiagonal solve similarly to what we do for single GPU as such:; ```julia; transpose_z_to_y!(storage) # copy data from storage.zfield to storage.yfield; solver.plan.forward.y!(parent(storage.yfield), buffer.y) ; transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.forward.x!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ; # Perform the implicit vertical solve here on storage.zfield... transpose_z_to_y!(storage); solver.plan.backward.y!(parent(storage.yfield), buffer.y); transpose_y_to_x!(storage) # copy data from storage.yfield to storage.xfield; solver.plan.backward.y!(parent(storage.xfield), buffer.x); transpose_x_to_y!(storage) # copy data from storage.xfield to storage.yfield; transpose_y_to_z!(storage) # copy data from storage.yfield to storage.zfield; ```. This is not super great because it requires eight transposes, but I think it's the same thing that was happening in #2538",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003:807,Perform,Perform,807,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-2197384003,1,['Perform'],['Perform']
Performance,"> Where in the model should we store the forcing array in this case?. The user would define an array in a script, declare it `const` to the compiler, and then write a function that indexes into it as a global:. ```julia; # define a; forcing(..., i, j, k) = a[i, j, k]; ```. We can also include a constructor for `Forcing` that allows the user to pass some function that defines a constant array, and set up the same functionality internally. > The main motivation being that we don't have to write extra functions that dispatch on the forcing, thus simplifying the time stepping code. As you point out we don't want to write 5! = 120 new functions. The update_source_terms! function is already 52 lines long so I'd rather avoid having to dispatch on this function. I think the problem is that our functions are trying to do too much at once. We need smaller functions that perform more atomic operations so we can dispatch on atomic operations. I don't think we need to re-invent multiple dispatch with macros. We just need to refactor the code so we can use multiple dispatch effectively.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414:873,perform,perform,873,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/110#issuecomment-470556414,1,['perform'],['perform']
Performance,"> While we should try to use powers of 2 for performance, I think that overly restricts the model resolutions we can be running at. There are a LOT of choices between e.g. `512x512x128` and `1024x1024x128`. It might be that the largest model that fits in memory isn't nice powers of 2. Users may have various reasons for running resolutions that aren't powers of 2. I over-simplified. FFTs are efficient when there are a small number of prime divisors --- 2, 3, 5, 7 --- of the length of the sample. 100 may actually be ok because it is 2\*2\*5\*5. I don't feel strongly, but you will find that most people running simulations are using powers of 2 and 3 (128, 192, 256, 384, 512, 768, 1024) --- even when their code has no FFTs! Perhaps the purpose of this convention is so people who *do* use codes that rely *heavily* on FFTs are able to run code comparisons. I find the convention to be an appropriate best practice. An 1D FFT of length 257, for example, is 4 times slower than an FFT of length 256 on my machine. For tests, of course, using small numbers of prime divisors is completely irrelevant; I just want to encourage best practices and promote awareness of them, and also implicitly emphasize to users that this code uses FFTs, and don't want random person X to read the tests and scratch their head and ask ""doesn't this code rely on FFTs?"" (like I did when I saw the examples). > Just a note that if we want to reuse `model.metadata.arch` with GPUifyLoops.jl then the options should be `:CPU` and `:GPU` (instead of `:cpu:` and `:gpu` which is what `ModelMetadata` currently uses) as I believe GPUifyLoops.jl expects ""capitalized"" Symbols. I certainly prefer that. It may be academic because the architecture should probably be a parameter of `Model`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468533848:45,perform,performance,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468533848,1,['perform'],['performance']
Performance,"> Yeah sure, we can do it. ~~Is there a performance difference?~~. ~~The best solution might use dispatch to enable ""non-stretched WENO"" automatically when the grid has constant spacing.~~. After actually looking at the code, it seems this is what this PR does do, indeed.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969063314:40,perform,performance,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-969063314,1,['perform'],['performance']
Performance,"> Yeah this is pretty worrying... I'm pretty sure this is the cause of #1420 which has been open for a while so this slowdown must have been around for a while (and just flew under the radar). [Profiling](https://docs.julialang.org/en/v1/manual/profile/) might help pinpoint the bottleneck. It looks like there are some extra temporary arrays being created for the cases with non-trivial (although still pretty trivial) indexing patterns. Profiling could be good - also just turning off as much as possible and then building up from the FFT alone, simple stencil etc... - if that is possible?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627:279,bottleneck,bottleneck,279,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1919#issuecomment-891443627,2,['bottleneck'],['bottleneck']
Performance,"> Yep, I would call it bulk velocity though, instead of phase speed, and change the name from `Orlanski` to something more descriptive like `AdvectiveOutflow`. But these are mathematically identical right? Orlanski called is a ""phase speed"", but ""outflow velocity"" is equally valid and refers to exactly the same mathematical object. The reference you posted says. > The test results also confirm that this type of boundary condition, which was originally designed by Orlanski primarily for equations which are hyperbolic in nature, also performs well for parabolic problems. I think we can keep the name ""Orlanski"" and provide a generic interface for specifying the outflow speed (whatever you want to call it). It can be user-specific, dynamically computed, etc. The code can be extensible, so if users want to experiment with different methods for computing the outflow speed, this is possible.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965488832:538,perform,performs,538,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1965488832,1,['perform'],['performs']
Performance,"> [AMGX.jl](https://github.com/JuliaGPU/AMGX.jl) only has prebuilt libraries for linux systems. That said, calling using AMGX will fail on, e.g., Mac OS X. What's the best way to optionally load AMGX.jl? Or is there another way around that?. @simone-silvestri any ideas for how to solve this?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242544194:190,load,load,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1242544194,1,['load'],['load']
Performance,"> `2)` is because I cannot think of a situation where you would want to output something different than Array? But please correct me if I'm wrong. I haven't found another example in this repository. We chose `array_type` to permit the flexibility of other array types. I don't know enough to say that we would _never_ want another array type. Better to be defensive than aggressively constraining user action?. `Float32` used to be the default. However, this produced a lot of pain in some testing situations where we wanted to show bitwise reproducability / accuracy in saving. I can't remember all the details, but after a few user issues (in addition to our own pain), we decided to switch to Float64. I agree that Float32 is better, but could be regarded as ""premature optimization"" in this case. Definitely open to discuss though.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679415894:773,optimiz,optimization,773,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3214#issuecomment-1679415894,1,['optimiz'],['optimization']
Performance,"> ```julia; > [ Info: ... simulation initialization complete (1.471 minutes); > [ Info: Executing initial time step...; > ERROR: LoadError: TaskFailedException; > ; > nested task error: TaskFailedException; > ; > nested task error: type Tuple has no field surface_TKE_flux; > Stacktrace:; > [1] getproperty(x::Tuple{CATKEVerticalDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.MixingLength{Float64}, Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.SurfaceTKEFlux{Float64}}, AnisotropicDiffusivity{VerticallyImplicitTimeDiscretization, Float64, Float64, Float64, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}, NamedTuple{(:b, :c, :e), Tuple{Float64, Float64, Float64}}}}, f::Symbol); > @ Base ./Base.jl:33; > [2] call; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:456 [inlined]; > [3] fallback; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:454 [inlined]; > [4] overdub; > @ ~/.julia/packages/Cassette/1lyEM/src/context.jl:279 [inlined]; > [5] overdub; > @ ~/.julia/packages/Oceananigans/H39qI/src/TurbulenceClosures/turbulence_closure_implementations/CATKEVerticalDiffusivities/surface_TKE_flux.jl:39 [inlined]; > [6] getbc(::BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{Oceananigans.TurbulenceClosures.CATKEVerticalDiffusivities.TKETopBoundaryConditionParameters{NamedTuple{(:b, :c, :e), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.BoundaryConditions.DiscreteBoundaryFunction{NamedTuple{(:Ly, :Lz, :Qᵇ, :y_shutoff, :τ, :μ, :ΔB, :H, :h, :y_sponge, :λt), NTuple{11, Float64}}, typeof(buoyancy_flux)}}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}}, NamedTuple{(:u, :v), Tuple{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Oceananigans.Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418:129,Load,LoadError,129,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2225#issuecomment-1030744418,1,['Load'],['LoadError']
Performance,"> and we'll only have to dispatch on one type instead of three. I guess the point of this design is to simplify more generalized dispatch by ""unfusing"" the three directions. The solution you're proposing is simply returning to what we were doing before, right?. Note one immediate advantage: the `nodes` function now works with *any* field (and the implementation is actually less code than before). We lose this feature and must return to dispatching on lots of different cases (as you say, unions), if we fuse the three directions into one type. . However, this becomes even more critical when we think about abstracting operators. When performing an `x` derivative, for example, we know that the field changes location from `{Cell, Y, Z}` to `{Face, Y, Z}`. If the directions were fused, we would have to code each 3D case manually, rather than the 1 (or 2) cases we need with this design. When writing an abstracted interpolation function from an arbitrary location `X1, Y1, Z1` to `X2, Y2, Z2`, it greatly simplifies the task if the directions are ""unfused"". I think it's also easier to reason about abstracted operators on fields this way.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/409#issuecomment-531763391:639,perform,performing,639,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/409#issuecomment-531763391,1,['perform'],['performing']
Performance,"> the constructors of a CuSparseMatrix are different from the ones for a SparseMatrix. Can the constructors for CuSparse be derived from Sparse? If so, we just build the sparse on CPU, and then implement `arch_array`. > It means that we will first have to create the full matrix (of size Nx * Ny x Nx * Ny!!) Or is this computationally/memory-wise restrictive?. I think you should avoid allocating the whole matrix and build the sparse representation on the fly. The sparse representation is like a graph --- we add nodes only when they exist. Once we've built the graph, we can convert it to a computationally efficient format for time-stepping on CPU or GPU. > Also it is kind of a brute force which would be quite computationally inefficient because it scales badly. I propose we get this up and running in 2D and see whether this is a feasible calculation to perform during model construction. There is the question of preconditioners / changing time-step. Do the sparse matrix implementations we work with have efficient implementations for operations like. ```julia; A += b * I; ```. where `I isa UniformScaling` and `b` is a scalar?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238:863,perform,perform,863,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2396#issuecomment-1109680238,1,['perform'],['perform']
Performance,> the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. What does this have to do with putting boundary conditions in operators?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2356567627:14,perform,performance,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2356567627,1,['perform'],['performance']
Performance,"> then we'd have to rewrite loads of stuff to make it so the user can specify whatever they want for the external state. I think see your point (I'm not sure I grasp the totality of it). Is your point that we are able to _re-use_ more existing code if we allow `ContinuousBoundaryFunction` and `DiscreteBoundaryFunction` as `condition`? I didn't understand this previously so thank you for clarifying. To re-use that code with a new `condition`, we can use a nesting technique:. ```julia; function getbc(open_bc::OpenBoundaryCondition, ...); state_value = getbc(open_bc.condition.external_state, ...); # other stuff related to matching; end; ```. This means that we don't have to rewrite anything, we just add new functionality for open boundary conditions on top. You could make the point that we have less _new_ code to write though, if we implement a design that allows conditions to be the same. And for users, this could be clearer, so I see the advantage of that. On the flip side, the advantage of making a new `OpenCondition` is that `getbc` retains its meaning as ""the function that returns the boundary condition value"". When we have an external state + matching scheme, the boundary condition values are not exactly the external state and are modified by the matching scheme. So I see pros and cons to both, but the good news is that we can actually talk coherently about the pros and cons. And if there are other pros and cons please mention them.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194:28,load,loads,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-1988781194,2,['load'],['loads']
Performance,"> why not replace `const ƞ = 2` with `const ƞ = 2.0`, i.e. with a Float64?. I believe that if we do this, then we have to live with WENO5 that's 20x slower than the other schemes. I believe its the exponentiation with `Float64` that is slow (since exponentiation is compute intensive in general in my understanding) --- not the conversion from Int64 to Float64 (type conversions between numeric types are basically instantaneous as far as I know). In other words, the function `pow` for exponentiation with `Float64`:. https://github.com/JuliaGPU/CUDA.jl/blob/5d6127dbbef495c94d3dd8de98162188062e11b1/src/device/intrinsics/math.jl#L218. creates a bottleneck in simulations that use WENO5, whereas using `powi`:. https://github.com/JuliaGPU/CUDA.jl/blob/5d6127dbbef495c94d3dd8de98162188062e11b1/src/device/intrinsics/math.jl#L221. is much faster. > My understanding is that replacing it with with Int32 can make us forfeit some precision, no?. Why is that?. I believe we only need `Int64` if we need to represent very large integers. `Int32` integers can range from +/- 2^32 - 1, whereas 64 bit integers can range from +/- 2^64 - 1. Since 2 is represented with `Int32` there's no need to express its value in `Int64`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869776360:647,bottleneck,bottleneck,647,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869776360,1,['bottleneck'],['bottleneck']
Performance,">Maybe I am misunderstanding you, but isn't that already what is done in the horizontal convection example?. No, you are understanding me! I think you're on to something. > Is the intended behavior that output writers automatically call fill_halo_region! before saving when with_halos=true?. Ah no this is not default. However, for prognostic fields, the halos are filled within `update_state!`:. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/Models/NonhydrostaticModels/update_nonhydrostatic_model_state.jl#L24C1-L24C1. However, halos are not filled for diagnostic fields. We probably don't want to make filling halos default, since filling halo regions is expensive and useful only for a subset of experiments. However, we could add a keyword argument to `JLD2OutputWriter`, something like `fill_halos = true`. (Thinking about this with a little more coffee, it probably doesn't make sense to add something like this, because generally speaking the halo values for diagnostic fields are not useful except for periodic boundary conditions; only prognostic fields can have specified / meaningful boundary conditions.). I wonder if this is a bug in `FieldTimeSeries`. Are you using `FieldTimeSeries` to compute the diagnostics offline? Perhaps the halo data is saved correctly, but is not loaded correctly.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689838510:1333,load,loaded,1333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689838510,1,['load'],['loaded']
Performance,">[AMGX.jl](https://github.com/JuliaGPU/AMGX.jl) only has prebuilt libraries for linux systems. That said, calling using AMGX will fail on, e.g., Mac OS X. What's the best way to optionally load AMGX.jl? Or is there another way around that?. We may be able to optionally call `using AMGX` + all the `AMGX`-related functionality by using:. [`@static` + `islinux()`]( https://docs.julialang.org/en/v1/manual/handling-operating-system-variation/) + [`CUDA.has_cuda_gpu()`](https://cuda.juliagpu.org/stable/api/essentials/#CUDA.has_cuda_gpu)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1244923054:189,load,load,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1244923054,1,['load'],['load']
Performance,"@ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CUDAdrv`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; Building SpecialFunctions → `~/.julia/packages/SpecialFunctions/fvheQ/deps/build.log`; Building LLVM ────────────→ `~/.julia/packages/LLVM/tg8MX/deps/build.log`; Building CUDAnative ──────→ `~/.julia/packages/CUDAnative/B210M/deps/build.log`; Dependent package CUDAdrv.jl has not been built successfully.; This is not a fatal error, but GPU functionality will be unavailable.; If you expected this to work, please open a thread on; https://discourse.julialang.org/c/domain/gpu; ┌ Error: Error building `CUDAnative`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ┌ Error: Error building `CuArrays`: ; └ @ Pkg.Operations /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.1/Pkg/src/Operations.jl:1075; ERROR: LoadError: LoadError: UndefVarError: CUBLAS not defined; Stacktrace:; [1] top-level scope at none:0 (repeats 2 times); [2] include at ./boot.jl:326 [inlined]; [3] include_relative(::Module, ::String) at ./loading.jl:1038; [4] include at ./sysimg.jl:29 [inlined]; [5] include(::String) at /home/travis/.julia/packages/CuArrays/qZCAt/src/CuArrays.jl:3; [6] top-level scope at none:0; [7] include at ./boot.jl:326 [inlined]; [8] include_relative(::Module, ::String) at ./loading.jl:1038; [9] include(::Module, ::String) at ./sysimg.jl:29; [10] top-level scope at none:2; [11] eval at ./boot.jl:328 [inlined]; [12] eval(::Expr) at ./client.jl:404; [13] top-level scope at ./none:3; ```; The cuBLAS error might be related to CuArrays: https://github.com/JuliaGPU/CuArrays.jl/issues/255",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:2298,Load,LoadError,2298,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,4,"['Load', 'load']","['LoadError', 'loading']"
Performance,"@Yixiao-Zhang do you want to open a PR?. Sensible errors on GPU are a persistent problem... this seems like one of the trickiest though... I think the best easy thing we can do in this case is to add an article in our Wiki about how to debug `CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS)`, making @simone-silvestri 's points. For documentation the error being referred to is. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:27; [2] check; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/libcuda.jl:34 [inlined]; [3] cuMemcpyHtoDAsync_v2; @ ~/.julia/packages/CUDA/35NC6/lib/utils/call.jl:26 [inlined]; [4] #unsafe_copyto!#9; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/memory.jl:397 [inlined]; [5] (::CUDA.var""#1012#1013""{ComplexF64, CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, Int64, Vector{ComplexF64}, Int64, Int64})(); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:464; [6] #context!#887; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [7] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [8] unsafe_copyto!(dest::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, doffs::Int64, src::Vector{ComplexF64}, soffs::Int64, n::Int64); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:457; [9] copyto!; @ ~/.julia/packages/CUDA/35NC6/src/array.jl:415 [inlined]; [10] setindex!(::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, ::ComplexF64, ::Int64, ::Int64, ::Int64); @ GPUArrays ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:20; [11] setindex!; @ ~/.julia/packages/GPUArrays/5XhED/src/host/indexing.jl:24 [inlined]; [12] macro expansion; @ ~/.julia/packages/GPUArraysCore/uOYfN/src/GPUArraysCore.jl:136 [inlined]; [13] solve!(ϕ::Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Boun",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332:435,Load,LoadError,435,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3320#issuecomment-1755989332,1,['Load'],['LoadError']
Performance,"@ali-ramadhan , I tried running the example using the following `julia --project -p 4 mpi_shallow_water_turbulence.jl; `, and it seemed to fail because of error, see below. Any idea what I might have done wrong?. ```; ERROR: LoadError: ProcessExitedException(3). ...and 2 more exception(s). Stacktrace:; [1] sync_end(::Channel{Any}) at ./task.jl:314; [2] macro expansion at ./task.jl:333 [inlined]; [3] _require_callback(::Base.PkgId) at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Distributed/src/Distributed.jl:75; [4] #invokelatest#1 at ./essentials.jl:710 [inlined]; [5] invokelatest at ./essentials.jl:709 [inlined]; [6] require(::Base.PkgId) at ./loading.jl:931; [7] require(::Module, ::Symbol) at ./loading.jl:923; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /home/fpoulin/software/Oceananigans.jl/examples/mpi_shallow_water_turbulence.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347:225,Load,LoadError,225,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1430#issuecomment-792895347,3,"['Load', 'load']","['LoadError', 'loading']"
Performance,"@ali-ramadhan ; Thanks for the suggestion. I tried running it on the CPU and got a different error message, which is shown below. Additionally, the error occurs when defining background fields in the model as such; ```julia ; background_fields = Oceananigans.BackgroundFields(; background_closure_fluxes=true, b=B̄_field); ```; But it runs fine like the usual way; ```julia; background_fields = (; b=B̄_field); ```. ```; [ Info: Initializing simulation...; ERROR: LoadError: type BackgroundFields has no field u; Stacktrace:; [1] getproperty; @ ./Base.jl:37 [inlined]; [2] assemble_closure_velocities; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:35 [inlined]; [3] u_velocity_tendency; @ ~/.julia/packages/Oceananigans/xmqSH/src/Models/NonhydrostaticModels/nonhydrostatic_tendency_kernel_functions.jl:92 [inlined]; [4] cpu_compute_Gu!; @ ~/.julia/packages/KernelAbstractions/491pi/src/macros.jl:291 [inlined]; [5] __thread_run(tid::Int64, len::Int64, rem::Int64, obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:144; [6] __run(obj::KernelAbstractions.Kernel{…}, ndrange::Nothing, iterspace::KernelAbstractions.NDIteration.NDRange{…}, args::Tuple{…}, dynamic::KernelAbstractions.NDIteration.DynamicCheck, static_threads::Bool); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:111; [7] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}; ndrange::Nothing, workgroupsize::Nothing); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:46; [8] (::KernelAbstractions.Kernel{…})(::Field{…}, ::Vararg{…}); @ KernelAbstractions ~/.julia/packages/KernelAbstractions/491pi/src/cpu.jl:39; [9] launch!(::CPU, ::ImmersedBoundaryGrid{…}, ::Symbol, ::typeof(Oceananigans.Models.Nonhydros",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2432725343:464,Load,LoadError,464,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2432725343,1,['Load'],['LoadError']
Performance,"@ali-ramadhan I'm running on my desktop's GPU just to get a sense of the performance increase at the moment. According to `nvidia-smi` my card is a `NVS 310` (I apologize if I didn't get that right, I really have zero experience with GPUs). I'll create another issue to report this properly. Thanks for the feedback, though!. And I'm running our own group's LES model. Unfortunately I'm not allowed to share the code, but you can read about it [here](https://agupubs.onlinelibrary.wiley.com/doi/abs/10.1029/2018GL080296). @glwagner I'd be very willing to compare performances of our LES with Oceananigans. The caveats here being that; - our model of choice ([lagrangian-averaged scale-dynamic](https://aip.scitation.org/doi/10.1063/1.1839152)) takes relatively long to calculate compared to other models, but generally needs lower resolution to achieve the same results (so in this sense it might be similar to AMD) and that; - I'm not sure how relevant it would be to compare with us, being that I'm not allowed to share the source code. If you're still interested to make a comparison just let me know! I'd be happy to help. @ali-ramadhan @glwagner I'm not expecting at all to run their simulation at the resolution that they're running. My intent was to set-up the same case (but very coarse) and see how much I could increase the resolution (and how much activity I could see) until it became too slow or until I ran out of memory. This is basically a fun side-project, and not an actual research attempt if I'm being honest :). Thank you both for the helpful responses! I'm glad to help with whatever bugs or attempts at simulations that I can!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539785839:73,perform,performance,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539785839,2,['perform'],"['performance', 'performances']"
Performance,"@ali-ramadhan and @glwagner I tried the code below in some simple tests while waiting; for my car to be serviced. . ```; using Pkg; Pkg.add(""LinearAlgebra""); using LinearAlgebra. function solveLinearSystem(A,f); # Solve Aϕ=f; tol=1.e-12; E=eigen(A);; L=E.values;; V=E.vectors;; # Get amplitudes, F, of eigenvectors that give f; F=V'*f; # Get inverse eigenvalues (zeroing inverse for v. small ones); rL=map(x -> if (abs(x)>tol) 1.0/x; else 0. ; end , L);; # Get amplitudes, Φ, of eigenvectors that give ϕ; Φ=F.*rL; # Solve for ϕ given Φ; ϕ=V*Φ; println(A*ϕ,f,ϕ); return ϕ; end. Acyc=[-2. 1 1; 1 -2. 1; 1 1 -2.];; Aneu=[-1 1 0; 1. -2. 1; 0. 1. -1];; s=size(Acyc);; nx=s[1];; g=rand(nx+1,1);; divg=g[1:end-1]-g[2:end]; mdivg=sum(divg)./size(divg)[1]; divg=divg.-mdivg; solveLinearSystem(Acyc,divg); solveLinearSystem(Aneu,divg); ```. This is algorithm that underlies the FFT approach. The FFT just optimizes (and makes it more complicated) by utilizing the fact that the eigenvector/eigenvalue coefficients for the simple, constant spacing Poisson problem, are the cos and sin terms in an FFT. Code appears to work so I am going to try and hack together a ""_plugin_"" for ```solve_poisson_3d_mbc```. . The code won't be super high performance (or work for really big problems) but (fingers crossed) it should give something clean (and short) to get started and help with debugging/optimizing on GPU. Then we can work on various FFT approaches on CPU and GPU (3-d FFT, 2-d + cyclic reduction), Greg's thought on saving for gradients in continuous form. . In principle the eigenvectors and eigenvalues above should correspond with amplitudes that come out of FFTW - except that there are a bunch of 1/2 factors, N versus m numbers, complex versus split cos/sin notation bits that need to be carefully understood etc.... . Just going to learn a little about sparse matrices in Julia - I assume they must exist! Hopefully the car will take a little longer to be finished. . Chris",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-442521365:895,optimiz,optimizes,895,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/8#issuecomment-442521365,3,"['optimiz', 'perform']","['optimizes', 'optimizing', 'performance']"
Performance,"@ali-ramadhan currently waiting for the preview to load so that I can merge, but I don't think it'll do that with the GPU test failing. How do we fix that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819553284:51,load,load,51,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1543#issuecomment-819553284,1,['load'],['load']
Performance,"@christophernhill : I wanted to confirm that I took your clever idea of using `select_device()` and added that into my code. When I ran it on 1, 2 and 4 GPUs I was able to get efficiences of 97 percent. So the code is performing very well, and the server can be efficent on multi GPUs. . The link to where the function is defined is copied below. Is this something that is done automatically in Oceananigans through `AbstractKernels.jl` or something else?. https://github.com/christophernhill/ImplicitGlobalGrid.jl/blob/5e4fd0698b7087467d9314bfa253d6bc9a09a40a/src/select_device.jl. In chatting with the developers of `ImplicitGlobalGrid.jl` they mentioned that to get efficiency I should use something called `@hide_communication` in `ParallelKernel.jl`. Again, I don't pretend to understand what this does but wanted to share the information I was given. https://github.com/omlins/ParallelStencil.jl/blob/main/src/ParallelKernel/hide_communication.jl",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885799405:218,perform,performing,218,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885799405,1,['perform'],['performing']
Performance,"@christophernhill I also took a look at the `GFlops.jl` package. As said on its homepage: ""GFlops.jl does not see what happens outside the realm of Julia code. It especially does not see operations performed in external libraries such as BLAS calls.""; It works similarly to the profile macro and it can count basic math operations performed by whatever follows the macro or benchmark it for its Flops metric. These doesn't seem to work with simulations but works fine for `time_step!(model, 1)` due to the benchmarking process performing many evaluations of the code.; For the nonhydrostatic model running on CPU, `@count_ops` did not produce any results for either the simulation run or the time_step!, and `@gflops` produced the results below for time step!:; ```; 0.02 GFlops, 0.04% peak (1.89e+07 flop, 1.01e+00 s); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351:198,perform,performed,198,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-898103351,3,['perform'],"['performed', 'performing']"
Performance,"@francispoulin ! No worries about the question. I like questions. To answer your latest question --- our nonhydrostatic pressure solver is based on FFTs for regular grids and is therefore quite fast. In simple benchmarks long ago we found that other parts of the algorithm dominated the cost of a time-step. Because of that we aren't sure that having a hydrostatic-only solver would help. Of course, the story is different if we need to stretch the grid in horizontal directions. That said, it would still be interesting to be able to solve hydrostatic-only problems. This would complicate the algorithm a bit because you have to distinguish the barotropic mode, and perform a 2D pressure solve. We already have a function to integrate the buoyancy field to obtain the hydrostatic pressure. For ""things I want worked on"" my wish list falls into three categories: new physics features, new numerics / algorithms, and more boring software / UI work. Here's a couple... 1. Finishing the vertically-stretched grid implementation (numerics). We started work on this but its incomplete. This is a tricky and arduous task but would be quite nice to have... 2. Vertically-implicit time-stepping for diffusion terms (numerics). Ocean models typically use a time-stepping method that treats vertical diffusion terms implicitly. We haven't worried about this because we are focused on LES for the most part, or problems with very little diffusion. But ultimately we will need this, especially when we get around to implementing boundary layer closures. We have a tridiagonal solver that works on the GPU, so in some respects the hard work is already done for this problem. 3. Closures for LES and ocean modeling (Dynamic Smagorinsky, Deardorff, k-epsilon, Gent-McWilliams, convective adjustment (?) etc --- physics). We have a need to implement new turbulence closures new and old alike. Gent-McWilliams is probably easy since we already have a Leith closure implemented which calculates the tensor needed to rot",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281:667,perform,perform,667,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1153#issuecomment-724262281,1,['perform'],['perform']
Performance,"@francispoulin @glwagner @ali-ramadhan @christophernhill ; I took a look at all the benchmarking scripts in our benchmarks folder and realized that many of them are very similar and can be unified. For example, the single script for shallow water model's strong and weak scaling differ only by one substring. ; The latest commit I pushed to this branch unifies all of the launcher and single scripts for shallow water model into three scripts. Now, at the top of the launcher script `distributed_shallow_water_model.jl`, there are two boolean variables that the user can toggle for strong vs weak scaling and mpi vs threaded parallel execution. Everything including output graphs, HTML tables, and info messages also change accordingly based on the two booleans. There are some other features that Francis and I have discussed but would like your approval first before adding them in.; Other possible additions to the script can include a for loop which wraps around the whole launcher script which loops through the strong/weak scaling and mpi/threaded parallelism options to allow for running 4 benchmarks at once. Another possible addition is to have what model is benchmarked also be an option. Granted, I could just copy and paste the shallow water model scripts and replace all instances of `shallow water` with `nonhydrostatic` or `hydrostatic` and tune some options a little bit, but then this would again cause avoidable clutter. Having what model is benchmarked as an easily changeable option can be achieved through a model setup function that dispatches what model is initialized based on a custom model type object that's passed to it. Everything else would be cosmetic formatting of outputs and info messages.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441:1356,tune,tune,1356,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-899928441,1,['tune'],['tune']
Performance,@francispoulin I think it's always helpful to post the full error and stacktrace. From your original post. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!; ```. suggests that the error could be happening since `b̄` is being used in a `ComputedField`'s `compute!`: https://github.com/CliMA/Oceananigans.jl/blob/9eca5780658bb8f5c0debd34146a0ad5cb73c872/examples/inertially_unstable_jet.jl#L51,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237:119,Load,LoadError,119,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554#issuecomment-815055237,1,['Load'],['LoadError']
Performance,"@francispoulin sounds like a good plan! Then we can see how to proceed. Concerning the way forward with `WENOVectorInvariant`, it seems that it is very diffusive when compared to standard WENO. an example on a 256^2 periodic Bickley jet below, contours are of vertical vorticity (left) and zonal velocity (right). WENO5. https://user-images.githubusercontent.com/33547697/157509797-d61f45ba-8284-40f2-b9e9-4cafcba6db68.mp4. WENOVectorIvariant. https://user-images.githubusercontent.com/33547697/157533165-9281949b-1579-462d-ad16-e27b2f954969.mp4. Integrated Enstrophy (blue is 64^2, red is 128^2, green is 256^2, solid lines are WENO5, dashed are WENOVectorInvariant); ![enstrophy](https://user-images.githubusercontent.com/33547697/157510310-3acfaeaf-4d05-4fac-b332-e7b66563147e.png). @sandreza was pointing out that maybe the extra diffusivity comes from the fact that we are advecting vorticity which contains much thinner structures than velocity, then maybe the ""optimal WENO weight"" are not so optimal anymore. These weights are 3 constant parameters, which are quite empirical and ""free-to-choose"" (in our case just `1/10` for the downstream, `6/10` for the central and `3/10` for the upstream stencil). Dissipation can be reduced by increasing the ""central stencil weight"". The idea with @sandreza was to perform an easy calibration to try to ""reasonably"" preserve enstrophy in the Bickley jet (then maybe calibrate it also against the spherical bicklet jet or R-H waves where also Coriolis is involved). The objective is to completely eliminate explicit viscous dissipation in the horizontal direction (harmonic and/or biharmonic) for the global simulation",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741:1313,perform,perform,1313,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1063249741,1,['perform'],['perform']
Performance,"@glwagner ; After merging this PR and running it on the GPU, I encounter the following error. (I'm using Julia 1.10.2 and Oceananigans v0.92.0):. ```; [ Info: Initializing simulation...; ERROR: LoadError: InvalidIRError: compiling MethodInstance for Oceananigans.Models.NonhydrostaticModels.gpu_compute_Gu!(::KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(10, 10, 10)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(1, 1, 10)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, ::OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, ::ImmersedBoundaryGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Periodic, Bounded, RectilinearGrid{Float64, Oceananigans.Grids.Periodic, Oceananigans.Grids.Periodic, Bounded, Float64, Float64, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, CuDeviceVector{Float64, 1}}, Nothing}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, Nothing, Nothing, OffsetArrays.OffsetArray{Float64, 3, CuDeviceArray{Float64, 3, 1}}, Float64, Nothing, Nothing, Nothing}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, Nothing, Nothing}, ::Nothing, ::Tuple{WENO{3, Float64, Nothing, Nothing, Nothing, Nothing, WENO{2, Float64, Nothing, Nothing, Nothing, Nothing, UpwindBiased{1, Float64, Nothing, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}, Centered{2, Float64, Nothing, Nothing, Nothing, Centered{1, Float64, Nothing, Nothing, Nothing, Nothing}}}, ConstantCartesia",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700:194,Load,LoadError,194,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3646#issuecomment-2428001700,1,['Load'],['LoadError']
Performance,"@glwagner @tomchor ; I have just tested the turbulent boundary layer with wall model using Oceananigans on Julia 1.6.7 and Julia 1.9.2. The performances of AMD in both versions are exactly the same. It turns to overestimate the velocity shear at the second node from the wall, therefore, turns to overestimate the velocity in the middle and upper parts of the boundary layers. I used to use the SGS model based on the Lagrangian-averaged scale-dependent dynamic model (LASD) (https://pubs.aip.org/aip/pof/article/17/2/025105/895722/A-scale-dependent-Lagrangian-dynamic-model-for). @tomchor is very familiar with this SGS model. The performance of the LASD close to the wall is usually good, as you can see here; ![025105_1_f2](https://github.com/CliMA/Oceananigans.jl/assets/20816949/e4aa1b73-d37e-4afa-b3ec-317d2edf7769). I guess the problem of AMD is partly solved in reference Yang et al. (2017). Now the problem is that if someone can implement this filtering in the code or not. I am stilling learning the Oceananigans and Julia. I hope that someday in the future, I am able to implement this technique.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426:140,perform,performances,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3195#issuecomment-1652877426,4,['perform'],"['performance', 'performances']"
Performance,"@glwagner [AMGX.jl](https://github.com/JuliaGPU/AMGX.jl) only has prebuilt libraries for linux systems. That said, calling `using AMGX` will fail on, e.g., Mac OS X. What's the best way to optionally load AMGX.jl? Or is there another way around that?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241308749:200,load,load,200,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2688#issuecomment-1241308749,1,['load'],['load']
Performance,"@glwagner please help here... I can't even say `using Oceananigans`.... ```julia; julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: LoadError: LoadError: UndefVarError: NFBC not defined; Stacktrace:; [1] top-level scope; @ ~/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; [2] include(mod::Module, _path::String); @ Base ./Base.jl:386; [3] include(x::String); @ Oceananigans.BoundaryConditions ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; [4] top-level scope; @ ~/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:45; [5] include(mod::Module, _path::String); @ Base ./Base.jl:386; [6] include(x::String); @ Oceananigans ~/Research/OC/src/Oceananigans.jl:1; [7] top-level scope; @ ~/Research/OC/src/Oceananigans.jl:173; [8] include; @ ./Base.jl:386 [inlined]; [9] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1213; [10] top-level scope; @ none:1; [11] eval; @ ./boot.jl:360 [inlined]; [12] eval(x::Expr); @ Base.MainInclude ./client.jl:446; [13] top-level scope; @ none:1; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/apply_flux_bcs.jl:23; in expression starting at /Users/navid/Research/OC/src/BoundaryConditions/BoundaryConditions.jl:1; in expression starting at /Users/navid/Research/OC/src/Oceananigans.jl:1; ERROR: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to /Users/navid/.julia/compiled/v1.6/Oceananigans/jl_fSB7qw.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::Base.TTY, internal_stdout::Base.TTY); @ Base ./loading.jl:1360; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1306; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1021; [5] require(",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334:190,Load,LoadError,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1744#issuecomment-877746334,3,['Load'],['LoadError']
Performance,"@glwagner that sounds like a good strategy, ideally you would want to front-load the most useful tests for catching errors to the degree possible (the whole goal here is to reduce iteration time). If using Linux we can have up to 60 concurrent actions going so spawning as many as is useful for reducing the iteration time is the correct strategy (probably you could set this up as a job matrix for compactness). If spawning up a ton of github actions you can maximize concurrency by killing stale jobs (old push commits) as we do here: https://github.com/CliMA/ClimaCore.jl/blob/main/.github/workflows/Linux-UnitTests.yml#L24",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759:76,load,load,76,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906584759,3,"['concurren', 'load']","['concurrency', 'concurrent', 'load']"
Performance,"@glwagner the solution seems the same but two difference are that (1) `VectorInvariant` does not crash, (2) `WENOVectorInvariant` deviates from the pattern later. ; ; In this paper https://www.tandfonline.com/doi/pdf/10.3402/tellusa.v52i2.12258 they claim that : ""In the FV model, small departures from the flow pattern are triggered initially by grid related truncation errors but subsequently grow through the dynamical instability"" . I guess ""time-to-instability"" is itself a diagnostic of the performance of the scheme? . @francispoulin As implemented in (https://reader.elsevier.com/reader/sd/pii/S0021999105800166?token=A3A72AC493072CED8ECF098513A0BD1F822D2F2224207E533C86FB7D40361903E7AC0B4304841E64E089CBBFCEAFD08B&originRegion=us-east-1&originCreation=20220308154939) the cosine bell advection only tests the tracer advection, do you have any example of a test of that kind that tests momentum advection?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114:497,perform,performance,497,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2317#issuecomment-1061931114,1,['perform'],['performance']
Performance,"@glwagner, @navidcy ; Poll to decide where to put `η` in `z`. . The possibilities are:; - location `Face`, index `grid.Nz+1`. Pros: natural location of `η` field (same position of the `w` velocity).; - location `Center`, index `grid.Nz`. Pros: every calculation dealing with `η` is now performed at centers (ex `Az_∇h²ᶜᶜᶜ` and `linear_operation!`. . In case of the second option should we change all the metrics to reflect the fact that we are at faces?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1248631573:286,perform,performed,286,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2740#issuecomment-1248631573,1,['perform'],['performed']
Performance,"@glwagner, I think you're right that the error is coming from this line:; https://github.com/CliMA/Oceananigans.jl/blob/10a9479ec462f4f5f053e7447ff667fdfe20542d/src/Distributed/distributed_fft_based_poisson_solver.jl#L65; I checked the sizes of these variables, and here xc is sized on the global grid while lambda x is sized on the local grid. I'm not sure which grid this operation is intended to be performed on. The code here is impressively compact but not particularly easy to decipher (at least for me).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658:402,perform,performed,402,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1067340658,1,['perform'],['performed']
Performance,"@glwagner, regarding the; ```Julia; ERROR: LoadError: UndefVarError: bc not defined; ```; in the Docs, is it related to; https://github.com/JuliaDocs/Documenter.jl/issues/228; perhaps?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879623792:43,Load,LoadError,43,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1843#issuecomment-879623792,1,['Load'],['LoadError']
Performance,"@hennyg888 do you have the same problems using MPI instead of multi-threaded, and on the same CPU ( Intel(R) Xeon(R) Platinum 8260 CPU @ 2.40GHz ). ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880838040:62,multi-thread,multi-threaded,62,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-880838040,1,['multi-thread'],['multi-threaded']
Performance,"@jakebolewski I'm wondering what you think about the strategy of running a few key integration tests via GitHub actions, in addition perhaps to unit tests that have low compilation costs. For example, we have a couple ""regression tests"" that ensure the output of a simulation is identical to one run previously. These regression tests are imprecise (we only know that something has changed, but can't identify exactly what it is), but nevertheless catch both obvious API bugs and subtle numerics bugs incurred by refactoring. Another nice feature is that regression tests invoke (or are supposed to invoke) configurations that are most common / most valuable to users. They are also relatively cheap since we load states from a file and run for 10-100 time-steps at modest resolutions, and there are a small number of them which mitigates compilation cost. When I undertake a major refactor I often find myself running regression tests first. Testing corner cases and/or catching bugs associated with interactions between model components in less-frequently used configurations requires more extensive testing (a combinatorial explosion of cases...) and incurs heavier compilation costs; so these are probably better tested via `bors try`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444:709,load,load,709,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906570444,1,['load'],['load']
Performance,"@matinraayai is working on making PencilArrays performant. This PR is exploratory and is a fallback that might not be merged if we find an efficient way to do GPU transposes with PencilArrays (requires reducing memory allocations and improving the efficiency of permute operations) and implement r2r Fourier transforms in PencilFFTs. ; For the moment those two elements are part of this PR. This PR follows the (simple) configuration of the 2decomp library https://github.com/2decomp-fft/2decomp-fft,; the difference between PencilFFT/PencilArray and this PR (a part bounded domain ffts) is that here (at the moment) we impose the stricter limitation that `Ny` has to be divisible by `Rx` and `Ry` while `Nz` has to be divisible by `Ry`, where `Rx` and `Ry` are the number of ranks (divisions) in the x and y direction. Relaxing the requirements should not be too difficult.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521:47,perform,performant,47,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3279#issuecomment-1727661521,2,['perform'],['performant']
Performance,"@mukund-gupta reported the following error:. ```; [ Info: Oceananigans will use 16 threads; [ Info: Starting the simulation...; [ Info: i: 0010, t: 1.667 minutes, Δt: 10 seconds; ERROR: LoadError: MethodError: no method matching isless(::typeof(depth_dependent_κ), ::typeof(depth_dependent_κ)); Closest candidates are:; isless(!Matched::Missing, ::Any) at missing.jl:87; isless(::Any, !Matched::Missing) at missing.jl:88; Stacktrace:; [1] max(::Function, ::Function) at ./operators.jl:417; [2] BottomRF at ./reduce.jl:81 [inlined]; [3] _foldl_impl(::Base.BottomRF{typeof(max)}, ::Base._InitialValue, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:62; [4] foldl_impl(::Base.BottomRF{typeof(max)}, ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:48; [5] mapfoldl_impl(::typeof(identity), ::typeof(max), ::NamedTuple{(),Tuple{}}, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:44; [6] mapfoldl(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}; kw::Base.Iterators.Pairs{Union{},Union{},Tuple{},NamedTuple{(),Tuple{}}}) at ./reduce.jl:160; [7] mapfoldl at ./reduce.jl:160 [inlined]; [8] #mapreduce#208 at ./reduce.jl:287 [inlined]; [9] mapreduce(::Function, ::Function, ::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:287; [10] maximum(::NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}) at ./reduce.jl:652; [11] cell_diffusion_timescale(::AnisotropicDiffusivity{Int64,Int64,typeof(depth_dependent_κ),NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{Int64,Int64}},NamedTuple{(:T, :S),Tuple{typeof(depth_dependent_κ),typeof(depth_dependent_κ)}}}, ::Tuple{Nothing,Nothing}, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRange",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1104:186,Load,LoadError,186,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1104,1,['Load'],['LoadError']
Performance,"@navidcy I'm trying to add a drag flux to this example like we talked about in https://github.com/CliMA/Oceananigans.jl/issues/3148 but I'm getting an error that I can't figure out. Using `u` as an example, I'm trying to implement the BCs as . ```julia; @inline u_drag(x, y, t, u, v, w, p) = - p.cᵈ * u * √(u^2 + v^2 + w^2); @inline u_drag(x, y, z, t, u, v, w, cᵈ) = u_drag(x, y, t, u, v, w, cᵈ). u_drag_bc = FluxBoundaryCondition(u_drag, field_dependencies=(:u, :v, :w), parameters=(; cᵈ=1e-3)); boundary_conditions = (u = FieldBoundaryConditions(bottom=u_drag_bc),); ```. but when time-stepping the model I get. ```; ERROR: LoadError: MethodError: no method matching field_arguments(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, Nothing, CPU}, ::NamedTuple{(:u, :v, :w, :b, :η), Tuple{Field{Face, Center, Center, Nothing, ImmersedBoundaryGrid{Float64, Periodic, Flat, Bounded, RectilinearGrid{Float64, Periodic, Flat, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, Oceananigans.ImmersedBoundaries.Cent",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1667152069:626,Load,LoadError,626,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3132#issuecomment-1667152069,1,['Load'],['LoadError']
Performance,"@navidcy In the context of Enzyme (a tool for automatically differentiating LLVM), to ""mark"" a function as non-differentiable means to use `inactive_noinl` to tell Enzyme that it should not try to apply the chain rule to that function. Marking functions as non-differentiable has various reasons but here the reason is given as ""performance"". The code changed is also quite short so I think the description is complete.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3799#issuecomment-2383154154:329,perform,performance,329,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3799#issuecomment-2383154154,1,['perform'],['performance']
Performance,"@navidcy it shouldn't impact developer workflow too much. When going over the test structure with @glwagner on Tues. I suggested the following restructuring:. * Break-out ""quick"" unit-tests to be run by github actions under a single configuration (ex: linux, julia 1.6) and be able to run them in parallel. We have a ""Team"" account donated by Github so we can have tons of concurrent GitHub actions so this is beneficial if you can take advantage (might be limited by compilation costs). These tests will be run for every PR push and fast fail on error.; * `bors try` trigger a more expensive CI job to be submitted to the cluster, allowing for GPU / MPI tests. The logic here is that if the cpu tests are not working then the GPU tests almost certainly won't so you can get away with executing them less often. We have a daemon running on the cluster that synchronizes the jobs from buildkite with the local slurm controller, so every step in the buildkite config is submitted as a separate slurm job and canceling buildkite jobs kills them with slum. What is nice about that setup is you can tailor the resources used for each buildkite step just as you would slurm (ex. ""gres:1"" for 1 gpu). You can run jobs on multiple ranks, multiple GPU's, different resource limits, timeouts, etc. basically anything you can pass through to as a cli argument to a slurm batch job is supported. Also it's running on a cluster so obviously your job parallelism is very good.; * `bors r+` trigger merging the PR into `main` branch. This serializes the commits to `main` (and roll-up concurrent PR's to be submitted) so that all merge commits will pass the tests. This is an opportunity to also maybe run more expensive tests (it's easy in buildkite to conditionally run steps if running on `staging` branch) because you'll probably only run the staging CI step one or at most a few times at the very end,. the general strategy is to tier the tests so that they get progressively more expensive and to maximize ci-p",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778:373,concurren,concurrent,373,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1962#issuecomment-906541778,1,['concurren'],['concurrent']
Performance,"@navidcy thanks for the review! ; Indeed maybe we should document it. . Just to give a quick explanation of the different flavours. WENO involves the reconstruction of the value of the advected quantity on the face performed on different ""biased stencils"". <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2 ,r} = p_r(x_{i %2B 1/2}) = \sum_{j=0}^k c_{rj} \overline{v}_{i - r %2B j}"">. where <img src=""https://render.githubusercontent.com/render/math?math=p""> is the reconstruction polynomial constructed from the biased stencil <img src=""https://render.githubusercontent.com/render/math?math=r""> and <img src=""https://render.githubusercontent.com/render/math?math=k""> is the order of the polynomial. As we want a 5th order scheme, there will be three polynomials (<img src=""https://render.githubusercontent.com/render/math?math=r = 0, 1, 2"">) with (<img src=""https://render.githubusercontent.com/render/math?math=k = 2"">). Now the coefficients of these polynomials (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are based on the Lagrange interpolation of the integral of <img src=""https://render.githubusercontent.com/render/math?math=\overline{v}_{i}""> and, as such, are coordinate-dependent. The first thing to do, when wanting to implement the WENO scheme on a stretched grid, is then to make sure that the reconstruction is correctly done, and, as such, `WENO5(grid = grid)` takes care that (<img src=""https://render.githubusercontent.com/render/math?math=c_{rj}"">) are correctly calculated based on the underlying grid. Now, WENO schemes differ from ENO schemes since they do not just choose the ""smoothest stencil"" among the (in this case) three stencils, but weight them as such. <img src=""https://render.githubusercontent.com/render/math?math=v_{i %2B 1/2} = \sum_{r=0}^k w_{r} v_{i %2B 1/2,r} "">. Those weights have to satisfy <img src=""https://render.githubusercontent.com/render/math?math=\sum_{r=0}^k w_{r} = 1""> and are mostly a matte",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397:215,perform,performed,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-975649397,2,['perform'],['performed']
Performance,@navidcy what's the last version before the catastrophic performance loss? I'll do a benchmark to compare with `main`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480454534:57,perform,performance,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1480454534,1,['perform'],['performance']
Performance,"@peterahrens suggested removing `ModelMetadata` from `Field` structs and make the `Grid` a parameter, i.e. `Grid{T,G}` then it should be isbitstype. It's not isbits right now because T<:AbstractArray. Then we should be able to use some abstractions in the CPU/GPU element-wise kernels as well as multiple dispatch and won't need to have `δx_c2f`, `δx_f2c`, `δx_e2f`, `δx_f2e`, etc. Some goals for guidance:; - [ ] Prototype grid and field types that are `isbitstype`.; - [ ] Test that they do work with GPUifyLoops on the GPU. For this I will extend the example from https://github.com/vchuravy/GPUifyLoops.jl/pull/18; - [ ] Benchmark the simple example to see things slow down. I don't expect to see much of a difference.; - [ ] Refactor the operators and time stepping loop to use the new abstractions!; - [ ] Add tests to make sure any structure that may be passed to a CUDA kernel `isbitstype`. Just construct a bunch of grids, fields, and forcing functions and test that they are indeed `isbitstype`.; - [ ] Benchmark the model with `isbitstype` abstractions to make sure performance hasn't degraded.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59:1077,perform,performance,1077,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59,1,['perform'],['performance']
Performance,@sandreza and Adeline have a script that explodes into NaNs almost immediately at 128³ but takes many thousands of iterations to produce a NaN at 32³. Reverting to Oceananigans v0.27.0 the script runs fine. @sandreza suggested that it might be a race condition between kernels since KernelAbstractions.jl allows for multiple streams. Race conditions get much more (exponentially?) frequent as the number of threads increase I guess. I'm trying to reproduce this issue with a minimal working example.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/816:246,race condition,race condition,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/816,2,"['Race condition', 'race condition']","['Race conditions', 'race condition']"
Performance,@sandreza might be a good idea to code up the case we were using the diagnose the race condition as a test and see if we can catch the race condition in CI @ali-ramadhan,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926693915:82,race condition,race condition,82,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-926693915,2,['race condition'],['race condition']
Performance,"@siddharthabishnu, `CUDA.@allowscalar` introduced by [3cdd470](https://github.com/CliMA/Oceananigans.jl/pull/3488/commits/3cdd4705fedf3238d8858bb0f56e9b27b01ba34a) is detrimental for performance. Like it induces O(10-100x) slowdown I think.... Is this a temporary solution?. cc @glwagner, @simone-silvestri",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2033827149:183,perform,performance,183,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3488#issuecomment-2033827149,1,['perform'],['performance']
Performance,"@simone-silvestri : I tried running the branch in it's current version and received a GPU error. Is this something that works on your machine?. ```; ERROR: LoadError: InvalidIRError: compiling kernel gpu_calculate_Guh!(Cassette.Context{nametype(CUDACtx), Nothing, Nothing, KernelAbstractions.v; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785:156,Load,LoadError,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2522#issuecomment-1130253785,1,['Load'],['LoadError']
Performance,@simone-silvestri @jagoosw I think this PR may solve the race condition issue. The essential reason is that the Manifest was being re-resolved after init because downstream tests imported additional packages that were not imported during the initial instantiation.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361545069:57,race condition,race condition,57,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783#issuecomment-2361545069,1,['race condition'],['race condition']
Performance,"@simone-silvestri In addition to the NetCDF issue I mentioned [here](https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304038524), I found out that the `cell_advection_timescale()` and `interior()` aren't working with `MultiRegionGrids` yet. Here's an error example:. ```julia; ERROR: LoadError: type MultiRegionObject has no field parent; Stacktrace:; [1] getproperty; @ ./Base.jl:38 [inlined]; [2] cell_advection_timescale(model::NonhydrostaticModel{Oceananigans.TimeSteppers.QuasiAdamsBashforth2TimeStepper{Float64, NamedTuple{(:u, :v, :w), Tuple{Field{Face, Center, Center, Nothing, MultiRegionGrid{Float64, Bounded, Periodic, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, RightConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, LeftConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}, MultiRegionObject{Tuple{Tuple{Colon, Colon, Colon}, Tuple{Colon, Colon, Colon}}, Tuple{CPU, CPU}}, MultiRegionObject{Tuple{OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}}, Tuple{CPU, CPU}}, Any, MultiRegionObject{Tuple{FieldBoundaryConditions{Nothing, Bo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304574572:300,Load,LoadError,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1304574572,1,['Load'],['LoadError']
Performance,"@simone-silvestri Will do!. At the moment I am using `momentum_advection = VectorInvariant()`. If it goes unstable I will try the one you suggested on the other PR. I also tried what you suggested on the other PR,. ```; VectorInvariant(vorticity_scheme = WENO(), kinetic_energy_gradient_scheme = WENO()); ```. This failed because of the error below. Any idea what I need to do to fix this?. ```; ERROR: LoadError: MethodError: no method matching _symmetric_interpolate_yᵃᶜᵃ(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{…}, ::EnergyConserving{…}, ::typeof(Oceananigans.Advection.δx_v²), ::Field{…}, ::Field{…}). Closest candidates are:; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Union{Centered{2}, Centered{3}, Centered{4}, Centered{5}, Centered{6}, UpwindBiased{2}, UpwindBiased{3}, UpwindBiased{4}, UpwindBiased{5}, UpwindBiased{6}, WENO}, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/ImmersedBoundaries/conditional_fluxes.jl:210; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::ImmersedBoundaryGrid, ::Union{Centered{1}, UpwindBiased{1}}, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/ImmersedBoundaries/conditional_fluxes.jl:207; _symmetric_interpolate_yᵃᶜᵃ(::Any, ::Any, ::Any, ::Any, ::VectorInvariant{<:Any, <:Any, true}, ::Any, ::Any...); @ Oceananigans ~/Software/Oceananigans.jl/src/Advection/vector_invariant_advection.jl:250; ... ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1984534233:403,Load,LoadError,403,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3502#issuecomment-1984534233,1,['Load'],['LoadError']
Performance,"@simone-silvestri and I have discussed a number of improvements to solvers (mostly refactoring and cleanup); I'm opening this issue to record our discussion. Here are some items in no particular order:. 1. `HeptadiagonalIterativeSolver` should use our internal `PreconditionedConjugateGradientSolver`. This is important because we need to use `PreconditionedConjugateGradientSolver` elsewhere, and we want to a) ensure that it's optimized and b) ensure we can reason about _why_ one solver is faster than another. 2. Related to 1., we can refactor `PreconditionedConjugateGradientSolver` to have a similar interface as `cg` from `IterativeSolvers`. Then we can swap in and out. 3. `HeptadiagonalIterativeSolver` should solve linear systems only, and have nothing to do with time-stepping. Right now `solve!` for the `HeptadiagonalIterativeSolver` is entangled with time-stepping:. https://github.com/CliMA/Oceananigans.jl/blob/90f7de4cb3ed2fa9e22231177fd56b0f33c39df9/src/Solvers/heptadiagonal_iterative_solver.jl#L286-L308. since it ""knows"" about ""`previous_Δt`"". This logic should be moved to `MatrixIterativeFreeSurfaceSolver`. 4. We should disentangle / modularize the implementation of matrix-based preconditioners in `HeptadiagonalIterativeSolver`. In particular we should be able to use matrix-based preconditioners with any iterative solver that uses `PreconditionedConjugateGradientSolver`. Right now, the fastest way to compute left-hand-sides is with `PCGImplicitFreeSurfaceSolver`, but the best preconditioners can only be used with `MatrixIterativeSolver`. If our code were more modular, we could use the matrix-based preconditioners with `PCGImplicitFreeSurfaceSolver` to achieve the fastest possible combination of methods. Note that some of the changes in #2412 will help (in particular, an improvement to the interface into `PreconditionedConjugateGradientSolver` for defining preconditioners). There's probably a few other things on the todo list so please add them here.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2418:429,optimiz,optimized,429,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2418,1,['optimiz'],['optimized']
Performance,"@simone-silvestri any tips?. For conditionals, we should use `ifelse`; then there is no issue for performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1252872891:98,perform,performance,98,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2737#issuecomment-1252872891,1,['perform'],['performance']
Performance,"@simone-silvestri can I convince you to rewrite this section with updated benchmarks, and include results for distributed systems?. https://github.com/CliMA/Oceananigans.jl?tab=readme-ov-file#performance-benchmarks",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3684:192,perform,performance-benchmarks,192,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3684,1,['perform'],['performance-benchmarks']
Performance,"@simone-silvestri this doesn't seem to be working when the domain is `Bounded` in the x direction. Is this expected?:. ```julia; ERROR: LoadError: MethodError: no method matching PressureSolver(::CPU, ::MultiRegionGrid{Float64, Bounded, Bounded, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{Float64, RightConnected, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, RectilinearGrid{Float64, LeftConnected, Bounded, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}}, Tuple{CPU, CPU}}, Tuple{CPU, CPU}, CPU}); Closest candidates are:; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number, <:Number}) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:24; PressureSolver(::Any, ::RectilinearGrid{<:Any, <:Any, <:Any, <:Any, <:Number, <:Number}) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:25; PressureSolver(::Any, ::ImmersedBoundaryGrid) at ~/.julia/packages/Oceananigans/F1fni/src/Models/NonhydrostaticModels/NonhydrostaticModels.jl:28; ...; Stacktrace:; [1] NonhydrostaticModel(; grid::MultiRegionGrid{Float64, Bounded, Bounded, Bounded, XPartition{Int64}, MultiRegionObject{Tuple{RectilinearGrid{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302898706:136,Load,LoadError,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302898706,1,['Load'],['LoadError']
Performance,@simone-silvestri you mentioned that in this PR the pressure solver is done on a single GPU for the time being. Can https://github.com/CliMA/Oceananigans.jl/pull/2538 be a stating point to optimize that as well? That PR is really close to ready I think,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302354230:189,optimiz,optimize,189,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795#issuecomment-1302354230,1,['optimiz'],['optimize']
Performance,"@simone-silvestri's recent work on scalable performance for the `HydrostaticFreeSurfaceModel` used the concept of ""inner"" and ""boundary"" regions to overlap communication and computation. The basic components are:. 1) Reduce communication as much as possible (for example, compute diagnostic variables wherever needed rather than communicating results); 2) Compute the ""interior"" of the tendencies first, which do not require halo regions, while communication is occurring; 3) Once communication is finished, compute the ""boundary regions"" of the tendency. Point (1) requires us to compute diagnostic variables inside halo regions. This requires both expanded sizes and offsets for each diagnostic variable. Different diagnostic variables have different sizes --- the width of the diagnostics kernels depends on how many points are accessed. Points (2) and (3) require computations over parts of the grid (reduced size + offset). These considerations demand a nice abstraction so that the code for launching kernels is readable and understandable (and also concise).",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3067:35,scalab,scalable,35,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3067,2,"['perform', 'scalab']","['performance', 'scalable']"
Performance,@tomchor I guess we are hoping we can merge without the 3/4 performance penalty.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190886871:60,perform,performance,60,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190886871,1,['perform'],['performance']
Performance,"@tomchor just wanted to echo @ali-ramadhan's thank you for finding that bug!. Right now Oceananigans shines for medium-size LES problems around 256^3, perhaps up to 384^3. For that application I think you may find it is as fast or faster than other codes. On that note, it'd be great to compare performance with other codes for this problem size. . For utterly massive problems like the one reported in the Sullivan paper you've posted, Oceananigans is probably not the right tool right now. We haven't experimented with multi-node parallelism yet, but as @ali-ramadhan suggests, its possible we will start working on either multi-CPU parallelism or multi-GPU parallelism soon. For reproducing the Sullivan paper, you may want multi-CPU parallelism simply because of the sheer number of nodes you'll need. It's worth noting that our AMD turbulence closure *may* be less resolution-dependent than the TKE-based closure used by NCAR LES / Sullivan (and yourself?) and thus it may be possible to run at lower resolution (potentially saving factors of 10-100 in resolution. A [paper by Abkar and Moin (2017)](https://link.springer.com/article/10.1007/s10546-017-0288-4) hints at the potential for very coarse simulations with AMD.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569:295,perform,performance,295,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/449#issuecomment-539774569,1,['perform'],['performance']
Performance,"@tomchor unfortunately we don't have an issue for this problem. @sandreza is it possible to open an issue to document the problem that we are seeing? In the case that this PR does not resolve the issue, we'd like to have an issue open... I don't have much hard evidence to provide but I can describe the problem as I've seen it. Basically, very rare, subtle irregularities have been observed on the GPU when using `HydrostaticFreeSurfaceModel` in a `Periodic, Bounded, Bounded` configuration. I think that it is possible the main issue is an interaction (a read-write race condition) associated with both impenetrable boundary conditions and periodic boundary conditions that affects the 8 corner points. The race condition affects model trajectories via the Coriolis force (which is the only term as far as I know that touches the 8 ""corner"" points affected by this race condition). Because the race condition only manifests when a `Coriolis` or `VectorInvariant` stencil touches corner points, it may not affect _most_ `Periodic, Periodic, Bounded` models, which could explain why we haven't caught it. The reason it doesn't affect those models is because this race condition would only affect the corner points of `w`, which are not touched when using an `FPlane` Coriolis model. However, it's possible (I'm not sure) that the race condition could affect models using `NonTraditionalFPlane` in `Periodic, Periodic, Bounded` configurations. More generally, it will also affect models that are bounded in the `y`-direction, because in those models the corner points of the `y`-velocity are affected and also invoked when using `FPlane` or `BetaPlane` coriolis. That's as much as I know. It's very hard to gather information about this bug because it's so rare are subtle. In other words, only one grid point among 10,000 iterations might be affected, and the errors induced are very small. To find this issue, we have to run tens of thousands of iterations of identical models on the GPU, and then co",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865:568,race condition,race condition,568,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985#issuecomment-921143865,4,['race condition'],['race condition']
Performance,"@vchuravy - I modified `src/Grid/zeros_and_ones.jl` to be; ```; using CUDA; using AMDGPU; using Oceananigans.Architectures: CPU, CUDAGPU, ROCmGPU, AbstractArchitecture; using KernelAbstractions; import Base: zeros. zeros(FT, ::CPU, N...) = zeros(FT, N...); zeros(FT, ::CUDAGPU, N...) = CUDA.zeros(FT, N...); zeros(FT, ::ROCmGPU, N...) = KernelAbstractions.zeros(AMDGPU.ROCBackend(), FT, N...). zeros(arch::AbstractArchitecture, grid, N...) = zeros(eltype(grid), arch, N...); zeros(grid::AbstractGrid, N...) = zeros(eltype(grid), architecture(grid), N...). @inline Base.zero(grid::AbstractGrid) = zero(eltype(grid)); @inline Base.one(grid::AbstractGrid) = one(eltype(grid)); ```. This throws the same error as just using `AMDGPU.jl`. For reference. ```; ERROR: LoadError: Not implemented; Stacktrace:; [1] error(s::String); @ Base ./error.jl:35; [2] runtime_module(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/interface.jl:173; [3] build_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:101; [4] (::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}})(); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:139; [5] lock(f::GPUCompiler.var""#136#138""{GPUCompiler.CompilerJob{GPUCompiler.GCNCompilerTarget, AMDGPU.Compiler.HIPCompilerParams}}, l::ReentrantLock); @ Base ./lock.jl:229; [6] macro expansion; @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/rtlib.jl:120 [inlined]; [7] load_runtime(job::GPUCompiler.CompilerJob); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [8] macro expansion; @ ~/.julia/packages/GPUCompiler/U36Ed/src/driver.jl:290 [inlined]; [9] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/U36Ed/src/utils.jl:92; [10] emit_llvm; @ ~/.julia/packages/GP",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420:760,Load,LoadError,760,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3468#issuecomment-1936309420,1,['Load'],['LoadError']
Performance,@xkykai do you think you could run some immersed boundary tests with this branch to make sure this change doesn’t affect your work? I think we’re interested in both performance and making sure the solution is high quality.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1582732172:165,perform,performance,165,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3080#issuecomment-1582732172,1,['perform'],['performance']
Performance,A longer-term solution for efficient global ocean simulations is to implement a split-explicit time-stepping scheme. The first step should involve a simple but stable method where efficiency/accuracy tests can be performed,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2012:213,perform,performed,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2012,1,['perform'],['performed']
Performance,"A more hierarchical organization of the docs is. 1. Introduction; * What's Oceananigans?; * Installation; * Writing your first script; * Do you want to save the world? (by contributing to Oceananigans); - Contributing guide; - Features that need validating; - Features that need documenting and examples; * Gallery; 2. Examples; 3. Building models, running simulations, and post processing; * Grids and computer architectures; * Fields, BoundaryCondition, and AbstractOperations; * IncompressibleModel; * HydrostaticFreeSurfaceModel; * ShallowWaterModel; * Setting initial conditions; * Diffusion, viscosity, and TurbulenceClosures; * Forcing functions; * Coriolis forces; * Buoyancy forces; * Simulation; * OutputWriters; * OutputReaders, post-processing, and plotting; 5. Useful tips; * Using Graphics Processing Units (GPUs); * Common errors and performance pitfalls; 8. Fluid dynamics and ocean physics; * Navier-Stokes and tracer conservation equations; * The hydrostatic approximation and shallow water equations; * The Boussinesq approximation and equations of state for seawater; * Rotating domains and Coriolis forces; * Diffusion, hyperdiffusion, and parameterization of subgrid processes; - Basic models for diffusive processes; - Large eddy simulation; - Boundary layer parameterization; 9. Numerical implementation; * The finite volume discretization on a staggered grid; * Interpolation, differencing, and advection schemes; * Boundary conditions and immersed boundaries; * The pressure correction method for enforcing mass conservation; * Discretization of hydrostatic and non-hydrostatic pressure; * Implicit time-stepping; * Multi-domain simulations and the cubed sphere; 10. Developer guide; 11. Appendix; * References",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142:849,perform,performance,849,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1852#issuecomment-879259142,2,['perform'],['performance']
Performance,"A new idea for extending the pressure solver to `MultiRegion` is to divide the FFT computations into ""local"" and ""non-local"" directions. . The FFT in local directions can be easily performed wrapping the transform in `@apply_regionally`; For non local directions, if `storage` and `plan` are `unified_array`s, the non local FFT can be performed by permuting the partitioning of the `MultiRegionGrid` without having to transpose memory (that will happen under the hood thanks to unified memory). . This strategy would not be easily extensible to generally subdivided regions and will play well only with one direction partitioning, but given the current limitations of the FFT solver (only regular grid), I think it is a good strategy to get something to work",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969:181,perform,performed,181,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2523#issuecomment-1119850969,2,['perform'],['performed']
Performance,A potential race condition fix [WIP],MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1985:12,race condition,race condition,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1985,1,['race condition'],['race condition']
Performance,"A preliminary implementation of (constant) smagorinsky.; - temporary arrays to be revisited; - need to improve the way to disable it (without loss of performance); - no attempt to try it on GPU. ; Tested with deep_convection example, running nicely with smag_coeff=3.3e-2 and Prandtl_num=1",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/218:150,perform,performance,150,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/218,1,['perform'],['performance']
Performance,"ADER: failed to open iris: /usr/lib/dri/iris_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: iris; libGL error: MESA-LOADER: failed to open swrast: /usr/lib/dri/swrast_dri.so: cannot open shared object file: No such file or directory (search paths /usr/lib/x86_64-linux-gnu/dri:\$${ORIGIN}/dri:/usr/lib/dri, suffix _dri); libGL error: failed to load driver: swrast; ┌ Warning: GLFW couldn't create an OpenGL window.; │ This likely means, you don't have an OpenGL capable Graphic Card,; │ or you don't have an OpenGL 3.3 capable video driver installed.; │ Have a look at the troubleshooting section in the GLMakie readme:; │ https://github.com/JuliaPlots/Makie.jl/tree/master/GLMakie#troubleshooting-opengl.; └ @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:381; ERROR: LoadError: GLFWError (VERSION_UNAVAILABLE): GLX: Failed to create context: GLXBadFBConfig; Stacktrace:; [1] _ErrorCallbackWrapper(code::Int32, description::Cstring); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/callback.jl:43; [2] CreateWindow(width::Int64, height::Int64, title::String, monitor::GLFW.Monitor, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:499; [3] GLFW.Window(; name::String, resolution::Tuple{Int64, Int64}, debugging::Bool, major::Int64, minor::Int64, windowhints::Vector{Tuple{UInt32, Integer}}, contexthints::Vector{Tuple{UInt32, Integer}}, visible::Bool, focus::Bool, fullscreen::Bool, monitor::Nothing, share::GLFW.Window); @ GLFW ~/.julia/packages/GLFW/BWxfF/src/glfw3.jl:344; [4] GLMakie.Screen(; resolution::Tuple{Int64, Int64}, visible::Bool, title::String, kw_args::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ GLMakie ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:373; [5] Screen; @ ~/.julia/packages/GLMakie/XG7Hm/src/screen.jl:345 [inlined]; [6] global_gl_screen; @ ~/.julia/packages/GLMakie/XG7Hm/",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985:1386,Load,LoadError,1386,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542#issuecomment-1123091985,1,['Load'],['LoadError']
Performance,"Abstraction for ""equation"" for performance, code clarity, memory footprint reduction, and powerful user interface",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/259:31,perform,performance,31,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/259,1,['perform'],['performance']
Performance,"According to @maleadt on the Julia slack's GPU channel and in regards to the shallow water model profiles:. > Don't focus on time spent in API calls to much. since GPU execution is asynchronous, you'll have to synchronize at some point, and that API call will then 'soak up' time until the stream has finished executing. and here that's literally the synchronize function, which is implemented using cuStreamQuery: https://github.com/JuliaGPU/CUDA.jl/blob/2b3ec03ff9774b65541fc88dd6b0f1f7aea5d9e0/lib/cudadrv/stream.jl#L115-L144. >use a timeline profiler (i.e. NSNight Systems) to profile your app, or nvpp if you really want to use the old profiler toolchain. plain nvprof results are too simple once your application hits some level of complexity. >now, it is possible that our CPU-side implementation of synchronize does too many API calls and could be optimized a little, but in the end the call serves to wait until the GPU has finished so it probably doesn't matter much. if it does, e.g. because you want to perform other useful work on another CPU task concurrently, you could try to profile that in isolation and file an issue. Essentially, Tim explains that `cuStreamQuery` takes up more time as the grid size increases because it's called in the synchronize function. The synchronize function as shown in the link above tends to be called more and soaks up more waiting time the bigger the problem hence why it scales positively to grid size. ; Taking a closer look at the shallow water gpu profiling results above, it seems that `cuStreamQuery` takes up a lot of time in the finer resolution runs because it is called many times and not because each call takes a lot of time. For example, in the 16k case, `cuSteamQuery` is called three order of magnitudes more times than `cuLaunchKernel` while both calls are measured in microseconds. ; I'm not sure if `cuStreamQuery` being called 400,000 times is an error with our code, an error with CUDA.jl, not an error at all, or an error with my ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654:856,optimiz,optimized,856,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1912#issuecomment-899945654,2,['optimiz'],['optimized']
Performance,Adds test for race condition in `compute!(::AveragedField)`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1805:14,race condition,race condition,14,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1805,1,['race condition'],['race condition']
Performance,"After adding `MPI.Init()` back to `distributed_nonhydrostatic_model_mpi.jl`, the script seems to run (it's still running...). Here's a few idle thoughts (independent of this PR, just leaving here for future reference):. * The ""Benchmarks"" module in `/benchmarks/src` causes a few issues like:; ```julia; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ```; It'd be nice to fix that eventually. * The output is kind of annoying:. ```julia; [2022/03/13 13:17:49.875] INFO Benchmarking weak scaling nonhydrostatic model with Slab decomposition [N=(128, 128, 32), ranks=(1, 2, 1)]...; Invalid MIT-MAGIC-COOKIE-1 keyInvalid MIT-MAGIC-COOKIE-1 keyNo protocol specified; [ Info: Oceananigans will use 24 threads; [ Info: Oceananigans will use 24 threads; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for Benchmarks are suppressed.; ┌ Warning: Package Benchmarks does not have Oceananigans in its dependencies:; │ - If you have Benchmarks checked out for development and have; │ added Oceananigans as a dependency but haven't updated your primary; │ environment's manifest file, try `Pkg.resolve()`.; │ - Otherwise you may need to report an issue with Benchmarks; └ Loading Oceananigans into Benchmarks from project dependency, future warnings for ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590:637,Load,Loading,637,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2338#issuecomment-1066145590,1,['Load'],['Loading']
Performance,"After discussing with @ali-ramadhan, it seems more clear that a simple solution is just to use a default halo size of 3. For most models that use the highest order advection scheme we offer this has no effect. For models that use a lower-order advection scheme but don't change the halo size, the memory foot print of the model is ever-so-slightly larger than it needs to be. But this slightly-larger footprint probably isn't noticeable for most problems. So in summary, minimal halo sizes are a minor optimization that has little effect on most problems. Auto-optimizing the halo size has major downsides for usability, so I think the trade-off leans towards big default halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883:502,optimiz,optimization,502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1245#issuecomment-741886883,4,['optimiz'],"['optimization', 'optimizing']"
Performance,"After some discussion with @glwagner , I'm going to close this PR and rebase off of CLIMA:main. Stay tuned for a new PR..",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3466#issuecomment-1934850421:101,tune,tuned,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3466#issuecomment-1934850421,1,['tune'],['tuned']
Performance,"After the big changes yesterday I decided to run the tests to make sure everything was working. Thanks again @ali-ramadhan for helping me get that started. Now I'm finding that there are some failures and somethings that are broken. See below. Is it just me or do others get this now?. ```; Test Summary: | Pass Fail Broken Total; Oceananigans | 2987 8 5 3000; Unit tests | 1511 1 1512; Model and time stepping tests (part 1) | 99 99; Model and time stepping tests (part 2) | 214 1 215; Simulation tests | 1142 2 3 1147; Simulations | 26 26; Diagnostics | 12 12; Output writers | 409 2 411; FieldSlicer | 1 1; WindowedTimeAverage | 2 2; NetCDF [GPU] | 198 198; JLD2 [GPU] | 11 11; Checkpointer [GPU] | 166 2 168; Dependency adding [GPU] | 2 2; Time averaging of output [GPU] | 29 29; Abstract operations | 695 3 698; Regression | 14 6 20; Thermal bubble [GPU] | 5 5; Rayleigh–Bénard tracer [GPU] | 5 5; Ocean large eddy simulation [GPU] | 4 6 10; Scripts | 7 7; ERROR: LoadError: Some tests did not pass: 2987 passed, 8 failed, 0 errored, 5 broken.; in expression starting at /home/fpoulin/software/Oceananigans.jl/test/runtests.jl:77; ERROR: Package Oceananigans errored during testing; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1179:969,Load,LoadError,969,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1179,1,['Load'],['LoadError']
Performance,"After updating to julia 1.8.2 and updating branch to main, I tried running the validaton experiment `resting_stratified_bumpy_ocean.jl` and it failed. @fadaie91 also tried the same thing, and saw the same error. The problem is when we define the model, it complains about a `nested task error`. ```; grid = 1×128×64 ImmersedBoundaryGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo:; ├── immersed_boundary: PartialCellBottom(min(h)=-1.00e+00, max(h)=-5.00e-01, ϵ=0.2); ├── underlying_grid: 1×128×64 RectilinearGrid{Float64, Flat, Periodic, Bounded} on CPU with 0×3×3 halo; ├── Flat x; ├── Periodic y ∈ [-1.0, 1.0) regularly spaced with Δy=0.015625; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.015625; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 1×134×1 OffsetArray(::Array{Float64, 3}, 1:1, -2:131, 1:1) with eltype Float64 with indices 1:1×-2:131×1:1 at index [0, 1]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, I::Tuple{Int64, Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] overdub; @ ./abstractarray.jl:1273 [inlined]; [5] overdub; @ ./abstractarray.jl:1241 [inlined]; [6] overdub; @ ~/Software/Oceananigans.jl/src/ImmersedBoundaries/partial_cell_immersed_boundaries.jl:49 [inlined]; ...; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2798:731,Load,LoadError,731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2798,1,['Load'],['LoadError']
Performance,Again unsure if it affects performance but since `rate` is referenced as global it needs to be `const`; eg `const rate = 1/10`.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875683170:27,perform,performance,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1827#issuecomment-875683170,1,['perform'],['performance']
Performance,"Agreed. Useful and related comment. > I was thinking of doing some prototyping and benchmarking in a sandbox by building off the example in my PR [vchuravy/GPUifyLoops.jl#18](https://github.com/vchuravy/GPUifyLoops.jl/pull/18).; > ; > The PR contains an example that can be extended to rely on a `Grid` struct, multiple `FaceField`s and ` CellField`. So I'll prototype grids and fields that are `isbitstype` (you already helped by doing this for a grid in [#59 (comment)](https://github.com/climate-machine/Oceananigans.jl/issues/59#issuecomment-467660181)) and test to see if they work on the GPU with GPUifyLoops.jl. If they do work and performance isn't degraded then I'll rewrite the operators to use grid and field structs.; > ; > You probably know how to do this better than me, but might be good if I rewrite the operators as they's still undocumented and do some _slightly convoluted_ stuff to avoid having to store intermediate calculations.; > ; > Right now I'm focusing on system tests and benchmarks but once @christophernhill @jm-c and I get closer to implementing the variable _Δz_ grid #47 I will work on this.; >; >_Originally posted by @ali-ramadhan in https://github.com/climate-machine/Oceananigans.jl/issues/115#issuecomment-470782067_",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910:639,perform,performance,639,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/59#issuecomment-470297910,1,['perform'],['performance']
Performance,"Ah ok I see why your original script didn't work now. When executing. ```julia; model = IncompressibleModel(grid=grid,; closure = closure,; boundary_conditions = (v=v_bcs); ); ```. this assigned `v_bcs` to the new variable `v` and passes it to the `IncompressibleModel` function. `v_bc` itself is a `NamedTuple` containing `x, y, z` properties so the `IncompressibleModel` constructor does not complain. Since the named tuple that is passed does not not have a `v` property, the velocities get the default boundary conditions (free slip and no normal flow). Then when you call `set!(model, v=-0.5)` it fills v to be -0.5 everywhere but then `update_state!(model)` is called to ensure that the velocity field is incompressible (divergence-free) by performing a pressure projection step. Since the default boundary condition enforces no-normal flow, the velocity cannot be -0.5 everywhere so the pressure field updates it to be zero to enforce incompressibility. This is a pretty subtle bug (related to #1204)... Since the proper named tuple can't be checked for in the constructor function signature, I wonder if it's worth adding a manual check to make sure a `NamedTuple{(:x,:y,:z)}` was not passed to the model constructor.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930:747,perform,performing,747,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1294#issuecomment-756979930,1,['perform'],['performing']
Performance,"Ah so I've realised this isn't the fix we needed, and I was just hiding it from myself in the profile because I replaced the function by writing it in the REPL. I made an MWE:. ```jula; using Oceananigans. grid = RectilinearGrid(GPU(), topology = (Flat, Flat, Bounded), size = (100, ), extent = (400, )). model = HydrostaticFreeSurfaceModel(; grid, velocities = PrescribedVelocityFields(), momentum_advection=nothing, buoyancy=nothing, tracers = ntuple(n->Symbol(:T, n), Val(30))); ```; <img width=""1361"" alt=""Screenshot 2024-09-26 at 12 00 29"" src=""https://github.com/user-attachments/assets/2cf2a379-88e9-428f-8156-4ddead2a02e4"">; You can see from this profile that `fill_open_boundary_regions!` takes a lot longer than `fill_halo_event!`, even though there are no velocity open boundaries. This is because it is launching a load of zero size kernels where as `fill_halo_event!` just returns nothing instead. I've fixed this now and get this from the profile instead:; <img width=""1251"" alt=""Screenshot 2024-09-26 at 12 02 11"" src=""https://github.com/user-attachments/assets/0bf91086-bc12-4a17-ba48-89b9b1c2e7ae"">. In numbers, the original version benchmarks `time_step!` at around 4.074 ms ± 581.472 μs and the new version 2.438 ms ± 501.642 μs",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3792#issuecomment-2376508207:827,load,load,827,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3792#issuecomment-2376508207,1,['load'],['load']
Performance,"Ah sorry I must have misunderstood your question. Yeah I think broadcasts; tend to perform really well on scalar operations so I don't see why not. On Tue, Mar 5, 2019, 12:13 PM Gregory L. Wagner <notifications@github.com>; wrote:. > I'm not suggesting we should always use broadcasting. I'm just wondering; > if it's ok to use it for simple operations. It's a nice abstraction that; > works on CPUs and GPUs for simple calculations / global array updates (for; > example; > <https://github.com/glwagner/StaggeredPoisson.jl/blob/d104825ba33f184af3b90ca0d958247d0011c7ad/src/solvers.jl#L148>; > ).; >; > —; > You are receiving this because you were mentioned.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/108#issuecomment-469768233>,; > or mute the thread; > <https://github.com/notifications/unsubscribe-auth/ATKyBSiIR6hlh-r4hjpSmahUJhp3x7Gzks5vTqXEgaJpZM4bfFUj>; > .; >",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469769111:83,perform,perform,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/108#issuecomment-469769111,1,['perform'],['perform']
Performance,"Ah yes as noted here:. > This speed issue disappears either when ζ = ∂x(v) - ∂y(u) is replaced with ζ = Field(∂x(v) - ∂y(u)), or when ζ is the only variable in fields_slice. That's pretty bizarre. That makes me think it's some kind of weird interaction between `NCDatasets` and `Oceananigans`. I can say, with `ζ = Field(∂x(v) - ∂y(u))` the output type is different. It would seem more complex in fact, because it has one more layer of indirection (ie it's the window that refers to a 3D computed field, rather than a windowed computed field). So I don't know why that would compile faster. Honestly I don't think any of us has much experience optimizing compile time. Perhaps first reading this blog post:. https://julialang.org/blog/2020/08/invalidations/. and then the source code for `NetCDFOutputWriter` will lead to revelations.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189:644,optimiz,optimizing,644,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3381#issuecomment-1805104189,1,['optimiz'],['optimizing']
Performance,"Ah! In `HydrostaticFreeSurfaceModel`, the implicit free surface algorithm uses a pressure correction / operator splitting method. It's really a sort of pseudo-implicit treatment (because the velocity field is _corrected_ rather than time-stepped concurrently with the free surface. I think it would be possible to implement an operator splitting method in `ShallowWaterModel`. But is this useful? This could lead to a loss of accuracy (I'm not sure). In the event that the pressure / free surface displacement is passive (so one doesn't care about accuracy), it might be better to use a rigid lid approximation (and thus a two-dimensional `IncompressibleModel`, rather than `ShallowWaterModel`). But I am ready to stand corrected.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1378#issuecomment-781574578:246,concurren,concurrently,246,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1378#issuecomment-781574578,1,['concurren'],['concurrently']
Performance,"Ah, apparently the error appears when we have an `AveragedTimeInterval`. Change the `simple_output` call to. ```julia; simulation.output_writers[:simple_output] = NetCDFOutputWriter(model, wout,; schedule = AveragedTimeInterval(10seconds),; filepath = ""windowed_avg.nc"", mode = ""c""); ```. and we have the following error:. ```; ERROR: LoadError: Custom output Uw needs dimensions!; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::String, ::Type{T} where T, ::Int64, ::Tuple{}, ::Dict{Any,Any}) at /home/tomas/repos2/Oceananigans.jl/src/OutputWriters/netcdf_output_writer.jl:357; [3] NetCDFOutputWriter(::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :b),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{Coordinat",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056:335,Load,LoadError,335,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784246056,1,['Load'],['LoadError']
Performance,"Ah, nice! Maybe using `ConditionalOperation` is a bit slower than `WindowSpatialAverage` because the reduction is performed on the whole domain. Anyways, I don't think reduction is performance-critical so I agree to nuke `WindowSpatialAverage`.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022501885:114,perform,performed,114,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2185#issuecomment-1022501885,2,['perform'],"['performance-critical', 'performed']"
Performance,"Ah, thanks for that @maleadt. So microbenchmarks suggest squaring by `Float64` and `Int32` are virtually indistinguishable in simple code. Is there any way that this change is somehow affected by compiler heuristics; eg code inlining is somehow much more effective / optimized when we can invoke `nv_pow`... ? Otherwise I'm at a loss. I think prior to the changes we grouped into our ""upgrade to julia 1.6"" we were using the function `CUDA.pow` (from an ancient `CUDA.jl` version).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869812530:267,optimiz,optimized,267,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1770#issuecomment-869812530,2,['optimiz'],['optimized']
Performance,"Also important to keep in mind in this discussion: Our workflow will be different from most standard models, which write out instantaneous output that then is post-processed to get statistics etc. We will have to accumulate statistics on the fly, and we can (and should) forgo most instantaneous output, at least for the atmosphere. The model will learn from the accumulated statistics. Otherwise, with instantaneous output, the data volume, especially with embedded LES, will create an I/O and data transfer bottleneck that will limit us, and, e.g., will limit our ability to use distributed computing platforms.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475692509:509,bottleneck,bottleneck,509,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475692509,1,['bottleneck'],['bottleneck']
Performance,"Also reported by @qwert2266 but this is my fault since GitLab CI doesn't seem to be actually running GPU tests... Using something like; ```julia; @inline FT(x, y, z, t, T, p) = - exp(z/p.ℓ) * 2p.K/p.Δz^2 * T; T_forcing = Forcing(FT, field_dependencies=:T, parameters=bc_params); forcing = (T=T_forcing,); ```. causes. ```; ERROR: LoadError: GPU compilation of kernel gpu_calculate_Gu!(Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks}, typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!), OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}, RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, Oceananigans.Advection.CenteredSecondOrder, NonTraditionalFPlane{Float64}, Nothing, AnisotropicDiffusivity{Float64,Float64,Float64,NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}},NamedTuple{(:T,),Tuple{Float64}}}, NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, NamedTuple{(:T,),Tuple{OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}}}}, Nothing, NamedTuple{(:u, :v, :w, :T),Tuple{Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:330,Load,LoadError,330,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['Load'],['LoadError']
Performance,"Also, I forgot to post an example of the error that happens when you pass an operation as a `condition`. Here's the error that I get in that case:. ```; ERROR: LoadError: MethodError: no method matching arch_array(::CPU, ::KernelFunctionOperation{Center, Center, Face, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Float64, typeof(boundary_node), Tuple{Center, Center, Face}}). Closest candidates are:; arch_array(::Distributed, ::Any); @ Oceananigans ~/repos/Oceananigans.jl/src/DistributedComputations/distributed_architectures.jl:263; arch_array(::CPU, ::Array); @ Oceananigans ~/repos/Oceananigans.jl/src/Architectures.jl:59; arch_array(::CPU, ::CUDA.CuArray); @ Oceananigans ~/repos/Oceananigans.jl/src/Architectures.jl:60; ... Stacktrace:; [1] condition_operand; @ ~/repos/Oceananigans.jl/src/ImmersedBoundaries/immersed_reductions.jl:24 [inlined]; [2] sum(f::Function, c::Oceananigans.AbstractOperations.GridMetricOperation{Center, Center, Center, ImmersedBoundaryGrid{Float64, Periodic, Periodic, Bounded, RectilinearGrid{Float64, Periodic, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, Periodic, Periodic, B",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1907385408:160,Load,LoadError,160,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3439#issuecomment-1907385408,1,['Load'],['LoadError']
Performance,"Also, the docs are failing to build with this error:. ```; ERROR: LoadError: IOError: sendfile: no space left on device (ENOSPC); ```. Do we still have a storage problem? I believe these tests run on tartarus, not sverdrup, no?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867678106:66,Load,LoadError,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1762#issuecomment-867678106,1,['Load'],['LoadError']
Performance,"Also, the implicit vertical solver seems to affect the performance. I would have to guess that it is because we are passing functions as arguments to the kernel.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485410927:55,perform,performance,55,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2996#issuecomment-1485410927,1,['perform'],['performance']
Performance,"Also, what's the correct syntax to define kernel_parameters over one dimension? For example, the line; ```julia; kernel_parameters = KernelParameters((Nc, 1), (0, Nz_grid-1)); ```; works correctly. However, when I try to define it for one dimension with; ```julia; kernel_parameters = KernelParameters((1,), (Nz_grid-1,)); ```; I encounter the following error:; ```julia; ERROR: LoadError: MethodError: no method matching heuristic_workgroup(::Int64). Closest candidates are:; heuristic_workgroup(::Any, ::Any, ::Any, ::Any); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-aquaplanet/src/Utils/kernel_launching.jl:48; heuristic_workgroup(::Any, ::Any, ::Any); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-aquaplanet/src/Utils/kernel_launching.jl:48; heuristic_workgroup(::Any, ::Any); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-aquaplanet/src/Utils/kernel_launching.jl:48; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3611#issuecomment-2138476721:379,Load,LoadError,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3611#issuecomment-2138476721,1,['Load'],['LoadError']
Performance,"Am I doing something wrong?; ```julia; navid:Oceananigans.jl/ (master) $ julia --project [19:00:13]; _; _ _ _(_)_ | Documentation: https://docs.julialang.org; (_) | (_) (_) |; _ _ _| |_ __ _ | Type ""?"" for help, ""]?"" for Pkg help.; | | | | | | |/ _` | |; | | |_| | | | (_| | | Version 1.1.0 (2019-01-21); _/ |\__'_|_|_|\__'_| |; |__/ |. julia> include(""examples/internal_wave.jl""); ERROR: LoadError: could not open file /Users/navid/Research/Oceananigans.jl/examples/utils.jl; ...; ```. I guess the problem is the `include(""utils.jl"")` line found in all example .jl scripts. Is this supposed to be `src/utils.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/254:389,Load,LoadError,389,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/254,1,['Load'],['LoadError']
Performance,"Among the packages that are loaded in `dependencies_for_runtests.jl` are `DataDeps` and `TimeDate`, which aren't part of Oceananigans dependencies. So I always have to either install those packages or comment out those lines when running tests locally. (Unless there's an easier solution that I'm not aware of!). While this isn't a huge hassle, it does make it less likely (at least for me) to test my changes locally, so I'm attempting this slight change in the loading of packages where only standard Julia packages and Oceananigans dependencies are loaded in `dependencies_for_runtests.jl` and the rest are loaded only in the scripts where they used. Hopefully this should make testing changes locally easier for everyone.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2715:28,load,loaded,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2715,4,['load'],"['loaded', 'loading']"
Performance,"An easier course of action would be to forget about performance at first and just fill halos every substep.; This will be quite inefficient but will allow us to test open boundary conditions for the hydrostatic model and validate them first. There is an implementation of a split explicit free surface solver that does not require special operators (specifically for a multi region grid) in #3596 ; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L130-L170. We could adapt this implementation for normal grids by implementing a keyword argument in the `SpliExplicitFreeSurface` constructor. Something like the `extended_halos` that is mentioned here; https://github.com/CliMA/Oceananigans.jl/blob/a6e9a465aa9528b5b3afd49737310e710e4681b0/src/MultiRegion/multi_region_split_explicit_free_surface.jl#L19-L28. For serial grids, `extended_halos` is not the correct argument, though, because we do not extend halos (we do that only on distributed and multi region grids), so maybe something like `use_boundary_aware_operators.` . Once the numerics have been settled we can adapt the open boundary condition implementation to the special operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268:52,perform,performance,52,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3828#issuecomment-2399186268,1,['perform'],['performance']
Performance,"Another important point is that this discussion is not about ""deciding"" on a _single_ user interfaces, but rather deciding what interfaces we want to put into the code. We can and perhaps should have multiple ways of specifying stretched grids. We have already agreed that specifying cell interface locations with an array (loaded from file, for example) is an important pattern to support.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072:324,load,loaded,324,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-814924072,1,['load'],['loaded']
Performance,"Another thought for @christophernhill . At the talk today on `ImplicitGlobalGrid.jl`, they were using `@view` in the simplest code but they dropped it as soon as they started to optimize the code. I believe they started using `LazyArrays.jl`. I don't know what it is but I suspect it doesn't have the problems that `@view` might have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320:178,optimiz,optimize,178,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-885901320,2,['optimiz'],['optimize']
Performance,"Apologies - other urgent work and family needs have delayed me. I'm using; Julia 1.9.3; CairoMakie v0.9.4; and have in my status report; GLMakie v0.7.4 and Makie v0.18.4. I tried to use update with the pkg manager to no effect, but see I should be using CairoMakie@0.11, which I am now installing.; This was not successful. For example the file S7LmV_3TYIX.dll would not load giving a permission denied error, but my check of the properties/security did not reveal a deficiency. However, the example worked fine. Many thanks - Kevin",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1920152651:371,load,load,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3442#issuecomment-1920152651,1,['load'],['load']
Performance,"Apologies for the late reply, I got distracted and accidentally forgot to respond. I tested out the fix this morning/early afternoon and I keep getting an error along the lines of what I have below. Did I compile the branch of oceananigans incorrectly?. ```julia; wireless-10-104-201-207:BottomBoundaryLayer loganknudsen$ julia ""/Users/loganknudsen/Documents/GitHub/BottomBoundaryLayer/PSI_Base_Test.jl""; ┌ Warning: Overwriting existing ./psi_base_ocng_test.nc.; └ @ Oceananigans.OutputWriters ~/.julia/packages/Oceananigans/Feeqx/src/OutputWriters/netcdf_output_writer.jl:359; ERROR: LoadError: NetCDF error: Permission denied (NetCDF error code: 13); Stacktrace:; [1] check; @ ~/.julia/packages/NCDatasets/st9Jz/src/errorhandling.jl:25 [inlined]; [2] nc_create(path::String, cmode::UInt16); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/netcdf_c.jl:255; [3] NCDatasets.NCDataset(filename::String, mode::String; format::Symbol, share::Bool, diskless::Bool, persist::Bool, memory::Nothing, attrib::Dict{Any, Any}); @ NCDatasets ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:236; [4] NCDataset; @ ~/.julia/packages/NCDatasets/st9Jz/src/dataset.jl:177 [inlined]; [5] NetCDFOutputWriter(model::NonhydrostaticModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64, NamedTuple{(:u, :v, :w, :b), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Flat, Periodic, Bounded, Float64, Float64, Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, Float64, FieldBoundaryConditions{Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{O",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784:585,Load,LoadError,585,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3228#issuecomment-1747397784,1,['Load'],['LoadError']
Performance,"Apparently defining a forcing in this way actually slows the model down by a lot. It's ~2x slower with just this one forcing function which seems a little excessive. ```julia; @inline FT(grid, U, Φ, i, j, k) = ifelse(k == 1, -1e-4 * (Φ.T[i, j, 1] - 0), 0); forcing = Forcing(FT=FT); ```. Seems that maybe the exact way the forcing function is defined could have a huge impact on performance.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/365:379,perform,performance,379,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/365,1,['perform'],['performance']
Performance,"Are the current options (`@async` blocks) not sufficient? I'd rather not have a parallel mechanism and have to maintain the APIs (explicitly passing streams/queues) to support it. Even right now it's relatively broken, only supporting kernel launches and memory copies (i.e. BLAS APIs do not take explicit stream arguments).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1429353692:157,queue,queues,157,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2924#issuecomment-1429353692,1,['queue'],['queues']
Performance,"Are we ok with this as a user interface? it's a little implicit. We could alternatively use a function-based API to make things a little more obvious, something like. ```julia; fts[1, 2, 3, 4] # get 4th time-index; ```. ```julia; at_time(4, fts, 1, 2, 3) # linearly interpolate to t=4; ```. mainly i'd be worried about issues like. ```julia; fts[1, 2, 3, 4] \ne fts[1, 2, 3, 4.0]; ```. which is rather easy to confuse?. We also might be able to use syntax like. ```julia; fts[1, 2, 3, time=4]; ```. if that is performant. Or. ```julia; fts[1, 2, 3, Time(4)]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139:510,perform,performant,510,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3236#issuecomment-1696028139,1,['perform'],['performant']
Performance,"Are you proposing a third interface that takes a 3-argument function of `x, L, N`? I think that's fine as a proposal, I just want to be clear about what is being suggested, exactly. What I didn't understand is how one can specify the cell interface locations (call it the ""`z_faces` interface"" --- the one we currently have) without knowing the number of grid points:. > I agree that to define the grid with z_faces we need to know the number of grid points, but that can be done internally. I agree there are other possible interfaces that _do not_ require passing the number of grid points as a parameter; or rather simplify this process by performing calculations under the hood. It could be nice to design types such as `LinearStretching` or `ChebyshevStretching` that provide users with out-of-the-box stretched grids to be used with interface 2 proposed above (call this the ""coordinate map interface""). We can incorporate dispatch on such types (versus on plain functions) in the grid constructor. An example of this being used is. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = ChebyshevStretching()); ```. or, when a parameter is involves such as for hyperbolic stretching, something like. ```julia; grid = VerticallyStretchedRectilinearGrid(size = (Nx, Ny, Nz), ; x = (0, 2π),; y = (0, 2π),; z = (-1, 1),; z_stretching = HyperbolicStretching(stretching_parameter=1.3)); ```. It seems like maybe there is a 3rd option too? It looks somewhat similar to the coordinate map interface, except that the map expects three arguments rather than one, and returns an array rather than a scalar value that represents the map?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100:643,perform,performing,643,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1551#issuecomment-815419100,2,['perform'],['performing']
Performance,"As a first step towards porting the Simulations infrastructure out of Oceananigans and into (ClimaEarth)[https://github.com/CliMA/ClimaEarth.jl], we should refactor the Simulations implementation so that it gets loaded _first_. Currently, it is loaded last:. https://github.com/CliMA/Oceananigans.jl/blob/fad81b074cc914173d1760ae4769a24841e20a83/src/Oceananigans.jl#L195-L229. This reorganization will help disentangle the current implementation from Oceananigans.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3088:212,load,loaded,212,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3088,2,['load'],['loaded']
Performance,"As an aside, I think this issue illustrates that users are indeed interested in being able to evaluate gradients across boundaries. This is important because @simone-silvestri proposed a change that would make this impossible (eg it has been proposed we do not fill halos for `Value` and `Gradient` boundary conditions, and instead evaluate the associated fluxes in the same way we do for immersed boundaries --- because this has performance advantages for very large models).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689901112:430,perform,performance,430,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689901112,1,['perform'],['performance']
Performance,"As an update, I have pushed a commit consisting of a working version of the double gyre example, where Δz is replaced by zspacings and znodes, the plots are improved with additional attributes, and visualization is performed on the CPU even if the code runs on the GPU. I still need to incorporate some of the suggested modifications listed above. I am uploading the plots and animation here. In today's meeting with Navid and Simone, we looked at switching to the lat-lon grid and more. In the upcoming commits, I will run for longer time on a lat-lon grid, introduce checkpoints for restarting the simulation, and add a topography. . [double_gyre_grid_spacing.pdf](https://github.com/CliMA/Oceananigans.jl/files/11493173/double_gyre_grid_spacing.pdf). [double_gyre_circulation.pdf](https://github.com/CliMA/Oceananigans.jl/files/11493174/double_gyre_circulation.pdf). https://github.com/CliMA/Oceananigans.jl/assets/12926768/cf148a0c-58c8-4ba2-b649-cb40418d0665",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-1550535207:215,perform,performed,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3087#issuecomment-1550535207,1,['perform'],['performed']
Performance,"As discussed via zoom with @kburns, passing a key to computations to be stored and used to determine whether a computation needs to be performed is a simple method that may work for us. A simple option for a key is the current model time, which works for all the time stepping methods we employ and has the additional advantage of interpretability. One complication is that we allow users to specify memory space for `ComputedField`s and `AveragedField`s. As a result, two `ComputedField`s that share memory space may have incorrect `data` if the memory is overwritten. This is, in fact, a problem even in the current code and not dependent on the optimizations discussed in this issue. Since we think it is important to give users the option of avoiding unnecessary memory allocation by managing the allocation of scratch space for computations, we cannot prevent incorrect output resulting from overwriting of scratch space during operations with embedded averaged fields and computed fields. We simply have to document this potential ""gotcha"". We can make avoiding repeated operations a bit safer by requiring users to enable it when a `ComputedField` or `AveragedField` is constructed by a keyword argument, something like `recompute_safely`: . ```julia; U = AveragedField(model.velocities.u, dims=(1, 2), data=scratch, recompute_safely=false); ```. When `recompute_safely` is disabled, the model time at computation will be cached. The cache can either be inside `AveragedField`, or in a global cache. (A global cache has the advantage of being on the CPU; a local cache has the advantage of being local).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458:135,perform,performed,135,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/955#issuecomment-694601458,7,"['cache', 'optimiz', 'perform']","['cache', 'cached', 'optimizations', 'performed']"
Performance,"As suggested by @francispoulin, the following was commented out https://github.com/CliMA/Oceananigans.jl/blob/master/src/Models/ShallowWaterModels/update_shallow_water_state.jl#L19-L22 to remove filling halo regions and buffering between ranks.; This gave perfect efficiency up to 3 ranks. This was mainly done to locate where possible bottlenecks are and not a legitimate change to the code. It was expected that buffering is what's causing efficiency decreases, and this confirms that there are no other additional undetected causes for efficiency drops.; <html>; <body>; <!--StartFragment-->. size | ranks | slowdown | efficiency | memory | allocs; -- | -- | -- | -- | -- | --; (4096, 256) | (1, 1) | 1.0 | 1.0 | 1.0 | 1.0; (4096, 512) | (1, 2) | 0.988079 | 1.01206 | 1.06328 | 1.0406; (4096, 768) | (1, 3) | 0.992832 | 1.00722 | 1.06328 | 1.0406. <!--EndFragment-->; </body>; </html>. system environment and CUDA.versioninfo():; ```; Oceananigans v0.60.0; Julia Version 1.6.2; Commit 1b93d53fc4 (2021-07-14 15:36 UTC); Platform Info:; OS: Linux (powerpc64le-unknown-linux-gnu); CPU: unknown; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-11.0.1 (ORCJIT, pwr9); Environment:; JULIA_MPI_PATH = /home/software/spack/openmpi/3.1.4-nhjzelonyovxks5ydtrxehceqxsbf7ik; JULIA_CUDA_USE_BINARYBUILDER = false; JULIA_DEPOT_PATH = /nobackup/users/henryguo/projects/henry-test/.julia; GPU: Tesla V100-SXM2-32GB. CUDA toolkit 10.1.243, local installation; CUDA driver 10.2.0; NVIDIA driver 440.64.0; Libraries: ; - CUBLAS: 10.2.2; - CURAND: 10.1.1; - CUFFT: 10.1.1; - CUSOLVER: 10.2.0; - CUSPARSE: 10.3.0; - CUPTI: 12.0.0; - NVML: 10.0.0+440.64.0; - CUDNN: missing; - CUTENSOR: missing; Toolchain:; - Julia: 1.6.2; - LLVM: 11.0.1; - PTX ISA support: 3.2, 4.0, 4.1, 4.2, 4.3, 5.0, 6.0, 6.1, 6.3, 6.4; - Device capability support: sm_30, sm_32, sm_35, sm_37, sm_50, sm_52, sm_53, sm_60, sm_61, sm_62, sm_70, sm_72, sm_75; Environment:; - JULIA_CUDA_USE_BINARYBUILDER: false; 3 devices:; 0: Tesla V100-SXM2-32GB (",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846:336,bottleneck,bottlenecks,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1882#issuecomment-887933846,1,['bottleneck'],['bottlenecks']
Performance,"At the GPU hackathon way back in June we learned that the `calculate_interior_source_terms` kernel was a bottleneck as each thread required a lot of registers. It could benefit greatly from shared memory to reduce register pressure and allow more threads to run at a time. Some preliminary work has been done in PR https://github.com/climate-machine/Oceananigans.jl/pull/293. @vchuravy has an `@stencil` abstraction in development at https://github.com/vchuravy/GPUifyLoops.jl/pull/81. But would be good to implement plain shared memory without an abstraction and see how much of a performance boost we get, especially with LES closures.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/442:105,bottleneck,bottleneck,105,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/442,2,"['bottleneck', 'perform']","['bottleneck', 'performance']"
Performance,"At the moment we fill the velocity halos with multiple passes, e.g., . https://github.com/CliMA/Oceananigans.jl/blob/2447ea7c15d552fb6a50d3fd347d6534af0018c7/validation/multi_region/multi_region_cubed_sphere.jl#L115-L119. We should utilize the grid's connectivity and develop a method to fill the velocity halos that only requires _one_ pass. This is very important for performance and scaling on distributed systems.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3201:370,perform,performance,370,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3201,1,['perform'],['performance']
Performance,"At the moment, the pressure solve is performed on one GPU/CPU, but this PR builds the infrastructure to allow multi-process global solves",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2795:37,perform,performed,37,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2795,1,['perform'],['performed']
Performance,"Average reduction with conditional expressions, e.g., like. https://github.com/CliMA/Oceananigans.jl/blob/748feab10a55fa65a46455620203252a6fc0646e/test/test_field_reductions.jl#L107. induce scalar operations on the GPU. I guess it's not a surprise. I just had to add, e.g,. ```Julia; @compute Txyz = CUDA.@allowscalar Field(Average(T, condition=T.>3)); ```. Only mentioning this here in case it might something in the source code that could be affecting code performance.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221170568:459,perform,performance,459,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2701#issuecomment-1221170568,1,['perform'],['performance']
Performance,"Averaging operations does not allocate any extra memory and is more performant than precalculating a field, storing the data, and then taking the average of that. In general, you only need 3D scratch space if you have 3D output.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1439244612:68,perform,performant,68,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2931#issuecomment-1439244612,1,['perform'],['performant']
Performance,Avoid data dep race condition in CI,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1804:15,race condition,race condition,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1804,1,['race condition'],['race condition']
Performance,"Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:1; ERROR: Failed to precompile Oce",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:4791,load,loading,4791,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,"Base.jl:418 [inlined]; [15] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [16] top-level scope; @ none:1; [17] eval; @ ./boot.jl:373 [inlined]; [18] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [19] top-level scope; @ none:1; during initialization of module MPICH_jll; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/deps/deps.jl:1; ERROR: LoadError: Failed to precompile MPI [da04e1cc-30fd-572f-bb4f-1f8673147195] to /Users/sean/.julia/compiled/v1.7/MPI/jl_AfEwik.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, ignore_loaded_modules::Bool); @ Base ./loading.jl:1466; [3] compilecache(pkg::Base.PkgId, path::String); @ Base ./loading.jl:1410; [4] _require(pkg::Base.PkgId); @ Base ./loading.jl:1120; [5] require(uuidkey::Base.PkgId); @ Base ./loading.jl:1013; [6] require(into::Module, mod::Symbol); @ Base ./loading.jl:997; [7] include(mod::Module, _path::String); @ Base ./Base.jl:418; [8] include(x::String); @ Oceananigans ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:5; [9] top-level scope; @ ~/.julia/packages/Oceananigans/jmNfq/src/Oceananigans.jl:190; [10] include; @ ./Base.jl:418 [inlined]; [11] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::Nothing); @ Base ./loading.jl:1318; [12] top-level scope; @ none:1; [13] eval; @ ./boot.jl:373 [inlined]; [14] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [15] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/jmNfq/src/Distributed/Distributed.jl:1; in expression starting at /Users/sean/.julia/packages/Oceananigans/",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:4731,load,loading,4731,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,1,['load'],['loading']
Performance,"Below is a link to a paper that compares the scalability of multi-threading in Python, Julia and Chapel. . Brief Summary: They find that none of them do as well as OpenMP but give some reasons as to why. But they do find some improvements going up to 64 threads, but the effiicency in some cases go down to 20%. It seems that Python might do better on low numbers of threads but Julia does better on more. This was last year so I am sure this should probably redone. Also, I should mention I don't believe their problem is like ours but it's an example and has some pictures, so that's nice to see. https://hal.inria.fr/hal-02879767/document",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610:45,scalab,scalability,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886076610,2,"['multi-thread', 'scalab']","['multi-threading', 'scalability']"
Performance,Benchmarking fully loaded simulations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1089:19,load,loaded,19,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1089,1,['load'],['loaded']
Performance,"Billy mentioned it in some other comments but while we do splat args for some of the function calls, the function definitions use Varargs instead. This should avoid the catastrophic slowdown we saw with splatting earlier, but I agree that it should be tested. Do you have any good CPU performance tests set up @glwagner ?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150096206:285,perform,performance,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3480#issuecomment-2150096206,1,['perform'],['performance']
Performance,"But I'm not sure which part are you referring as ""good idea or not"". The fact that they belong to a different module? Perhaps we could have these constants loaded/exported with Oceananigans main module. Is this what you are thinking? That would work also!. What I think is _not_ good is having, e.g., every module redefining constants. E.g., `R_Earth` is currently defined in two places. Say we change one definition thinking it will affect everything but it won't. Also I found it quite cumbersome in scripts when I wanted to load these constants I had to load one from `Grids` and one from `Coriolis` and one from `BuoyancyModels`.... That's a bit counterintuitive from a user's perspective.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492618180:156,load,loaded,156,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3045#issuecomment-1492618180,3,['load'],"['load', 'loaded']"
Performance,"But definitely clean up and performance. Just to clarify fixing type inference doesn't change the result of the reduction, it just makes it go much faster",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380363489:28,perform,performance,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3794#issuecomment-2380363489,1,['perform'],['performance']
Performance,"By the way, WENO (and other advection schemes) are always going to be at most second order as they are implemented right now. So the _order_ might not be the correct metric to look at the performance, the truncation error is probably what we want to look at",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164473690:188,perform,performance,188,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164473690,1,['perform'],['performance']
Performance,CPU performance regression: tons of allocations,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/675:4,perform,performance,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/675,1,['perform'],['performance']
Performance,"Can we use a wrapper that automagically loads data from file for the specified time index (and also perform spatial slicing), using the nice GeoData getindex syntax?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413:40,load,loads,40,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1244#issuecomment-738272413,2,"['load', 'perform']","['loads', 'perform']"
Performance,"Can you tell us a bit more about your system?. What is `versioninfo(verbose=true)` and `] status -m`?. Was there anything more printed above the message that precompilation; failed?. One thing you might want to try is using Julia 1.10, instead of 1.9, but; right now I don't have information to pinpoint what is causing the; segmentation fault. On Wed, Jul 17, 2024, 12:23 Logan Knudsen ***@***.***> wrote:. > Update: I have been able to reduce the error to be a procompiling error in; > oceananigans.jl:; >; > ERROR: LoadError: Failed to precompile Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09] to ""/glade/u/home/knudsenl/.julia/compiled/v1.9/Oceananigans/jl_AMNEzH"".; > Stacktrace:; > [1] error(s::String); > @ Base ./error.jl:35; > [2] compilecache(pkg::Base.PkgId, path::String, internal_stderr::IO, internal_stdout::IO, keep_loaded_modules::Bool); > @ Base ./loading.jl:2300; > [3] compilecache; > @ ./loading.jl:2167 [inlined]; > [4] _require(pkg::Base.PkgId, env::String); > @ Base ./loading.jl:1805; > [5] _require_prelocked(uuidkey::Base.PkgId, env::String); > @ Base ./loading.jl:1660; > [6] macro expansion; > @ ./loading.jl:1648 [inlined]; > [7] macro expansion; > @ ./lock.jl:267 [inlined]; > [8] require(into::Module, mod::Symbol); > @ Base ./loading.jl:1611; > in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; >; > I have been trying to make sure that everything is up to date, and I am; > running on Julia version 1.9.2. My code is just; >; > using Oceananingans; >; > as I have been trying to get the library to loas properly. Does anyone; > have any experience with this error or does it make things any clearer?; >; > —; > Reply to this email directly, view it on GitHub; > <https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233710372>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AABDO2XAIMUIHCDCBIJA4NLZM2K75AVCNFSM6AAAAABK643UJWVHI2DSMVQWIX3LMV43OSLTON2WKQ3PNVWWK3TUHMZDEMZTG4YTAMZXGI",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098:518,Load,LoadError,518,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2233731098,7,"['Load', 'load']","['LoadError', 'loading']"
Performance,Catching common performance / type inference issues with user functions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1885:16,perform,performance,16,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1885,1,['perform'],['performance']
Performance,"Changing the function call to ; ```julia; function define_output_variable!(dataset,; wsa::Union{WindowedSpatialAverage, WindowedTimeAverage{<:WindowedSpatialAverage}},; name, array_type, compression, attributes, dimensions); ```; raises some other errors and I'm not sure the best way to fix them. I think the issue is that a `WindowedTimeAverage` doesn't have the properties `field` (it has `operand`) and it doesn't have the property `dims`. . For example, running the code above I get:. ```; ERROR: LoadError: type WindowedTimeAverage has no field field; Stacktrace:; [1] getproperty(::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}}}}},FieldSlicer{Colon,UnitRange{Int64},Colon},Int64},Array{Float64,2},FieldSlicer{Colon,Colon,Colon}}, ::Symbol) at ./Base.jl:33; [2] define_output_variable!(::NCDatasets.NCDataset{Nothing}, ::WindowedTimeAverage{WindowedSpatialAverage{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},RegularRectilinearGrid{Float64,Periodic,Periodic,Periodic,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryCo",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449:502,Load,LoadError,502,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1397#issuecomment-784288449,1,['Load'],['LoadError']
Performance,"Coded some difference and averaging operators using the `@views` macro. Just a proof of concept right now as the model goes run on a GPU when creating a `Problem` with `arch=:gpu`, but because the kernels are very small (and there are many of them) it's very slow. At least we have something that runs, now we can worry about how to optimize for performance. Some hacks were used to get this to work but the operators and time stepping is completely shared. The only bit that is different is the quasi-spectral solver as cuFFT does not perform R2R or DCT transforms (`FFTW.REDFT01` and `FFTW.REDFT10`) in particular. A GPU-compatible DCT/IDCT transform was coded that calculates the DCT/IDCT in terms of `fft!` and `ifft!`.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/15:333,optimiz,optimize,333,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/15,3,"['optimiz', 'perform']","['optimize', 'perform', 'performance']"
Performance,"Compilation performance is affected by this, so I think it's more correct to say that performance is affected.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2429332352:12,perform,performance,12,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3851#issuecomment-2429332352,2,['perform'],['performance']
Performance,"Compiler/eJOtJ/src/irgen.jl:4; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:142 [inlined]; [5] macro expansion; @ ~/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [6] macro expansion; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/driver.jl:141 [inlined]; [7] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64; libraries::Bool, deferred_codegen::Bool, optimize::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:62; [8] emit_llvm(job::GPUCompiler.CompilerJob, method_instance::Any, world::UInt64); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/utils.jl:60; [9] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:300; [10] check_cache; @ ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:47 [inlined]; [11] cached_compilation; @ ~/.julia/packages/GPUArrays/Z5nPF/src/host/broadcast.jl:57 [inlined]; [12] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob{GPUCompiler.PTXCompilerTarget, CUDA.CUDACompilerParams, GPUCompiler.FunctionSpec{GPUArrays.var""#broadcast_kernel#16"", Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}}, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler ~/.julia/packages/GPUCompiler/eJOtJ/src/cache.jl:0; [13] cufunction(f::GPUArrays.var""#broadcast_kernel#16"", tt::Type{Tuple{CUDA.CuKernelContext, CUDA.CuDeviceArray{Float64, 3, 1}, Base.Broadcast.Broadcasted{Nothing, Tuple{Base.OneTo{Int64}, Base.OneTo{Int64}, Base.OneTo{Int64}}, typeof(identity), Tuple{Int64}}, Int64}}; name::Nothing, kwargs::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ CUDA ~/.julia/packages/CUDA/3VnCC/src/compiler/execution.jl:289; [14] cufunction; @ ~/.julia/packages/CU",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1706:1676,cache,cache,1676,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1706,1,['cache'],['cache']
Performance,"Convection/blob/bf2c917e43a6198a55061a46b2097b6b4a9dda3b/horizontal_diffusion.jl), in which we turn off advection in the `horizontal_convection.jl` example and numerically integrate the solution to equilibrium. We compare timeseries of the volume-integrated buoyancy dissipation rates calculated online versus those calculated offline (as in the `horizontal_convection.jl` example). The results show that the online calculation correctly asymptotes to the numerical solution of the equilibrium boundary value problem while the offline calculation is erroneous and effectively yields a Nusselt number that is more than 6 times too high. ![equilibration_ratio](https://github.com/CliMA/Oceananigans.jl/assets/12971166/1f79e7eb-b361-4ea0-aa76-a81d6049c25a). The bug is also evident by comparing snapshots of the two buoyancy dissipation rate fields. The dissipation rates computed offline clearly do not satisfy the no-flux boundary conditions on the boundaries. <img width=""587"" alt=""Screenshot 2023-08-22 at 12 38 27 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/eee4e10c-432b-413c-8670-aaf47c8b0d0a"">. This bug is present in the live `main` Oceananigans.jl branch (circa `v0.86.0`), as is evident from the movie of the buoyancy dissipation rate field in the [`horizontal_convection.jl` example documentation](https://clima.github.io/OceananigansDocumentation/v0.84.1/generated/horizontal_convection/#Load-saved-output,-process,-visualize) and verified locally. <img width=""519"" alt=""Screenshot 2023-08-22 at 1 13 30 PM"" src=""https://github.com/CliMA/Oceananigans.jl/assets/12971166/c61b002c-5fd5-453d-8809-623e577e54f3"">. I am referring to this as a bug because it is contrary to the expected behavior of halos containing the necessary information for satisfying boundary conditions, as discussed in the horizontal convection documentation example:; https://github.com/CliMA/Oceananigans.jl/blob/a226b3efa7db7426ccee03884d610035314955e4/examples/horizontal_convection.jl#L143-L147",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224:2220,Load,Load-saved-output,2220,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224,1,['Load'],['Load-saved-output']
Performance,"Copied below. ```; ERROR: LoadError: `makedocs` encountered an error. Terminating build; --;   | Stacktrace:;   | [1] error(s::String);   | @ Base ./error.jl:33;   | [2] runner(#unused#::Type{Documenter.Builder.RenderDocument}, doc::Documenter.Documents.Document);   | @ Documenter.Builder /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Builder.jl:255;   | [3] dispatch(#unused#::Type{Documenter.Builder.DocumentPipeline}, x::Documenter.Documents.Document);   | @ Documenter.Utilities.Selectors /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Utilities/Selectors.jl:170;   | [4] #2;   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:257 [inlined];   | [5] cd(f::Documenter.var""#2#3""{Documenter.Documents.Document}, dir::String);   | @ Base.Filesystem ./file.jl:106;   | [6] #makedocs#1;   | @ /storage7/buildkite-agent/.julia-3423/packages/Documenter/4JDQo/src/Documenter.jl:256 [inlined];   | [7] top-level scope;   | @ ~/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;   | in expression starting at /var/lib/buildkite-agent/builds/tartarus-9/clima/oceananigans/docs/make.jl:155;   | 🚨 Error: The command exited with status 1;   | user command error: exit status 1; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299:26,Load,LoadError,26,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1881#issuecomment-884364299,1,['Load'],['LoadError']
Performance,"Could you explain why using `ifelse` has better performance?; Is this because the ternary `? :` is an alias for `ifelse`? ; What about `@inline`?. In this case, we only had the wind velocity from the specifications of the computer fans we used for the rotating tank experiment, but I understand that even in this case, I could calculate `τ₀` using bulk formula while defining `p`. Thanks for the idea. For the boundary conditions. I was my bad. You specify on the [Documentation](https://clima.github.io/OceananigansDocumentation/stable/model_setup/boundary_conditions/#.-Spatially-and-temporally-varying-flux) that. > By default, a function boundary condition is called with the signature; > ; > `f(ξ, η, t)`; > ; > where t is time and ξ, η are spatial coordinates that vary along the boundary:; > ; > `f(y, z, t)` on x-boundaries;; > `f(x, z, t)` on y-boundaries;; > `f(x, y, t)` on z-boundaries. I am just repeating here in case someone falls in the same problem and comes to this issue.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066113425:48,perform,performance,48,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2336#issuecomment-1066113425,1,['perform'],['performance']
Performance,"Current operators assume constant Δz which allow the model to use faster operators and use a tiny bit less space, so they'd have to be rewritten a tiny bit to account for a variable Δz when that gets implemented. We can either write new operators that get dispatched on `HorizontallyRegularCartesianGrid` structs (already possible), or maybe the performance gain is so tiny that we just make `RegularCartesianGrid` a subset of `HorizontallyRegularCartesianGrid` and only have one set of operators. `HorizontallyRegularCartesianGrid` might be a descriptive but pretty bad struct name.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/47:346,perform,performance,346,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/47,1,['perform'],['performance']
Performance,"Currently `BatchedTridiagonalSolver` supports `Callable` tridiagonal coefficients via. https://github.com/CliMA/Oceananigans.jl/blob/bcc34f07b3f949ea6fb34c7814f4b856d24924c2/src/Solvers/batched_tridiagonal_solver.jl#L58-L59. However, as noted on #3030 this can produce a catastrophic loss of performance. Therefore, this support should be discontinued. cc @simone-silvestri",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3047:292,perform,performance,292,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3047,1,['perform'],['performance']
Performance,"Currently halo regions are filled _prior_ to performing a time-step. This means that _after_ the time-step, they are incorrect. We therefore cannot output fields with correct halo regions, since data is outputted after a time-step is taken. But it gets worse. If the average of a field is taken, we zero out the halo regions. Zeroing out the halo regions corrupts near-boundary data for all subsequent computations with the fields. Currently, abstract operations cannot be trusted in boundary-adjacent cells. To remedy this we need to fill halo regions on fields prior to performing computations. One way we might do this is to write a `compute!` method for fields:. ```julia; compute!(field::Field) = fill_halo_regions!(field); ```. We can also define a `conditional_compute!` method for `Field`s and add a `status` property, so that halo regions are not filled ""redundantly"". For this to work, we also need to invalidate `field.status` when halo regions are zeroed out by `compute!(averaged_field::AveragedField)`, (for example by setting `field.status.time = NaN`). This won't work currently, of course, due to #971 . So this issue cannot be resolved until #971 is resolved.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1063:45,perform,performing,45,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1063,2,['perform'],['performing']
Performance,"Currently in my workflow, I define an environment variable that contains an string like `$init_$end.nc`, where `init` is the initial time and `end` is the `stop_time` of the simulation. In the first instantiation of the model for 60 days, this string will be appended to my output filename e.g.`vel_field_`, resulting on something like `vel_field_0_60.nc`. For the next pickup the filename will be changed to `vel_field_60_120.nc`. This works well when the files are not split, i.e. `file_splitting = NoFileSplitting()`. However when splitting the file, e.g. `file_splitting = TimeInterval(30days)`, the first instantiation will result in the following files:; ```; vel_fields_0_60_part1.nc vel_fields_0_60_part2.nc vel_fields_0_60_part3.nc; ```; then the next pickup will result in files: ; ```; vel_fields_60_120_part1.nc vel_fields_60_120_part3.nc vel_fields_60_120_part5.nc; vel_fields_60_120_part2.nc vel_fields_60_120_part4.nc; ```; of this files, the first 2 parts (`vel_fields_60_120_part1.nc` and `vel_fields_60_120_part2.nc`) are empty, and the `vel_fields_60_120_part3.nc` contains data from the day 61 until 91. This makes the loading of the data for post-processing a bit tricky, since some of they are empty and the disk storage will make more difficult chunking data. . If I don't change the name each time I pickup, with the `overwrite_existing=false` it crashes, and with `overwrite_existing=true` it rewrites all the files. . Another workflow will be to create a new folder for each pickup keeping the same filename, but splitting the files will result in the same issue of file duplication. . I hope this description of the workflow is clearer.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301:1139,load,loading,1139,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3818#issuecomment-2391946301,2,['load'],['loading']
Performance,"Currently schedules are exported from `Oceananigans.Diagnostics` and `Oceananigans.OutputWriters` while being defined in `Oceananigans.Utils`. I guess an inconsistency is that we export output writers from the top-level `Oceananigans` module so users can end up with access to output writers via `using Oceananigans` but without any schedules/intervals, leading to errors like. ```; ERROR: LoadError: UndefVarError: TimeInterval not defined; ```; cc @mukund-gupta @qwert2266. Might make sense to either export schedules at the top-level or stop exporting output writers at the top-level. Both seem like consistent solutions to me but I'll argue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1131:390,Load,LoadError,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1131,1,['Load'],['LoadError']
Performance,"Currently, we use the constructor `output_writer.array_type` to convert array data prior to outputting:. https://github.com/CliMA/Oceananigans.jl/blob/03a6f855f839504d94cb8cee3c2665b17afbc6d5/src/OutputWriters/fetch_output.jl#L17. But we should use `convert` instead, because this avoids allocating memory when no type conversion is needed:. ```julia; julia> a = rand(1, 1, 1); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b = convert(Array{Float64}, a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> b === a; true; ```. so `b` is just a reference to `a`, but. ```julia; julia> c = Array{Float64}(a); 1×1×1 Array{Float64,3}:; [:, :, 1] =; 0.7727202498256802. julia> c === a; false; ```. `c` is not a reference to `a`. This matters very little since we basically always need to allocate memory to convert from Float64 to Float32. A related minor optimization would be to avoid converting views to the same type as the parent array, since we could just output those directly. I think we have to use dispatch on one of the type parameters of `SubArray` for that. But maybe simpler code is worth not implementing a minor optimization for an edge case.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1182:884,optimiz,optimization,884,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1182,2,['optimiz'],['optimization']
Performance,"Damn, it looks like the tests on the GPU are not working because CUDA is not loaded properly. ; I am trying to address this in #3880. A segmentation fault probably means the MPI is not CUDA-aware. Typically, the MPI that is shipped with MPI_jll is not cuda-aware. A good way to check is; ```julia; julia> using MPI. julia> MPI.has_cuda(); true; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3878#issuecomment-2443869989:77,load,loaded,77,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3878#issuecomment-2443869989,1,['load'],['loaded']
Performance,Data is loaded into `FieldTimeSeries` by. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L146. which calls. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L200-L205. The data seems to be loaded into the intermediate `Field`:. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L237. so the problem may be. https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/OutputReaders/field_time_series.jl#L205. Voila... https://github.com/CliMA/Oceananigans.jl/blob/cca182a11bcd1881e20316fc80ac7782286a8bfe/src/Fields/set!.jl#L43-L55,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689910675:8,load,loaded,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3224#issuecomment-1689910675,2,['load'],['loaded']
Performance,"Dear Oceananigans team,. I am new to Julia and Oceananigans.; I installed Julia version 1.6.2 (2021-07-14) on Ubuntu 20.04 LTS, then Oceananigans v0.62.1 as instructed. I am interested in ""stratified plane Couette flow"" .; When I run the case using ""julia run_stratified_couette_flow_simulations.jl"", I am having following error;. **""; ERROR: LoadError: UndefVarError: Value not defined; Stacktrace:; [1] simulate_stratified_couette_flow(; Nxy::Int64, Nz::Int64, arch::GPU, h::Int64, U_wall::Int64, Re::Int64, Pr::Float64, Ri::Int64, Ni::Int64, end_time::Int64); @ Main ~/Desktop/stratified_couette_flow/stratified_couette_flow.jl:103; [2] top-level scope; @ ~/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; in expression starting at /home/ilyas/Desktop/stratified_couette_flow/run_stratified_couette_flow_simulations.jl:3; ""****. It complaints about undefined Boundary Condition Value (stratified_couette_flow.jl:103).; Can you help me to fix it?. Please forgive me if I missed something obvious or made a trivial mistake.; Thanks,. Ilyas",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1981:343,Load,LoadError,343,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1981,1,['Load'],['LoadError']
Performance,"Did a quick small strong scaling benchmark on Tartarus (256^3) up to 16 cores but results don't look super great? ~9.5x speedup on 16 cores. Better than multi-threading though. Maybe I'm not benchmarking properly though. Could also be missing some MPI barriers. Should probably learn how to profile MPI code. ```; Incompressible model strong scaling benchmark; ┌─────────────────┬───────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ size │ ranks │ min │ median │ mean │ max │ memory │ allocs │; ├─────────────────┼───────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ (256, 256, 256) │ 1 │ 3.641 s │ 3.686 s │ 3.686 s │ 3.730 s │ 355.28 KiB │ 2336 │; │ (256, 256, 256) │ 2 │ 1.917 s │ 1.918 s │ 1.921 s │ 1.928 s │ 346.00 KiB │ 2782 │; │ (256, 256, 256) │ 4 │ 1.249 s │ 1.283 s │ 1.279 s │ 1.300 s │ 348.47 KiB │ 2822 │; │ (256, 256, 256) │ 8 │ 652.029 ms │ 714.833 ms │ 704.940 ms │ 738.885 ms │ 353.84 KiB │ 2902 │; │ (256, 256, 256) │ 16 │ 377.153 ms │ 388.435 ms │ 394.780 ms │ 415.562 ms │ 366.16 KiB │ 3062 │; └─────────────────┴───────┴────────────┴────────────┴────────────┴────────────┴────────────┴────────┘; ```. ```; Incompressible model strong scaling speedup; ┌─────────────────┬───────┬─────────┬──────────┬─────────┐; │ size │ ranks │ speedup │ memory │ allocs │; ├─────────────────┼───────┼─────────┼──────────┼─────────┤; │ (256, 256, 256) │ 1 │ 1.0 │ 1.0 │ 1.0 │; │ (256, 256, 256) │ 2 │ 1.92195 │ 0.973876 │ 1.19092 │; │ (256, 256, 256) │ 4 │ 2.87312 │ 0.980825 │ 1.20805 │; │ (256, 256, 256) │ 8 │ 5.15614 │ 0.995954 │ 1.24229 │; │ (256, 256, 256) │ 16 │ 9.48879 │ 1.03061 │ 1.31079 │; └─────────────────┴───────┴─────────┴──────────┴─────────┘; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-794954624:153,multi-thread,multi-threading,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/590#issuecomment-794954624,1,['multi-thread'],['multi-threading']
Performance,Do not install/load CUDA packages if no GPU is detected.,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/178:15,load,load,15,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/178,1,['load'],['load']
Performance,"Doctests fail because of all the `loop not unrolled` warnings we get.; We should remedy this before we move to Julia v1.10. @glwagner you bumped onto this previously, right?. ```Julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 143 already precompiled.; [ Info: Oceananigans will use 8 threads. julia> grid = RectilinearGrid(size=(1, 8, 8), extent=(1, 1, 1)); 1×8×8 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 3×3×3 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=0.125; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=0.125. julia> model = NonhydrostaticModel(; grid); warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: /Users/navid/.julia/packages/KernelAbstractions/WoCk1/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requeste",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814:845,optimiz,optimizer,845,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3403#issuecomment-1872469814,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"Documents/Projects/Oceananigans.jl/src/Models/HydrostaticFreeSurfaceModels/compute_hydrostatic_free_surface_tendencies.jl:236; [7] gpu_compute_hydrostatic_free_surface_Gu!; @ ~/.julia/packages/KernelAbstractions/cWlFz/src/macros.jl:90; [8] gpu_compute_hydrostatic_free_surface_Gu!; @ ./none:0; Hint: catch this exception as `err` and call `code_typed(err; interactive = true)` to introspect the erronous code with Cthulhu.jl; Stacktrace:; [1] check_ir(job::GPUCompiler.CompilerJob{GPUCompiler.MetalCompilerTarget, Metal.MetalCompilerParams}, args::LLVM.Module); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/validation.jl:147; [2] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:440 [inlined]; [3] macro expansion; @ ~/.julia/packages/TimerOutputs/RsWnF/src/TimerOutput.jl:253 [inlined]; [4] macro expansion; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:439 [inlined]; [5] emit_llvm(job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, only_entry::Bool, validate::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:89; [6] emit_llvm; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/utils.jl:83 [inlined]; [7] codegen(output::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool, parent_job::Nothing); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:129; [8] codegen; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:110 [inlined]; [9] compile(target::Symbol, job::GPUCompiler.CompilerJob; libraries::Bool, toplevel::Bool, optimize::Bool, cleanup::Bool, strip::Bool, validate::Bool, only_entry::Bool); @ GPUCompiler ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:106; [10] compile; @ ~/.julia/packages/GPUCompiler/Cp7sE/src/driver.jl:98 [inlined]; [11] #45; @ ~/.julia/packages/Metal/lnkVP/src/compiler/compilation.jl:57 [inlined]; [12] JuliaContext(f::Metal.var""#45#46""{GPUCompiler.CompilerJob{",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822:36336,optimiz,optimize,36336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2618#issuecomment-1731573822,1,['optimiz'],['optimize']
Performance,Does this reduce performance or is the effect negligible? (Just curious.),MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261409044:17,perform,performance,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2754#issuecomment-1261409044,1,['perform'],['performance']
Performance,ERROR: LoadError: UndefVarError: SolutionBoundaryConditions not defined,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/686:7,Load,LoadError,7,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/686,1,['Load'],['LoadError']
Performance,Each Appveyor build takes 30-50 minutes to run (and they run sequentially) so Appveyor takes forever to finish testing. Compare with ~10 minutes per build on Travis and JuliaGPU's CI on GitLab. It also builds CUDA packages unsuccessfully so maybe defining a CPU testing env and using it on Travis and Appveyor can help? See https://github.com/ali-ramadhan/Oceananigans.jl/issues/79. Problem might go away on its own but otherwise this might help: https://www.appveyor.com/docs/build-cache/,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/89:483,cache,cache,483,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/89,1,['cache'],['cache']
Performance,Enzyme (performance) mark some functions as non-differentiable,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3799:8,perform,performance,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3799,1,['perform'],['performance']
Performance,"Exactly what I am struggling with right now: figuring out how to quickly get x, y, z coordinates when loading an output file created previously (with JLD2 output writer}). So as far as I understand in that case the 'model' and 'grid' variables do not exist. ; `xc = file([""grid/xC""]) `; etc. works, but contains the halos.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367:102,load,loading,102,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1850#issuecomment-1022295367,1,['load'],['loading']
Performance,"Executing the validation/multi_region/cubed_sphere_steady_state.jl file yields an error partially shown below:; ```julia; julia> include(""validation/multi_region/cubed_sphere_steady_state.jl""); [ Info: Initializing simulation...; Iteration: 0000, time: 0 seconds, Δt: 41.133 ms, wall time: 0 seconds; [ Info: ... simulation initialization complete (820.774 ms); [ Info: Executing initial time step...; ERROR: LoadError: MethodError: no method matching _fill_south_halo!(::Int64, ::Int64, ::Oceananigans.Grids.ZRegOrthogonalSphericalShellGrid{Float64, FullyConnected, FullyConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, Matrix{Float64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Float64, NamedTuple{(:ξ, :η, :rotation), Tuple{Tuple{Float64, Float64}, Tuple{Float64, Float64}, Rotations.RotXY{Float64}}}, CPU}, ::OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ::BoundaryCondition{Oceananigans.BoundaryConditions.MultiRegionCommunication, Oceananigans.MultiRegion.CubedSphereRegionalConnectivity{Oceananigans.MultiRegion.South, Oceananigans.MultiRegion.North, Nothing}}, ::Tuple{Center, Center, Face}). Closest candidates are:; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Open}, ::Any, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_open.jl:36; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::BoundaryCondition{<:Oceananigans.BoundaryConditions.Flux}, ::Any...); @ Oceananigans /Users/Sid/Library/CloudStorage/Dropbox/StudyFolder/PostDocMITDesktop/Codes/Oceananigans/cubed-sphere-steady-state/src/BoundaryConditions/fill_halo_regions_flux.jl:32; _fill_south_halo!(::Any, ::Any, ::Any, ::Any, ::Union{BoundaryCondition{<:Oceananigans.BoundaryConditions.Value}, BoundaryCondition{<:Oceananigans.BoundaryCondition",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619:409,Load,LoadError,409,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3302#issuecomment-1742355619,1,['Load'],['LoadError']
Performance,Fix bug loading `netcdf`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2847:8,load,loading,8,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2847,1,['load'],['loading']
Performance,Fix performance benchmarks dead link in README,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/822:4,perform,performance,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/822,1,['perform'],['performance']
Performance,Fix race condition affecting `HydrostaticFreeSurfaceModel` with `isnothing(free_surface)`,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2821:4,race condition,race condition,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2821,1,['race condition'],['race condition']
Performance,Fixes GPU to CPU loading and writing fields with function boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/797:17,load,loading,17,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/797,1,['load'],['loading']
Performance,Fixes checkpointer GPU to CPU loading and writing fields with function boundary conditions,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/797:30,load,loading,30,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/797,1,['load'],['loading']
Performance,"Float32, 3, 1}}}}, Nothing, NamedTuple{(:u, :v, :w, :T, :S), NTuple{5, typeof(Oceananigans.Forcings.zeroforcing)}}, NamedTuple{(:time, :iteration, :stage), Tuple{Float32, Int64, Int64}}}}}, args::LLVM.Module); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/validation.jl:111; [2] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/driver.jl:319 [inlined]; [3] macro expansion; @ /g/data/v45/nc3020/.julia/packages/TimerOutputs/PZq45/src/TimerOutput.jl:226 [inlined]; [4] macro expansion; @ /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/driver.jl:317 [inlined]; [5] emit_asm(job::GPUCompiler.CompilerJob, ir::LLVM.Module; strip::Bool, validate::Bool, format::LLVM.API.LLVMCodeGenFileType); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/utils.jl:62; [6] cufunction_compile(job::GPUCompiler.CompilerJob); @ CUDA /g/data/v45/nc3020/.julia/packages/CUDA/mVgLI/src/compiler/execution.jl:313; [7] cached_compilation(cache::Dict{UInt64, Any}, job::GPUCompiler.CompilerJob, compiler::typeof(CUDA.cufunction_compile), linker::typeof(CUDA.cufunction_link)); @ GPUCompiler /g/data/v45/nc3020/.julia/packages/GPUCompiler/2WWTr/src/cache.jl:89; [8] cufunction(f::typeof(Cassette.overdub), tt::Type{Tuple{Cassette.Context{nametype(CUDACtx), KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(32, 32, 32)}, KernelAbstractions.NDIteration.DynamicCheck, Nothing, Nothing, KernelAbstractions.NDIteration.NDRange{3, KernelAbstractions.NDIteration.StaticSize{(2, 2, 32)}, KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)}, Nothing, Nothing}}, Nothing, KernelAbstractions.var""##PassType#257"", Nothing, Cassette.DisableHooks}, typeof(Oceananigans.Models.IncompressibleModels.gpu_calculate_Gw!), OffsetArrays.OffsetArray{Float32, 3, CUDA.CuDeviceArray{Float32, 3, 1}}, RegularRectilinearGrid{Float32, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float32, StepRangeLen{Float32, Float64, Float64}}}",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360:17236,cache,cache,17236,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1780#issuecomment-870162360,1,['cache'],['cache']
Performance,"For better or for worse, Oceananigans currently does not store intermediate terms in the computation of a PDE's right hand side (with notable exceptions hydrostatic pressure and eddy diffusivities). In other words, a single, sometimes large kernel that evaluates the right hand side at each grid point `i, j, k` is compiled for each PDE in a user's model, and there's no way to pull out intermediate steps in that calculation to use elsewhere. It's important to note when considering optimization strategies that our computations are probably memory-limited, rather than compute-limited. In other words, we think the process of transferring data from global memory to local thread memory is a bottleneck for our computations (we can really only know this through profiling a particular application, however, since all models are different...) Storing intermediate components of the tendency terms would probably create more memory accesses overall (since rather than immediately using intermediate results for subsequent calculations, we would have to send them to global memory, and then back, to complete the evaluation of a tendency) --- and thus could slow down tendency evaluations that are performed 1-3 times per time-step. For example, our best idea for speeding up tendency evaluations is to better manage memory movement using GPU shared memory (unfortunately, we haven't had the time to explore such optimization strategies...). I think there may be other ways to optimize diagnostics calculations, however. # Fusing `ComputedField` kernels. One possibility to speed up diagnostics is to ""fuse"" kernels for different `ComputedField` diagnostics. The kernel for a `ComputedField` is. https://github.com/CliMA/Oceananigans.jl/blob/9b52f3f911d26a66c75f1c3cb58fdd0a1cecb131/src/Fields/computed_field.jl#L112-L115. where `operand` is an `AbstractOperation`. But different `ComputedField`s may somehow depend on the same underlying data in memory. Thus if the kernels for differnet `ComputedField",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837:484,optimiz,optimization,484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483#issuecomment-800567837,2,"['bottleneck', 'optimiz']","['bottleneck', 'optimization']"
Performance,"For complicated models and examples, user-defined forcing functions can impose significant penalties on simulation performance. In addition to that, models with extensive and complicated diagnostics (especially those involving time-averaging) can further slow down time-to-science. It thus might be useful to provide some utilities that make benchmarking forcing functions, boundary condition functions, and diagnostics a bit easier. For forcing functions, I think a utility that benchmarks time-stepping for two models that are identical except for forcing might be useful. Something along the lines of. ```julia; function benchmark_user_forcing(model); ; # Build a ""forcingless_model"" that's identical to model, but with no forcing functions; model_property_names = propertynames(model); forcingless_model_properties = Dict{Any, Any}(name => getproperty(model, name) for name in model_property_names); forcingless_model_properties[:forcing] = NamedTuple{}() # default; ModelConstructor = typeof(model).name.wrapper # or whatever this needs to be; forcingless_model = ModelConstructor(Tuple(forcingless_model_properties[name] for name in model_property_names)...). @info ""Benchmarking model with user forcing...""; @btime time_step!(model, 1). @info ""Benchmarking model without user forcing...""; @btime time_step!(forcingless_model, 1). return nothing; end; ```. might work for forcing functions. For boundary conditions, we have to build default boundary conditions manually and use the model's outer constructor (to avoid excess memory allocation), which is slightly more annoying, but should be supported by at least the nonhydrostatic and hydrostatic model constructors. For output I think we want to benchmark `fetch_output`:. https://github.com/CliMA/Oceananigans.jl/blob/051e03ecfcb0c00e0c6ed4dd2808148e700d0342/src/OutputWriters/fetch_output.jl#L17-L18. Worth noting that fetching is actually already timed by `JLD2OutputWriter` with `verbose=true`:. https://github.com/CliMA/Oceananigans.jl/b",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1918:115,perform,performance,115,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1918,1,['perform'],['performance']
Performance,"For example, when running on MIT's Satori cluster one must use a magic incantation to obtain useful output (and also to run 4 simulations on a single node):. ```bash; #!/bin/bash. #SBATCH --job-name=eady; #SBATCH --output=slurm-eady-%j.out; #SBATCH --error=slurm-eady-%j.err; #SBATCH --time=12:00:00; #SBARCH --mem=0; #SBATCH --nodes=1; #SBATCH --ntasks-per-node=4; #SBATCH --gres=""gpu:4"" # GPUs per Node; #SBATCH --cpus-per-task=4. # Clear the environment from any previously loaded modules; module purge > /dev/null 2>&1. module load spack/0.1; module load gcc/8.3.0 # to get libquadmath; module load julia/1.4.1; module load cuda/10.1.243; module load openmpi/3.1.4-pmi-cuda; module load py-matplotlib/3.1.1. DIR=""$( cd ""$( dirname ""${BASH_SOURCE[0]}"" )"" >/dev/null 2>&1 && pwd )"". cd $DIR/../Oceananigans/. CUDA_VISIBLE_DEVICES=0 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear.out &; CUDA_VISIBLE_DEVICES=1 unbuffer julia --project run_small_eady_problem.jl --Nh 128 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear.out &; CUDA_VISIBLE_DEVICES=2 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.25 --years 2.0 2>&1 | tee quarter_shear_hires.out &; CUDA_VISIBLE_DEVICES=3 unbuffer julia --project run_small_eady_problem.jl --Nh 192 --Nz 96 --geostrophic-shear 0.1 --years 2.0 2>&1 | tee tenth_shear_hires.out. sleep 42480 # sleep for 11.8 hours; ```. (and explanations for each part of the script might be helpful)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1045:477,load,loaded,477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1045,7,['load'],"['load', 'loaded']"
Performance,"For example,. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. errors with. ```julia; julia> include(""problem.jl""); ┌ Warning: Inflating model grid halo size to (3, 3, 3) and recreating grid. Note that an ImmersedBoundaryGrid requires an extra halo point in all non-flat directions compared to a non-immersed boundary grid.; └ @ Oceananigans.Models.NonhydrostaticModels ~/.julia/packages/Oceananigans/OHYQj/src/Models/NonhydrostaticModels/nonhydrostatic_model.jl:223; ERROR: LoadError: ArgumentError: halo must be ≤ size for coordinate y; ```. Sad, because I didn't actually ask for a halo (3, 3, 3)! Manually setting things doesn't help:. ```julia; using Oceananigans. grid = RectilinearGrid(size = (16, 1, 16),; halo = (3, 1, 3),; x = (0, 1),; y = (0, 1),; z = (0, 1),; topology = (Periodic, Periodic, Bounded)). model = NonhydrostaticModel(; grid, advection = WENO(order=5)); ```. I guess the restriction on the halo size is supposed to be an optimization, but its not working in this case because I can't even set up my model. @navidcy",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3622:651,Load,LoadError,651,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3622,2,"['Load', 'optimiz']","['LoadError', 'optimization']"
Performance,"For example:. ```julia; julia> using Oceananigans. julia> grid = RectilinearGrid(size=(1, 1, 1), extent=(1, 1, 1)); 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Periodic y ∈ [0.0, 1.0) regularly spaced with Δy=1.0; └── Bounded z ∈ [-1.0, 0.0] regularly spaced with Δz=1.0. julia> b = CenterField(grid); 1×1×1 Field{Center, Center, Center} on RectilinearGrid on CPU; ├── grid: 1×1×1 RectilinearGrid{Float64, Periodic, Periodic, Bounded} on CPU with 1×1×1 halo; ├── boundary conditions: FieldBoundaryConditions; │ └── west: Periodic, east: Periodic, south: Periodic, north: Periodic, bottom: ZeroFlux, top: ZeroFlux, immersed: ZeroFlux; └── data: 3×3×3 OffsetArray(::Array{Float64, 3}, 0:2, 0:2, 0:2) with eltype Float64 with indices 0:2×0:2×0:2; └── max=0.0, min=0.0, mean=0.0. julia> f = 1; 1. julia> vz_op = @at (Face, Center, Center) - ∂x(b) / f; ERROR: LoadError: MethodError: no method matching var""@at""(::LineNumberNode, ::Module, ::Expr); Closest candidates are:; var""@at""(::LineNumberNode, ::Module, ::Any, ::Any) at /Users/gregorywagner/Projects/Oceananigans.jl/src/AbstractOperations/at.jl:42; in expression starting at REPL[16]:1; ```. Found with @iuryt",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2415:957,Load,LoadError,957,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2415,1,['Load'],['LoadError']
Performance,"For now this PR just adds a function `convective_adjustment!(model, Δt, K)` that performs a convective adjustment step on a model. . I believe this results in an operator splitting method for treating vertically implicit diffusion using backward Euler. ## TODO. If this seems like an appropriate method for implementing vertically implicit diffusion, I'd suggest the following steps for turning this PR into something that can be merged:; 1. Define a new closure; ```julia; 	struct ConvectiveAdjustment{K, ∂}; 	 κ :: K; 	∂b∂z :: ∂; 		...; 	end; ```; 2. Maybe `ConvectiveAdjustment` should act on a `BuoyancyField`?; 3. Refactor `convective_adjustment!` to use the `BatchedTridiagonalSolver`.; 4. Add a free convection test to test that using `ConvectiveAdjustment` on a linearly stratified column model results in a mixed layer with ∂b/∂z ≈ 0 (could also test for the mixed layer depth). `ConvectiveAdjustment` could then be used as part of a tuple of turbulence closures, e.g. ```julia; closure = (IsotropicDiffusivity(κ=1e-4), ConvectiveAdjustment(κv=10)); ```. ## Future plans?. Vertically implicit diffusion with the `BatchedTridiagonalSolver` could then be abstracted to support other parameterizations such as `OceanTurb.KPP` and `OceanTurb.TKEMassFlux`. I think @glwagner envisioned a more general way of time-stepping implicit terms in general, i.e. adding IMEX time-steppers I think?. ## Note on user interface. Right now the user must manually call `convective_adjustment!` inside the `simulation.progress` callback so it's very awkward to use, but it should be usable if we need it. Ideally `convective_adjustment!` would be called at the end of each time step, perhaps by `time_step!` or by a simulation callback. The second approach would require resolving #1138.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1342:81,perform,performs,81,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1342,1,['perform'],['performs']
Performance,"For run, I just ran `barotropic_gyre.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/barotropic_gyre/barotropic_gyre.jl). The simulation part ran nicely but when it came to visualization I got the following error. I guess the plotting needs to be updated?. ```; ERROR: LoadError: LoadError: setting show_axis for scene via plot attribute not supported anymore; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, Tuple{Sphere{Float32}}}}, attributes::Attributes, input::Tuple{Observable{Sphere{Float32}}}, args::Observable{Tuple{Sphere{Float32}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:399; [3] plot!(scene::Scene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie ~/.julia/packages/Makie/umL6V/src/interfaces.jl:320; [4] plot!; @ ~/.julia/packages/Makie/umL6V/src/interfaces.jl:288 [inlined]; [5] plot!(lscene::LScene, P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, attributes::Attributes, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Union{}, Union{}, Tuple{}, NamedTuple{(), Tuple{}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6; [6] plot!; @ ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:6 [inlined]; [7] plot!(P::Type{Combined{Makie.wireframe, ArgType} where ArgType}, ls::LScene, args::Sphere{Float32}; kw_attributes::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:show_axis,), Tuple{Bool}}}); @ Makie.MakieLayout ~/.julia/packages/Makie/umL6V/src/makielayout/blocks/scene.jl:14; [8] #wireframe!#600; @ ~/.julia/packages/MakieCore/aD9Dy/src/recipes.jl:37 [inlined]; [9] visualize_barotropic_gyre(filepath::String); @ Main ~/Software/Oceananigans.jl/validation/barotropic_gyre/visualize_barotropic_gyre.jl:64; [10] top-level scop",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2542:300,Load,LoadError,300,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2542,2,['Load'],['LoadError']
Performance,"For the last few days I've been getting weird errors running hydrostatic-free surface models with immersed boundaries on GPUs. First I was getting some ""illegal instruction"" core dump errors from CUDA but upgrading various things and playing around with the CUDA configurations fixed that (and I don't think this is an Oceananigans issue), but now with `v0.85.0` I get this error:; ```; ERROR: LoadError: DivideError: integer division error; Stacktrace:; [1] macro expansion; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:102 [inlined]; [2] #21; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:27 [inlined]; [3] #1; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:17 [inlined]; [4] retry_reclaim(f::CUDA.CUBLAS.var""#1#2""{CUDA.CUBLAS.var""#21#22""{Ptr{CUDA.CUBLAS.cublasContext}, Int64, CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, Int64, Base.R$; @ CUDA ~/.julia/packages/CUDA/pCcGc/src/pool.jl:337; [5] check; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/libcublas.jl:16 [inlined]; [6] cublasDnrm2_v2; @ ~/.julia/packages/CUDA/pCcGc/lib/utils/call.jl:26 [inlined]; [7] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:172 [inlined]; [8] nrm2; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/wrappers.jl:177 [inlined]; [9] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:131 [inlined]; [10] norm; @ ~/.julia/packages/CUDA/pCcGc/lib/cublas/linalg.jl:130 [inlined]; [11] cg_iterator!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuff$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:140; [12] cg_iterator!; @ ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:120 [inlined]; [13] cg!(x::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}, A::CUDA.CUSPARSE.CuSparseMatrixCSC{Float64, Int32}, b::CUDA.CuArray{Float64, 1, CUDA.Mem.DeviceBuffer}; abst$; @ IterativeSolvers ~/.julia/packages/IterativeSolvers/rhYBz/src/cg.jl:224; [14] cg!; @ ~/.julia/pack",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3189:394,Load,LoadError,394,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3189,1,['Load'],['LoadError']
Performance,"From a correctness and functionality stand point this PR should be ready to merge. I have some problems with performance though. It looks like with `--check-bounds=no` this PR has roughly the same wall time than main (slightly more if you have weno because of additional boundary weno schemes) but without it's 2 - 2.5X slower. (Exacerbated on the GPU). I guess it might be a matter of `@inbounds` having to be placed strategically, but I seem to miss it; @glwagner, @navidcy do you have any easy suggestion that I might have missed?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177948330:109,perform,performance,109,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1177948330,1,['perform'],['performance']
Performance,"From the discussion #3587 @scott-conn found out that our definition of immersed derivatives ~~does not work very well~~ is **wrong** when using reduced fields. Consider, for example, a field reduced in z. If we try performing a derivative in the x-direction it will check the immersed condition ; https://github.com/CliMA/Oceananigans.jl/blob/7a4b3f04e402be70d45fcb775a4dedef087f3bb0/src/ImmersedBoundaries/conditional_differences.jl#L21; on `k == 1`. This might be ~~very~~ wrong if the field is a sum (or a mean) over the column. ; For example, for integrals we want to check if the whole column is immersed.; If we are dealing with a `GridFittedBottom`, instead, we just need to check the upmost grid cell (`k == Nz`). We could procede in a couple of ways from here:; - use simple derivatives for `AsbtractOperations` that do not account for immersed boundaries. ; - We can augment operations on Immersed `Reduced` fields by attaching to them a `condition` like in conditional operations",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3588:215,perform,performing,215,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3588,1,['perform'],['performing']
Performance,"From the standpoint of `NonhydrostaticModel`, the only requirement (I think?) is a pressure solver that's valid on more grids. The `FourierTridiagonalPoissonSolver` combines FFTs with a tridiagonal solve in one direction to solve the Poisson equation. Thus, this method can be used if the grid is stretched in just one (1) direction. Right now, we only support grids that are stretched in `z`, the third direction / index. Presumably it's at most a matter of copy and paste and index permutation to support grids that are stretched in `x` (and regular in `y, z`) or stretched in `y` (and regular in `x, z`). Under the hood, the `FourierTridiagonalPoissonSolver` relies on the `BatchedTridiagonalSolver` to perform the tridiagonal solve:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/fourier_tridiagonal_poisson_solver.jl#L81-L82. The `BatchedTridiagonalSolver` launches a kernel over `xy` and performs a tridiagonal solve in `z`:. https://github.com/CliMA/Oceananigans.jl/blob/4551a78b1f3fe4bb3b238676c128dc751be9b934/src/Solvers/batched_tridiagonal_solver.jl#L79-L80. So the first task is to extend the tridiagonal solver to support integrals in `x` and `y`. . This could be straightforwardly supported by adding some kind of tag to indicate the ""tridiagonal direction"" (ie `:x`, `:y`, or `:z`), and copy-pasting the functionality for each case. It's a bit of code duplication but pretty straightforward... Alternatively we could introduce some kind of abstraction that permutes array dimensions. Then we just have one algorithm which assumes the tridiagonal index is `k`, and support `i` or `j` under the hood via an array wrapper that performs an index permutation. I'm leaning towards copy/paste because it's a little easier to understand and it's not that much code in this case...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620:706,perform,perform,706,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3116#issuecomment-1557689620,3,['perform'],"['perform', 'performs']"
Performance,"From the talks we've had here and in [this discussion](https://github.com/CliMA/Oceananigans.jl/discussions/1482), as well me looking things I have some things we could include as tips. Please let me know if I'm missing something. ## General simulation tips; - In general defining variables (that are used in the calculations) as constants makes things faster as it helps the compiler optimize things; - It's probably worth inlining small functions that get called often to reduce function call overhead (at the very least it's worth playing with this). ## GPU simulation tips:; - Any global variable that needs to be accessed by the GPU needs to be a constant or the simulation will crash; - Complex `ComputedField`s may not work, so the user can either nest `ComputedField`s (simple, but costly; probably good for development) or use `KernelComputedField`s (complex but efficient; probably what you wanna use for production-ready code); - GPU runs are generally memory-limited, so it's good to both keep track of and try to reduce the size of your runs. Useful tips in this regard are; - Try to use higher-order schemes as you need fewer grid points to achieve the same resolution; - Use `nvidia-smi` to monitor the memory usage of the GPU; - Manually define scratch space to be reused in diagnostics, to avoid creating one scratch space for each separate diagnostic you have.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575:385,optimiz,optimize,385,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-802225575,2,['optimiz'],['optimize']
Performance,Fusing kernels for calculating diagnostics to improve performance,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1483:54,perform,performance,54,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1483,1,['perform'],['performance']
Performance,"Given that there seems to be increasing interest in vertically-periodic simulations, we could revive #3080 (despite the caveats mentioned there, which mainly unknowns associated with the performance of potential future nonhydrostatic solvers for complex domains), since it's always possible to reverse course in the future and restore the separation (perhaps when the separation is restored, it can be done in a way that's compatible with vertically periodic domains).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782219409:187,perform,performance,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3364#issuecomment-1782219409,1,['perform'],['performance']
Performance,Glw/performance,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2033:4,perform,performance,4,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2033,1,['perform'],['performance']
Performance,"Good idea, let's change the phrase but keep this issue open so that I remember to tackle the performance benchmarks",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3758#issuecomment-2327680150:93,perform,performance,93,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3758#issuecomment-2327680150,1,['perform'],['performance']
Performance,"Good news: shallow water tests pass!. Bad news: the halo tests now has 12 fails, of 600 in total. . ```; <div class=""JobLogOutputComponent"" style=""box-sizing: border-box; background: rgb(23, 23, 23); border-radius: 3px; min-height: 85px; color: white; font-size: 12px; padding: 0px 0px 15px; width: 1108px; font-family: -apple-system, BlinkMacSystemFont, &quot;Segoe UI&quot;, Roboto, &quot;Helvetica Neue&quot;, Helvetica, sans-serif; font-style: normal; font-variant-ligatures: normal; font-variant-caps: normal; font-weight: 400; letter-spacing: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; text-decoration-thickness: initial; text-decoration-style: initial; text-decoration-color: initial;""><div class=""JobLogOutputComponent__Body"" style=""box-sizing: border-box; font-family: SFMono-Regular, Monaco, Menlo, Consolas, &quot;Liberation Mono&quot;, Courier, monospace;"">; Oceananigans \| 818 12 830; --; &nbsp; | Distributed MPI Oceananigans \| 816 12 828; &nbsp; | Multi architectures rank connectivity \| 28 28; &nbsp; | Local grids for distributed models \| 24 24; &nbsp; | Injection of halo communication BCs \| 168 168; &nbsp; | Halo communication \| 588 12 600; &nbsp; | Time stepping IncompressibleModel \| 4 4; &nbsp; | Time stepping ShallowWaterModel \| 4 4; &nbsp; | Distributed FFT-based Poisson solver \| 2 2; &nbsp; | ERROR: ERROR: ERROR: ERROR: LoadError: LoadError: LoadError: LoadError: Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-6/clima/oceananigans/test/runtests.jl:80; &nbsp; | Some tests did not pass: 818 passed, 0 failed, 12 errored, 0 broken.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081:1477,Load,LoadError,1477,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-843285081,4,['Load'],['LoadError']
Performance,"Good question @simone-silvestri !. On main it doesn't run as is. There are two issues. . First, there is `device!(2)` in line 30 but I commented that out easily. . Second, on line 159 we load `VorticityStencil`, which is not defined. I deleted that and changed the momentum_advection to `VectorInvariant()`, but it occurs to me that this is not what was done before. Before it was using a vorticity stencil. How would I change to use the other formulation?. However, when I try running this on main it goes far beyond what I see in the PR. So I guess the version on main does run and is stable. Pasat a day easy. Hmm... If we have a problem with the height going negative, I wonder if this is a sign that the conservation of mass equation is not quite right? I will look at that today.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1983382184:187,load,load,187,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3486#issuecomment-1983382184,1,['load'],['load']
Performance,"Got bitten by CuArray scalar operations while debugging some Europa runs so this PR adds an `__init__()` function to the Oceananigans module that disables CuArray scalar operations once the module has been loaded and only allows scalar ops via the `CUDA.@allowscalar` macro. Now when we accidentally perform scalar ops on CuArrays we should get an error, which is much better than having silent performance regressions which has happened multiple times in the past. Two remaining problems:; 1. `set!(u::Field, v::Number) = @. u.data = v` actually incurs scalar ops because `a::CuArray .= 1.5` does not but `a::OffsetArray{CuArray .= 1.5` does, so it's probably something we have to fix by adapting broadcasting over offsetarrays?; 2. For similar broadcasting reasons I think; ```julia; data = cpudata(output); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```; also incurs scalar ops during NetCDF output so I will try changing back to the old behavior where we used something like `	 ; ```julia; data = interiorparent(output); !isa(output, Array) && (data = Array(data)); ds[name][:, :, :, time_index] = view(data, ow.slices[name]...); ```. Resolves #276",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/851:206,load,loaded,206,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/851,3,"['load', 'perform']","['loaded', 'perform', 'performance']"
Performance,"Greg, Ali, and what if we began to consider more complex geometries etc -; hard to resist going in that direction..... we'd have to change the solvers; - more MITgcm-like, congrad etc - but what would the implications be for; boundary conditions? More food for thought. John. On Sat, Mar 28, 2020 at 10:22 AM Gregory L. Wagner <notifications@github.com>; wrote:. > Mostly I am worried about scalability and sustainability in this design,; > or future designs.; >; > Currently our models are fairly simple, but its challenging to place; > bounds on potential future complexity. For example, models in the future; > may require additional fields associated with closures or; > parameterizations, such as (two-dimensional) boundary layer depth fields,; > plume quantities, mixing lengths and perhaps other auxiliary fields; > associated with various prognostic / diagnostic LES models. We probably; > can't plan to support setting boundary conditions on every possible field; > via the model constructor.; >; > With our current design we have essentially special-cased turbulent; > diffusivities because our focus is LES, turbulent diffusivities are; > relatively common, and it convenient for us. However doing this incurs some; > maintenance burden --- which will increase if we plan to hard-code; > validation and error checking.; >; > Food for thought.; >; > —; > You are receiving this because you are subscribed to this thread.; > Reply to this email directly, view it on GitHub; > <https://github.com/climate-machine/Oceananigans.jl/issues/721#issuecomment-605453798>,; > or unsubscribe; > <https://github.com/notifications/unsubscribe-auth/AKXUEQT642WME2EIX3DDSITRJYBYXANCNFSM4LVSZPAA>; > .; >. -- ; ==========================================; John Marshall; Cecil and Ida Green Professor of Oceanography; Massachusetts Institute of Technology; http://oceans.mit.edu/JohnMarshall/; ==========================================",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060:391,scalab,scalability,391,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/721#issuecomment-605455060,1,['scalab'],['scalability']
Performance,"Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Oceananigans.Grids.Cell,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Face,Nothing,0,typeof(Oceananigans.Forcings.zeroforcing),Tuple{}},Oceananigans.Forcings.ContinuousForcing{Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,Oceananigans.Grids.Cell,NamedTuple{(:K, :ℓ, :Δz),Tuple{Float64,Float64,Float64}},1,typeof(FT),Tuple{typeof(identity)}}}},OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},NamedTuple{(:time, :iteration, :stage),Tuple{Float64,Int64,Int64}}}}; kwargs::Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}}) at /home/ptuckman/.julia/packages/CUDA/dZvbp/src/compiler/execution.jl:310; [8] #87 at /home/ptuckman/.julia/packages/GPUCompiler/4e9CU/src/cache.jl:21 [inlined]; [9] get!(::GPUCompiler.var""#87#88""{Base.Iterators.Pairs{Symbol,Int64,Tuple{Symbol},NamedTuple{(:maxthreads,),Tuple{Int64}}},typeof(CUDA._cufunction),GPUCompiler.FunctionSpec{typeof(Cassette.overdub),Tuple{Cassette.Context{nametype(CUDACtx),KernelAbstractions.CompilerMetadata{KernelAbstractions.NDIteration.StaticSize{(128, 128, 128)},KernelAbstractions.NDIteration.DynamicCheck,Nothing,Nothing,KernelAbstractions.NDIteration.NDRange{3,KernelAbstractions.NDIteration.StaticSize{(8, 8, 128)},KernelAbstractions.NDIteration.StaticSize{(16, 16, 1)},Nothing,Nothing}},Nothing,KernelAbstractions.var""##PassType#253"",Nothing,Cassette.DisableHooks},typeof(Oceananigans.TimeSteppers.gpu_calculate_Gu!),OffsetArrays.OffsetArray{Float64,3,CUDA.CuDeviceArray{Float64,3,CUDA.AS.Global}},RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}},Oceananigans.Ad",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1010:7642,cache,cache,7642,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1010,1,['cache'],['cache']
Performance,Halo optimization and solving the race condition on corner nodes,MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2035:5,optimiz,optimization,5,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2035,2,"['optimiz', 'race condition']","['optimization', 'race condition']"
Performance,"Happy to open an issue (or post to #1634) when I have the time to work on CI. What should we do with this PR? I think it's a net positive change so I'm happy to approve as long as the images aren't in git history. If we decide to nuke this part of the docs then I suppose this PR is moot and should be closed. > _when_ / _if_ somebody can take responsibility for maintaining it. I think responsibility for maintaining the pipeline should fall on all maintainers/developers, otherwise it's not sustainable. Ideally if you open a PR that breaks a validation experiment you should fix it. If done concurrently it should only consist of small changes so it should only be a small burden (although burdens to add up). I guess we don't run the validation CI on every PR since it's too expensive so maintenance is tough right now. Maybe we can run validation CI before every tagged release or something? Better infrastructure is needed I suppose.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889:594,concurren,concurrently,594,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1797#issuecomment-872481889,1,['concurren'],['concurrently']
Performance,"Hello, @amontoison. Nice work. Do you see a performance improvement when switching to this package?; There should be some benchmarks in the `benchmark` folder that we can test (probably we need to update that folder a bit, let me know if you have problems with it)",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2353126955:44,perform,performance,44,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3778#issuecomment-2353126955,1,['perform'],['performance']
Performance,"Hello, I am getting this error while trying to add Oceananigans on the NASA Pleiade cluster. Any ideas? Thanks a lot ! Lia. (@v1.6) pkg> update Oceananigans; Updating registry at `~/.julia/registries/General`; Installed HDF5_jll ─── v1.10.5+7; Installed ColorTypes ─ v0.11.0; Installed HTTP ─────── v0.9.8; Installed HDF5 ─────── v0.13.7; Installed URIs ─────── v1.3.0; Downloaded artifact: HDF5; No Changes to `~/.julia/environments/v1.6/Project.toml`; Updating `~/.julia/environments/v1.6/Manifest.toml`; [3da002f7] ↑ ColorTypes v0.10.12 ⇒ v0.11.0; [f67ccb44] ↑ HDF5 v0.13.6 ⇒ v0.13.7; [cd3eb016] ↑ HTTP v0.8.19 ⇒ v0.9.8; [5c2747f8] + URIs v1.3.0; [0234f1f7] ↓ HDF5_jll v1.12.0+1 ⇒ v1.10.5+7; Building HDF5 → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/0b812e7872e2199a5a04944f486b4048944f1ed8/build.log`; Precompiling project...; ✗ Oceananigans; 15 dependencies successfully precompiled in 101 seconds (143 already precompiled); 1 dependency errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the package",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1635:1037,load,load,1037,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1635,1,['load'],['load']
Performance,"Hello, I am having some technical trouble installing and using Oceananigans. I am new to Julia and would like to try to set up Oceananigans on a Macbook. But it is running into issues. . (1) - installation process says some things are missing:; Building MPI → `~/.julia/scratchspaces/44cfe95a-1eb2-52ea-b672-e2afdf69b78f/d56a80d8cf8b9dc3050116346b3d83432b1912c0/build.log`; Precompiling project...; ✗ MPI; ✗ PencilArrays; ✗ PencilFFTs; ✗ Oceananigans; 89 dependencies successfully precompiled in 41 seconds; 4 dependencies errored. To see a full report either run `import Pkg; Pkg.precompile()` or load the packages. (2) - using Oceananigans is looking for MPI, but to my knowledge if I want to run on my computer, it shouldn't need MPI, like MITgcm using serial instead of parallel. But I don't know where to change the setting? This is what happens when I call using Oceananigans:. julia> using Oceananigans; [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: MPI.jl not properly configured, please run `Pkg.build(""MPI"")`.; Stacktrace:; [1] error(s::String); @ Base ./error.jl:33; [2] top-level scope; @ ~/.julia/packages/MPI/08SPr/src/MPI.jl:38; [3] include; @ ./Base.jl:418 [inlined]; [4] include_package_for_output(pkg::Base.PkgId, input::String, depot_path::Vector{String}, dl_load_path::Vector{String}, load_path::Vector{String}, concrete_deps::Vector{Pair{Base.PkgId, UInt64}}, source::String); @ Base ./loading.jl:1318; [5] top-level scope; @ none:1; [6] eval; @ ./boot.jl:373 [inlined]; [7] eval(x::Expr); @ Base.MainInclude ./client.jl:453; [8] top-level scope; @ none:1; in expression starting at /Users/sean/.julia/packages/MPI/08SPr/src/MPI.jl:1. caused by: LoadError: InitError: could not load library ""/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib""; dlopen(/Users/sean/.julia/artifacts/48a9a608db31268626d8b8d4d1272c3e7ccbf7d5/lib/libmpifort.12.dylib, 0x0001): Library not loaded: @rpath/libquadm",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2480:598,load,load,598,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2480,2,"['Load', 'load']","['LoadError', 'load']"
Performance,"Here's a few options for optimizing AbstractOperations with `^`:. 1. Auto-convert exponents to `Int32`. For this we'd define. ```julia; Base.^(L::Tuple, a::AbstractField, b::Int64) = ^(L::Tuple, a, Int32(b)); ```. Basically implementing the approach CUDA previously took. For us it's a ""less egregious"" hack since, unlike CUDA.jl, we can ""almost surely"" guarantee that users won't exponentiate with integers larger than `2^31-1 = 2147483647`. Probably the easiest thing to do in the near term. This is a specific extension of the abstract operation defined via `@binary ^` (such that `op = ^`):. https://github.com/CliMA/Oceananigans.jl/blob/1756bc9380999f160f3d2b96f64bf76771614c60/src/AbstractOperations/binary_operations.jl#L100-L108. 2. Convert small-power exponents to literal multiplications. Like `Base.literal_pow`:. ```julia; Base.^(L::Tuple, a::AbstractField, b::Integer) = our_literal_pow(L, a, Val(b)). our_literal_pow(L, a, Val{0}) = one(eltype(a)); our_literal_pow(L, a, Val{1}) = a; our_literal_pow(L, a, Val{2}) = *(L, a, a) # binary operation; our_literal_pow(L, a, Val{3}) = *(L, a, a, a) # multiary operation; our_literal_pow(L, a, Val(b)) where b = _binary_operation(location(a), ^, a, b, location(a), location(a), a.grid) ; ```. etc. I guess 2 would instead happen under the hood when abstract operations are compiled, hopefully, in the best of worlds.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-876812225:25,optimiz,optimizing,25,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1832#issuecomment-876812225,1,['optimiz'],['optimizing']
Performance,"Here's a summary of the current design:. I've introduced a new type called `ImmersedBoundaryCondition` to represent boundary conditions on immersed boundaries. The type has 6 fields for each direction, west, east, south, north, bottom, top. I believe this covers the general case in which we might have different fluxes on any face of a cell that's the boundary between a wet node and an immersed node. For example, we can implement ""bottom drag"" for large scale ocean models, with no ""side drag"". In practice this is really just a performance optimization rather than a physical model (the horizontal drag has no effect on the solution), but it's probably important that we can support it. This low-level, but fully general interface allow advanced users to specify any kind of immersed flux / boundary condition they need to. The next challenge is to design a convenient API that interprets user-input and builds `ImmersedBoundaryCondition` appropriately under the hood. For constant `ValueBoundaryCondition` (eg no-slip) or constant `FluxBoundaryCondition`, this is simple --- just copy the boundary condition into every direction. For `FluxBoundaryCondition` we orient the flux along the inward normal (eg positive for `west, south, bottom` and negative for `east, north, top`. This breaks existing convention for fluxes... but we really don't have a choice. We may want to change the convention for the _other_ boundaries eventually. `ContinuousBoundaryFunction` is perhaps the most important case since we'll use this to implement drag boundary conditions. For this I believe we can use the existing infrastructure for `ContinuousBoundaryFunction` (eg we have a way to properly interpolate fields in a manner consistent with the application of drag boundary conditions, etc). It's functionality will have to be extended to accept functions of `i, j, k` (the way it works now is that the ""third"" index (normal to the boundary) is stored inside the object; for immersed boundary conditions we don'",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991:532,perform,performance,532,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100563991,4,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"Here's an example:. ```julia; using Oceananigans; using MPI; using JLD2. arch = Distributed(); @show arch. x = y = z = (0, 1); global_size = (8, 2, 2); grid = RectilinearGrid(arch, size=global_size; x, y, z); @show size(grid). rank = arch.local_rank; if rank === 0; bathymetry = 0.1 * rand(global_size...); @save ""bathymetry.jld2"" bathymetry; end. MPI.Barrier(arch.communicator); @load ""bathymetry.jld2"" bathymetry. @show size(bathymetry). grid = ImmersedBoundaryGrid(grid, GridFittedBottom(bathymetry)). @show grid; ```. Run this with. ```bash; mpiexec -n 2 julia --project mwe.jl; ```. from the Oceananigans repo. I get. ```julia; $ /Users/gregorywagner/.julia/bin/mpiexecjl -n 2 julia --project mwe.jl [17:11:03]; [ Info: MPI has not been initialized, so we are calling MPI.Init().; [ Info: MPI has not been initialized, so we are calling MPI.Init().; arch = arch = Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 1 of 0-1; ├── local_index: [2, 1, 1]; └── connectivity: east=0 west=0Distributed{CPU} across 2 = 2×1×1 ranks:; ├── local_rank: 0 of 0-1; ├── local_index: [1, 1, 1]; └── connectivity: east=1 west=1. size(grid) = size(grid) = (4, 2, 2); (4, 2, 2); size(bathymetry) = (8, 2, 2); size(bathymetry) = (8, 2, 2); ERROR: LoadError: ERROR: LoadError: ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination field; Stacktrace:; [1] ArgumentError: ERROR: DimensionMismatch: array could not be set to match destination fieldset!(u::Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, fal",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3816:381,load,load,381,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3816,1,['load'],['load']
Performance,"Here's the julia docs on constants for reference:. https://docs.julialang.org/en/v1/manual/variables-and-scoping/#Constants. This statement in the julia docs could maybe be clarified:. > It is difficult for the compiler to optimize code involving global variables, since their values (or even their types) might change at almost any time. because its ambiguous what ""code involving global variables"" is. For Oceananigans, this almost always means ""functions that capture global variables in their scope"". So `f(x) = a * x` is going to be slow unless `a` is `const`; otherwise `f(x)` cannot be inlined properly because the type of `a` is uncertain.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539:223,optimiz,optimize,223,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1863#issuecomment-881696539,1,['optimiz'],['optimize']
Performance,"Here's where we're at.; I've made the following modifications to `baroclinic_adjustment.jl`. ```; using Oceananigans, AMDGPU; ```; and the grid construction now specifies GPU architecture with `GPU(AMDGPU.ROCBackend())`, ie,. ```; grid = RectilinearGrid(GPU(AMDGPU.ROCBackend());; size = (48, 48, 8),; x = (0, Lx),; y = (-Ly/2, Ly/2),; z = (-Lz, 0),; topology = (Periodic, Bounded, Bounded)); ```. When running this, we hit a runtime issue at `plan_forward_transform`. ```; $ julia --project=. baroclinic_adjustment.jl ; ERROR: LoadError: MethodError: no method matching plan_forward_transform(::ROCArray{ComplexF64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, ::Periodic, ::Vector{Int64}, ::UInt32). Closest candidates are:; plan_forward_transform(::CUDA.CuArray, ::Union{Bounded, Periodic}, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:36; plan_forward_transform(::Array, ::Periodic, ::Any, ::Any); @ Oceananigans ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:16; plan_forward_transform(::Union{CUDA.CuArray, Array}, ::Flat, ::Any...); @ Oceananigans ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:47; ... Stacktrace:; [1] plan_transforms(grid::RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, GPU{ROCBackend}}, storage::ROCArray{ComplexF64, 3, AMDGPU.Runtime.Mem.HIPBuffer}, planner_flag::UInt32); @ Oceananigans.Solvers ~/.julia/packages/Oceananigans/DPfYS/src/Solvers/plan_transforms.jl:93; [2] Oceananigans.Solvers.FFTBasedPoissonSolver(grid::RectilinearGrid{Float64, Periodic, Bounded, Flat, Float64, Float64, Float64, OffsetArrays.Offset",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1946746065:528,Load,LoadError,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3475#issuecomment-1946746065,1,['Load'],['LoadError']
Performance,"Hey @beta-effect!. Yes as of PR #282 (included in master, but not in v0.8.0), boundary conditions must be specified at `Model` creation time. This is part of an ongoing attempt at making the types we use in Oceananigans more concrete. If we use structs whose types are set once the struct is created (concrete types), then the compile can more easily optimize things as it knows the data type won't change. The default boundary conditions are given by `ModelBoundaryConditions()` where; ```julia; function ModelBoundaryConditions(;; u = DoublyPeriodicBCs(),; v = DoublyPeriodicBCs(),; w = DoublyPeriodicBCs(),; T = DoublyPeriodicBCs(),; S = DoublyPeriodicBCs(); ); return ModelBoundaryConditions(u, v, w, T, S); end; ```; so I think what you want instead is something like; ```julia; T_bc = FieldBoundaryConditions(; x = CoordinateBoundaryConditions(; BoundaryCondition(Periodic, nothing),; BoundaryCondition(Periodic, nothing)),; y = CoordinateBoundaryConditions(; BoundaryCondition(Periodic, nothing),; BoundaryCondition(Periodic, nothing)),; z = CoordinateBoundaryConditions(; BoundaryCondition(Flux, 0),; BoundaryCondition(Flux, bottom_flux))). bcs = ModelBoundaryConditions(; u = DoublyPeriodicBCs(),; v = DoublyPeriodicBCs(),; w = DoublyPeriodicBCs(),; T = T_bc,; S = DoublyPeriodicBCs()); ```. We still need to figure the API a little because this gets a little annoying: you need to compute `bottom_flux` before constructing the `Model` but it's nice to use `xC, yC, zC` to compute `bottom_flux` but we get them from `model.grid`... The easiest thing to do right now might be to just create the model again but with the new `bcs`:; ```julia; # Set up the model and use an artificially high viscosity ν and diffusivity κ.; model = Model(N=(Nx, Ny, Nz), L=(Lx, Ly, Lz), arch=GPU(),; ν=1e-4, κ=1e-4). # Get location of the cell centers in x, y, z and reshape them to easily; # broadcast over them when calculating hot_bubble_perturbation.; xC, yC, zC = model.grid.xC, model.grid.yC, model.grid.zC",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515189875:351,optimiz,optimize,351,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/314#issuecomment-515189875,1,['optimiz'],['optimize']
Performance,"Hey thanks for doing all this! Things look a lot neater. Just have a few comments/thoughts that I'll pepper throughout but should be good to merge!. > A `Model` constructor is now provided in which all important information can be input via keyword arguments. This is great for understanding what the model does, I agree. Would still be nice to keep the ""legacy constructor"" around for when you just want to create a simple `Model` for playing around with or for testing. And it makes for very nice and simple example code. > I also reduced the computational burden of a few of the tests, and changed to factor of 2 resolutions since this makes sense for FFTs (though relatively unimportant for testing, I think should encourage users to use powers of 2 and make a habit of using them ourselves). I would argue against this. While we should try to use powers of 2 for performance, I think that overly restricts the model resolutions we can be running at. There are a LOT of choices between e.g. `512x512x128` and `1024x1024x128`. It might be that the largest model that fits in memory isn't nice powers of 2. Users may have various reasons for running resolutions that aren't powers of 2. Either way, we should always be testing a wide range of grid sizes (and weird grid sizes like `109x77x13`) because the code should work for all of them. If computational cost becomes an issue we should look into paying for extra CI resources rather than reduce testing. > A few more notes:. Might be good to create some new issues based on those just to keep track of what needs to be done. > The examples are outdated. We should probably reduce the number of examples until the code becomes more stable, and commit to maintaining the few that remain. This is something I'm actively working on in a different branch. I'll make sure they work with the changes in this pull request. > Lots of work to do!. For sure!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468525078:868,perform,performance,868,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/97#issuecomment-468525078,1,['perform'],['performance']
Performance,"Hey, original author of both https://github.com/JuliaGeo/NetCDF.jl and https://github.com/meggart/ZarrNative.jl here. Regarding the state of NetCDF.jl , yes I would say I mostly stopped developing the package due to time constraints and currently shift my focus towards Zarr since this is what we are using in our current project. . My last attempt at improving the NetCDF solved many of the issues with the package https://github.com/JuliaGeo/NetCDF.jl/pull/61 but was not merged because of conflicts with other bugfix PRs. However, might be source of inspiration if someone wants to do a rewrite. . Regarding write performance, I would be very interested to see examples where NetCDF.jl performs worse than e.g. python-netcdf4, since most of the time should be spent in the same NetCDF C library. I have been using the package extensively and did not experience it to be slower than comparable packages. . I you are worried about the robustness of NetCDF.jl, you should not even look at ZarrNative.jl, since it is still very young and rather a prototype. . I would be very happy to discuss the issues further, maybe in a call? Would also be interested to learn about your project which seems to be very cool.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874:617,perform,performance,617,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/145#issuecomment-475680874,2,['perform'],"['performance', 'performs']"
Performance,"Hi @roxyboy, we'll make some docs/examples soon! There are some tools in a different repo but they are rough on the edges at the moment and I'm bit reluctant to point you to it. If you have the `bathymetry` loaded as an array of the same size as a flat-bottom latitude-longitude grid then you can use [GridFittedBottom](https://clima.github.io/OceananigansDocumentation/stable/appendix/library/#Oceananigans.ImmersedBoundaries.GridFittedBottom) to do something like:. ```Julia; underlying_grid = LatitudeLongitudeGrid(arch,; size = (Nx, Ny, Nz),; longitude = (-180, 180),; latitude = (-75, 75),; z = (-depth, 0),; topology = (Periodic, Bounded, Bounded)). grid = ImmersedBoundaryGrid(underlying_grid, GridFittedBottom(bathymetry)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809223215:207,load,loaded,207,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3389#issuecomment-1809223215,1,['load'],['loaded']
Performance,"Hi all!. With the help of Ali and a colleague at my school, I can now run Oceananigans using a GPU on my school's HPC. I am now at a step that is totally unfamiliar to me, coding for a GPU. . Based on what I have read from the Oceananigans documentation, I think the only trouble I will have is creating my forcing functions and my initial conditions. Currently, I read in data from csv's, perform a 1D spline interpolation, and then assign the interpolated function (which is 1D) to a 3D field function. . My understanding is that the way arrays are treated is quite different when working with GPUs and I honestly don't even know where to begin. Below is an excerpt of my run script that shows the initial and boundary condition creation with a CPU architecture. If anyone can share resources on how to code this for a GPU or just explain it if it is easy, I would greatly appreciate the help!. ```; ρₒ = 1025; ############## Boundary conditions ###################; ## Pulling the boundary conditions from the data csv; df = CSV.read(""data_inputs/kma_buoy_fluxes_soulik.csv"", DataFrame);. seconds = df.time[:]*86400; # convert to seconds; secs = [tnow - seconds[1] for tnow in seconds]; # set first time stamp to 0; secs = [s - 518400 for s in secs]; # Move 0 time stamp to later in the time series. ## make the splines; spl_taux = Spline1D(secs, df.taux/(ρₒ), k=1);; spl_tauy = Spline1D(secs, df.tauy/(ρₒ), k=1);; spl_latHF = Spline1D(secs, df.lat_hf/(ρₒ * cᴾ), k=1);; spl_senHF = Spline1D(secs, df.sens_hf/(ρₒ * cᴾ), k=1);. ## turn the splines into functional arguments; @inline Fxn_taux(x,y,t) = spl_taux(t);; @inline Fxn_tauy(x,y,t) = spl_tauy(t);; @inline Fxn_HFlx(x,y,t) = spl_latHF(t) + spl_senHF(t); # K m⁻¹ s⁻¹, surface _temperature_ flux. ############# Initial conditions #############; ## Initial surface stress condition; Qo = sqrt(spl_taux(0)^2 + spl_tauy(0)^2). ## Random noise damped at top and bottom; Ξ(z) = randn() * z / model.grid.Lz * (1 + z / model.grid.Lz); # noise. ## Veloci",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1509:390,perform,perform,390,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1509,1,['perform'],['perform']
Performance,"Hi all, I am trying to setup a DNS in a triply bounded domain with inflow conditions on the west wall. All boundary conditions are as default except for the bottom boundary (no-slip), west wall (inflow) and right wall (outflow). I tried setting up the boundaries as; ```; ubcs = UVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0), west = BoundaryCondition(Value,0.1), east = BoundaryCondition(Gradient,0)); vbcs = VVelocityBoundaryConditions(grid, bottom = BoundaryCondition(Value, 0)); bbcs = TracerBoundaryConditions(grid, west = BoundaryCondition(Value,0)); ```; The tracer boundary condition is fixed to 0 on the west wall. I am getting the following error when running the simulation:. ERROR: LoadError: MethodError: no method matching fill_west_halo!(::OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}, ::BoundaryCondition{Value,Float64}, ::CPU, ::RegularCartesianGrid{Float64,Bounded,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,3,Base.ReshapedArray{Float64,3,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}},Tuple{}}}}, ::Clock{Float64}, ::NamedTuple{(:velocities, :tracers, :diffusivities),Tuple{NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},NamedTuple{(:b,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}},Nothing}}). I now wonder if it is currently possible to have inflow conditions with buoyancy, or if this is a boundary condition that is not implemented. Are inflow conditions incompatible with buoyancy or is the error unrelated? Thanks very much for your help! Entire script below:. ```; # # Lock-release gravity current example. using Oceananigans, Oceananigans.Grids, Printf, SpecialFunctions, Plots. # ## Physical and numerical parameters; #; # First, we pick a resolution and domain size,. Nx = 256; Ny = 256 # x resolution; Nz = 32 # z resolution; Lx = 10; Ly = ",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/789:718,Load,LoadError,718,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/789,1,['Load'],['LoadError']
Performance,"Hi all,. I'm stuck trying to debug an error I keep getting when running a non-hydrostatic model on GPU. . It runs for a bit and then throws this error:; ```; ... (loads of similar CUDA stuff that goes on for a very very long time); @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:170 [inlined]; [16] context!; @ ~/.julia/packages/CUDA/35NC6/lib/cudadrv/state.jl:165 [inlined]; [17] unsafe_free!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}, stream::CUDA.CuStream) ; @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:129; [18] unsafe_finalize!(xs::CUDA.CuArray{ComplexF64, 3, CUDA.Mem.DeviceBuffer}); @ CUDA ~/.julia/packages/CUDA/35NC6/src/array.jl:150; [19] top-level scope; @ ~/.julia/packages/InteractiveErrors/JOo2y/src/InteractiveErrors.jl:329; [20] eval; @ ./boot.jl:370 [inlined]; [21] eval_user_input(ast::Any, backend::REPL.REPLBackend, mod::Module); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:153; [22] repl_backend_loop(backend::REPL.REPLBackend, get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:249; [23] start_repl_backend(backend::REPL.REPLBackend, consumer::Any; get_module::Function); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:234; [24] run_repl(repl::REPL.AbstractREPL, consumer::Any; backend_on_current_task::Bool, backend::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:379; [25] run_repl(repl::REPL.AbstractREPL, consumer::Any); @ REPL /rds/user/js2430/hpc-work/julia-1.9.2/share/julia/stdlib/v1.9/REPL/src/REPL.jl:365; [26] (::Base.var""#1017#1019""{Bool, Bool, Bool})(REPL::Module); @ Base ./client.jl:421; [27] #invokelatest#2; @ ./essentials.jl:816 [inlined]; [28] invokelatest; @ ./essentials.jl:813 [inlined]; [29] run_main_repl(interactive::Bool, quiet::Bool, banner::Bool, history_file::Bool, color_set::Bool); @ Base ./client.jl:405; [30] exec_options(opts::Base.JLOpti",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3267:163,load,loads,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3267,1,['load'],['loads']
Performance,"Hi! I am trying to implement the following setup with a `VerticallyStretchedRectilinearGrid` and `AnisotropicBiharmonicDiffusivity`:. ```; ## Initializing grid; # Horizontal grid; Nx = 64; Ny = 64; Δy = 250.0; Δx = 250.0; Lx = Δx*Nx; Ly = Δy*Ny; # Vertical grid; Lz = 160; zF = collect(0:2.5:160); zF = -zF[end:-1:1]; ; Nz = length(zF) - 1; # Setup grid; grid = VerticallyStretchedRectilinearGrid(Float64; architecture = GPU(),size = (Nx,Ny,Nz), x=(0, Lx), y=(0, Ly), zF=zF, halo = (3, 3, 3), topology = (Periodic, Bounded, Bounded)). ## Turbulence closure; kappaH = 1e5 # m4/s; kappaV = 5e-5 # m2/s. ## Setting up model; model = IncompressibleModel(; architecture = GPU(),; grid = grid,; closure = (AnisotropicDiffusivity(νh=0, κh=0, κz = kappaV, νz = kappaV),; AnisotropicBiharmonicDiffusivity(νh=kappaH, κh=kappaH)); ). ## Running; simulation = Simulation(model, Δt=2, stop_iteration=1) ; run!(simulation); ```. I get the following error:. ```; ERROR: LoadError: time = 2.0, iteration = 1: NaN found in u. Aborting simulation.; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] run_diagnostic!(::NaNChecker{IterationInterval,NamedTuple{(:u,),Tuple{Field{Face,Center,Center,OffsetArrays.OffsetArray{Float64,3,CuArray{Float64,3}},VerticallyStretchedRectilinearGrid{Float64,Periodic,Bounded,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}},OffsetArrays.OffsetArray{Float64,1,CuArray{Float64,1}}},NamedTuple{(:x, :y, :z),Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing},BoundaryCondition{Oceananigans.BoundaryConditions.Periodic,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}},CoordinateBoundaryConditions{BoundaryCondition{Flux,Nothing},BoundaryCondition{Flux,Nothing}}}}}}}}, ::IncompressibleModel{Oceananigans.TimeSteppers.RungeKutta3TimeStepper{Float64,NamedTuple{(:u, :v, :w, :T, :S),Tuple{Field{Face,Center",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1574:955,Load,LoadError,955,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1574,1,['Load'],['LoadError']
Performance,"Hi, PencilArrays / PencilFFTs author here. I'd be happy to help solving this issue, and I'd also welcome any ideas that would help improve the PencilArrays interface and docs. I am not familiar with how you define your domain partition. However, from the point of view of PencilFFTs, there is one restriction, which is that the first dimension (`x`) must *not* be decomposed in physical space. This is because FFTs are first performed along this dimension (along which data is contiguous, as usual for Julia arrays). Also, to avoid potential issues, your eigenvalues should be `PencilArray` wrappers. For now, PencilArrays allows broadcasting together `PencilArray`s and regular `Array`s, but I'm thinking this is not a good idea since the behaviour is non-intuitive and can lead to precisely this kind of issue. So I'm thinking about changing the current behaviour in the future -- and improving documentation on this. Finally, when you write:. ```julia; xc = b = solver.storage[2]; ```. you probably mean `xc = solver.storage[3]` (or, equivalently, `last(solver.storage)`, as in [this example](https://jipolanco.github.io/PencilFFTs.jl/dev/generated/in-place/#Applying-plans)). `storage[2]` holds an intermediate state that has no ""physical"" meaning, since it has been overwritten by the end of a transform. I should clarify all this in the in-place transforms example... Feel free to ping me if things are unclear in the docs or if I can provide any other information.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088:425,perform,performed,425,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2347#issuecomment-1102319088,2,['perform'],['performed']
Performance,"Hi,; I encounter an error when running `pkg> test Oceananigans` despite being able to run example simulation internal_wave.jl on both CPU and GPU. The description of CUDA error code 201 is also attached below. ```; ERROR: LoadError: CUDA error (code 201, CUDA_ERROR_INVALID_CONTEXT); Stacktrace:; [1] throw_api_error(::CUDAdrv.cudaError_enum) at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:105; [2] macro expansion at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/error.jl:112 [inlined]; [3] cuCtxGetDevice(::Base.RefValue{Int32}) at /home/raphael/.julia/packages/CUDAapi/XuSHC/src/call.jl:93; [4] device at /home/raphael/.julia/packages/CUDAdrv/Uc14X/src/context.jl:142 [inlined]; [5] device! at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:198 [inlined]; [6] device!(::CUDAdrv.CuDevice) at /home/raphael/.julia/packages/CUDAnative/ierw8/src/init.jl:188; [7] top-level scope at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:74; [8] include(::String) at ./client.jl:439; [9] top-level scope at none:6; in expression starting at /home/raphael/.julia/packages/Oceananigans/1xP6n/test/runtests.jl:61; ERROR: Package Oceananigans errored during testing; ```. Has anyone encountered this issue? I am on master 0.30.0. Thanks for your help!; ![Screenshot_2020-07-02 CUDA Driver API CUDA Toolkit Documentation](https://user-images.githubusercontent.com/31293515/86409162-4f484f80-bc86-11ea-8736-bad7a9da5345.png)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/788:222,Load,LoadError,222,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/788,1,['Load'],['LoadError']
Performance,"Hmmm - I am skeptical about that from a computer point of view? In an implicit algorithm and/or radiative transfer alg the next step often depends on the result of the previous steps. . As every CCE graduate student learns, computers take many tens of cycles to evaluate an operation like a an add or multiply. The operation is sequential and carried out in a multi-stage pipeline in the heart of a CPU (or GPU). So unless the compiler has something else for the processor to do, the processor will have to wait for one step to make it through the pipeline before the next step? . I think the normal way to do this is to have some inner horiz blocking that is flexible (and can be 1,1) and then iterate over levels with some intermediate stores? The horiz block can be some fraction of inner cache or GPU local proc shared mem. The math doesn't quite look at this way because it assumes that a+b and/or a*b etc.. happen ""instantaneously"". It does not take into account that the awnser from a*b might take; 5-10 clock cycles to pass through the CPU floating point unit. . I think that is fairly generally true? Functional style code in Julia should make it possible; to express this in a fairly clean way, but with flexibility to change blocking for different ; target arch.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073:792,cache,cache,792,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/470#issuecomment-541363073,1,['cache'],['cache']
Performance,Hmmm a lot of failures due to CUDA scalar `getindex` operations even though we explicitly set `CUDA.allowscalar(true)` in `runtests.jl`... We could take this opportunity to get rid of all scalar operations in the tests and just use `CUDA.@allowscalar` where it's needed. Maybe new CUDA scalar operations are hurting performance and that's why GPU CI has slowed down?,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002:316,perform,performance,316,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-816964002,1,['perform'],['performance']
Performance,"Huh --- on my GPU I was getting 2x speed up for `Float32`. I'll have to check that again. The slow down has to do with the abstractions I have introduced. 30% is a huge slow down for one function, indicative of a major problem --- probably a type inference issue? . I think that once this problem is solved the code may become faster because of the disambiguation this PR lends to the innermost kernels. This problem becomes catastrophic for the closures, which make heavy use of the abstraction. So solving this problem is imperative. We can restore the performance of the default closure by simply pasting the old operators into `constant_diffusivity_closures.jl`. However, I believe the issue with type inference is solvable. . Unfortunately, I'm in `Cthulhu` hell right now trying to figure it out... I'm wondering whether these problems will vanish once we eliminate branches from the inmost functions...",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496902962:555,perform,performance,555,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/245#issuecomment-496902962,1,['perform'],['performance']
Performance,"I add a bit of context here:. @Yixiao-Zhang is doing a non-hydrostatic simulation with an immersed boundary and he finds that the code crashes with the PCG solver. That is not necessarily connected with the PCG solver but it might be caused by simulation setup or other issues. Since the pressure solver used is experimental (from [this branch](https://github.com/CliMA/Oceananigans.jl/tree/glw-xk/divergence-free-immersed-velocity-field)), as a way to assess where the crashing comes from, I suggested using another method to see if the crash would also happen, which would validate or not the experimental pressure solver. @Yixiao-Zhang, optimizing GPU preconditioners is a quite difficult task as demonstrated by the preconditioners slowing down the simulation, and probably not a good use of time of trying to figure out a way to speed up these solvers that we are not sure we want to use. ; Since this simple attempt to have a simulation that runs (with another _correct_ solver) up to the crashing point does not work, I would suggest to just trying to use a (slightly non-correct) FFT pressure solver to see if the simulation still crashes.; If not, then we can assume the crashing occurs due to the PCG solver and try to catch the bug. ; This will probably be a better way to ""optimize"" the solver since we know that the PCG preconditioned with FFT is faster than these other methods.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749:640,optimiz,optimizing,640,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3552#issuecomment-2052606749,4,['optimiz'],"['optimize', 'optimizing']"
Performance,"I agree that I would expect it to saturate at higher than 16 if there were 48 cores, but clearly I'm wrong. Getting another benchmark would be a good idea. I'm happy to consider the numba + parallel idea since that would be good to test the architecture. This [mini-course](https://github.com/omlins/parallel-gpu-workshop-JuliaCon21) did give some threaded examples to solve the diffusion equation in 3D. I wonder if we might want to ask Ludovic if they have done any scalings for multi-threading?. I'm happy to discuss this with @hennyg888 on Monday and see what we come up with. Others are happy to join the discussion if they like.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548:481,multi-thread,multi-threading,481,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1861#issuecomment-886074548,2,['multi-thread'],['multi-threading']
Performance,"I agree with @navidcy's points. Of course, it doesn't even matter whether the tracer is initialized or not (referring to the comment in @navidcy's script). The main point is that you can ""re-initialize"" a state whenever you like. I'd also like to make the extra point that @navidcy's pattern is interpretable and readable. I'm not sure we would achieve the same if we hide such a feature inside the source code. Does @navidcy's suggestion work for you @tomchor ?. I also think it is preferred to use separate files for a situation like this (though it may not be necessary to save intermediate times in the spin-up at all --- so a second file might not be necessary). If the spin up is recorded, I think it's better to use a separate file for its data. If the spin up is expensive, the following performance optimization could be used (we can leverage the `velocities` kwarg to save a bit of allocation):. ```julia; # Spin up with no tracers; model = NonhydrostaticModel(; tracers=nothing, kwargs...); simulation = Simulation(model, ...) # etc; run!(simulation). # Run for real, re-using the old `velocities` fields but overwriting the old `model`; model = NonhydrostaticModel(; tracers=:c, velocities=model.velocities, kwargs...); simulation = Simulation(model, ...) # etc; ```. There is some additional memory allocation for tendencies in this case, however, so it may not work for simulations that push GPU memory. > (I'm not aware of any way to ""remove"" the old Simulation from the GPU memory, but if there is, then this downside can be negated.). This occurs automatically with garbage collection, provided that there's no reference to the old simulation in the name space. CUDA may have a way to manually call the garbage collector, after doing something like `model=nothing; simulation=nothing`. If you figure that out, it'd be nice to know. > It makes for more complex code, especially when figuring out when it's safe to pick-up a simulation or not, due to the way pick-ups work. I don't foll",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680:796,perform,performance,796,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3154#issuecomment-1605717680,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"I also had this issue, as new into GPU running, I was super confused about this error. It will be helpful if this issue is not fixable, to at least point out in the documentation. . I encountered this error by running a simulation based on the tutorial ([Langmuir turbulence](https://clima.github.io/OceananigansDocumentation/stable/generated/langmuir_turbulence/#Langmuir-turbulence-example)) in GPUs. Note that the print function prints the `maximum(abs, u), maximum(abs, v), maximum(abs, w)`:; ```; msg = @sprintf(""i: %04d, t: %s, Δt: %s, umax = (%.1e, %.1e, %.1e) ms⁻¹, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.Δt),; maximum(abs, u), maximum(abs, v), maximum(abs, w),; prettytime(simulation.run_wall_time)); ```; thus resulting in the error:; ```; LoadError: CUDA error: too many resources requested for launch; ```; For reference, the code works once the `maximum` functions are removed:; ```; msg = @sprintf(""i: %04d, t: %s, �~Tt: %s, wall time: %s\n"",; iteration(simulation),; prettytime(time(simulation)),; prettytime(simulation.�~Tt),; prettytime(simulation.run_wall_time)); ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103:807,Load,LoadError,807,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3427#issuecomment-1992106103,1,['Load'],['LoadError']
Performance,"I also tried to run `baroclinic_adjustmenet.jl` found [here](https://github.com/CliMA/Oceananigans.jl/blob/main/validation/mesoscale_turbulence/baroclinic_adjustment.jl) and got the following error. ```; ERROR: LoadError: MethodError: Cannot `convert` an object of type Float64 to an object of type VerticallyImplicitTimeDiscretization; Closest candidates are:; convert(::Type{T}, ::T) where T at essentials.jl:205; Stacktrace:; [1] convert_diffusivity(FT::Type, κ::Float64; kw::Base.Iterators.Pairs{Symbol, Bool, Tuple{Symbol}, NamedTuple{(:discrete_form,), Tuple{Bool}}}); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_utils.jl:15; [2] ScalarDiffusivity(time_discretization::ExplicitTimeDiscretization, formulation::Oceananigans.TurbulenceClosures.VerticalFormulation, FT::Type; ν::Float64, κ::Float64, discrete_form::Bool); @ Oceananigans.TurbulenceClosures ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:52; [3] #VerticalScalarDiffusivity#39; @ ~/Software/Oceananigans.jl/src/TurbulenceClosures/turbulence_closure_implementations/scalar_diffusivity.jl:87 [inlined]; [4] top-level scope; @ ~/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; in expression starting at /home/fpoulin/Software/Oceananigans.jl/validation/mesoscale_turbulence/baroclinic_adjustment.jl:51; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2543:211,Load,LoadError,211,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2543,1,['Load'],['LoadError']
Performance,"I also want to drop another optimization that can be used here --- using a `Float32` grid with the preconditioner. This will speed things up a bit. Eg:. ```julia; using Oceananigans.Grids: with_number_type. reduced_precision_grid = with_number_type(Float32, underlying_grid). pressure_solver = ConjugateGradientPoissonSolver(grid;; preconditioner = fft_poisson_solver(reduced_precision_grid),; maxiter = 10; ); ```. I also suggest plotting the divergence to get a handle on how the solver is working. A well-converged solution seems to have isotropically-distributed divergence errors. With looser tolerances, the divergence may be concentrated around the bathymetry (and of course with the naive FFT solver it has a thin layer adjacent to the bathymetry). I also think it would be nice if setting `maxiter=0` had a similar effect as simply using the FFT-based preconditioner. It's not the case right now, I think because we do not apply the preconditioner to the pressure initially before doing the CG iteration. It might not work (I believe I experimented briefly with that to no avail).",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414308611:28,optimiz,optimization,28,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3831#issuecomment-2414308611,2,['optimiz'],['optimization']
Performance,I am actually looking into implementing a multidimensional _sweep_ approach that will allow us to break the 2nd order limit. https://d-nb.info/1124132775/34; https://www.sciencedirect.com/science/article/pii/S0021999104002281. I ll see if it is too difficult or unfeasible in terms of performance,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164483965:285,perform,performance,285,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2615#issuecomment-1164483965,1,['perform'],['performance']
Performance,I am currently running a 0.083-degree global ocean simulation on Tesla V100 GPUs. I am benchmarking a bit to understand where we can target optimization to improve the performance and I thought I would leave the benchmarks here to document them for later use. (we do not have to merge this PR),MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2760:140,optimiz,optimization,140,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2760,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"I am happy to open a PR but when I try the line you suggested , unfortunately, there is still a problem. Some good news! This fixes it for the vector invariant formulation. However, when I try the conervative form it complains about not knowing `u`. See the start of the output below. ```; ERROR: LoadError: TaskFailedException. nested task error: type NamedTuple has no field u; Stacktrace:; [1] getproperty(x::NamedTuple{(:uh, :vh, :h), Tuple{Field{Face, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Periodic, Flat, Float64, Float64, Float64, OffsetArrays.; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984:297,Load,LoadError,297,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2606#issuecomment-1152672984,1,['Load'],['LoadError']
Performance,"I am happy with both names but do we need a distributed for each framework? I thought they were almost identical but don't remember the details. Francis; ________________________________; From: Ali Ramadhan ***@***.***>; Sent: Tuesday, March 23, 2021 10:34:09 AM; To: CliMA/Oceananigans.jl ***@***.***>; Cc: Francis Poulin ***@***.***>; Author ***@***.***>; Subject: Re: [CliMA/Oceananigans.jl] `MultiCPU` or `MPI_CPU` (#1502). True. I guess we don't have a separate architecture for multi-threaded. I agree that MPI_CPU or MPICPU would be more precise. What do you think of DistributedCPU and DistributedGPU?. -; You are receiving this because you authored the thread.; Reply to this email directly, view it on GitHub<https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804952861>, or unsubscribe<https://github.com/notifications/unsubscribe-auth/AB63PQIRKGMIJUKMEU5CYQTTFCRGDANCNFSM4ZUIJ5FQ>.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804964762:484,multi-thread,multi-threaded,484,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1502#issuecomment-804964762,1,['multi-thread'],['multi-threaded']
Performance,"I am having a problem with `NonTraditionalBetaPlane`. Please see the minimum working example below. . If is run it on a grid of `(4,4,4)` it works fine or if I use `FPlane`, it works fine. However, if I have 8 points in the vertical, it gives an error, which I have copied part of below, involving the size fo OffsetArrays. . Can someone help me understand how to fix this?. ```; using Oceananigans. grid = RectilinearGrid(CPU();; size = (4, 4, 8), halo = (3, 3, 3),; x = (-1, 1), y = (-1, 1), z = (-1, 0),; topology = (Periodic, Periodic, Bounded)); ; model = NonhydrostaticModel( grid = grid,; coriolis = NonTraditionalBetaPlane(fy=1e-4, fz=1e-4, β = 0, γ = 0,)). simulation = Simulation(model, Δt=1, stop_time=4); run!(simulation); ```. Error:. ```; julia> include(""mwe_nontraditional.jl""); [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (188.650 μs); [ Info: Executing initial time step...; ERROR: LoadError: TaskFailedException. nested task error: BoundsError: attempt to access 10-element OffsetArray(::StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}, -2:7) with eltype Float64 with indices -2:7 at index [8]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:703; [2] overdub; @ ~/.julia/packages/KernelAbstractions/3ZHln/src/compiler.jl:51 [inlined]; [3] overdub; @ ./abstractarray.jl:668 [inlined]; [4] getindex(::OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, ::Int64); @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]; [5] overdub; @ ~/.julia/packages/OffsetArrays/WvkHl/src/OffsetArrays.jl:435 [inlined]. ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2876:938,Load,LoadError,938,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2876,1,['Load'],['LoadError']
Performance,"I am not certain what the `ignore-cache` flag does, I borrowed the module loading sequence. I am pretty it ignores previously loaded modules with the same or similar name.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2256247465:34,cache,cache,34,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2256247465,3,"['cache', 'load']","['cache', 'loaded', 'loading']"
Performance,"I am on the fence. In the cubed sphere aquaplanet (not even MPI but just on one GPU) the gain of performance is a factor 5 by using the efficient split explicit rather than filling the halos at each substep. We do not have to tackle this problem here or now, but we have keep in mind that fill halo is very inefficient and probably not the way to go. Maybe @ali-ramadhan finds a better way to have a gpu-compatible code that does not require adding boundary conditions in the operators.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353966686:97,perform,performance,97,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3268#issuecomment-2353966686,1,['perform'],['performance']
Performance,"I am trying to run a script and when opening packages as below:; ```; ### Load in Packages; # using Pkg; # Pkg.instantiate(); using Oceananigans; using Oceananigans.AbstractOperations: @at, ∂x, ∂y, ∂z; using Oceananigans.AbstractOperations: @at, Average; using Oceananigans.Grids: Center, Face; using Oceananigans.Units; using Random; using Printf; using ArgParse; using CUDA: has_cuda_gpu; using CUDA ; using Oceanostics; ```; I get the following error:; ```; [32609] signal (11.1): Segmentation fault; in expression starting at /glade/u/home/knudsenl/.julia/packages/Oceanostics/cbCj1/src/Oceanostics.jl:35; Allocations: 575575 (Pool: 574672; Big: 903); GC: 1; ┌ Warning: You are using a non-official build of Julia. This may cause issues with CUDA.jl.; │ Please consider using an official build from https://julialang.org/downloads/.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:180; ┌ Warning: CUDA runtime library `libcublasLt.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libcublasLt.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; │ environment variable, or that it does not contain paths to CUDA libraries.; │; │ In any other case, please file an issue.; └ @ CUDA ~/.julia/packages/CUDA/Tl08O/src/initialization.jl:219; ┌ Warning: CUDA runtime library `libnvJitLink.so.12` was loaded from a system path, `/glade/u/apps/common/23.08/spack/opt/spack/cuda/12.2.1/lib64/libnvJitLink.so.12`.; │; │ This may cause errors. Ensure that you have not set the LD_LIBRARY_PATH; ""BBL_O_10.out"" 47L, 2643B 1,0-1 Top; ```; How do I fix this? Thank you for any help; Edit: I have been working with @tomchor on trying to debug this issue",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655:74,Load,Load,74,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655,3,"['Load', 'load']","['Load', 'loaded']"
Performance,"I am using Oceananigans v0.54.0 with Julia v1.6 on GPU. I tried setting an initial condition in salinity as follows:. ```; Stop = 29.5; Sbot = 32; ztop = -35; zbot = -70; dSdz = (Sbot-Stop)/ztop; S_func(x, y, z) = Stop + dSdz*(z > ztop)*z ; set!(model, S=S_func); ```. and got the error copied below. Note that this works fine in Julia v1.5.4. . ```; ┌ Warning: You appear to be using MPI.jl with the default MPI binary on a cluster.; │ We recommend using the system-provided MPI, see the Configuration section of the MPI.jl docs.; └ @ MPI ~/.julia/packages/MPI/3q18R/deps/deps.jl:15; ERROR: LoadError: MethodError: no method matching set!(::Field{Center, Center, Center, OffsetArrays.OffsetArray{Float64, 3, CuArray{Float64, 3}}, RegularRectilinearGrid{Float64, Periodic, Periodic, Bounded, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Flux, Nothing}, BoundaryCondition{Flux, CuArray{Float64, 2}}}}}}, ::typeof(S_func)); Closest candidates are:; set!(::Oceananigans.Fields.AbstractField, !Matched::Number) at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:14; set!(::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G, !Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where G) where {X, Y, Z, A} at /home/guptam/.julia/packages/Oceananigans/SPGnT/src/Fields/set!.jl:16; set!(!Matched::Oceananigans.Fields.AbstractField{X, Y, Z, A, G} where {X, Y, Z, A<:(OffsetArrays.OffsetArray{T, D, var""#s203""} where {T, D, var""#s203""<:Array}), G}, ::Function) at /home/guptam/.julia/p",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1555:592,Load,LoadError,592,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1555,1,['Load'],['LoadError']
Performance,"I attempted to run the [eady_turbulence.jl](https://github.com/CliMA/Oceananigans.jl/blob/master/examples/eady_turbulence.jl) example with `TwoDimensionalLeith()`closure as follows:. ```; closure = (AnisotropicDiffusivity(νh=0, κh=0, νz=κᵥ, κz=κᵥ),; #AnisotropicBiharmonicDiffusivity(νh=κ₄h, κh=κ₄h)); TwoDimensionalLeith()); ```. and got the error posted below. I am using Oceananigans.jl v0.40.0. . ```; ERROR: LoadError: TaskFailedException:; MethodError: no method matching ∂ⱼ_2ν_Σ₁ⱼ(::Int64, ::Int64, ::Int64, ::RegularCartesianGrid{Float64,Periodic,Periodic,Bounded,OffsetArrays.OffsetArray{Float64,1,StepRangeLen{Float64,Base.TwicePrecision{Float64},Base.TwicePrecision{Float64}}}}, ::Clock{Float64}, ::TwoDimensionalLeith{Float64,NamedTuple{(:b,),Tuple{Float64}},NamedTuple{(:b,),Tuple{Float64}}}, ::NamedTuple{(:u, :v, :w),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}},OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}, ::NamedTuple{(:νₑ,),Tuple{OffsetArrays.OffsetArray{Float64,3,Array{Float64,3}}}}); Closest candidates are:; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid, ::Any, ::Tuple{C1,C2}, ::Any, ::Any) where {C1, C2} at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/closure_tuples.jl:13; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::AbstractGrid{FT,TX,TY,TZ} where TZ where TY where TX, ::Any, ::Tuple, ::Any, ::Any, ::Any...) where FT at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/TurbulenceClosures.jl:110; ∂ⱼ_2ν_Σ₁ⱼ(::Any, ::Any, ::Any, ::Any, ::Any, ::IsotropicDiffusivity, ::Any, ::Any...) at /home/guptam/.julia/packages/Oceananigans/g8qkN/src/TurbulenceClosures/turbulence_closure_implementations/isotropic_diffusivity.jl:53; ...; Stacktrace:; [1] call at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:456 [inlined]; [2] fallback at /home/guptam/.julia/packages/Cassette/158rp/src/context.jl:454 [inlined]; [3] _overdub_fallback at /home/guptam/.juli",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1034:413,Load,LoadError,413,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1034,1,['Load'],['LoadError']
Performance,I believe #1770 does the trick:. ```; [2021/06/25 18:04:55.066] INFO Writing Advection_schemes_relative_performance_(CPU).html...; Advection schemes relative performance (GPU); ┌───────────────┬────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Schemes │ slowdown │ memory │ allocs │; ├───────────────┼────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ CenteredFourthOrder │ 1.36629 │ 1.07711 │ 1.66944 │; │ GPU │ CenteredSecondOrder │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ UpwindBiasedFifthOrder │ 1.53522 │ 1.11266 │ 1.9781 │; │ GPU │ UpwindBiasedThirdOrder │ 1.31322 │ 1.03505 │ 1.30432 │; │ GPU │ WENO5 │ 1.84272 │ 1.1889 │ 2.64008 │. ```. would be good to get confirmation from someone.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868903480:158,perform,performance,158,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868903480,1,['perform'],['performance']
Performance,"I believe there's some issue with initialization. It doesn't help to rebuild the individual jobs, because the initialization only happens once and the results are cached are re-used within each build. I think somehow we have to start a new build with a new ID.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3580#issuecomment-2371783629:163,cache,cached,163,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3580#issuecomment-2371783629,1,['cache'],['cached']
Performance,"I can't quite identify where this issue is coming from but if you load a `FieldTimeSeries` in the normal way, i.e.:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u"");; ```; when it gets adapted the `data` and `times` are not adapted to GPU arrays if the `FieldTimeSeries` is adapted to `GPUAdaptedFieldTimeSeries` when it's passed to a model etc. If instead I specify the grid like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; ```; then the data is correctly adapted but the `times` are still a regular vector. I can of course manually create the adapted time series like:; ```julia; u = FieldTimeSeries(""path.jld2"", ""u""; grid);; u_adapt = GPUAdaptedFieldTimeSeries{Face, Center, Center, eltype(grid)}(arch_array(arch, u.data), arch_array(arch, u.times)); ```; and also defining:; ```julia; adapt_structure(to, fts::GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}) where {LX, LY, LZ, FT} = ; GPUAdaptedFieldTimeSeries{LX, LY, LZ, FT}(adapt(to, fts.data),; adapt(to, fts.times)); ```; but this should probably be part of the default behaviour.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3472:66,load,load,66,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3472,1,['load'],['load']
Performance,"I can't seem to construct a `Float32` hydrostatic model with CATKE. I'm pretty sure this used to work but I can't figure out when this error started happening or why. But it's happening as of the current `main` branch or v0.93.0 on two different machines. I guess with CUDA illegal memory access errors, they tend to occur after the illegal memory access has actually occured so the stacktrace might not be useful. MWE:. ```julia; using Oceananigans; using Oceananigans.TurbulenceClosures: CATKEVerticalDiffusivity. grid = LatitudeLongitudeGrid(; GPU(),; Float32,; topology = (Bounded, Bounded, Bounded),; size = (16, 16, 16),; longitude = (0, 1),; latitude = (0, 1),; z = (-100, 0); ). model = HydrostaticFreeSurfaceModel(;; grid,; buoyancy = BuoyancyTracer(),; tracers = (:b, :e),; closure = CATKEVerticalDiffusivity(Float32); ); ```. Error:. ```julia; ERROR: LoadError: CUDA error: an illegal memory access was encountered (code 700, ERROR_ILLEGAL_ADDRESS); Stacktrace:; [1] throw_api_error(res::CUDA.cudaError_enum); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:30; [2] check; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/libcuda.jl:37 [inlined]; [3] cuStreamGetCaptureInfo; @ ~/.julia/packages/CUDA/2kjXI/lib/utils/call.jl:34 [inlined]; [4] capture_status(stream::CUDA.CuStream); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:174; [5] is_capturing (repeats 2 times); @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/graph.jl:179 [inlined]; [6] checked_cuModuleLoadDataEx(_module::Base.RefValue{Ptr{CUDA.CUmod_st}}, image::Ptr{UInt8}, numOptions::Int64, options::Vector{CUDA.CUjit_option_enum}, optionValues::Vector{Ptr{Nothing}}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:17; [7] CUDA.CuModule(data::Vector{UInt8}, options::Dict{CUDA.CUjit_option_enum, Any}); @ CUDA ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:60; [8] CuModule; @ ~/.julia/packages/CUDA/2kjXI/lib/cudadrv/module.jl:49 [inlined]; [9] link(job::GPUCompiler.CompilerJob, compiled::@NamedTupl",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3870:862,Load,LoadError,862,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3870,1,['Load'],['LoadError']
Performance,"I changed `∂xᶠᵃᵃ` to use `Δxᶠᵃᵃ` and when I try and compute the `x` derivative of the free surface in the `x` momentum equation I get the following error. It seems to me like we need to generalize this function, and others, to work on immersed grids. I pressume this is what the other models do? Looks like the fix could be easy. ```; ERROR: LoadError: TaskFailedException. nested task error: MethodError: no method matching ∂xᶠᵃᵃ(::Int64, ::Int64, ::Int64, ::ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}, ::typeof(Oceananigans.Models.ShallowWaterModels.gh2), ::Field{Center, Center, Center, CPU, OffsetArrays.OffsetArray{Float64, 3, Array{Float64, 3}}, ImmersedBoundaryGrid{Float64, Periodic, Bounded, Flat, RegularRectilinearGrid{Float64, Periodic, Bounded, Flat, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}}}}, GridFittedBoundary{typeof(bump)}}, Float64, NamedTuple{(:x, :y, :z), Tuple{CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}}, CoordinateBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, CoordinateBoundaryConditions{Nothing, Nothing}}}}, ::Float64); Closest candidates are:; ∂xᶠᵃᵃ(::Any, ::Any, ::Any, ::AbstractRectilinearGrid, ::F, ::Any...) where F<:Function at /home/fpoulin/software/Oceananigans.jl/src/Operators/derivative_operators.jl:16; ∂xᶠᵃᵃ(::Any, ::Any, ::Any, ::AbstractRectilinearGrid, ::Any) at /home/fpoulin/software/Oceananigans.jl/src/Operators/derivative_operators.jl:6; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-849719531:342,Load,LoadError,342,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1663#issuecomment-849719531,1,['Load'],['LoadError']
Performance,"I completely agree. I'd even go further and suggest a section for simulation tips in general, and then a subsection for GPU tips specifically. As an example, I noticed that defining as many things as `const` as possible helps with performance, even if I'm running on a CPU. It seems kinda obvious in hindsight, but it took me a few months to think of that.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800468178:231,perform,performance,231,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1478#issuecomment-800468178,1,['perform'],['performance']
Performance,"I copied one of the errors below. I remember seeing this error before but I'm not sure how it was resolved. Restarting the tests?. ```; Precompiling project...;   | ✓ Oceananigans;   | 1 dependency successfully precompiled in 87 seconds (200 already precompiled);   | Testing Running tests...;   | ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-7803/compiled/v1.6/Oceananigans/hU93i_V4y9F.ji"": No such file or directory;   | Stacktrace:; ...; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343:305,Load,LoadError,305,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2607#issuecomment-1157668343,2,['Load'],['LoadError']
Performance,"I could not get the Poisson pressure solver to work on the GPU. Most of it works but CUDA does not have a DCT function so I had to perform the DCT/IDCT in terms of the FFT/IFFT. The DCT/IDCT functions work in isolation (regression tested with `FFTW.r2r!`, see link to Jupyter notebook below) but not in the Poisson solver. More specifically, the IDCT fails when applied to the third dimension (after or before the IFFT is applied to dimensions 1 and 2). For now I got around this by copying the right hand side to the CPU, doing the transform on the CPU, and copying the geopotential back to the GPU. This operation is so much slower than the time stepping that it takes up like 98%+ of wall clock time. It might also be introducing further numerical errors. Link to current Poisson GPU solver:; https://github.com/ali-ramadhan/Oceananigans.jl/blob/93aa0038b3126470f263475d648bceb9562bbe91/src/spectral_solvers.jl#L421. Messy Jupyter notebook: [Testing DCT/IDCT on the GPU](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/DCT%2BIDCT%20from%20DFT%2BIDFT.ipynb). Messy Jupyter notebook: [Testing GPU Poisson solver](https://github.com/ali-ramadhan/random-jupyter-notebooks/blob/master/Oceananigans.jl/GPU/Testing%20GPU%20Poisson%20solver.ipynb)",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/56:131,perform,perform,131,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/56,1,['perform'],['perform']
Performance,"I couldn't run docs locally to make sure all is good... running ; ```bash; julia --project=docs/ -e 'using Pkg; Pkg.instantiate(); Pkg.develop(PackageSpec(path=pwd()))'; julia --project=docs/ docs/make.jl;; ```. returns. ```bash; ...; [ Info: Expanding citation: Kundu15.; [ Info: CheckDocument: running document checks.; [ Info: Populate: populating indices.; ERROR: LoadError: `makedocs` encountered an error. Terminating build; Stacktrace:; [1] error(::String) at ./error.jl:33; [2] runner(::Type{Documenter.Builder.RenderDocument}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Builder.jl:255; [3] dispatch(::Type{Documenter.Builder.DocumentPipeline}, ::Documenter.Documents.Document) at /Users/navid/.julia/packages/Documenter/pjwqp/src/Utilities/Selectors.jl:167; [4] #2 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:241 [inlined]; [5] cd(::Documenter.var""#2#3""{Documenter.Documents.Document}, ::String) at ./file.jl:104; [6] #makedocs#1 at /Users/navid/.julia/packages/Documenter/pjwqp/src/Documenter.jl:240 [inlined]; [7] top-level scope at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; [8] include(::Function, ::Module, ::String) at ./Base.jl:380; [9] include(::Module, ::String) at ./Base.jl:368; [10] exec_options(::Base.JLOptions) at ./client.jl:296; [11] _start() at ./client.jl:506; in expression starting at /Users/navid/Research/Oceananigans.jl/docs/make.jl:141; ```. which I couldn't trace down...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1072:368,Load,LoadError,368,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1072,1,['Load'],['LoadError']
Performance,"I d like to try to improve performance a bit first... Anyways, by next week I ll merge",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190872511:27,perform,performance,27,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1190872511,1,['perform'],['performance']
Performance,"I do hope that I found something useful but at the moment I am a bit confued as to what's going wrong. I'm going to copy the errors below so others can see this more easily. The error in the docs complains about `PlotUtils` failing to precompile. That doesn't seem related to shallow water so I am confused. The CPU test seems to be with `MPI`, but I didn't know we had any `MPI` tests that used shallow water that were being run. Docs:; ```; ERROR: could not load library ""/storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so""; --; &nbsp; | /storage7/buildkite-agent/julia-1.5.4/lib/julia/sys.so: ELF load command past end of file; &nbsp; | ERROR: LoadError: Failed to precompile PlotUtils [995b91a9-d308-5afd-9ec6-746e21dbc043] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/PlotUtils/YveHG_R3lk8.ji.; &nbsp; | Stacktrace:; &nbsp; | [1] top-level scope at none:2; &nbsp; | [2] eval at ./boot.jl:347 [inlined]; &nbsp; | in expression starting at /storage7/buildkite-agent/.julia-2556/packages/Plots/SjqWU/src/Plots.jl:20; &nbsp; | ERROR: LoadError: Failed to precompile Plots [91a5bcdd-55d7-5caf-9e0b-520d859cae80] to /storage7/buildkite-agent/.julia-2556/compiled/v1.5/Plots/ld3vC_R3lk8.ji.; &nbsp; | in expression starting at /storage7/buildkite-agent/builds/tartarus-mit-edu-1/clima/oceananigans/docs/make.jl:6; &nbsp; | 🚨 Error: The command exited with status 1. ```. CPU test; ```; [8] test() at /buildworker/worker/package_linux64/build/usr/share/julia/stdlib/v1.5/Pkg/src/API.jl:72; --; &nbsp; | [9] top-level scope at none:1; &nbsp; | Union{},Union{},Tuple{},NamedTuple{(test(::Pkg.Types.Context, ::Array{Pkg.Types.PackageSpec,1}; ERROR: failed process: Process(`/storage7/buildkite-agent/.julia-2556/artifacts/2fcd463fb9498f362be9d1c4ef70a63c920b0e96/bin/mpiexec -np 4 /storage7/buildkite-agent/julia-1.5.4/bin/julia -O0 --color=yes -e 'using Pkg; Pkg.test()'`, ProcessExited(1)) [1]; &nbsp; | &nbsp;; &nbsp; | Stacktrace:; &nbsp; | [1] pipeline_error at ./process.jl:525 [inlined]",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141:460,load,load,460,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1662#issuecomment-842643141,3,"['Load', 'load']","['LoadError', 'load']"
Performance,"I don't follow everything here but it looks like the simulation is being performed on a login node in the above screenshot. @Sumanshekhar17, your cluster may have a policy in place to stop (""kill"") jobs that run on a login node. To sort out script vs cluster issues I suggest running the script on a local machine (for example, your laptop) first. If it runs to completion, and also starts and runs on the cluster with `architecture=GPU()`, then we know the problem is due to cluster policy or some other cluster-specific setting, rather than a problem with your script or Oceananigans.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-756149003:73,perform,performed,73,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1289#issuecomment-756149003,1,['perform'],['performed']
Performance,"I don't know exactly what to do, so we'll need help. I've started with a post to the julia slack: https://julialang.slack.com/archives/C67910KEH/p1635909337281400. On the other hand, it may not be a huge issue if it only affects diagnostics that are evaluated fewer than 5 times. For long running simulations, our methods do eventually get cached? Do you have an example of a method that doesn't get cached after 5 evaluations?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958631268:340,cache,cached,340,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2024#issuecomment-958631268,2,['cache'],['cached']
Performance,"I don't know if this helps to make the issue clearer, but I just re-ran the code for just ; ```; using Oceananigans ; ```; and it executed without error. I ran it again to see if it was just a fluke and I got the following error:; ```. The following have been reloaded with a version change:; 1) cuda/12.2.1 => cuda/11.8.0. [59837] signal (11.1): Segmentation fault; in expression starting at /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/testcode.jl:1; Allocations: 605144 (Pool: 604223; Big: 921); GC: 1; /var/spool/pbs/mom_priv/jobs/1741845.casper-pbs.SC: line 31: 59837 Segmentation fault (core dumped) julia --project testcode.jl /glade/derecho/scratch/knudsenl/BottomBoundaryLayer/; ```; Could it be an issue with the computer loading Oceananigans.jl with a bunch of extra functions?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645:739,load,loading,739,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2237133645,2,['load'],['loading']
Performance,"I don't know. Increasing grid points to 4, there's still a problem with 6 threads. ```julia; (base) gregorywagner:Oceananigans.jl/ (main✗) $ JULIA_NUM_THREADS=6 julia --project race_condition_test.jl [19:56:49]; [ Info: Oceananigans will use 6 threads; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (79.416 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (6.660 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; (parent(simulation.model.velocities.u))[1, 1, :] = [1.9557581998545617, 1.9557581998545617, 1.956214574857873, 1.9553566305291932, 1.9553371609848056, 1.9553371609848056]; Test Failed at /Users/gregorywagner/Projects/test/Oceananigans.jl/race_condition_test.jl:17; Expression: (parent(simulation.model.velocities.u))[1, 1, 2] == (parent(simulation.model.velocities.u))[1, 1, 3]; Evaluated: 1.9557581998545617 == 1.956214574857873; ERROR: LoadError: There was an error during testing; in expression starting at /Users/gregorywagner/Projects/test/Oceananigans.jl/race_condition_test.jl:17; ```. and also with 4. But with 3,. ```julia; (base) gregorywagner:Oceananigans.jl/ (main✗) $ JULIA_NUM_THREADS=3 julia --project race_condition_test.jl [19:58:49]; [ Info: Oceananigans will use 3 threads; [ Info: Initializing simulation...; [ Info: ... simulation initialization complete (98.396 ms); [ Info: Executing initial time step...; [ Info: ... initial time step complete (6.548 seconds).; [ Info: Simulation is stopping. Model iteration 100 has hit or exceeded simulation stop iteration 100.; (parent(simulation.model.velocities.u))[1, 1, :] = [1.9543734841879783, 1.9543734841879783, 1.9543734841879783, 1.9560232965664703, 1.9567081251492398, 1.9567081251492398]; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308177839:988,Load,LoadError,988,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2809#issuecomment-1308177839,1,['Load'],['LoadError']
Performance,"I don't think we should depend on a heavy package like Plots.jl, but we might want to automatically install and load it when someone runs an example like the rising thermal bubble one on the README. Might be related to #14 so Requires.jl would help but we also want to add/build the package too.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/195:112,load,load,112,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/195,1,['load'],['load']
Performance,"I found this issue [here](https://github.com/JuliaGPU/CUDA.jl/issues/84) that seems to discuss the problem that we had with this PR (or at least my limited understanding of the problem). I went through the steps and I think they fixed it as it worked for me. . @ali-ramadhan , do you know which norm failed on a `CuArray` or did they all fail?. ```; julia> using LinearAlgebra, CUDA. julia> x=cu([1.,2.]); 2-element CuArray{Float32,1}:; 1.0; 2.0. julia> norm(x); 2.236068f0. julia> norm(x,2); ┌ Warning: Performing scalar operations on GPU arrays: This is very slow, consider disallowing these operations with `allowscalar(false)`; └ @ GPUArrays ~/.julia/packages/GPUArrays/WV76E/src/host/indexing.jl:43; 2.236068f0. julia> norm(x,0); 2.0f0. julia> norm(x,1); 3.0f0. julia> norm(x,4); 2.030543f0. julia> norm(x,Inf); 2.0f0; ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1562#issuecomment-817778463:504,Perform,Performing,504,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1562#issuecomment-817778463,1,['Perform'],['Performing']
Performance,"I get a `BoundsError` when running the following MWE using the latest version of Oceananigans:. ```julia; using Oceananigans. Nx=Ny=Nz=10. z_faces(k) = k/Nz; grid = RectilinearGrid(topology=(Bounded, Bounded, Bounded),; size=(Nx, Ny, Nz),; x=(0,1), y=(0,1), ; z=z_faces,; halo=(3,3,3),; ). advection = WENO(grid=grid, order=7); ```. The error I get is:. ```julia; ERROR: LoadError: BoundsError: attempt to access 19-element OffsetArray(::Vector{Float64}, -3:15) with eltype Float64 with indices -3:15 at index [-4]; Stacktrace:; [1] throw_boundserror(A::OffsetArrays.OffsetVector{Float64, Vector{Float64}}, I::Tuple{Int64}); @ Base ./abstractarray.jl:651; [2] checkbounds; @ ./abstractarray.jl:616 [inlined]; [3] getindex; @ ~/.julia/packages/OffsetArrays/80Lkc/src/OffsetArrays.jl:435 [inlined]; [4] #1; @ ./none:0 [inlined]; [5] MappingRF; @ ./reduce.jl:93 [inlined]; [6] FilteringRF; @ ./reduce.jl:105 [inlined]; [7] _foldl_impl(op::Base.FilteringRF{Oceananigans.Advection.var""#2#4""{Int64, Int64}, Base.MappingRF{Oceananigans.Advection.var""#1#3""{Int64, Int64, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, OffsetArrays.OffsetVector{Float64, Vector{Float64}}, Int64, typeof(-)}, Base.BottomRF{typeof(Base.mul_prod)}}}, init::Base._InitialValue, itr::UnitRange{Int64}); @ Base ./reduce.jl:58; [8] foldl_impl; @ ./reduce.jl:48 [inlined]; [9] mapfoldl_impl; @ ./reduce.jl:44 [inlined]; [10] #mapfoldl#214; @ ./reduce.jl:160 [inlined]; [11] mapfoldl; @ ./reduce.jl:160 [inlined]; [12] #mapreduce#218; @ ./reduce.jl:287 [inlined]; [13] mapreduce; @ ./reduce.jl:287 [inlined]; [14] #prod#225; @ ./reduce.jl:582 [inlined]; [15] prod; @ ./reduce.jl:582 [inlined]; [16] num_prod; @ ~/.julia/packages/Oceananigans/W63bs/src/Advection/reconstruction_coefficients.jl:31 [inlined]; [17] #18; @ ./none:0 [inlined]; [18] MappingRF; @ ./reduce.jl:93 [inlined]; [19] (::Base.FilteringRF{Oceananigans.Advection.var""#19#23""{Int64}, Base.MappingRF{Oceananigans.Advection.var""#18#22""{Int64, typeof(-), Int64, Noth",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2717:371,Load,LoadError,371,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2717,1,['Load'],['LoadError']
Performance,I got good results in the past on discretized PDE problems. The main bottleneck is to perform the sparse triangular solves at each iteration of the Krylov method (`ldiv!`) on GPU but I did some operators in `KrylovPreconditioners.jl` to reuse the analysis of the sparsity pattern as well as the buffers:; - https://github.com/JuliaSmoothOptimizers/KrylovPreconditioners.jl/blob/main/ext/CUDA/operators.jl#L82; - https://github.com/JuliaSmoothOptimizers/KrylovPreconditioners.jl/blob/main/ext/AMDGPU/operators.jl#L103; - https://github.com/JuliaSmoothOptimizers/KrylovPreconditioners.jl/blob/main/ext/oneAPI/operators.jl#L50. We can also apply the same strategy for the ILU(0) preconditioner provided by the GPU vendors.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3789#issuecomment-2374729281:69,bottleneck,bottleneck,69,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3789#issuecomment-2374729281,2,"['bottleneck', 'perform']","['bottleneck', 'perform']"
Performance,"I got it. ```julia; julia> using Oceananigans; Precompiling Oceananigans; 1 dependency successfully precompiled in 11 seconds. 139 already precompiled. julia> grid = RectilinearGrid(size=1, x=(0, 1), topology=(Periodic, Flat, Flat)); 1×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Flat y; └── Flat z. julia> grid = ImmersedBoundaryGrid(grid, GridFittedBoundary(x -> true)); warning: /Users/gregorywagner/.julia/packages/KernelAbstractions/MAxUm/src/cpu.jl:118:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; 1×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo:; ├── immersed_boundary: GridFittedBoundary{Field{Center, Center, Center, Nothing, RectilinearGrid{Float64, Periodic, Flat, Flat, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Nothing, Nothing, CPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Bool, 3, Array{Bool, 3}}, Bool, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, Nothing, Nothing, Nothing, Nothing, BoundaryCondition{Oceananigans.BoundaryConditions.Flux, Nothing}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}}; ├── underlying_grid: 1×1×1 RectilinearGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── Periodic x ∈ [0.0, 1.0) regularly spaced with Δx=1.0; ├── Flat y; └── Flat z. julia> c = CenterField(grid); 1×1×1 Field{Center, Center, Center} on ImmersedBoundaryGrid on CPU; ├── grid: 1×1×1 ImmersedBoundaryGrid{Float64, Periodic, Flat, Flat} on CPU with 1×0×0 halo; ├── boundary conditions: ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2314132900:578,optimiz,optimizer,578,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742#issuecomment-2314132900,2,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"I guess in our terminology ""saving"" is a bit more restricted than ""serializing"". When we ""save"" an object, we do it in a way that might be readable from Python or MATLAB (for example). This means that we only ""save"" common types like numbers, arrays, strings. Anything we output to NetCDF is ""saved"". When we ""serialize"" we might embed a Julia struct in a file. So when we serialize something we can only load it back from Julia. We can only serialize with JLD2.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039401633:405,load,load,405,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2245#issuecomment-1039401633,1,['load'],['load']
Performance,"I have a start to this soon to be PR (I hope) but nothing working yet. . One issue that comes up is that `automatic_halo_sizing.jl` should not extend the halo if the topology is flat This is easy enough to set this up in principle, however, when I try telling it what `Flat` means using the following `using Oceananigans.Grids: Flat`, it fails. . How should I load `Flat` at this stage?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292:360,load,load,360,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1499#issuecomment-803738292,1,['load'],['load']
Performance,"I have been playing with the one_dimensional_diffusion.jl example and have found something a bit odd. When I run it, with everything already installed, it seems to complain about [line18](https://github.com/CliMA/Oceananigans.jl/blob/a343711f1101b1a433124f5f9697ce60b1011a40/examples/one_dimensional_diffusion.jl#L18) with the following error,. ```; ERROR: LoadError: package `Oceananigans [9e8cae18]` has same name or UUID as the active project; ```. Is this expected? . Is this something we want to avoid?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1205:357,Load,LoadError,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1205,1,['Load'],['LoadError']
Performance,"I have been running on the system Julia for these, I attempted to do my own install but I do not think I ended up doing much with it. I believe `gcc` is a dependency for the subsequent modules as for example when I run:; ```; module --force purge; module load ncarenv/23.10 ; module load ncarcompilers/1.0.0; ```; the last line returns ; ```; Lmod has detected the following error: These module(s) or; extension(s) exist but cannot be loaded as requested: ""ncarcompilers/1.0.0""; Try: ""module spider ncarcompilers/1.0.0"" to see how to load the module(s).; ```; which does not happen if I include `gcc`. I was also able to run my code without netcdf!",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846:255,load,load,255,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3655#issuecomment-2258913846,4,['load'],"['load', 'loaded']"
Performance,"I have checked thoroughly _every_ function in the advection module for a `checkbounds()` call and couldn't produce any Bounds error. This is remaining a mystery to me because it seems that the whole advection module elides bounds checking. On the other hand, I found that `main` has the same problem, on the `near_global_quarter_degree.jl` experiment this is the wall time per 10 time steps; (with `--check-bounds=no`, without `--check-bounds=no`); main -> 2.7 / 3.6 s; this PR -> 3.3 / 4.4 s. so there is for sure a problem of performance (which I will try to solve) but it does not seem to be related to bounds checking as; `2.7 / 3.6 = 3.3 / 4.4 = 0.75`. It is a must to find out where these bounds checks are eating up 25% of our computational time (do you know an easy way to profile it?).; By the way @tomchor, is this also the ratio that you find in your simulations (maybe with the latest commit)? If yes, I ll give up trying to inbound and only try to speed up the advection.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186040507:528,perform,performance,528,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2603#issuecomment-1186040507,1,['perform'],['performance']
Performance,"I have continued to retest the 2D turbulence example and now get some loop warnings from several calls with the CPU architecture:; It would be nice to remove these or fix a possible flaw. I am using the latest versions of Julia and Oceananigans as at 5th March 2024. model = NonhydrostaticModel(; grid,; timestepper = :RungeKutta3,; advection = UpwindBiasedFifthOrder(),; closure = ScalarDiffusivity(ν=1e-5)); warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering; warning: C:\Users\kab\.julia\packages\KernelAbstractions\Zcyra\src\extras\loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3494:525,optimiz,optimizer,525,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3494,4,"['optimiz', 'perform']","['optimizer', 'perform']"
Performance,"I have created a new branch called ""ShallowWaterS1waveeqn"". S1 is for step 1. It doesn't do much right now but I'm trying to set up the skeleton so that we can actually do something intereting, like evolve the equation. At the moment I have the following:. 1. Created a ShallowWaterModels folder. 2. Created a ShallowWaterModels.jl module. It doesn't do much except include shallowwater_model.jl. 3. shallowwater_model.jl defines a mutable struct and a function. I couldn't get a lot of things to work but it does regularlize the boundary condtions, set up the velocities and a new variable called layer_depth. The name is not great and can go with depth or height, as people prefer. It will be in in the governing equations. 4. Created an example, in the same folder, called onedim_shallowwater.jl. Currently, this includes the module mentioned above, defines a grid (yes, a single point!), defines the initial conditions and sets the velocity. Questions:. 1. This is pretty bare bones so far but does this follow the philosophy of Oceananigans?. 2. I have tried to inititalze the layer_depth by adding an argument into the set! command but it failed. Below is the command that I thought would work and below is the error because layer_depth is not model.velocities or model.tracers. Can someone help me to see what silliness I am doing?. ```; set!(model, u = u, v = v, layer_deth = layer_depth); fails with ""ERROR: LoadError: ArgumentError: name layer_depth not found in model.velocities or model.tracers."". After I get the initial conditions defined I then need to specify the fluxes for the PDE. That should not be difficult but one issue is the nomenclature. The vector we have now is velocities, but we actually want, velocity transport. I should use and define hu and hv instead of u and v. That should be easy enough, I think.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1188:1417,Load,LoadError,1417,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1188,1,['Load'],['LoadError']
Performance,"I have moved the open fill to nominally be called within `fill_halo_regions!` as the new format (`fill_halo_regions!` and `fill_open_boundary_regions!` both having to be called separately) is confusing. I think a user would expect `fill_halo_regions!` to fill all of the halos. Instead `fill_halo_regions!` has a kwarg `fill_open_boundaries` which is nominally true, and I have set to `false` in the halo fill following the pressure correction. If we didn't do this we would also have needed to add loads of calls to `fill_open_boundary_regions!` in the hydrostatic model code, which would have confused matters.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2150059461:499,load,loads,499,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3482#issuecomment-2150059461,1,['load'],['loads']
Performance,I have never tried benchmarking this. maybe the gain in performance is negligible. I guess it will depend on the number of particles and the size of the grid.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431:56,perform,performance,56,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3356#issuecomment-1775560431,1,['perform'],['performance']
Performance,"I have put together an example for my own benefit (not to be merged into master unless people want it to be) that looks at the simulation of inertial instability in 2D. See [here](https://github.com/CliMA/Oceananigans.jl/blob/fjp/inertia-instability-example/examples/inertially_unstable_jet.jl) for the code. . I believe everything is working on a CPU but I am having two difficulties with GPUs. . 1. In line 39, where I define the background buoyancy of the jet, I can't use `coriolis.f` because CUDA seems to need a global variable and this doesn't cut it. I am presently using `f` instead and this works, but should this work? `ERROR: LoadError: InvalidIRError: compiling kernel gpu__compute!`; 2. When I make a simulation from a gpu calculation, I get that the buoyancy perturbation has perturbations at the top and bottom, which are not physical. Which is to say that it has different boundary conditions. I didn't actually specify the boundary conditions differently but just wanted a solid top and bottom. If I specify the boundary conditions explicitly, should this fix the problem? Maybe that's a fix but is this expected behaviour?. https://user-images.githubusercontent.com/8239041/113899192-8d851900-979a-11eb-97a7-b7f8085864b7.mp4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1554:638,Load,LoadError,638,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1554,1,['Load'],['LoadError']
Performance,"I have some validation scripts already that work on the CPU and indicate that the new closure is working. However, I can't make this work on the GPU. I keep getting this error:. ```; ERROR: LoadError: GPU compilation of MethodInstance for Oceananigans.TurbulenceClosures.gpu__compute_scale_invariant_smagorinsky_viscosity!(::KernelAbstractions.CompilerMetadata{…}, ::OffsetArrays.OffsetArray{…}, ::Field{…}, ::Field{…}, ::RectilinearGrid{…}, ::ScaleInvariantSmagorinsky{…}, ::Nothing, ::@NamedTuple{…}, ::@NamedTuple{}) failed; KernelError: passing and using non-bitstype argument. Argument 7 to your kernel function is of type ScaleInvariantSmagorinsky{Oceananigans.TurbulenceClosures.ExplicitTimeDiscretization, Oceananigans.TurbulenceClosures.DirectionalAveraging{Tuple{Int64, Int64}}, Float64, @NamedTuple{}, Integer}, which is not isbits:; .update_frequency is of type Integer which is not isbits.; ```. Reading up on the CUDA.jl docs I _think_ I understand where this error comes from (although I thought `update_frequency`, which is an `Integer`, should work, but it throws an error). Still couldn't figure out how to fix it in this case here. I assume it's not hard to fix though, so I was wondering if someone (I'm assuming @simone-silvestri or @glwagner) can please give me a hand or at least point me in the right direction?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2294992357:190,Load,LoadError,190,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3642#issuecomment-2294992357,1,['Load'],['LoadError']
Performance,I haven't looked at performance / GPU compilation in detail. I do think there is a type inference issue somewhere in this PR now because the flow over hills experiment is 7-8x slower on my laptop even without any immersed boundary condition. This likely indicates a problem with type inference in the flux divergence function (might also prevent GPU compilation). So we'll have to solve that and also add tests for CPU + GPU...,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751806:20,perform,performance,20,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2437#issuecomment-1100751806,1,['perform'],['performance']
Performance,"I hit these issues when setting a field on an immersed boundary grid.; ```; ERROR: LoadError: MethodError: no method matching ξname(::ImmersedBoundaryGrid{Float64, Periodic, RightConnected, Bounded, OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, GPU}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, OrthogonalSphericalShellGrid{Float64, Periodic, RightConnected, Bounded, OffsetArrays.OffsetMatrix{Float64, CUDA.CuArray{Float64, 2, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OffsetArrays.OffsetVector{Float64, CUDA.CuArray{Float64, 1, CUDA.DeviceMemory}}, OrthogonalSphericalShellGrids.Tripolar{Int64, Int64, Int64}, GPU}, Tuple{Colon, Colon, Colon}, OffsetArrays.OffsetArray{Float64, 3, CUDA.CuArray{Float64, 3, CUDA.DeviceMemory}}, Float64, FieldBoundaryConditions{BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Oceananigans.BoundaryConditions.Periodic, Nothing}, BoundaryCondition{Flux, Nothing}, BoundaryCondition{OrthogonalSphericalShellGrids.Zipper, Int64}, Nothing, Nothing, Oceananigans.BoundaryConditions.DefaultBoundaryCondition{BoundaryCondition{Flux, Nothing}}}, Nothing, Oceananigans.Fields.FieldBoundaryBuffers{Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}}, Oceananigans.ImmersedBoundaries.CenterImmersedCondition}, CUDA.CuArray{Tuple{UInt16, UInt16, UInt16}, 1, CUDA.DeviceMemory}, CUDA.CuArray{Tuple{UInt16, UInt16}, 1, CUDA.DeviceMemory}, GPU}). Closest candidates are:; ξname(!Matched::LatitudeLongitudeGrid); @ Oceananigans ~/.julia/packages/Oceananigans/O8Ult/src/Grids/latitude_longitude_grid.jl:574; ξname(!Match",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3742:83,Load,LoadError,83,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3742,1,['Load'],['LoadError']
Performance,"I implemented a simple new validation test that runs a two-dimensional barotropic turbulence problem with `ExplicitFreeSurface`: https://github.com/CliMA/Oceananigans.jl/blob/ss/multi_region/validation/multi_region/multi_region_turbulence.jl. Here's some miscellaneous notes:. * `WENO5(vector_invariant=VelocityStencil())` is faster than `WENO5()`. Note that when we write ""WENO5(vector_invariant=stencil)"" we mean that we are using the vector invariant formulation of momentum with a WENO reconstruction for vorticity, using either ""velocity"" or ""vorticity"" in the WENO smoothness metric. The ""WENO, Vector Invariant"" scheme is probably faster because it has fewer WENO interpolations (just one per momentum component rather than 2).; * `WENO5(vector_invariant=VelocityStencil())` blows up with `MultiRegionGrid`. Some timings:. | Resolution | Grid | Advection scheme | Wall time for 1000 time steps |; | ------------- | ------------- | -- | -- |; | 128^2 | `RegularRectilinearGrid` | `WENO5()` | 3.9 s |; | 128^2 | `MultiRegionGrid` | `WENO5()` | 7.4 s |; | 128^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 2.8 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5()` | 14.3 s |; | 256^2 | `MultiRegionGrid ` | `WENO5()` | 18.9 s |; | 256^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 10.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5()` | 56.3 s |; | 512^2 | `MultiRegionGrid ` | `WENO5()` | 62.3 s |; | 512^2 | `RegularRectilinearGrid` | `WENO5(vector_invariant=VelocityStencil())` | 40.3 s |. I propose that we. 1) Close the gap between multi-region and single-region performance?; 2) Understand why WENO vector invariant blows up on a multi region grid.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730:1635,perform,performance,1635,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2253#issuecomment-1107942730,2,['perform'],['performance']
Performance,"I just noticed that the Nusselt number calculation result in the horizontal convection example changed between v0.71.6 and v0.72.4. It almost doubled from around 10 at. https://clima.github.io/OceananigansDocumentation/v0.71.6/generated/horizontal_convection/#Load-saved-output,-process,-visualize. to around 20 in . https://clima.github.io/OceananigansDocumentation/v0.72.4/generated/horizontal_convection/#Load-saved-output,-process,-visualize. The calculation is done via. ```Julia; χ_diff = κ * b★^2 * π * tanh(2π * H / Lx). for i = 1:length(t); b = b_timeseries[i]; sum!(∫ⱽ_mod²_∇b, (∂x(b)^2 + ∂z(b)^2) * volume); Nu[i] = (κ * ∫ⱽ_mod²_∇b[1, 1, 1]) / χ_diff; end; ```. Did anything changed between these two version in the way `sum!` or `volume` works?. Here's the diff between v0.71.6 and v0.72.4: https://github.com/CliMA/Oceananigans.jl/compare/v0.71.6...v0.72.4",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2735:260,Load,Load-saved-output,260,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2735,2,['Load'],['Load-saved-output']
Performance,I just noticed:. https://buildkite.com/clima/oceananigans/builds/11955#018909c3-4c60-4b9c-b4e2-c6260d8b2189/40-2662. ```; [ Info: shallow_water_Bickley_jet.jl example took 28.452 minutes to build.; ```. We should optimize that or make it run first!,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1613995023:213,optimiz,optimize,213,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3151#issuecomment-1613995023,1,['optimiz'],['optimize']
Performance,"I just pushed changes for the geostrophic adjustment case. The code seems alright, but it returns the following warning:. `warning: ~/.julia/packages/KernelAbstractions/GCOhX/src/extras/loopinfo.jl:28:0: loop not unrolled: the optimizer was unable to perform the requested transformation; the transformation might be disabled or specified as part of an unsupported transformation ordering`. Then it returns the following error:. <details>; <summary>Error output:</summary>. ```; ERROR: ERROR: LoadError: ERROR: LoadError: LoadError: ERROR: LoadError: MethodError: no method matching MethodError: no method matching MethodError: iterate(::SplitExplicitFreeSurface{Field{Center, Center, Face, Nothing, ImmersedBoundaryGrid{Float64, FullyConnected, Periodic, Bounded, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, Distributed{CPU, false, Partition{Int64, Int64, Int64}, Tuple{Int64, Int64, Int64}, Int64, Tuple{Int64, Int64, Int64}, Oceananigans.DistributedComputations.RankConnectivity{Int64, Int64, Nothing, Nothing, Nothing, Nothing, Nothing, Nothing}, MPI.Comm, Vector{MPI.Request}, Base.RefValue{Int64}}}, GridFittedBottom{Field{Center, Center, Nothing, Nothing, RectilinearGrid{Float64, FullyConnected, Periodic, Bounded, Float64, Float64, Float64, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}, OffsetArrays.OffsetVector{Float64, StepRangeLen{Float64, Base.TwicePrecision{F",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212:227,optimiz,optimizer,227,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3429#issuecomment-1892087212,6,"['Load', 'optimiz', 'perform']","['LoadError', 'optimizer', 'perform']"
Performance,"I just tried running `validation/periodic_advection.jl` and see that it can't find WENO, which is I think because we removed the N-th order WENO code. Is it better to change it to WENO5 for the moment, since that's what we have?. ```; julia> include(""periodic_advection.jl""); [ Info: Precompiling Oceananigans [9e8cae18-63c1-5223-a75c-80ca9d6e9a09]; ERROR: LoadError: UndefVarError: WENO not defined; Stacktrace:; [1] top-level scope at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; [2] include(::String) at ./client.jl:457; [3] top-level scope at REPL[1]:1; in expression starting at /home/fpoulin/software/Oceananigans.jl/validation/periodic_advection/periodic_advection.jl:55; ```",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1271:357,Load,LoadError,357,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1271,1,['Load'],['LoadError']
Performance,"I just updated my packages and now I get an error .... UndefVarError: RectilinearGrid not defined; Stacktrace:; [1] top-level scope; @ In[8]:18; [2] eval; @ .\boot.jl:360 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base .\loading.jl:1116. ....with even the simples grid-defenition, e.g. ; ```; Nz = 24 # number of points in the vertical direction; Lz = 32 # domain depth; grid = RectilinearGrid(size = (32, 32, Nz),; x = (0, 64),; y = (0, 64),; z = (-64, 0)); ```; What am I doing wrong?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2077:289,load,loading,289,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2077,1,['load'],['loading']
Performance,"I just want to point out that this involves an extra memory fetch so it might affect performance, probably very negligibly and maybe the compiler is smart enough to elide the extra node call, but it is an extra operation nonetheless.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3074#issuecomment-1516299701:85,perform,performance,85,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3074#issuecomment-1516299701,1,['perform'],['performance']
Performance,"I looked at one of the errors and saw the message below. I think this means we need to restart the tests. ```; ERROR: LoadError: LoadError: SystemError: opening file ""/data5/glwagner/.julia-8057/compiled/v1.6/Oceananigans/hU93i_xHskz.ji"": No such file or directory;  ```",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246:118,Load,LoadError,118,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2645#issuecomment-1178207246,2,['Load'],['LoadError']
Performance,"I looked through the package and it seems like things are already in CuArrays then. https://github.com/climate-machine/Oceananigans.jl/blob/master/src/time_steppers.jl#L42-L78. this should quite readily port over to using DifferentialEquations.jl. It looks like you're using an IMEXEuler scheme? I think there would be some pretty good performance gains, and it would be interesting to start being able to use this entire package as a benchmark.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/391:336,perform,performance,336,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/391,1,['perform'],['performance']
Performance,"I mean, we can move the docs to the caltech cluster but I think they will slow down a lot. This is a bottleneck for us right now so I don't think we can afford to move them... Notice that the out of memory error doesn't occur when we are using the GPU. We only use the GPU for the one quick start example --- and for nothing else. If we want to ""solve"" this, we can just get rid of the quick start example and then return to the previous behavior where we set `CUDA_VISIBLE_DEVICES=-1` for the docs build. Another solution is to hide / prevent tartarus users from using GPU 0.",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356553645:101,bottleneck,bottleneck,101,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/3779#issuecomment-2356553645,1,['bottleneck'],['bottleneck']
Performance,"I noticed ""On the other hand, a Z-WENO formulation is *always* beneficial (also in case of a uniform mesh) with no major; decrease in performance."". Why don't we then change `zweno = true`?",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976013319:134,perform,performance,134,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/2060#issuecomment-976013319,1,['perform'],['performance']
Performance,"I noticed that some issues with buildkite have to do with needing to re-resolve the Manifest, so this is yet another attempt to fix the race condition in our CI...",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/3783:136,race condition,race condition,136,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/3783,1,['race condition'],['race condition']
Performance,"I often run Oceananigans on a cluster at my university that has a few nodes with IBM Power9. Since very few people use these nodes, it is a big advantage to be able to run Oceananigans there because they will almost always have the GPUs available. Almost everything seems to run as expected, but I cannot use `NetCDFOutputWriter`. I really prefer saving the output in NC files because this is more easily used by other programming languages. ```; UndefVarError: NetCDFOutputWriter not defined. Stacktrace:; [1] top-level scope; @ :0; [2] eval; @ ./boot.jl:368 [inlined]; [3] include_string(mapexpr::typeof(REPL.softscope), mod::Module, code::String, filename::String); @ Base ./loading.jl:1428; ```. I noticed that if I try to `using NCDatasets`, it returns. ```; ERROR: InitError: UndefVarError: libnetcdf not defined; Stacktrace:; [1] nc_inq_libvers; @ ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:242 [inlined]; [2] netcdf_version(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2157; [3] init_certificate_authority(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/netcdf_c.jl:2170; [4] __init__(); @ NCDatasets ~/.julia/packages/NCDatasets/h1epE/src/NCDatasets.jl:33; [5] _include_from_serialized(pkg::Base.PkgId, path::String, depmods::Vector{Any}); @ Base ./loading.jl:831; [6] _require_search_from_serialized(pkg::Base.PkgId, sourcepath::String, build_id::UInt64); @ Base ./loading.jl:1039; [7] _require(pkg::Base.PkgId); @ Base ./loading.jl:1315; [8] _require_prelocked(uuidkey::Base.PkgId); @ Base ./loading.jl:1200; [9] macro expansion; @ ./loading.jl:1180 [inlined]; [10] macro expansion; @ ./lock.jl:223 [inlined]; [11] require(into::Module, mod::Symbol); @ Base ./loading.jl:1144; during initialization of module NCDatasets; ```. It looks like the problem is because `NCDatasets` needs `NetCDF_jll`, which is not available for Power9.; https://github.com/JuliaBinaryWrappers/NetCDF_jll.jl#platforms. Any way to work around this?; Maybe using `NetCDF.jl`?",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2840:678,load,loading,678,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2840,7,['load'],['loading']
Performance,"I opened a wiki for Oceananigans:. https://github.com/CliMA/Oceananigans.jl/wiki. I think we should use the wiki to host practical information and tips for using Oceananigans on various hardware (laptops, CPUs, GPUs), clusters / high-performance computing system (HPCs), and more. Using the wiki this way will allow us to focus the docs on code and numerics, and alleviate the need to submit PRs to update details about using clusters. We need to provide an introduction to Oceananigans ""knowledge base"" (where to find useful information in the documentation, wiki, Github Discussions, and Github Issues) in the README, the docs, and the wiki.",MatchSource.ISSUE,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/2470:234,perform,performance,234,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/2470,1,['perform'],['performance']
Performance,I opened an issue about the `Int128`/`UInt128` segfault (https://github.com/JuliaGPU/CUDA.jl/issues/793) but will revisit this PR later to look into the performance regression.,MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809568648:153,perform,performance,153,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1514#issuecomment-809568648,1,['perform'],['performance']
Performance,"I ran the `benchmark_incompressible_model.jl` script on the master branch (twice) and this branch (also twice), and ; actually see a tiny bit of a speedup, maybe only significant for larger CPU models though. Hard to say whether it's noise, it might be more due to other processes causing small variations in runtime. To me I don't think this PR slows down or speeds up the code, but it simplifies and improves the time stepping code so it should be merged. There's a few more memory allocations now (due to extra kernel launches) but this shouldn't affect performance. # System info. ```; Oceananigans v0.44.1; Julia Version 1.5.2; Commit 539f3ce943 (2020-09-23 23:17 UTC); Platform Info:; OS: Linux (x86_64-pc-linux-gnu); CPU: Intel(R) Xeon(R) Silver 4214 CPU @ 2.20GHz; WORD_SIZE: 64; LIBM: libopenlibm; LLVM: libLLVM-9.0.1 (ORCJIT, cascadelake); GPU: TITAN V; ```. # Master branch; ```; Incompressible model benchmarks; ┌───────────────┬─────────────┬─────┬────────────┬────────────┬────────────┬────────────┬────────────┬────────┐; │ Architectures │ Float_types │ Ns │ min │ median │ mean │ max │ memory │ allocs │; ├───────────────┼─────────────┼─────┼────────────┼────────────┼────────────┼────────────┼────────────┼────────┤; │ CPU │ Float32 │ 32 │ 5.399 ms │ 5.668 ms │ 5.758 ms │ 7.186 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 64 │ 36.710 ms │ 37.583 ms │ 37.974 ms │ 41.678 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 128 │ 312.780 ms │ 313.477 ms │ 313.622 ms │ 314.726 ms │ 242.42 KiB │ 1876 │; │ CPU │ Float32 │ 256 │ 2.802 s │ 2.819 s │ 2.819 s │ 2.836 s │ 242.42 KiB │ 1876 │; │ CPU │ Float64 │ 32 │ 5.828 ms │ 6.049 ms │ 6.157 ms │ 7.044 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 64 │ 43.084 ms │ 43.619 ms │ 43.650 ms │ 44.363 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 128 │ 365.051 ms │ 365.317 ms │ 365.475 ms │ 366.288 ms │ 293.44 KiB │ 1876 │; │ CPU │ Float64 │ 256 │ 3.602 s │ 3.653 s │ 3.653 s │ 3.703 s │ 293.44 KiB │ 1876 │; │ GPU │ Float32 │ 32 │ 2.797 ms │ 2.870 ms ",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736692263:557,perform,performance,557,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/pull/1210#issuecomment-736692263,1,['perform'],['performance']
Performance,"I ran the advection scheme benchmarks and comparing with some older Julia 1.5 results it definitely is slower on the GPU. WENO5 used to only be ~3x slower than CenteredSecondOrder, but now it's 26x slower. All other advection schemes are just as fast as they used to be. Not slow enough to be CUDA scalar operations so maybe the GPU compiler changed in some way that kernels calling/using WENO5 are compiling into suboptimal machine code?. @maleadt might have some ideas/suggestions but maybe we just have to profile and find the new bottleneck?. ---. ```; Advection schemes relative performance (GPU); ┌───────────────┬────────────────────────┬──────────┬─────────┬─────────┐; │ Architectures │ Schemes │ slowdown │ memory │ allocs │; ├───────────────┼────────────────────────┼──────────┼─────────┼─────────┤; │ GPU │ CenteredFourthOrder │ 1.38356 │ 1.05911 │ 1.60067 │; │ GPU │ CenteredSecondOrder │ 1.0 │ 1.0 │ 1.0 │; │ GPU │ UpwindBiasedFifthOrder │ 1.53145 │ 1.0868 │ 1.88203 │; │ GPU │ UpwindBiasedThirdOrder │ 1.30611 │ 1.04135 │ 1.42012 │; │ GPU │ WENO5 │ 26.1429 │ 4.68526 │ 38.4468 │; └───────────────┴────────────────────────┴──────────┴─────────┴─────────┘; ```. Compare with: https://github.com/CliMA/Oceananigans.jl/pull/1169#issuecomment-725471594",MatchSource.ISSUE_COMMENT,CliMA,Oceananigans.jl,v0.93.2,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868093699:534,bottleneck,bottleneck,534,https://clima.github.io/OceananigansDocumentation/stable,https://github.com/CliMA/Oceananigans.jl/issues/1764#issuecomment-868093699,2,"['bottleneck', 'perform']","['bottleneck', 'performance']"
