quality_attribute,sentence,source,author,repo,version,id,keyword,matched_word,match_idx,filename,wiki,url,total_similar,target_keywords,target_matched_words
Performance,"reated; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. NOTE: the action specifies how to behave when detaching a cache from the; the TFile. If set to (default) kDisconnect, the contents of the cache; will be flushed when it is removed from the file, and it will disconnect; the cache object from the file. In almost all cases, this is what you want.; If you want to disconnect the cache temporarily from this tree and re-attach; later to the same fil, you can set action to kDoNotDisconnect. This will allow; things like prefetching to continue in the background while it is no longer the; default cache for the TTree. Except for a few expert use cases, kDisconnect is; likely the correct setting. WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& ); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFile.html:40504,cache,cache,40504,root/html534/TFile.html,https://root.cern,https://root.cern/root/html534/TFile.html,2,['cache'],['cache']
Performance,"recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsSelfCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill cache with sampling of p.d.f as defined by the evaluate() implementation. RooArgSet* actualObservables(const RooArgSet& nset) const; Defines observables to be cached, given a set of user defined observables; Returns the subset of nset that are observables this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Defines parameters on which cache contents depends. Returns; subset of variables of self that is not contained in the; supplied nset. const char* inputBaseName() const; Use own name as base name for caches. » Last changed: Mon Dec 7 13:45:48 2009 » Last generated: 2009-12-07 13:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedPdf.html:41519,cache,cache,41519,root/html526/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedPdf.html,5,['cache'],"['cache', 'cached', 'caches']"
Performance,"recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsSelfCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill cache with sampling of p.d.f as defined by the evaluate() implementation. RooArgSet* actualObservables(const RooArgSet& nset) const; Defines observables to be cached, given a set of user defined observables; Returns the subset of nset that are observables this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Defines parameters on which cache contents depends. Returns; subset of variables of self that is not contained in the; supplied nset. const char* inputBaseName() const; Use own name as base name for caches. » Last changed: Mon Jul 4 15:21:30 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsSelfCachedPdf.html:42620,cache,cache,42620,root/html530/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsSelfCachedPdf.html,5,['cache'],"['cache', 'cached', 'caches']"
Performance,"recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsSelfCachedPdf(); Destructor. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill cache with sampling of p.d.f as defined by the evaluate() implementation. RooArgSet* actualObservables(const RooArgSet& nset) const; Defines observables to be cached, given a set of user defined observables; Returns the subset of nset that are observables this p.d.f. RooArgSet* actualParameters(const RooArgSet& nset) const; Defines parameters on which cache contents depends. Returns; subset of variables of self that is not contained in the; supplied nset. const char* inputBaseName() const; Use own name as base name for caches. » Last changed: Thu Nov 3 20:06:49 2011 » Last generated: 2011-11-03 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedPdf.html:43027,cache,cache,43027,root/html532/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedPdf.html,5,['cache'],"['cache', 'cached', 'caches']"
Performance,"recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsPdf(); Default constructor. RooAbsPdf(const char* name, const char* title = 0); Constructor with name and title only. RooAbsPdf(const char* name, const char* title, Double_t minVal, Double_t maxVal); Constructor with name, title, and plot range. RooAbsPdf(const RooAbsPdf& other, const char* name = 0); Copy constructor. ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:48465,cache,cached,48465,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,12,['cache'],"['cache', 'cached']"
Performance,"reco.Define(""weight"", ""{}"".format(weight_bkg_4el))\; .Histo1D((""h_bkg_4el"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; df_data_4el_reco = reco_higgs_to_4el(df_data_doubleel); ; df_h_data_4el = df_data_4el_reco.Define(""weight"", ""1.0"")\; .Histo1D((""h_data_4el"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; # Reconstruct Higgs to 2 electrons and 2 muons; df_sig_2el2mu_reco = reco_higgs_to_2el2mu(df_sig_4l); ; df_h_sig_2el2mu = df_sig_2el2mu_reco.Define(""weight"", ""{}"".format(weight_sig_2el2mu))\; .Histo1D((""h_sig_2el2mu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; df_bkg_2el2mu_reco = reco_higgs_to_2el2mu(df_bkg_2el2mu); ; df_h_bkg_2el2mu = df_bkg_2el2mu_reco.Define(""weight"", ""{}"".format(weight_bkg_2el2mu))\; .Histo1D((""h_bkg_2el2mu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; df_data_2el2mu_reco = reco_higgs_to_2el2mu(df_data_doublemu); ; df_h_data_2el2mu = df_data_2el2mu_reco.Define(""weight"", ""1.0"")\; .Histo1D((""h_data_2el2mu_doublemu"", """", nbins, 70, 180), ""H_mass"", ""weight""); ; # RunGraphs allows to run the event loops of the separate RDataFrame graphs; # concurrently. This results in an improved usage of the available resources; # if each separate RDataFrame can not utilize all available resources, e.g.,; # because not enough data is available.; ROOT.RDF.RunGraphs([df_h_sig_4mu, df_h_bkg_4mu, df_h_data_4mu,; df_h_sig_4el, df_h_bkg_4el, df_h_data_4el,; df_h_sig_2el2mu, df_h_bkg_2el2mu, df_h_data_2el2mu]); ; # Get histograms (does not rerun the event loop); signal_4mu = df_h_sig_4mu.GetValue(); background_4mu = df_h_bkg_4mu.GetValue(); data_4mu = df_h_data_4mu.GetValue(); ; signal_4el = df_h_sig_4el.GetValue(); background_4el = df_h_bkg_4el.GetValue(); data_4el = df_h_data_4el.GetValue(); ; signal_2el2mu = df_h_sig_2el2mu.GetValue(); background_2el2mu = df_h_bkg_2el2mu.GetValue(); data_2el2mu = df_h_data_2el2mu.GetValue(); ; # Make plots; plot(signal_4mu, background_4mu, data_4mu, ""m_{4#mu} (GeV)"", ""higgs_4mu.pdf""); plot(signal_4el, background_4el, data_4el, ""m_{4e} ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html:14969,concurren,concurrently,14969,doc/master/df103__NanoAODHiggsAnalysis_8py.html,https://root.cern,https://root.cern/doc/master/df103__NanoAODHiggsAnalysis_8py.html,1,['concurren'],['concurrently']
Performance,rect pointers to individual branch leaves; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tfTypeRWN (0) or CWN (1); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); char*fXstorage area for RWN; Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static Int_tTTree::fgBranchStyleOld/New branch,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/THbookTree.html:24370,load,loading,24370,root/html530/THbookTree.html,https://root.cern,https://root.cern/root/html530/THbookTree.html,3,['load'],['loading']
Performance,"rectory hierarchies. More...;  ; class  TFileCacheRead;  A cache when reading files over the network. More...;  ; class  TFileCacheWrite;  A cache when writing files over the network. More...;  ; class  TFileMerger;  This class provides file copy and merging services. More...;  ; class  TFileOpenHandle;  Class holding info about the file being opened. More...;  ; class  TFilePrefetch;  The prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries. More...;  ; class  TFPBlock;  This class represents the encapsulation of a block request. More...;  ; class  TFree;  Service class for TFile. More...;  ; class  TGenCollectionProxy;  Proxy around an arbitrary container, which implements basic functionality and iteration. More...;  ; class  TGenMapProxy;  Localoptimization class. More...;  ; class  TGenSetProxy;  Localoptimization class. More...;  ; class  TGenVectorBoolProxy;  Local optimization class. More...;  ; class  TGenVectorProxy;  Local optimization class. More...;  ; class  TKey;  Book space in a file, create I/O buffers, to fill them, (un)compress them. More...;  ; class  TKeyMapFile;  Utility class for browsing TMapFile objects. More...;  ; class  TKeySQL;  TKeySQL represents meta-information about object, which was written to SQL database. More...;  ; class  TLockFile;  A scoped lock based on files. More...;  ; class  TMapFile;  This class implements a shared memory region mapped to a file. More...;  ; class  TMapRec;  Keep track of an object in the mapped file. More...;  ; class  TMemFile;  A TMemFile is like a normal TFile except that it reads and writes only from memory. More...;  ; class  TNetFile;  A TNetFile is like a normal TFile except that it reads and writes its data via a rootd server (for more on the rootd daemon see the source files in root/rootd/src/). More...;  ; class  TS3WebFile;  A TS3WebFile is a TWebFile which retrieves the file contents from a web server implementing the REST API of th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__IO.html:4663,optimiz,optimization,4663,doc/master/group__IO.html,https://root.cern,https://root.cern/doc/master/group__IO.html,1,['optimiz'],['optimization']
Performance,"rectory) {; 7016 LoadBaskets(2*fTotBytes);; 7017 SetDirectory(nullptr);; 7018 return true;; 7019 }; 7020 if (newdirectory->GetFile() == GetCurrentFile()) {; 7021 SetDirectory(newdirectory);; 7022 return true;; 7023 }; 7024 TTreeCloner cloner(this, newdirectory, options);; 7025 if (cloner.IsValid()); 7026 return cloner.Exec();; 7027 else; 7028 return false;; 7029}; 7030 ; 7031////////////////////////////////////////////////////////////////////////////////; 7032/// Function called when loading a new class library.; 7033 ; 7034bool TTree::Notify(); 7035{; 7036 TIter next(GetListOfLeaves());; 7037 TLeaf* leaf = nullptr;; 7038 while ((leaf = (TLeaf*) next())) {; 7039 leaf->Notify();; 7040 leaf->GetBranch()->Notify();; 7041 }; 7042 return true;; 7043}; 7044 ; 7045////////////////////////////////////////////////////////////////////////////////; 7046/// This function may be called after having filled some entries in a Tree.; 7047/// Using the information in the existing branch buffers, it will reassign; 7048/// new branch buffer sizes to optimize time and memory.; 7049///; 7050/// The function computes the best values for branch buffer sizes such that; 7051/// the total buffer sizes is less than maxMemory and nearby entries written; 7052/// at the same time.; 7053/// In case the branch compression factor for the data written so far is less; 7054/// than compMin, the compression is disabled.; 7055///; 7056/// if option =""d"" an analysis report is printed.; 7057 ; 7058void TTree::OptimizeBaskets(ULong64_t maxMemory, Float_t minComp, Option_t *option); 7059{; 7060 //Flush existing baskets if the file is writable; 7061 if (this->GetDirectory()->IsWritable()) this->FlushBasketsImpl();; 7062 ; 7063 TString opt( option );; 7064 opt.ToLower();; 7065 bool pDebug = opt.Contains(""d"");; 7066 TObjArray *leaves = this->GetListOfLeaves();; 7067 Int_t nleaves = leaves->GetEntries();; 7068 Double_t treeSize = (Double_t)this->GetTotBytes();; 7069 ; 7070 if (nleaves == 0 || treeSize == 0) {; 7",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:275633,optimiz,optimize,275633,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['optimiz'],['optimize']
Performance,"rectoryStatus()=true); or will not be added to any directory if AddDirectoryStatus()=false; independently of the current directory stored in the original histogram. TObject* Clone(const char* newname = 0) const; Make a complete copy of the underlying object. If 'newname' is set,; the copy's name will be set to that name. void DirectoryAutoAdd(TDirectory* ); Perform the automatic addition of the histogram to the given directory. Note this function is called in place when the semantic requires; this object to be added to a directory (I.e. when being read from; a TKey or being Cloned). Int_t DistancetoPrimitive(Int_t px, Int_t py); Compute distance from point px,py to a line. Compute the closest distance of approach from point px,py to elements; of an histogram.; The distance is computed in pixels units. Algorithm:; Currently, this simple model computes the distance from the mouse; to the histogram contour only. Bool_t Divide(TF1* f1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); if errors are defined (see TH1::Sumw2), errors are also recalculated. Only bins inside the function range are recomputed.; IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Divide. The function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1); Divide this histogram by h1. this = this/h1; if errors are defined (see TH1::Sumw2), errors are also recalculated.; Note that if h1 has Sumw2 set, Sumw2 is automatically called for this; if not already set.; The resulting errors are calculated assuming uncorrelated histograms.; See the other TH1::Divide that gives the possibility to optionally; compute binomial errors. IMPORTANT NOTE: If you intend to use the errors of this histogram later; you should call Sumw2 before making this operation.; This is particularly important if you fit the histogram after TH1::Scale. The fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TH1.html:63614,Perform,Performs,63614,root/html604/TH1.html,https://root.cern,https://root.cern/root/html604/TH1.html,1,['Perform'],['Performs']
Performance,"recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const; const RooAbsReal&xF().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMoment.html:24675,cache,cache,24675,root/html528/RooMoment.html,https://root.cern,https://root.cern/root/html528/RooMoment.html,2,['cache'],['cache']
Performance,"recursion ;  ; TList * fFriends;  pointer to list of friend elements ;  ; bool fIMTEnabled;  ! true if implicit multi-threading is enabled for this tree ;  ; TArrayI fIndex;  Index of sorted values. ;  ; TArrayD fIndexValues;  Sorted index values. ;  ; TIOFeatures fIOFeatures {0};  IO features to define for newly-written baskets and branches. ;  ; TObjArray fLeaves;  Direct pointers to individual branch leaves. ;  ; Int_t fMakeClass;  ! not zero when processing code generated by MakeClass ;  ; Int_t fMaxClusterRange;  ! Memory allocated for the cluster range. ;  ; Long64_t fMaxEntries;  Maximum number of entries in case of circular buffers. ;  ; Long64_t fMaxEntryLoop;  Maximum number of entries to process. ;  ; Long64_t fMaxVirtualSize;  Maximum total size of buffers kept in memory. ;  ; Int_t fNClusterRange;  Number of Cluster range in addition to the one defined by 'AutoFlush'. ;  ; UInt_t fNEntriesSinceSorting;  ! Number of entries processed since the last re-sorting of branches ;  ; Int_t fNfill;  ! Local for EntryLoop ;  ; TObject * fNotify;  Object to be notified when loading a Tree. ;  ; Int_t fPacketSize;  ! Number of entries in one packet for parallel root ;  ; TVirtualPerfStats * fPerfStats;  ! pointer to the current perf stats object ;  ; TVirtualTreePlayer * fPlayer;  ! Pointer to current Tree player ;  ; Long64_t fReadEntry;  ! Number of the entry being processed ;  ; Long64_t fSavedBytes;  Number of autosaved bytes. ;  ; Int_t fScanField;  Number of runs before prompting in Scan. ;  ; std::vector< TBranch * > fSeqBranches;  ! Branches to be processed sequentially when IMT is on ;  ; std::vector< std::pair< Long64_t, TBranch * > > fSortedBranches;  ! Branches to be processed in parallel when IMT is on, sorted by average task time ;  ; Float_t fTargetMemoryRatio {1.1f};  ! Ratio for memory usage in uncompressed buffers versus actual occupancy. ;  ; Int_t fTimerInterval;  Timer interval in milliseconds. ;  ; std::atomic< Long64_t > fTotalBuffers;  ! Tota",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:49625,load,loading,49625,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,9,['load'],['loading']
Performance,"recursive graph traversal. More...;  ; class  Roo1DTable;  One-dimensional table. More...;  ; class  RooAbsAnaConvPdf;  Base class for PDFs that represent a physics model that can be analytically convolved with a resolution model. More...;  ; class  RooAbsArg;  Common abstract base class for objects that represent a value and a ""shape"" in RooFit. More...;  ; class  RooAbsBinning;  Abstract base class for RooRealVar binning definitions. More...;  ; class  RooAbsCache;  Abstract base class for data members of RooAbsArgs that cache other (composite) RooAbsArg expressions. More...;  ; class  RooAbsCachedPdf;  Abstract base class for p.d.f.s that need or want to cache their evaluate() output in a RooHistPdf defined in terms of the used observables. More...;  ; class  RooAbsCachedReal;  Abstract base class for functions that need or want to cache their evaluate() output in a RooHistFunc defined in terms of the used observables. More...;  ; class  RooAbsCacheElement;  Abstract base class for objects to be stored in RooAbsCache cache manager objects. More...;  ; class  RooAbsCategory;  A space to attach TBranches. More...;  ; class  RooAbsCategoryLValue;  Abstract base class for objects that represent a discrete value that can be set from the outside, i.e. More...;  ; class  RooAbsCollection;  Abstract container object that can hold multiple RooAbsArg objects. More...;  ; class  RooAbsData;  Abstract base class for binned and unbinned datasets. More...;  ; class  RooAbsDataStore;  Abstract base class for a data collection. More...;  ; class  RooAbsFunc;  Abstract interface for evaluating a real-valued function of one real variable and performing numerical algorithms on it. More...;  ; class  RooAbsGenContext;  Abstract base class for generator contexts of RooAbsPdf objects. More...;  ; class  RooAbsHiddenReal;  Base class for objects that want to hide their return value from interactive use, e.g. More...;  ; class  RooAbsIntegrator;  Abstract interface for integrators of rea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Roofitcore.html:1342,cache,cache,1342,doc/master/group__Roofitcore.html,https://root.cern,https://root.cern/doc/master/group__Roofitcore.html,1,['cache'],['cache']
Performance,"red signal and the others considered background. This is ok in binary classification but in in multi class classification, the ROC surface is an N dimensional shape, where N is number of classes - 1. ; Definition at line 932 of file Factory.cxx. ◆ GetROCCurve() [4/4]. TCanvas * TMVA::Factory::GetROCCurve ; (; TString ; datasetname, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). Draws ROC curves for all methods booked with the factory for a given class. ; Argument iClass specifies the class to generate the ROC curve in a multiclass setting. It is ignored for binary classification.; NOTE: The ROC curve is 1 vs. all where the given class is considered signal and the others considered background. This is ok in binary classification but in in multi class classification, the ROC surface is an N dimensional shape, where N is number of classes - 1. ; Definition at line 1077 of file Factory.cxx. ◆ GetROCCurveAsMultiGraph() [1/2]. TMultiGraph * TMVA::Factory::GetROCCurveAsMultiGraph ; (; DataLoader * ; loader, . UInt_t ; iClass, . Types::ETreeType ; type = Types::kTesting . ). Generate a collection of graphs, for all methods for a given class. ; Suitable for comparing method performance.; Argument iClass specifies the class to generate the ROC curve in a multiclass setting. It is ignored for binary classification.; NOTE: The ROC curve is 1 vs. all where the given class is considered signal and the others considered background. This is ok in binary classification but in in multi class classification, the ROC surface is an N dimensional shape, where N is number of classes - 1. ; Definition at line 988 of file Factory.cxx. ◆ GetROCCurveAsMultiGraph() [2/2]. TMultiGraph * TMVA::Factory::GetROCCurveAsMultiGraph ; (; TString ; datasetname, . UInt_t ; iClass, . Types::ETreeType ; type = Types::kTesting . ). Generate a collection of graphs, for all methods for a given class. ; Suitable for comparing method performance.; Argument iClass specifies the class to g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:29522,load,loader,29522,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,"ree &t, Int_t bufSize=32000) overrideRooAbsRealprotectedvirtual; attachToVStore(RooVectorDataStore &vstore) overrideRooAbsRealprotectedvirtual; attributes() constRooAbsArginline; Auto enum valueRooAbsArg; autoGenContext(const RooArgSet &vars, const RooDataSet *prototype=nullptr, const RooArgSet *auxProto=nullptr, bool verbose=false, bool autoBinned=true, const char *binnedTag="""") constRooAbsPdfvirtual; binBoundaries(RooAbsRealLValue &obs, double xlo, double xhi) constRooAbsRealvirtual; bindVars(const RooArgSet &vars, const RooArgSet *nset=nullptr, bool clipInvalid=false) constRooAbsReal; binnedGenContext(const RooArgSet &vars, bool verbose=false) constRooAbsPdfvirtual; branchNodeServerList(RooAbsCollection *list, const RooAbsArg *arg=nullptr, bool recurseNonDerived=false) constRooAbsArg; Browse(TBrowser *b)TObjectvirtual; buildCallToAnalyticIntegral(Int_t code, const char *rangeName, RooFit::Detail::CodeSquashContext &ctx) constRooAbsRealvirtual; CacheMode enum nameRooAbsArg; cacheUniqueSuffix() constRooAbsArginlinevirtual; callRedirectServersHook(RooAbsCollection const &newSet, bool mustReplaceAll, bool nameChange, bool isRecursionStep)RooAbsArgprivate; CanBeExtended enum valueRooAbsPdf; canBeExtended() constRooAbsPdfinline; canComputeBatchWithCuda() constRooAbsArginlinevirtual; canNodeBeCached() constRooAbsArginlinevirtual; CanNotBeExtended enum valueRooAbsPdf; changeServer(RooAbsArg &server, bool valueProp, bool shapeProp)RooAbsArg; CheckedHash()TObjectinline; checkObservables(const RooArgSet *nset) constRooAbsArgvirtual; chi2FitTo(RooDataHist &data, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const RooCmdArg &arg4={}, const RooCmdArg &arg5={}, const RooCmdArg &arg6={}, const RooCmdArg &arg7={}, const RooCmdArg &arg8={})RooAbsRealvirtual; chi2FitTo(RooDataHist &data, const RooLinkedList &cmdList)RooAbsRealvirtual; chi2FitTo(RooDataSet &xydata, const RooCmdArg &arg1={}, const RooCmdArg &arg2={}, const RooCmdArg &arg3={}, const Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf-members.html:4535,cache,cacheUniqueSuffix,4535,doc/master/classRooAbsPdf-members.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf-members.html,1,['cache'],['cacheUniqueSuffix']
Performance,"ree & ; t, . Int_t ; bufSize = 32000 . ). protectedpure virtual . Overloadable function for derived classes to implement attachment as branch to a TTree. ; Implemented in RooAbsCategory, RooAbsReal, RooRealVar, and RooStringVar.; Definition at line 1497 of file RooAbsArg.cxx. ◆ attachToVStore(). virtual void RooAbsArg::attachToVStore ; (; RooVectorDataStore & ; vstore). protectedpure virtual . Implemented in RooStringVar, RooAbsCategory, RooAbsReal, and RooRealVar. ◆ attributes(). const std::set< std::string > & RooAbsArg::attributes ; (; ); const. inline . Definition at line 313 of file RooAbsArg.h. ◆ branchNodeServerList(). void RooAbsArg::branchNodeServerList ; (; RooAbsCollection * ; list, . const RooAbsArg * ; arg = nullptr, . bool ; recurseNonDerived = false . ); const. Fill supplied list with all branch nodes of the arg tree starting with ourself as top node. ; A branch node is node that has one or more servers declared. ; Definition at line 483 of file RooAbsArg.cxx. ◆ cacheUniqueSuffix(). virtual const char * RooAbsArg::cacheUniqueSuffix ; (; ); const. inlinevirtual . Reimplemented in RooAbsOptTestStatistic.; Definition at line 470 of file RooAbsArg.h. ◆ callRedirectServersHook(). bool RooAbsArg::callRedirectServersHook ; (; RooAbsCollection const & ; newSet, . bool ; mustReplaceAll, . bool ; nameChange, . bool ; isRecursionStep . ). private . Private helper function for RooAbsArg::redirectServers(). ; Definition at line 1134 of file RooAbsArg.cxx. ◆ canComputeBatchWithCuda(). virtual bool RooAbsArg::canComputeBatchWithCuda ; (; ); const. inlinevirtual . Reimplemented in RooArgusBG, RooBernstein, RooBifurGauss, RooBMixDecay, RooBreitWigner, RooBukinPdf, RooCBShape, RooChebychev, RooChiSquarePdf, RooDstD0BG, RooExponential, RooGamma, RooGaussian, RooGaussModel, RooJohnson, RooLandau, RooLegacyExpPoly, RooLognormal, RooNovosibirsk, RooPoisson, RooPolynomial, RooPowerSum, RooVoigtian, RooAddModel, RooAddPdf, RooPolyVar, RooRatio, RooTruthModel, RooNormalizedPdf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:48280,cache,cacheUniqueSuffix,48280,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cacheUniqueSuffix']
Performance,"ree ROOT.RooDataSets in (y,z); dsA = ds2.reduce({x, y}, ""z<-5""); dsB = ds2.reduce({x, y}, ""abs(z)<5""); dsC = ds2.reduce({x, y}, ""z>5""); ; # Create a dataset that imports contents of all the above datasets mapped; # by index category c; dsABC = ROOT.RooDataSet(""dsABC"", ""dsABC"", {x, y}, Index=c, Import={""SampleA"": dsA, ""SampleB"": dsB, ""SampleC"": dsC}); ; dsABC.Print(); RooDataHist::dh[c,x] = 300 bins (2964 weights); RooDataHist::dh[c,x] = 300 bins (2964 weights); [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because z cannot accommodate the value 10; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds2) Ignored 36 out-of-range events; RooDataSet::ds2[x,z,y] = 26 entries; [#1] INFO:DataHandling -- RooAbsReal::attachToTree(i) TTree Int_t branch i will be converted to double precision.; RooDataS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8py.html:4427,load,loadValues,4427,doc/master/rf401__importttreethx_8py.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8py.html,1,['load'],['loadValues']
Performance,"ree branches; TString_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_t_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Int_tRooAbsTestStatistic::_setNumPartition number of this instance in parallel calculation mode; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsOptTestStatistic(const char* name, const char* title, RooAbsReal& real, RooAbsData& data, const RooArgSet& projDeps, const char* rangeName = 0, const char* addCoefRangeName = 0, Int_t nCPU = 1, RooFit::MPSplit interleave = RooFit::BulkPartition, Bool_t verbose = kTRUE, Bool_t splitCutRange = kFALSE, Bool_t cloneInputData = kTRUE); Constructor taking function (real), a dataset (data), a set of projected observables (projSet). If; rangeName is not null, only eve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:42898,cache,cache,42898,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,4,['cache'],['cache']
Performance,"ree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgr! The cache manager; RooSetProxy_cacheObsVariables to be cached; Bool_t_cacheSourceKeep an attached clone of the source in the cache for fast operation; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:36163,cache,cache,36163,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,14,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"ree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TEveElement::EDestructTEveElement::kAnnihilate; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveStraightLineSetProjected(); Constructor. void SetProjection(TEveProjectionManager* mng, TEveProjectable* model); Set projection manager and model object. void SetDepthLocal(Float_t d); Set depth (z-coordinate) of the projected points. void UpdateProjection(); Callback that actually performs the projection.; Called when projection parameters have been updated. TEveStraightLineSet& operator=(const TEveStraightLineSetProjected& ). TEveStraightLineSetProjected(const TEveStraightLineSetProjected& ). virtual ~TEveStraightLineSetProjected(); {}. TEveElement* GetProjectedAsElement(); { return this; }. » Last changed: root/eve:$Id$ » Last generated: 2015-06-02 15:45; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEveStraightLineSetProjected.html:28922,perform,performs,28922,root/html604/TEveStraightLineSetProjected.html,https://root.cern,https://root.cern/root/html604/TEveStraightLineSetProjected.html,2,['perform'],['performs']
Performance,"ree items that prevent automatic destruction.; void*TEveElement::fUserData! Externally assigned and controlled user data.; TEveElement*TEveElement::fVizModel! Element used as model from VizDB.; TStringTEveElement::fVizTagTag used to query VizDB for model element.; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TEveElement::EDestructTEveElement::kAnnihilate; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainColorToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBApplyMainTransparencyToMatchingChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBImplySelectAllChildren; static TEveElement::ECompoundSelectionColorBitsTEveElement::kCSCBTakeAnyParentAsMaster; static TEveElement::EDestructTEveElement::kNone; static TEveElement::EDestructTEveElement::kStandard. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEveStraightLineSetProjected(); Constructor. void SetProjection(TEveProjectionManager* mng, TEveProjectable* model); Set projection manager and model object. void SetDepthLocal(Float_t d); Set depth (z-coordinate) of the projected points. void UpdateProjection(); Callback that actually performs the projection.; Called when projection parameters have been updated. TEveStraightLineSet& operator=(const TEveStraightLineSetProjected& ). TEveStraightLineSetProjected(const TEveStraightLineSetProjected& ). virtual ~TEveStraightLineSetProjected(); {}. TEveElement* GetProjectedAsElement(); { return this; }. » Last changed: root/eve:$Id$ » Last generated: 2015-06-30 14:46; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEveStraightLineSetProjected.html:28922,perform,performs,28922,root/html602/TEveStraightLineSetProjected.html,https://root.cern,https://root.cern/root/html602/TEveStraightLineSetProjected.html,2,['perform'],['performs']
Performance,"ree* tree, Long64_t nentries /* = -1 */, Option_t* option /* = """" */, bool needCopyAddresses /* = false */); 3536{; 3537 if (!tree) {; 3538 return 0;; 3539 }; 3540 // Options; 3541 TString opt = option;; 3542 opt.ToLower();; 3543 bool fastClone = opt.Contains(""fast"");; 3544 bool withIndex = !opt.Contains(""noindex"");; 3545 EOnIndexError onIndexError;; 3546 if (opt.Contains(""asisindex"")) {; 3547 onIndexError = kKeep;; 3548 } else if (opt.Contains(""buildindex"")) {; 3549 onIndexError = kBuild;; 3550 } else if (opt.Contains(""dropindex"")) {; 3551 onIndexError = kDrop;; 3552 } else {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:140778,cache,cacheSizeLoc,140778,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,8,['cache'],"['cacheSize', 'cacheSizeEnd', 'cacheSizeLoc', 'cacheSizeStr', 'cachesize']"
Performance,"ree, const unsigned int nSlots, const RColumnRegister &colRegister, RDataSource *ds, std::weak_ptr< RJittedAction > *jittedActionOnHeap, const bool vector2RVec)Definition RDFInterfaceUtils.cxx:849; ROOT::Internal::RDF::FindUnknownColumnsColumnNames_t FindUnknownColumns(const ColumnNames_t &requiredCols, const ColumnNames_t &datasetColumns, const RColumnRegister &definedCols, const ColumnNames_t &dataSourceColumns)Definition RDFInterfaceUtils.cxx:611; ROOT::Internal::VecOps::voidvoid(off) SmallVectorTemplateBase< T; ROOT::Math::Chebyshev::Tdouble T(double x)Definition ChebyshevPol.h:34; ROOT::RDFDefinition RArrowDS.hxx:28; ROOT::RDF::ColumnNames_tstd::vector< std::string > ColumnNames_tDefinition RInterfaceBase.hxx:35; ROOT::TypeTraitsROOT type_traits extensions.Definition TypeTraits.hxx:21; ROOTtbb::task_arena is an alias of tbb::interface7::task_arena, which doesn't allow to forward declare tb...Definition EExecutionPolicy.hxx:4; ROOT::IsImplicitMTEnabledBool_t IsImplicitMTEnabled()Returns true if the implicit multi-threading in ROOT is enabled.Definition TROOT.cxx:570; TMath::MaxShort_t Max(Short_t a, Short_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::MinShort_t Min(Short_t a, Short_t b)Returns the smallest of a and b.Definition TMathBase.h:198; TMath::MeanDouble_t Mean(Long64_t n, const T *a, const Double_t *w=nullptr)Returns the weighted mean of an array a with length n.Definition TMath.h:1089; TMath::StdDevDouble_t StdDev(Long64_t n, const T *a, const Double_t *w=nullptr)Definition TMath.h:527; ROOT::Detail::RDF::ExtraArgsForDefine::NoneDefinition RDefine.hxx:39; ROOT::Detail::RDF::RInferredTypeDefinition Utils.hxx:59; ROOT::RDF::RSnapshotOptionsA collection of options to steer the creation of the dataset on file.Definition RSnapshotOptions.hxx:22; ROOT::TypeTraits::TypeListLightweight storage for a collection of types.Definition TypeTraits.hxx:25. treedataframeincROOTRDFInterfaceUtils.hxx. ROOT master - Reference Guide Generated on Tue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html:46758,multi-thread,multi-threading,46758,doc/master/InterfaceUtils_8hxx_source.html,https://root.cern,https://root.cern/doc/master/InterfaceUtils_8hxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"ree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted acc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:34665,cache,cache,34665,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['cache'],['cache']
Performance,"ree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specif",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:35151,cache,cache,35151,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,2,['cache'],['cache']
Performance,"ree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTree(); Default constructor and I/O constructor. Note: We do *not* insert ourself into the current directory. TTree(const char* name, const char* title, Int_t splitlevel = 99); Normal tree constructor. The tree is created in the current directory.; Use the various functions Branch below to add branches to this tree. If the first character of title is a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Remove the branch with name 'bname' from the Tree cache.; If bname=""*"" all branches are removed from the cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Remove the branch b from the Tree cache.; if subbranches is true all the branches of the subbranches are; also removed from the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:36397,cache,cache,36397,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['cache'],['cache']
Performance,"ree. TTreeReader registers its fNotify data member with the TChain/TTree which in turn leads to this method being called upon the execution of LoadTree. ; Reimplemented from TObject.; Definition at line 323 of file TTreeReader.cxx. ◆ RegisterValueReader(). bool TTreeReader::RegisterValueReader ; (; ROOT::Internal::TTreeReaderValueBase * ; reader). protected . Add a value reader for this tree. ; Definition at line 858 of file TTreeReader.cxx. ◆ Restart(). void TTreeReader::Restart ; (; ). Restart a Next() loop from entry 0 (of TEntryList index 0 of fEntryList is set). ; Definition at line 571 of file TTreeReader.cxx. ◆ SetEntriesRange(). TTreeReader::EEntryStatus TTreeReader::SetEntriesRange ; (; Long64_t ; beginEntry, . Long64_t ; endEntry . ). Set the range of entries to be loaded by Next(); end will not be loaded. ; If end <= begin, end is ignored (set to -1, i.e. will run on all entries from begin onwards).; Example:; reader.SetEntriesRange(3, 5);; while (reader.Next()) {; // Will load entries 3 and 4.; }; Note that if a TEntryList is present, beginEntry and endEntry refer to the beginEntry-th/endEntry-th entries of the TEntryList (or the main TEntryList in case it has sub-entrylists). In other words, SetEntriesRange can be used to only loop over part of the TEntryList, but not to further restrict the actual TTree/TChain entry numbers considered.; Parameters. beginEntryThe first entry to be loaded by Next(). ; endEntryThe entry where Next() will return false, not loading it. . Definition at line 533 of file TTreeReader.cxx. ◆ SetEntry(). EEntryStatus TTreeReader::SetEntry ; (; Long64_t ; entry). inline . Set the next entry (or index of the TEntryList if that is set). ; Parameters. entryIf not TEntryList is set, the entry is a global entry (i.e. not the entry number local to the chain's current tree). . Returnsthe entry's read status, i.e. whether the entry is available. ; Definition at line 225 of file TTreeReader.h. ◆ SetEntryBase(). TTreeReader::EEntryStatus TT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReader.html:31621,load,load,31621,doc/master/classTTreeReader.html,https://root.cern,https://root.cern/doc/master/classTTreeReader.html,1,['load'],['load']
Performance,"ree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is specified, compute t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:114310,Optimiz,OptimizeBaskets,114310,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,1,['Optimiz'],['OptimizeBaskets']
Performance,"ree. Trees in the list can be memory or disk-resident trees.; The new tree is created in the current directory (memory if gROOT). Long64_t Merge(TCollection* list, Option_t* option = """"); Merge the trees in the TList into this tree. Returns the total number of entries in the merged tree. Long64_t Merge(TCollection* list, TFileMergeInfo* info); Merge the trees in the TList into this tree.; If info->fIsFirst is true, first we clone this TTree info the directory; info->fOutputDirectory and then overlay the new TTree information onto; this TTree object (so that this TTree object is now the appropriate to; use for further merging). Returns the total number of entries in the merged tree. void MoveReadCache(TFile* src, TDirectory* dir); Move a cache from a file to the current file in dir.; if src is null no operation is done, if dir is null or there is no; current file the cache is deleted. Bool_t Notify(); Function called when loading a new class library. void OptimizeBaskets(ULong64_t maxMemory = 10000000, Float_t minComp = 1.1000000000000001, Option_t* option = """"); This function may be called after having filled some entries in a Tree; Using the information in the existing branch buffers, it will reassign; new branch buffer sizes to optimize time and memory. The function computes the best values for branch buffer sizes such that; the total buffer sizes is less than maxMemory and nearby entries written; at the same time.; In case the branch compression factor for the data written so far is less; than compMin, the compression is disabled. if option =""d"" an analysis report is printed. TPrincipal* Principal(const char* varexp = """", const char* selection = """", Option_t* option = ""np"", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Interface to the Principal Components Analysis class. Create an instance of TPrincipal; Fill it with the selected variables; if option ""n"" is specified, the TPrincipal object is filled with; normalized variables.; If option ""p"" is speci",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:115767,Optimiz,OptimizeBaskets,115767,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,2,['Optimiz'],['OptimizeBaskets']
Performance,"ree.h:557; TTree::LoadTreevirtual Long64_t LoadTree(Long64_t entry)Set current entry.Definition TTree.cxx:6473; TTree::GetAliasvirtual const char * GetAlias(const char *aliasName) constReturns the expanded value of the alias. Search in the friends if any.Definition TTree.cxx:5226; TTree::GetMinimumvirtual Double_t GetMinimum(const char *columname)Return minimum of column with name columname.Definition TTree.cxx:6275; TTree::RemoveFriendvirtual void RemoveFriend(TTree *)Remove a friend from the list of friends.Definition TTree.cxx:7977; TTree::Browsevoid Browse(TBrowser *) overrideBrowse content of the TTree.Definition TTree.cxx:2609; TTree::LoadTreeFriendvirtual Long64_t LoadTreeFriend(Long64_t entry, TTree *T)Load entry on behalf of our master tree, we may use an index.Definition TTree.cxx:6557; TTree::WriteInt_t Write(const char *name=nullptr, Int_t option=0, Int_t bufsize=0) overrideWrite this object to the current directory.Definition TTree.cxx:9753; TTree::fNotifyTObject * fNotifyObject to be notified when loading a Tree.Definition TTree.h:120; TTree::GetListOfClonesvirtual TList * GetListOfClones()Definition TTree.h:527; TTree::fCacheSizeLong64_t fCacheSize! Maximum size of file buffersDefinition TTree.h:105; TTree::fClonesTList * fClones! List of cloned trees which share our addressesDefinition TTree.h:135; TTree::Classstatic TClass * Class(); TTree::kLoadTree@ kLoadTreeDefinition TTree.h:221; TTree::CopyAddressesvirtual void CopyAddresses(TTree *, bool undo=false)Set branch addresses of passed tree equal to ours.Definition TTree.cxx:3299; TTree::GetListOfFriendsvirtual TList * GetListOfFriends() constDefinition TTree.h:530; TTree::fReadEntryLong64_t fReadEntry! Number of the entry being processedDefinition TTree.h:107; TTree::GetNbranchesvirtual Int_t GetNbranches()Definition TTree.h:542; TTree::FindLeafvirtual TLeaf * FindLeaf(const char *name)Find leaf..Definition TTree.cxx:4916; TTree::fDirectoryTDirectory * fDirectory! Pointer to directory holding this tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:150872,load,loading,150872,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loading']
Performance,"ree::DeleteNode(TMVA::Node*); TMVA::MsgLogger&TMVA::BinaryTree::Log() const. private:. Double_tSamplePurity(TMVA::DecisionTree::EventList eventSample). Data Members; public:. enum EPruneMethod { kExpectedErrorPruning; kCostComplexityPruning; kNoPruning; };. protected:. UInt_tTMVA::BinaryTree::fDepthmaximal depth in tree reached; UInt_tTMVA::BinaryTree::fNNodestotal number of nodes in the tree (counted); TMVA::Node*TMVA::BinaryTree::fRootthe root node of the tree; static TMVA::MsgLogger*TMVA::BinaryTree::fgLoggermessage logger, static to save resources . private:. TMVA::Types::EAnalysisTypefAnalysisTypekClassification(=0=false) or kRegression(=1=true); UInt_tfClassclass which is treated as signal when building the tree; UInt_tfMaxDepthmax depth; Double_tfMinLinCorrForFisherthe minimum linear correlation between two variables demanded for use in fisher criterium in node splitting; Double_tfMinSepGainmin number of separation gain to perform node splitting; Double_tfMinSizemin number of events in node; TRandom3*fMyTrandomrandom number generator for randomised trees; Int_tfNCutsnumber of grid point in variable cut scans; UInt_tfNNodesMaxmax # of nodes; Double_tfNodePurityLimitpurity limit to decide whether a node is signal; UInt_tfNvarsnumber of variables used to separate S and B; TMVA::DecisionTree::EPruneMethodfPruneMethodmethod used for prunig ; Double_tfPruneStrengtha parameter to set the ""amount"" of pruning..needs to be adjusted ; Bool_tfRandomisedTreechoose at each node splitting a random set of variables ; TMVA::RegressionVariance*fRegTypethe separation crition used in Regression; TMVA::SeparationBase*fSepTypethe separation crition; Int_tfTreeIDjust an ID number given to the tree.. makes debugging easier as tree knows who he is.; Bool_tfUseExclusiveVarsindividual variables already used in fisher criterium are not anymore analysed individually for node splitting; Bool_tfUseFisherCutsuse multivariate splits using the Fisher criterium; Int_tfUseNvarsthe number of var",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__DecisionTree.html:6685,perform,perform,6685,root/html528/TMVA__DecisionTree.html,https://root.cern,https://root.cern/root/html528/TMVA__DecisionTree.html,1,['perform'],['perform']
Performance,"ree::Merge(TCollection,Option_t).; TTreeCache; The TTreeCache is now enabled by default. The default size of the TTreeCache is the estimated size of a cluster size for the TTree. The TTreeCache prefilling is also enabled by default; when in learning phase rather than reading each requested branch individually, the TTreeCache will read all the branches thus trading off the latencies inherent to multiple small reads for the potential of requesting more data than needed by read from the disk or server the baskets for too many branches.; The default behavior can be changed by either updating one of the rootrc files or by setting environment variables. The rootrc files, both the global and the local ones, now support the following the resource variable TTreeCache.Size which set the default size factor for auto sizing TTreeCache for TTrees. The estimated cluster size for the TTree and this factor is used to give the cache size. If option is set to zero auto cache creation is disabled and the default cache size is the historical one (equivalent to factor 1.0). If set to non zero auto cache creation is enabled and both auto created and default sized caches will use the configured factor: 0.0 no automatic cache and greater than 0.0 to enable cache. This value can be overridden by the environment variable ROOT_TTREECACHE_SIZE.; The resource variable TTreeCache.Prefill sets the default TTreeCache prefilling type. The prefill type may be: 0 for no prefilling and 1 to prefill all the branches. It can be overridden by the environment variable ROOT_TTREECACHE_PREFILL; In particular the default can be set back to the same as in version 5 by setting TTreeCache.Size (or ROOT_TTREECACHE_SIZE) and TTreeCache.Prefill (or ROOT_TTREECACHE_PREFILL) both to zero.; TTree methods which are expected to modify a cache, like AddBranchToCache, will attempt to setup a cache of default size if one does not exist, irrespective of whether the auto cache creation is enabled. Additionally several method",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:12727,cache,cache,12727,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,2,['cache'],['cache']
Performance,"ree::fAutoFlushLong64_t fAutoFlushAuto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced.Definition TTree.h:101; TTree::fUpdateInt_t fUpdateUpdate frequency for EntryLoop.Definition TTree.h:93; TTree::ResetAfterMergevirtual void ResetAfterMerge(TFileMergeInfo *)Resets the state of this TTree after a merge (keep the customization but forget the data).Definition TTree.cxx:8034; TTree::BranchTBranch * Branch(const char *name, std::array< T, N > *obj, Int_t bufsize=32000, Int_t splitlevel=99)Definition TTree.h:405; TTree::GetEntriesvirtual Long64_t GetEntries() constDefinition TTree.h:463; TTree::SetEstimatevirtual void SetEstimate(Long64_t nentries=1000000)Set number of entries to estimate variable limits.Definition TTree.cxx:9110; TTree::fTimerIntervalInt_t fTimerIntervalTimer interval in milliseconds.Definition TTree.h:91; TTree::fDebugInt_t fDebug! Debug levelDefinition TTree.h:111; TTree::SetCacheSizeAuxInt_t SetCacheSizeAux(bool autocache=true, Long64_t cacheSize=0)Set the size of the file cache and create it if possible.Definition TTree.cxx:8711; TTree::AutoSavevirtual Long64_t AutoSave(Option_t *option="""")AutoSave tree header every fAutoSave bytes.Definition TTree.cxx:1500; TTree::GetEntryNumbervirtual Long64_t GetEntryNumber(Long64_t entry) constReturn entry number corresponding to entry.Definition TTree.cxx:5865; TTree::CloneTreevirtual TTree * CloneTree(Long64_t nentries=-1, Option_t *option="""")Create a clone of this tree and copy nentries.Definition TTree.cxx:3139; TTree::GetImplicitMTvirtual bool GetImplicitMT()Definition TTree.h:520; TTree::fFileNumberInt_t fFileNumber! current file number (if file extensions)Definition TTree.h:116; TTree::GetLeafvirtual TLeaf * GetLeaf(const char *branchname, const char *leafname)Return pointer to the 1st Leaf named name in any Branch of this Tree or any branch in the list of fri...Definition TTree.cxx:6195; TTree::GetZipBytesvirtual Long64_t GetZipBytes() constDefinition TTree.h:585; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:71322,cache,cacheSize,71322,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"reeCache.; Definition at line 947 of file TTreeCacheUnzip.cxx. ◆ ReadBufferExt(). Int_t TTreeCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 961 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 501 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ; (; Int_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TTreeCache.; Definition at line 359 of file TTreeCacheUnzip.cxx. ◆ SetEntryRange(). void TTreeCacheUnzip::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). overridevirtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented from TTreeCache.; Definition at line 375 of file TTreeCacheUnzip.cxx. ◆ SetParallelUnzip(). Int_t TTreeCacheUnzip::SetParallelUnzip ; (; TTreeCacheUnzip::EParUnzipMode ; option = TTreeCacheUnzip::kEnable). static . Static function that (de)activates multithreading unzipping. ; The possible options are:; kEnable Enable it, which causes an automatic detection and launches the additional thread if the number of cores in the machine is greater than one; kDisable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:34828,cache,cache,34828,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"reeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Ret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:24582,cache,cache,24582,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['cache'],['cache']
Performance,"reeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds2) Ignored 36 out-of-range events; RooDataSet::ds2[x,y,z] = 26 entries; [#1] INFO:DataHandling -- RooAbsReal::attachToTree(i) TTree Int_t branch i will be converted to double precision.; RooDataSet::ds3[i,x] = 100 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #2 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #5 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #8 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #11 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds4) Ignored 33 out-of-range events; RooDataSet::ds4[i,x] = 67 entries; RooDataSet::dsABC[x,y,c] = 26 entries; DateJuly 2008 ; AuthorWouter Verkerke ; Definition in file rf401_importttreethx.C. tutorialsroofitrf401_importttree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8C.html:8282,load,loadValues,8282,doc/master/rf401__importttreethx_8C.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8C.html,1,['load'],['loadValues']
Performance,"reeName(). Int_t TProofLite::SetDataSetTreeName ; (; const char * ; dataset, . const char * ; treename . ). overridevirtual . Set/Change the name of the default tree. ; The tree name may contain subdir specification in the form ""subdir/name"". Returns 0 on success, -1 otherwise. ; Reimplemented from TProof.; Definition at line 2002 of file TProofLite.cxx. ◆ SetProofServEnv(). Int_t TProofLite::SetProofServEnv ; (; const char * ; ord). private . Create environment files for worker 'ord'. ; Definition at line 684 of file TProofLite.cxx. ◆ SetQueryRunning(). void TProofLite::SetQueryRunning ; (; TProofQueryResult * ; pq). protected . Set query in running state. ; Definition at line 1025 of file TProofLite.cxx. ◆ SetupWorkers(). Int_t TProofLite::SetupWorkers ; (; Int_t ; opt = 0, . TList * ; wrks = 0 . ). protected . Start up PROOF workers. ; Definition at line 489 of file TProofLite.cxx. ◆ ShowCache(). void TProofLite::ShowCache ; (; Bool_t ; all = kFALSE). overridevirtual . List contents of file cache. ; If all is true show all caches also on slaves. If everything is ok all caches are to be the same. ; Reimplemented from TProof.; Definition at line 1508 of file TProofLite.cxx. ◆ ShowData(). void TProofLite::ShowData ; (; ). overridevirtual . List contents of the data directory in the sandbox. ; This is the place where files produced by the client queries are kept ; Reimplemented from TProof.; Definition at line 2479 of file TProofLite.cxx. ◆ ShowDataDir(). void TProofLite::ShowDataDir ; (; const char * ; dirname). private . List contents of the data directory 'dirname'. ; Definition at line 2495 of file TProofLite.cxx. ◆ ShowDataSetCache(). void TProofLite::ShowDataSetCache ; (; const char * ; dataset = 0). overridevirtual . Display the content of the dataset cache, if any (matching 'dataset', if defined). ; Reimplemented from TProof.; Definition at line 2292 of file TProofLite.cxx. ◆ ShowDataSets(). void TProofLite::ShowDataSets ; (; const char * ; uri = """", . const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:66342,cache,cache,66342,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['cache'],['cache']
Performance,"reen value and apply modifiers. ;  ; virtual void Apply (const TGLBoundingBox &sceneBox, const TGLRect *pickRect=nullptr) const =0;  ; virtual void Configure (Double_t zoom, Double_t dolly, Double_t center[3], Double_t hRotate, Double_t vRotate)=0;  ; virtual Bool_t Dolly (Int_t delta, Bool_t mod1, Bool_t mod2);  Dolly the camera - 'move camera along eye line, retaining lens focal length'. ;  ; void DrawDebugAids () const;  Draw out some debugging aids for the camera: ;  ; TGLVector3 EyeDirection () const;  Extract the camera eye direction (vector), running from EyePoint() Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 EyePoint () const;  Return the camera eye point (vertex) in world space Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 FrustumCenter () const;  Find the center of the camera frustum from intersection of planes This method will work even with parallel left/right & top/bottom and infinite eye point of ortho cameras Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; Rgl::EOverlap FrustumOverlap (const TGLBoundingBox &box) const;  Calculate overlap (kInside, kOutside, kPartial) of box with camera frustum Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; const TGLPlane & FrustumPlane (EFrustumPlane plane) const;  ; const TGLMatrix & GetCamBase () const;  ; const TGLMatrix & GetCamTrans () const;  ; Double_t * GetCenterVec ();  ; Bool_t GetExternalCenter ();  ; Double_t GetFarClip () const;  ; Double_t * GetFixDefCenterVec ();  ; Double_t GetNearClip () const;  ; Double_t GetTheta () const;  Get angle between camera up axis. ;  ; Float_t GetVAxisMinAngle ();  ; void IncTimeStamp ();  ; TClass * IsA () const override;  ; Bool_t IsCacheDirty () const;  ; virtual Bool_t IsOrthographic () const;  ; virtual Bool_t IsPerspective () const;  ; Bool_t OfIntere",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLCamera.html:3587,cache,cache,3587,doc/master/classTGLCamera.html,https://root.cern,https://root.cern/doc/master/classTGLCamera.html,1,['cache'],['cache']
Performance,"reen; 85and PostScript) style. Each marker style is identified by an integer number; 86(first column) corresponding to a marker shape (second column) and can be also; 87accessed via a global name (third column).; 88 ; 89~~~ {.cpp}; 90 Marker number Marker shape Marker name; 91 1 dot kDot; 92 2 + kPlus; 93 3 * kStar; 94 4 o kCircle; 95 5 x kMultiply; 96 6 small dot kFullDotSmall; 97 7 medium dot kFullDotMedium; 98 8 large scalable dot kFullDotLarge; 99 9 -->19 large scalable dot; 100 20 full circle kFullCircle; 101 21 full square kFullSquare; 102 22 full triangle up kFullTriangleUp; 103 23 full triangle down kFullTriangleDown; 104 24 open circle kOpenCircle; 105 25 open square kOpenSquare; 106 26 open triangle up kOpenTriangleUp; 107 27 open diamond kOpenDiamond; 108 28 open cross kOpenCross; 109 29 full star kFullStar; 110 30 open star kOpenStar; 111 31 *; 112 32 open triangle down kOpenTriangleDown; 113 33 full diamond kFullDiamond; 114 34 full cross kFullCross; 115 35 open diamond cross kOpenDiamondCross; 116 36 open square diagonal kOpenSquareDiagonal; 117 37 open three triangle kOpenThreeTriangles; 118 38 octagon with cross kOctagonCross; 119 39 full three triangles kFullThreeTriangles; 120 40 open four triangleX kOpenFourTrianglesX; 121 41 full four triangleX kFullFourTrianglesX; 122 42 open double diamond kOpenDoubleDiamond; 123 43 full double diamond kFullDoubleDiamond; 124 44 open four triangle+ kOpenFourTrianglesPlus; 125 45 full four triangle+ kFullFourTrianglesPlus; 126 46 open cross X kOpenCrossX; 127 47 full cross X kFullCrossX; 128 48 four squares X kFourSquaresX; 129 49 four squares+ kFourSquaresPlus; 130~~~; 131 ; 132Begin_Macro; 133{; 134 TCanvas *c = new TCanvas(""c"",""Marker types"",0,0,500,200);; 135 TMarker marker;; 136 marker.DisplayMarkerTypes();; 137}; 138End_Macro; 139 ; 140\warning Non-symmetric symbols should be used carefully. See markerwarning.C; 141 ; 142\anchor ATTMARKER21; 143### Marker line width; 144 ; 145The line width of a marker is n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TAttMarker_8cxx_source.html:3428,scalab,scalable,3428,doc/master/TAttMarker_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TAttMarker_8cxx_source.html,2,['scalab'],['scalable']
Performance,"rees) leverages TTree's ""friend"" mechanism.; 1323 ; 1324Simple joins of trees that do not have the same number of rows are also possible with indexed friend trees (see below).; 1325 ; 1326To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame; 1327with the main tree:; 1328 ; 1329~~~{.cpp}; 1330TTree main([...]);; 1331TTree friend([...]);; 1332main.AddFriend(&friend, ""myFriend"");; 1333 ; 1334RDataFrame df(main);; 1335auto df2 = df.Filter(""myFriend.MyCol == 42"");; 1336~~~; 1337 ; 1338The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; 1339or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; 1340""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree).; 1341 ; 1342\note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; 1343 entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; 1344 one: rows will be mismatched.; 1345 ; 1346Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; 1347When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; 1348""index"" columns have a value identical to the one in the main one. For example, in Python:; 1349 ; 1350~~~{.py}; 1351main_tree = ...; 1352aux_tree = ...; 1353 ; 1354# If a friend tree has an index on `commonColumn`, when the main tree loads; 1355# a given row, it also loads the row of the friend tree that has the same; 1356# value of `commonColumn`; 1357aux_tree.BuildIndex(""commonColumn""); 1358 ; 1359mainTree.AddFriend(aux_tree); 1360 ; 1361df = ROOT.RDataFrame(mainTree); 1362~~~; 1363 ; 1364RDataFrame supports indexed friend TTrees from ROOT v6.24 in single",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:77892,multi-thread,multi-thread,77892,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-thread']
Performance,"rees) leverages TTree's ""friend"" mechanism.; 1363 ; 1364Simple joins of trees that do not have the same number of rows are also possible with indexed friend trees (see below).; 1365 ; 1366To use friend trees in RDataFrame, set up trees with the appropriate relationships and then instantiate an RDataFrame; 1367with the main tree:; 1368 ; 1369~~~{.cpp}; 1370TTree main([...]);; 1371TTree friend([...]);; 1372main.AddFriend(&friend, ""myFriend"");; 1373 ; 1374RDataFrame df(main);; 1375auto df2 = df.Filter(""myFriend.MyCol == 42"");; 1376~~~; 1377 ; 1378The same applies for TChains. Columns coming from the friend trees can be referred to by their full name, like in the example above,; 1379or the friend tree name can be omitted in case the column name is not ambiguous (e.g. ""MyCol"" could be used instead of; 1380""myFriend.MyCol"" in the example above if there is no column ""MyCol"" in the main tree).; 1381 ; 1382\note A common source of confusion is that trees that are written out from a multi-thread Snapshot() call will have their; 1383 entries (block-wise) shuffled with respect to the original tree. Such trees cannot be used as friends of the original; 1384 one: rows will be mismatched.; 1385 ; 1386Indexed friend trees provide a way to perform simple joins of multiple trees over a common column.; 1387When a certain entry in the main tree (or chain) is loaded, the friend trees (or chains) will then load an entry where the; 1388""index"" columns have a value identical to the one in the main one. For example, in Python:; 1389 ; 1390~~~{.py}; 1391main_tree = ...; 1392aux_tree = ...; 1393 ; 1394# If a friend tree has an index on `commonColumn`, when the main tree loads; 1395# a given row, it also loads the row of the friend tree that has the same; 1396# value of `commonColumn`; 1397aux_tree.BuildIndex(""commonColumn""); 1398 ; 1399mainTree.AddFriend(aux_tree); 1400 ; 1401df = ROOT.RDataFrame(mainTree); 1402~~~; 1403 ; 1404RDataFrame supports indexed friend TTrees from ROOT v6.24 in single",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:79572,multi-thread,multi-thread,79572,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-thread']
Performance,"rees. Consecutive decision trees are ; : trained using the original training data set with re-weighted ; : events. By default, the AdaBoost method is employed, which gives ; : events that were misclassified in the previous tree a larger ; : weight in the training of the following tree.; : ; : Decision trees are a sequence of binary splits of the data sample; : using a single discriminant variable at a time. A test event ; : ending up after the sequence of left-right splits in a final ; : (""leaf"") node is classified as either signal or background; : depending on the majority type of training events in that node.; : ; : ␛[1m--- Performance optimisation:␛[0m; : ; : By the nature of the binary splits performed on the individual; : variables, decision trees do not deal well with linear correlations; : between variables (they need to approximate the linear split in; : the two dimensional space by a sequence of splits on the two ; : variables individually). Hence decorrelation could be useful ; : to optimise the BDT performance.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The two most important parameters in the configuration are the ; : minimal number of events requested by a leaf node as percentage of the ; : number of training events (option ""MinNodeSize"" replacing the actual number ; : of events ""nEventsMin"" as given in earlier versions; : If this number is too large, detailed features ; : in the parameter space are hard to be modelled. If it is too small, ; : the risk to overtrain rises and boosting seems to be less effective; : typical values from our current experience for best performance ; : are between 0.5(%) and 10(%) ; : ; : The default minimal number is currently set to ; : max(20, (N_training_events / N_variables^2 / 10)) ; : and can be changed by the user.; : ; : The other crucial parameter, the pruning strength (""PruneStrength""),; : is also related to overtraining. It is a regularisation parameter ; : that is used when determining",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:31761,perform,performance,31761,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['perform'],['performance']
Performance,"ref MG01); 47 - [Setting drawing options](\ref MG01a); 48 - [Titles setting](\ref MG01b); 49 - [The option \""3D\""](\ref MG01c); 50 - [Legend drawing](\ref MG01d); 51 - [Automatic coloring](\ref MG01e); 52 - [Reverse axis](\ref MG01f); 53- [MultiGraphs' fitting](\ref MG02); 54 - [Fit box position](\ref MG02a); 55- [Axis' limits setting](\ref MG03); 56 ; 57 ; 58\anchor MG00; 59### Introduction; 60 ; 61A TMultiGraph allows to manipulate a set of graphs as a single entity. In particular,; 62when drawn, the X and Y axis ranges are automatically computed such as all the graphs; 63will be visible.; 64 ; 65`TMultiGraph::Add` should be used to add a new graph to the list.; 66 ; 67The TMultiGraph owns the objects in the list.; 68 ; 69The number of graphs in a multigraph can be retrieve with:; 70~~~ {.cpp}; 71mg->GetListOfGraphs()->GetEntries();; 72~~~; 73 ; 74\anchor MG01; 75### MultiGraphs' Drawing; 76 ; 77The drawing options are the same as for TGraph.; 78Like for TGraph, the painting is performed thanks to the TGraphPainter; 79class. All details about the various painting options are given in this class.; 80 ; 81Example:; 82~~~ {.cpp}; 83 TGraph *gr1 = new TGraph(...; 84 TGraphErrors *gr2 = new TGraphErrors(...; 85 TMultiGraph *mg = new TMultiGraph();; 86 mg->Add(gr1,""lp"");; 87 mg->Add(gr2,""cp"");; 88 mg->Draw(""a"");; 89~~~; 90 ; 91\anchor MG01a; 92#### Setting drawing options; 93 ; 94The drawing option for each TGraph may be specified as an optional; 95second argument of the `Add` function.; 96 ; 97If a draw option is specified, it will be used to draw the graph,; 98otherwise the graph will be drawn with the option specified in; 99`TMultiGraph::Draw`; 100 ; 101\anchor MG01b; 102#### Titles setting; 103 ; 104The global title and the axis titles can be modified the following way:; 105 ; 106~~~ {.cpp}; 107 [...]; 108 auto mg = new TMultiGraph;; 109 mg->SetTitle(""title;xaxis title; yaxis title"");; 110 mg->Add(g1);; 111 mg->Add(g2);; 112 mg->Draw(""apl"");; 113~~~; 114 ; 115\ancho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMultiGraph_8cxx_source.html:2533,perform,performed,2533,doc/master/TMultiGraph_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMultiGraph_8cxx_source.html,1,['perform'],['performed']
Performance,"refore, if bins 0 and 2 are not equal, the FFT sees a cyclical function with a step at the 2|0 boundary, which causes artifacts in Fourier space.; The spillover or discontinuity can be reduced or eliminated by introducing a buffer zone in the FFT calculation. If this feature is activated (on by default), the sampling array for the FFT calculation is extended in both directions, and padded with the lowest/highest bin. Example: original: -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5; add buffer zones: U U -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5 O O; rotate: 0 +1 +2 +3 +4 +5 O O U U -5 -4 -3 -2 -1; zonesDefinition zones.py:1; The buffer bins are stripped away when the FFT output values are transferred back to the p.d.f cache. The default buffer size is 10% of the observable domain size, and can be changed with the setBufferFraction() member function.; The RooFFTConvPdf uses caching inherited from a RooAbsCachedPdf. If it is evaluated for a particular value of x, the FFT and convolution is calculated for all bins in the observable space for the given choice of parameters, which are also stored in the cache. Subsequent evaluations for different values of the convolution observable and identical parameters will be retrieved from the cache. If one or more of the parameters change, the cache will be updated, i.e., a new FFT runs.; The sampling density of the FFT is controlled by the binning of the the convolution observable, which can be changed using RooRealVar::setBins(N). For good results, N should be large (>=1000). Additional interpolation between the bins may improve the result if coarse binnings are chosen. These can be activated in the constructor or by calling setInterpolationOrder(). For N >> 1000, interpolation will not substantially improve the accuracy.; Additionial information on caching can be displayed by monitoring the message stream with topic ""Caching"" at the INFO level, i.e. by calling RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")) to see these messa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:2754,cache,cache,2754,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,"refoxProfilePath: file path to Firefox profile; WebGui.FirefoxRandomProfile: usage of random Firefox profile -1 never, 0 - only for headless mode (dflt), 1 - always; WebGui.LaunchTmout: time required to start process in seconds (default 30 s); WebGui.OperationTmout: time required to perform WebWindow operation like execute command or update drawings; WebGui.RecordData: if specified enables data recording for each web window 0 - off, 1 - on; WebGui.JsonComp: compression factor for JSON conversion, if not specified - each widget uses own default values; WebGui.ForceHttp: 0 - off (default), 1 - always create real http server to run web window; WebGui.Console: -1 - output only console.error(), 0 - add console.warn(), 1 - add console.log() output; WebGui.ConnCredits: 10 - number of packets which can be send by server or client without acknowledge from receiving side; WebGui.openui5src: alternative location for openui5 like https://openui5.hana.ondemand.com/; WebGui.openui5libs: list of pre-loaded ui5 libs like sap.m, sap.ui.layout, sap.ui.unified; WebGui.openui5theme: openui5 theme like sap_belize (default) or sap_fiori_3; THttpServer-related parameters documented in CreateServer method ; Definition at line 692 of file RWebWindowsManager.cxx. ◆ Terminate(). void RWebWindowsManager::Terminate ; (; ). Terminate http server and ROOT application. ; Definition at line 851 of file RWebWindowsManager.cxx. ◆ Unregister(). void RWebWindowsManager::Unregister ; (; RWebWindow & ; win). private . Release all references to specified window Called from RWebWindow destructor. ; Definition at line 591 of file RWebWindowsManager.cxx. ◆ WaitFor(). int RWebWindowsManager::WaitFor ; (; RWebWindow & ; win, . WebWindowWaitFunc_t ; check, . bool ; timed = false, . double ; timelimit = -1 . ). private . Waits until provided check function or lambdas returns non-zero value Regularly calls WebWindow::Sync() method to let run event loop If call from the main thread, runs system events processing C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html:17917,load,loaded,17917,doc/v632/classROOT_1_1RWebWindowsManager.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowsManager.html,1,['load'],['loaded']
Performance,"regateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooArgusBG.html:1897,cache,cacheUniqueSuffix,1897,root/html602/RooArgusBG.html,https://root.cern,https://root.cern/root/html602/RooArgusBG.html,88,['cache'],['cacheUniqueSuffix']
Performance,"reground color. void DrawText(Int_t x, Int_t y, Float_t angle, Float_t mgn, const char* text, TVirtualX::ETextMode mode); Draw text using TrueType fonts. If TrueType fonts are not available the; text is drawn with TGX11::DrawText. XImage * GetBackground(Int_t x, Int_t y, UInt_t w, UInt_t h); Get the background of the current window in an XImage. Bool_t IsVisible(Int_t x, Int_t y, UInt_t w, UInt_t h); Test if there is really something to render. void RenderString(Int_t x, Int_t y, TVirtualX::ETextMode mode); Perform the string rendering in the pad.; LayoutGlyphs should have been called before. void SetTextFont(Font_t fontnumber); Set specified font. Int_t SetTextFont(char* fontname, TVirtualX::ETextSetMode mode); Set text font to specified name.; mode : loading flag; mode=0 : search if the font exist (kCheck); mode=1 : search the font and load it if it exists (kLoad); font : font name. Set text font to specified name. This function returns 0 if; the specified font is found, 1 if not. void SetTextSize(Float_t textsize); Set current text size. FontStruct_t LoadQueryFont(const char* font_name); Parses an XLFD name and opens a font. void DeleteFont(FontStruct_t fs); Explicitely delete font structure obtained with LoadQueryFont(). Int_t TextWidth(FontStruct_t font, const char* s, Int_t len); Return lenght of string in pixels. Size depends on font. void GetFontProperties(FontStruct_t font, Int_t& max_ascent, Int_t& max_descent); Return some font properties. void DrawString(Drawable_t id, GContext_t gc, Int_t x, Int_t y, const char* s, Int_t len); Draw text string. TGX11TTF(const TGX11& org). virtual ~TGX11TTF(); { }. » Author: Olivier Couet 01/10/02 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/x11ttf:$Id: TGX11TTF.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:16; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGX11TTF.html:26564,Load,LoadQueryFont,26564,root/html532/TGX11TTF.html,https://root.cern,https://root.cern/root/html532/TGX11TTF.html,2,['Load'],['LoadQueryFont']
Performance,"regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped; Returns 0 branch dropped or not in cache; -1 on error. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:24477,cache,cache,24477,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['cache'],['cache']
Performance,"relation matrix to use; in the method. Only the Likelihood; Method can make proper use of independent; transformations of signal and background; fNbinsMVAPdf = 50 Number of bins used to create a PDF of MVA; fNsmoothMVAPdf = 2 Number of times a histogram is smoothed before creating the PDF; fHasMVAPdfs create PDFs for the MVA outputs; V for Verbose output (!V) for non verbos; H for Help message. void ProcessBaseOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". void CreateVariableTransforms(const TString& trafoDefinition, TMVA::DataSetInfo& dataInfo, TMVA::TransformationHandler& transformationHandler, TMVA::MsgLogger& log); create variable transformations. void DeclareCompatibilityOptions(). std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument; This is just a dummy .. have a look at the MethodBDT how you could; perhaps implment the same thing for the other Classifiers.. void TrainMethod(). void GetRegressionDeviation(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t *const err, Double_t *const errUpper). Double_t GetMvaValue(const TMVA::Event *const ev, Double_t* err = 0, Double_t* errUpper = 0). Bool_t IsSignalLike(). Bool_t IsSignalLike(Double_t mvaVal). void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddClassifierOutputProb(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodBase.html:22122,tune,tuneParameters,22122,root/html530/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodBase.html,3,['tune'],['tuneParameters']
Performance,"removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidreplaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsArg(); RooAbsArg(const char* name, const char* title); RooAbsArg(const RooAbsArg& other, const char* name = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*serverIterator() const; RooFIterserverMIterator() const; virtual voidserverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidsetAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidsetDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidsetExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetLocalNoDirtyInhibit(Bool_t flag) const; virtual voidSetName(const char* name); virtual voidSetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidsetOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetProhibitServerRedirect(Bool_t flag); voidsetShapeDirty() const; voidsetStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidsetTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetValueDirty() const; TIterator*shapeClientIterator() const; RooFItershapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsArg.html:13119,cache,cache,13119,root/html602/RooAbsArg.html,https://root.cern,https://root.cern/root/html602/RooAbsArg.html,4,['cache'],['cache']
Performance,"rence Guide ; .  . Loading...; Searching...; No Matches. Namespaces ; rf204b_extendedLikelihood_rangedFit.py File ReferenceTutorials » RooFit Tutorials. Detailed Description; This macro demonstrates how to set up a fit in two ranges for plain likelihoods and extended likelihoods. . 1. Shape fits (plain likelihood); If you fit a non-extended pdf in two ranges, e.g. pdf.fitTo(data,Range=""Range1,Range2""), it will fit the shapes in the two selected ranges and also take into account the relative predicted yields in those ranges.; This is useful for example to represent a full-range fit, but with a blinded signal region inside it. 2. Shape+rate fits (extended likelihood); If your pdf is extended, i.e. measuring both the distribution in the observable as well as the event count in the fitted region, some intervention is needed to make fits in ranges work in a way that corresponds to intuition.; If an extended fit is performed in a sub-range, the observed yield is only that of the subrange, hence the expected event count will converge to a number that is smaller than what's visible in a plot. In such cases, it is often preferred to interpret the extended term with respect to the full range that's plotted, i.e., apply a correction to the extended likelihood term in such a way that the interpretation of the expected event count remains that of the full range. This can be done by applying a correcion factor (equal to the fraction of the pdf that is contained in the fitted range) in the Poisson term that represents the extended likelihood term.; If an extended likelihood fit is performed over two sub-ranges, this correction is even more important: without it, each component likelihood would have a different interpretation of the expected event count (each corresponding to the count in its own region), and a joint fit of these regions with different interpretations of the same model parameter results in a number that is not easily interpreted.; If both regions correct their inte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html:1027,perform,performed,1027,doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,https://root.cern,https://root.cern/doc/master/rf204b__extendedLikelihood__rangedFit_8py.html,1,['perform'],['performed']
Performance,"renced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TObjArrayfAjiarray of pointers to predictions of real template distributions; Double_tfChisquareTemplate fit chisquare; TH1*fDatapointer to the ""data"" histogram to be fitted to; vector<Int_t>fExcludedBinsbins excluded from the fit; Bool_tfFitDoneflags whether a valid fit has been performed; ROOT::Fit::Fitter*fFractionFitterpointer to Fitter class; Double_t*fFractionstemplate fractions scaled to the ""data"" histogram statistics; Int_tfHighLimitXlast bin in X dimension; Int_tfHighLimitYlast bin in Y dimension; Int_tfHighLimitZlast bin in Z dimension; Double_tfIntegralData""data"" histogram content integral over allowed fit range; Double_t*fIntegralMCssame for template histograms (weights not taken into account); Int_tfLowLimitXfirst bin in X dimension; Int_tfLowLimitYfirst bin in Y dimension; Int_tfLowLimitZfirst bin in Z dimension; TObjArrayfMCsarray of pointers to template histograms; Int_tfNDFNumber of degrees of freedom in the fit; Int_tfNparnumber of fit parameters; Int_tfNpfitsNumber of points used in the fit; TH1*fPlotpointer to histogram containing summed template predictions; TObjArrayfWeightsarray of pointers to corresponding weight factors (may be null). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFractionFitter(); TFractionFitter default constructor. TFractionFitter(TH1* data, TObjArray* MCs, Option_t* option = """"); TFractionFitter constructor. Does a complete initialisation (including; consistency checks, default fit range as the whole histogram but without; under- and overflows, and declaration of the fit p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFractionFitter.html:12123,perform,performed,12123,root/html602/TFractionFitter.html,https://root.cern,https://root.cern/root/html602/TFractionFitter.html,4,['perform'],['performed']
Performance,"rent geometry; - Current Directory in memory; - Current Directory on file. TObject * FindObjectAny(const char* name) const; Return a pointer to the first object with name starting at //root.; This function scans the list of all folders.; if no object found in folders, it scans the memory list of all files. TObject * FindObjectAnyFile(const char* name) const; Scan the memory lists of all files for an object with name. const char * FindObjectClassName(const char* name) const; Returns class name of a ROOT object including CINT globals. const char * FindObjectPathName(const TObject* obj) const; Return path name of obj somewhere in the //root/... path.; The function returns the first occurence of the object in the list; of folders. The returned string points to a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in their area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:25569,load,load,25569,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['load'],['load']
Performance,"rent geometry; - List of shapes in current geometry; - List of matrices in current geometry; - List of Nodes in current geometry; - Current Directory in memory; - Current Directory on file. TObject * FindObjectAny(const char* name) const; Return a pointer to the first object with name starting at //root.; This function scans the list of all folders.; if no object found in folders, it scans the memory list of all files. const char * FindObjectClassName(const char* name) const; Returns class name of a ROOT object including CINT globals. const char * FindObjectPathName(const TObject* obj) const; Return path name of obj somewhere in the //root/... path.; The function returns the first occurence of the object in the list; of folders. The returned string points to a static char array in TROOT.; If this function is called in a loop or recursively, it is the; user's responsability to copy this string in his area. TClass * FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; return a TClass object corresponding to 'name' assuming it is an STL container.; In particular we looking for possible alternative name (default template; parameter, typedefs template arguments, typedefed name). TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class with name. Obsolete, use TClass::GetClass directly. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; Return pointer to class from its name. Obsolete, use TClass::GetClass directly; See TClass::GetClass. TColor * GetColor(Int_t color) const; Return address of color with index color. TCanvas * MakeDefCanvas() const; Return a default canvas. TDataType * GetType(const char* name, Bool_t load = kFALSE) const; Return pointer to type with name. TFile * GetFile(const char* name) const; Return pointer to file with name. TStyle * GetStyle(const char* name) const; Return pointer to style with name. TObject * GetFunction(const ch",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TROOT.html:22264,load,load,22264,root/html528/TROOT.html,https://root.cern,https://root.cern/root/html528/TROOT.html,1,['load'],['load']
Performance,"rent process in case of failure. void ResolveKeywords(TString& fname, const char* path = 0); Replace <ord>, <user>, <u>, <group>, <stag>, <qnum> and <file> placeholders in fname. Int_t GetSessionStatus(); Return the status of this session:; 0 idle; 1 running; 2 being terminated (currently unused); 3 queued; 4 idle timed-out (not set in here but in TIdleTOTimer::Notify); This is typically run in the reader thread, so access needs to be protected. Int_t UpdateSessionStatus(Int_t xst = -1); Update the session status in the relevant file. The status is taken from; GetSessionStatus() unless xst >= 0, in which case xst is used.; Return 0 on success, -errno if the file could not be opened. Bool_t IsIdle(); Return the idle status. void SetIdle(Bool_t st = kTRUE); Change the idle status. Bool_t IsWaiting(); Return kTRUE if the session is waiting for the OK to start processing. Int_t WaitingQueries(); Return the number of waiting queries. Int_t QueueQuery(TProofQueryResult* pq); Add a query to the waiting list; Returns the number of queries in the list. TProofQueryResult * NextQuery(); Get the next query from the waiting list.; The query is removed from the list. Int_t CleanupWaitingQueries(Bool_t del = kTRUE, TList* qls = 0); Cleanup the waiting queries list. The objects are deleted if 'del' is true.; If 'qls' is non null, only objects in 'qls' are removed.; Returns the number of cleanup queries. void SetLastMsg(const char* lastmsg); Set the message to be sent back in case of exceptions. Long_t GetVirtMemMax(); VirtMemMax getter. Long_t GetResMemMax(); ResMemMax getter. Float_t GetMemHWM(); MemHWM getter. Float_t GetMemStop(); MemStop getter. Int_t GetCompressionLevel() const. TProof * GetProof() const; { return fProof; }. const char * GetService() const; { return fService; }. const char * GetConfDir() const; { return fConfDir; }. const char * GetConfFile() const; { return fConfFile; }. const char * GetUser() const; { return fUser; }. const char * GetGroup() const; { return f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofServ.html:30547,Queue,QueueQuery,30547,root/html532/TProofServ.html,https://root.cern,https://root.cern/root/html532/TProofServ.html,1,['Queue'],['QueueQuery']
Performance,"rent window. ; Otherwise creates pixmap from gif file ; Reimplemented in TGWin32, TGX11, and TGCocoa.; Definition at line 607 of file TVirtualX.cxx. ◆ ReadPictureDataFromFile(). Bool_t TVirtualX::ReadPictureDataFromFile ; (; const char * ; filename, . char *** ; ret_data . ). virtual . Reads picture data from file ""filename"" and store it in ""ret_data"". ; Returns kTRUE in case of success, kFALSE otherwise. ; Reimplemented in TGCocoa, TGWin32, TGWin32VirtualXProxy, and TGX11.; Definition at line 1464 of file TVirtualX.cxx. ◆ RemoveWindow(). void TVirtualX::RemoveWindow ; (; ULongptr_t ; qwid). virtual . Removes the created by Qt window ""qwid"". ; Reimplemented in TGCocoa, TGX11, TGWin32, and TGWin32VirtualXProxy.; Definition at line 570 of file TVirtualX.cxx. ◆ ReparentWindow(). void TVirtualX::ReparentWindow ; (; Window_t ; id, . Window_t ; pid, . Int_t ; x, . Int_t ; y . ). virtual . If the specified window is mapped, ReparentWindow automatically performs an UnmapWindow request on it, removes it from its current position in the hierarchy, and inserts it as the child of the specified parent. ; The window is placed in the stacking order on top with respect to sibling windows. ; Reimplemented in TGWin32, TGWin32VirtualXProxy, TGX11, and TGCocoa.; Definition at line 1138 of file TVirtualX.cxx. ◆ RequestLocator(). Int_t TVirtualX::RequestLocator ; (; Int_t ; mode, . Int_t ; ctyp, . Int_t & ; x, . Int_t & ; y . ). virtual . Requests Locator position. ; Parameters. [in]x,ycursor position at moment of button press (output) ; [in]ctypcursor type (input); ctyp = 1 tracking cross; ctyp = 2 cross-hair; ctyp = 3 rubber circle; ctyp = 4 rubber band; ctyp = 5 rubber rectangle. [in]modeinput mode; mode = 0 request; mode = 1 sample. Returns; in request mode:; 1 = left is pressed; 2 = middle is pressed; 3 = right is pressed. in sample mode:; 11 = left is released; 12 = middle is released; 13 = right is released; -1 = nothing is pressed or released; -2 = leave the window; else = keycode",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTVirtualX.html:112346,perform,performs,112346,doc/master/classTVirtualX.html,https://root.cern,https://root.cern/doc/master/classTVirtualX.html,1,['perform'],['performs']
Performance,"replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheAllNumeric(Int_t ndim); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheNumeric(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:21989,cache,cache,21989,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,1,['cache'],['cache']
Performance,"replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidsetCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidsetEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidsetIntegratorConfig(); voidsetIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*sigma(RooRealVar& obs); RooMoment*sigma(RooRealVar& obs, const RooArgSet& nset); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsReal.html:22002,cache,cache,22002,root/html530/RooAbsReal.html,https://root.cern,https://root.cern/root/html530/RooAbsReal.html,1,['cache'],['cache']
Performance,"represents the running integral of the function over one or more observables listed in iset, i.e. int[x_lo,x] f(x_prime) dx_prime. The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The default strategy to calculate the running integrals is. - If the integrand (this object) supports analytical integration, construct an integral object; that calculate the running integrals value by calculating the analytical integral each; time the running integral object is evaluated. - If the integrand (this object) requires numeric integration to construct the running integral; create an object of class RooNumRunningInt which first samples the entire function and integrates; the sampled function numerically. This method has superior performance as there is no need to; perform a full (numeric) integration for each evaluation of the running integral object, but; only when one of its parameters has changed. The choice of strategy can be changed with the ScanAll() argument, which forces the use of the; scanning technique implemented in RooNumRunningInt for all use cases, and with the ScanNone(); argument which forces the 'integrate each evaluation' technique for all use cases. The sampling; granularity for the scanning technique can be controlled with the ScanParameters technique; which allows to specify the number of samples to be taken, and to which order the resulting; running integral should be interpolated. The default values are 1000 samples and 2nd order; interpolation. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation appli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsReal.html:66329,perform,performance,66329,root/html526/RooAbsReal.html,https://root.cern,https://root.cern/root/html526/RooAbsReal.html,20,['perform'],"['perform', 'performance']"
Performance,requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; vector<double>_low; static Int_tRooPrintable::_nameLength; double_nominal; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_paramIter! do not persist; RooListProxy_paramList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shape,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HistFactory__LinInterpVar.html:31428,cache,cache,31428,root/html528/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html528/RooStats__HistFactory__LinInterpVar.html,2,['cache'],['cache']
Performance,requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; vector<double>_low; static Int_tRooPrintable::_nameLength; double_nominal; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_paramIter! do not persist; RooListProxy_paramList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input s,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__LinInterpVar.html:31928,cache,cache,31928,root/html532/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__LinInterpVar.html,2,['cache'],['cache']
Performance,requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; vector<int>_interpCode; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; vector<double>_low; static Int_tRooPrintable::_nameLength; double_nominal; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_paramIter! do not persist; RooListProxy_paramList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalcula,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HistFactory__FlexibleInterpVar.html:31927,cache,cache,31927,root/html530/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html530/RooStats__HistFactory__FlexibleInterpVar.html,1,['cache'],['cache']
Performance,requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; vector<int>_interpCode; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; vector<double>_low; static Int_tRooPrintable::_nameLength; double_nominal; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_paramIter! do not persist; RooListProxy_paramList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recal,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__FlexibleInterpVar.html:32302,cache,cache,32302,root/html532/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__FlexibleInterpVar.html,2,['cache'],['cache']
Performance,requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooRealProxy_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; int_l1; int_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; int_m1; int_m2; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumer,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooLegendre.html:31152,cache,cache,31152,root/html528/RooLegendre.html,https://root.cern,https://root.cern/root/html528/RooLegendre.html,2,['cache'],['cache']
Performance,requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooRealProxy_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; int_l1; int_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; int_m1; int_m2; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigN,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooLegendre.html:31652,cache,cache,31652,root/html532/RooLegendre.html,https://root.cern,https://root.cern/root/html532/RooLegendre.html,2,['cache'],['cache']
Performance,"requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSize = GetCacheAutoSize(true);; 8729 }; 8730 }; 8731 ; 8732 TFile* file = GetCurrentFile();; 8733 if (!file || GetTree() != this) {; 8734 // if there's no file or we are not a plain tree (e.g. if we're a TChain); 8735 // do not create a cache, only record the size if one was given; 8736 if (!autocache) {; 8737 fCacheSize = cacheSize;; 8738 }; 8739 if (GetTree() != this) {; 8740 return 0;; 8741 }; 8742 if (!autocache && cacheSize>0) {; 8743 Warning(""SetCacheSizeAux"", ""A TTreeCache could not be created because the TTree has no file"");; 8744 }; 8745 return 0;; 8746 }; 8747 ; 8748 // Check for an existing cache; 8749 TTreeCache* pf = GetReadCache(file);; 8750 if (pf) {; 8751 if (autocache) {; 8752 // reset our cache status tracking in case existing cache was added; 8753 // by the user without using one of the TTree methods; 8754 fCacheSize = pf->GetBufferSize();; 8755 fCacheUserSet = !pf->IsAutoCreated();; 8756 ; 8757 if (fCacheUserSet) {; 8758 // existing cache was created by the user, don't change it; 8759 return 0;; 8760 }; 8761 } else {; 8762 // update the cache to ensure it records the user has explicitly; 8763 // requested it; 8764 pf->SetAutoCreated(false);; 8765 }; 8766 ; 8767 // if we're using an automatically calculated size and the existing; 8768 // cache is already almost large enough don't resize; 8769 if (autocache && Long64_t(0.80*cacheSize) < fCacheSize) {; 8770 // already large enough; 8771 return 0;; 8772 }; 8773 ; 8774 if (cacheSize == fCacheSize) {; 8775 return 0;; 8776 }; 8777 ; 8778 if (cacheSize == 0) {; 8779 // delete existing cache; 8780 pf->WaitFinishPrefetch();; 8781 file->SetCacheRead(nullptr,this);; 8782 delete pf;; 8783 pf = nullptr;; 8784 } else {; 8785 // resize; 8786 Int_t res = pf->SetBufferSize(cacheSize);; 8787 if (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:340107,cache,cache,340107,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,9,['cache'],"['cache', 'cacheSize']"
Performance,"requests. void HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; prioroty is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific group (e.g. promptana); a higher priority than users in other groups, and on the analysis; of historical logging data (i.e. usage of CPU by the group in a; previous time slot, as recorded in TPerfStats::WriteQueryLog()). Currently the group priority is obtained by a query in a SQL DB; table proofpriority, which has the format:; CREATE TABLE proofpriority (; id INT NOT NULL PRIMARY KEY AUTO_INCREMENT,; group VARCHAR(32) NOT NULL,; priority INT; ). Int_t SendAsynMessage(const char* msg, Bool_t lf = kTRUE); Send an asychronous message to the master / client .; Masters will forward ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:27311,cache,cache,27311,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['cache'],['cache']
Performance,"resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsAnaConvPdf.html:29384,cache,cache,29384,root/html530/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsAnaConvPdf.html,56,['cache'],['cache']
Performance,"resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidsetOptions(TString options); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/Roo2DKeysPdf.html:27649,cache,cache,27649,root/html530/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html530/Roo2DKeysPdf.html,1,['cache'],['cache']
Performance,"resetErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); voidsetNoRounding(bool flag = kTRUE); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooPoisson.html:27204,cache,cache,27204,root/html530/RooPoisson.html,https://root.cern,https://root.cern/root/html530/RooPoisson.html,1,['cache'],['cache']
Performance,"resholds(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Double_t*_coefThresh[_nComp] Array of coefficient thresholds ; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; TList_gcListList of component generator contexts; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_t_isModelAre we generating from a RooAddPdf or a RooAddModel; Bool_tRooAbsGenContext::_isValidIs context in valid state?; Int_t_nCompNumber of PDF components; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; RooAbsPdf*_pdfPointer to cloned p.d.f; RooArgSet*_pdfSetSet owned all nodes of internal clone of p.d.f; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; const RooArgSet*_vars; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAddGenContext(const RooAddPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddGenContext.html:8328,load,load,8328,root/html528/RooAddGenContext.html,https://root.cern,https://root.cern/root/html528/RooAddGenContext.html,2,['load'],['load']
Performance,ress is a pointer to an addressDefinition TChainElement.h:43; TChainElement::SetLoadResultvoid SetLoadResult(Int_t result)Definition TChainElement.h:76; TChainElement::fEntriesLong64_t fEntriesNumber of entries in the tree of this chain element.Definition TChainElement.h:36; TChainElement::fDecomposedObjbool fDecomposedObj! True if the address needs the branch in MakeClass/DecomposedObj mode.Definition TChainElement.h:44; TChainElement::SetBaddressClassNamevirtual void SetBaddressClassName(const char *clname)Definition TChainElement.h:70; TChainElement::GetEntriesvirtual Long64_t GetEntries() constDefinition TChainElement.h:60; TChainElement::SetCheckedTypevoid SetCheckedType(bool m)Definition TChainElement.h:74; TChainElement::GetPacketsvirtual char * GetPackets() constDefinition TChainElement.h:64; TChainElement::fPacketSizeInt_t fPacketSizeNumber of events in one packet for parallel root.Definition TChainElement.h:38; TChainElement::fBranchPtrTBranch ** fBranchPtr! Address of user branch pointer (to updated upon loading a file)Definition TChainElement.h:47; TChainElement::SetPacketSizevirtual void SetPacketSize(Int_t size=100)Set number of entries per packet for parallel root.Definition TChainElement.cxx:92; TChainElement::~TChainElement~TChainElement() overrideDefault destructor for a chain element.Definition TChainElement.cxx:57; TChainElement::fNPacketsInt_t fNPacketsNumber of packets.Definition TChainElement.h:37; TChainElement::fPacketschar * fPackets! Packet descriptor stringDefinition TChainElement.h:46; TChainElement::EStatusBitsEStatusBitsTChainElement status bits.Definition TChainElement.h:31; TChainElement::kHasBeenLookedUp@ kHasBeenLookedUpDefinition TChainElement.h:32; TChainElement::SetDecomposedObjvoid SetDecomposedObj(bool m)Definition TChainElement.h:75; TChainElement::HasBeenLookedUpvirtual bool HasBeenLookedUp()Definition TChainElement.h:67; TChainElement::SetStatusvirtual void SetStatus(Int_t status)Definition TChainElement.h:80; TChainElement,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChainElement_8h_source.html:7514,load,loading,7514,doc/master/TChainElement_8h_source.html,https://root.cern,https://root.cern/doc/master/TChainElement_8h_source.html,1,['load'],['loading']
Performance,"ressDialogStatus ; (; ). inline . Definition at line 1021 of file TProof.h. ◆ RestoreActiveList(). Int_t TProof::RestoreActiveList ; (; ). private . Restore saved list of active workers. ; Definition at line 11557 of file TProof.cxx. ◆ Retrieve() [1/2]. Int_t TProof::Retrieve ; (; const char * ; ref, . const char * ; path = 0 . ). Send retrieve request for the query specified by ref. ; If path is defined save it to path. Generic method working for all queries known by the server. ; Definition at line 5967 of file TProof.cxx. ◆ Retrieve() [2/2]. Int_t TProof::Retrieve ; (; Int_t ; qry, . const char * ; path = 0 . ). Send retrieve request for the qry-th query in fQueries. ; If path is defined save it to path. ; Definition at line 5948 of file TProof.cxx. ◆ SaveActiveList(). void TProof::SaveActiveList ; (; ). private . Save current list of active workers. ; Definition at line 11542 of file TProof.cxx. ◆ SaveInputData(). Int_t TProof::SaveInputData ; (; TQueryResult * ; qr, . const char * ; cachedir, . TString & ; emsg . ). staticprotected . Save input data file from 'cachedir' into the sandbox or create a the file with input data objects. ; Definition at line 12311 of file TProof.cxx. ◆ SavePerfTree(). Int_t TProof::SavePerfTree ; (; const char * ; pf = 0, . const char * ; ref = 0 . ). Save performance information from TPerfStats to file 'pf'. ; If 'ref' is defined, do it for query 'ref'. Return 0 on sucecss, -1 in case of any error ; Definition at line 12646 of file TProof.cxx. ◆ SaveWorkerInfo(). void TProof::SaveWorkerInfo ; (; ). protectedvirtual . Save information about the worker set in the file .workers in the working dir. ; Called each time there is a change in the worker setup, e.g. by TProof::MarkBad(). ; Definition at line 11808 of file TProof.cxx. ◆ SendCommand(). Int_t TProof::SendCommand ; (; const char * ; cmd, . ESlaves ; list = kActive . ). private . Send command to be executed on the PROOF master and/or slaves. ; Command can be any legal command line ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:135649,cache,cachedir,135649,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['cache'],['cachedir']
Performance,"ressing the left mouse button near to its center and moving it to a new desire position.; ""Minimization"" Tab; ""Library"" group allows you to use Minuit, Minuit2 or Fumili minimization packages for your fit. ""Minuit"" - the popular Minuit minimization package. ""Minuit2"" - a new object-oriented implementation of Minuit in C++. ""Fumili"" - the popular Fumili minimization package.; ""Method"" group has currently restricted functionality. ""MIGRAD"" method is available for Minuit and Minuit2 ""FUMILI"" method is available for Fumili and Minuit2 ""SIMPLEX"" method is disabled (will come with the new fitter design); ""Minimization Settings' group allows users to set values for:; ""Error definition"" - between 0.0 and 100.0 (default is 1.0).; ""Maximum tolerance"" - the fit relative precision in use.; ""Maximum number of iterations"" - default is 5000. Print options:; ""Default"" - between Verbose and Quiet.; ""Verbose"" - prints results after each iteration.; ""Quiet"" - no fit information is printed.; Fit button - performs a fit. Reset - resets all GUI elements and related fit settings to the default ones. Close - closes this window. ; Definition at line 54 of file TFitEditor.h. Classes; struct  FuncParamData_t;  . Public Types; typedef std::vector< FuncParamData_t > FuncParams_t;  ;  Public Types inherited from TGWindow; enum  EEditMode { ;   kEditEnable = 0; , kEditDisable = (1ULL << ( 0 )); , kEditDisableEvents = (1ULL << ( 1 )); , kEditDisableGrab = (1ULL << ( 2 )); , ;   kEditDisableLayout = (1ULL << ( 3 )); , kEditDisableResize = (1ULL << ( 4 )); , kEditDisableHeight = (1ULL << ( 5 )); , kEditDisableWidth = (1ULL << ( 6 )); , ;   kEditDisableBtnEnable = (1ULL << ( 7 )); , kEditDisableKeyEnable = (1ULL << ( 8 )). };  ; enum  EStatusBits { kIsHtmlView = (1ULL << ( 14 )); };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFitEditor.html:4372,perform,performs,4372,doc/master/classTFitEditor.html,https://root.cern,https://root.cern/doc/master/classTFitEditor.html,1,['perform'],['performs']
Performance,"ression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual TString GetNewUrl ();  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; virtual Long64_t GetSeekFree () const;  ; virtual Long64_t GetSeekInfo () const;  ; virtual Long64_t GetSize () const;  Returns the current file size. ;  ; const TList * GetStreamerInfoCache ();  Returns the cached list of StreamerInfos used in this file. ;  ; virtual TList * GetStreamerInfoList () final;  Read the list of TStreamerInfo objects written to this file. ;  ; Int_t GetVersion () const;  ; virtual void IncrementProcessIDs ();  ; virtual Bool_t IsArchive () const;  ; Bool_t IsBinary () const;  ; Bool_t IsRaw () const;  ; void ls (Option_t *option="""") const override;  List file contents. ;  ; virtual void MakeFree (Long64_t first, Long64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual void ReadFree ();  Read the FREE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetFile.html:6568,cache,cached,6568,doc/master/classTNetFile.html,https://root.cern,https://root.cern/doc/master/classTNetFile.html,1,['cache'],['cached']
Performance,"rest (return nullptr if not existing) ;  ; RooAbsPdf * GetPdf () const;  get model PDF (return nullptr if pdf has not been specified or does not exist) ;  ; RooAbsPdf * GetPriorPdf () const;  get parameters prior pdf (return nullptr if not existing) ;  ; RooAbsData * GetProtoData () const;  get Proto data set (return nullptr if not existing) ;  ; const RooArgSet * GetSnapshot () const;  get RooArgSet for parameters for a particular hypothesis (return nullptr if not existing) ;  ; RooWorkspace * GetWorkspace () const;  alias for GetWS() ;  ; RooWorkspace * GetWS () const override;  get from TRef ;  ; void GuessObsAndNuisance (const RooAbsData &data, bool printModelConfig=true);  Makes sensible guesses of observables, parameters of interest and nuisance parameters if one or multiple have been set by the creator of this ModelConfig. ;  ; TClass * IsA () const override;  ; void LoadSnapshot () const;  load the snapshot from ws if it exists ;  ; void Print (Option_t *option="""") const override;  overload the print method ;  ; void ReplaceWS (RooWorkspace *ws) override;  Remove the existing reference to a workspace and replace it with this new one. ;  ; virtual void SetConditionalObservables (const char *argList);  Specify the conditional observables through a comma-separated list of arguments already in the workspace. ;  ; virtual void SetConditionalObservables (const RooArgSet &set);  Specify the conditional observables. ;  ; virtual void SetConstraintParameters (const char *argList);  Specify the constraint parameters through a comma-separated list of arguments already in the workspace. ;  ; virtual void SetConstraintParameters (const RooArgSet &set);  Specify the constraint parameters. ;  ; virtual void SetExternalConstraints (const char *argList);  Specify the external constraints through a comma-separated list of arguments already in the workspace. ;  ; void SetExternalConstraints (const RooArgSet &set);  Specify the external constraints. ;  ; virtual void SetGlobalO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1ModelConfig.html:4710,load,load,4710,doc/master/classRooStats_1_1ModelConfig.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1ModelConfig.html,1,['load'],['load']
Performance,"resultPtr.GetValue() << std::endl;; 1270}; 1271~~~; 1272 ; 1273See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); 1274for a more complete example.; 1275 ; 1276#### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); 1277 ; 1278Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; 1279executes the callable on the values of those columns for each event that passes all upstream selections.; 1280It can be used to perform actions that are not already available in the interface. For example, the following snippet; 1281evaluates the root mean square of column ""x"":; 1282~~~{.cpp}; 1283// Single-thread evaluation of RMS of column ""x"" using Foreach; 1284double sumSq = 0.;; 1285unsigned int n = 0;; 1286df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1287std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1288~~~; 1289In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1290thread will execute the expression concurrently.; 1291The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1292this is probably too much head-scratch for such a simple operation.; 1293 ; 1294ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1295additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; 1296guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; 1297executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; 1298We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; 1299~~~{.cpp}; 1300// Thread-safe evaluation of RMS of column ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:74642,multi-thread,multi-thread,74642,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,2,"['concurren', 'multi-thread']","['concurrently', 'multi-thread']"
Performance,"resultPtr.GetValue() << std::endl;; 1310}; 1311~~~; 1312 ; 1313See the Book() method for more information and [this tutorial](https://root.cern/doc/master/df018__customActions_8C.html); 1314for a more complete example.; 1315 ; 1316#### Injecting arbitrary code in the event loop with Foreach() and ForeachSlot(); 1317 ; 1318Foreach() takes a callable (lambda expression, free function, functor...) and a list of columns and; 1319executes the callable on the values of those columns for each event that passes all upstream selections.; 1320It can be used to perform actions that are not already available in the interface. For example, the following snippet; 1321evaluates the root mean square of column ""x"":; 1322~~~{.cpp}; 1323// Single-thread evaluation of RMS of column ""x"" using Foreach; 1324double sumSq = 0.;; 1325unsigned int n = 0;; 1326df.Foreach([&sumSq, &n](double x) { ++n; sumSq += x*x; }, {""x""});; 1327std::cout << ""rms of x: "" << std::sqrt(sumSq / n) << std::endl;; 1328~~~; 1329In multi-thread runs, users are responsible for the thread-safety of the expression passed to Foreach():; 1330thread will execute the expression concurrently.; 1331The code above would need to employ some resource protection mechanism to ensure non-concurrent writing of `rms`; but; 1332this is probably too much head-scratch for such a simple operation.; 1333 ; 1334ForeachSlot() can help in this situation. It is an alternative version of Foreach() for which the function takes an; 1335additional ""processing slot"" parameter besides the columns it should be applied to. RDataFrame; 1336guarantees that ForeachSlot() will invoke the user expression with different `slot` parameters for different concurrent; 1337executions (see [Special helper columns: rdfentry_ and rdfslot_](\ref helper-cols) for more information on the slot parameter).; 1338We can take advantage of ForeachSlot() to evaluate a thread-safe root mean square of column ""x"":; 1339~~~{.cpp}; 1340// Thread-safe evaluation of RMS of column ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:76322,multi-thread,multi-thread,76322,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,2,"['concurren', 'multi-thread']","['concurrently', 'multi-thread']"
Performance,"resulting graph will be drawn into the current pad. If this function is used via the context menu, it recommended to create a new canvas/pad before invoking this function. ; Reimplemented from TF1.; Reimplemented in TF3.; Definition at line 91 of file TF2.h. ◆ ExecuteEvent(). void TF2::ExecuteEvent ; (; Int_t ; event, . Int_t ; px, . Int_t ; py . ). overridevirtual . Execute action corresponding to one event. ; This member function is called when a F2 is clicked with the locator ; Reimplemented from TF1.; Reimplemented in TF3.; Definition at line 316 of file TF2.cxx. ◆ FindMinMax(). Double_t TF2::FindMinMax ; (; Double_t * ; x, . bool ; findmax . ); const. protectedvirtual . Return minimum/maximum value of the function. ; To find the minimum on a range, first set this range via the SetRange function. If a vector x of coordinate is passed it will be used as starting point for the minimum. In addition on exit x will contain the coordinate values at the minimuma; If x is NULL or x is infinity or NaN, first, a grid search is performed to find the initial estimate of the minimum location. The range of the function is divided into fNpx and fNpy sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search The minimizer algorithm used (by default Minuit) can be changed by callinga ROOT::Math::Minimizer::SetDefaultMinimizerType("".."") Other option for the minimizer can be set using the static method of the MinimizerOptions class ; Reimplemented in TF3.; Definition at line 363 of file TF2.cxx. ◆ GetContour(). Int_t TF2::GetContour ; (; Double_t * ; levels = nullptr). virtual . Return contour values into array levels. ; The number of contour levels can be returned by getContourLevel ; Definition at line 326 of file TF2.cxx. ◆ GetContourLevel(). Double_t TF2::GetContourLevel ; (; Int_t ; level); const. virtual . Return the number of contour levels. ; Defini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF2.html:55442,perform,performed,55442,doc/master/classTF2.html,https://root.cern,https://root.cern/doc/master/classTF2.html,1,['perform'],['performed']
Performance,"ret->getAttMarker()->SetMarkerColor(markerColor) ;; 1849 if (markerStyle!=-999) ret->getAttMarker()->SetMarkerStyle(markerStyle) ;; 1850 if (markerSize!=-999) ret->getAttMarker()->SetMarkerSize(markerSize) ;; 1851 ; 1852 if ((fillColor != -999 || fillStyle != -999) && !drawOpt.Contains(""F"")) {; 1853 coutW(Plotting) << ""Fill color or style was set for plotting \"""" << GetName(); 1854 << ""\"", but these only have an effect when 'DrawOption(\""F\"")' for fill is used at the same time."" << std::endl;; 1855 }; 1856 ; 1857 // Move last inserted object to back to drawing stack if requested; 1858 if (pc.getInt(""moveToBack"") && frame->numItems()>1) {; 1859 frame->drawBefore(frame->getObject(0)->GetName(), frame->getCurve()->GetName());; 1860 }; 1861 ; 1862 return ret ;; 1863}; 1864 ; 1865 ; 1866 ; 1867/// Plotting engine function for internal use; 1868///; 1869/// Plot ourselves on given frame. If frame contains a histogram, all dimensions of the plotted; 1870/// function that occur in the previously plotted dataset are projected via partial integration,; 1871/// otherwise no projections are performed. Optionally, certain projections can be performed; 1872/// by summing over the values present in a provided dataset ('projData'), to correctly; 1873/// project out data dependents that are not properly described by the PDF (e.g. per-event errors).; 1874///; 1875/// The functions value can be multiplied with an optional scale factor. The interpretation; 1876/// of the scale factor is unique for generic real functions, for PDFs there are various interpretations; 1877/// possible, which can be selection with 'stype' (see RooAbsPdf::plotOn() for details).; 1878///; 1879/// The default projection behaviour can be overridden by supplying an optional set of dependents; 1880/// to project via RooFit command arguments.; 1881//_____________________________________________________________________________; 1882// coverity[PASS_BY_VALUE]; 1883RooPlot* RooAbsReal::plotOn(RooPlot *frame, PlotOpt ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:82113,perform,performed,82113,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['perform'],['performed']
Performance,"rete implementation of the ProposalFunction interface. ; It proposes points across the parameter space in the distribution of the given PDF.; To make Propose(xPrime, x) dependent on x, configure with PdfProposal::AddMapping(varToUpdate, valueToUse). For example, suppose we have:; // our parameter; RooRealVar p(""p"", ""p"", 5, 0, 10);; ; // create mean and sigma for gaussian proposal function; RooRealVar meanP(""meanP"", ""meanP"", 0, 10);; RooRealVar sigma(""sigma"", ""sigma"", 1, 0, 5);; RooGaussian pGaussian(""pGaussian"", ""pGaussian"", p, meanP, sigma);; ; // configure proposal function; PdfProposal pdfProposal(pGaussian);; pdfProposal.AddMapping(meanP, p); // each call of Propose(xPrime, x), meanP in; // the proposal function will be updated to; // the value of p in x. this will center the; // proposal function about x's p when; // proposing for xPrime; ; // To improve performance, PdfProposal has the ability to cache a specified; // number of proposals. If you don't call this function, the default cache size; // is 1, which can be slow.; pdfProposal.SetCacheSize(desiredCacheSize);; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStats::PdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface.Definition PdfProposal.h:30; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; PdfProposal currently uses a fixed cache size. Adaptive caching methods are in the works for future versions. ; Definition at line 30 of file PdfProposal.h. Public Member Functions;  PdfProposal ();  By default, PdfProposal does NOT own the PDF that serves as the proposal density function. ;  ;  PdfProposal (RooAbsPdf &pdf);  By default, PdfProposal does NOT own the PDF that serves as the proposal density function. ;  ;  ~PdfProposal () override;  ; virtual void AddMapping (RooRealVar &propos",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html:1371,cache,cache,1371,doc/master/classRooStats_1_1PdfProposal.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html,1,['cache'],['cache']
Performance,"reter = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); virtual TKey*TDirectory::FindKey(const char*) const; virtual TKey*TDirectory::FindKeyAny(const char*) const; virtual TObject*FindObject(const char* name) const; virtual TObject*FindObject(const TObject* obj) const; virtual TObject*FindObjectAny(const char* name) const; virtual TObject*FindObjectAnyFile(const char* name) const; const char*FindObjectClassName(const char* name) const; const char*FindObjectPathName(const TObject* obj) const; TObject*FindSpecialObject(const char* name, void*& where); TClass*FindSTLClass(const char* name, Bool_t load, Bool_t silent = kFALSE) const; voidForceStyle(Bool_t force = kTRUE); Bool_tFromPopUp() const; virtual TObject*TDirectory::Get(const char* namecycle); TApplication*GetApplication() const; virtual Int_tTDirectory::GetBufferSize() const; Int_tGetBuiltDate() const; Int_tGetBuiltTime() const; TClass*GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TClass*GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE) const; TSeqCollection*GetClipboard() const; TColor*GetColor(Int_t color) const; const char*GetConfigFeatures() const; const char*GetConfigOptions() const; const char*GetCutClassName() const; const char*GetDefCanvasName() const; virtual TDirectory*TDirectory::GetDirectory(const char* namecycle, Bool_t printError = false, const char* funcname = ""GetDirectory""); static Int_tGetDirLevel(); virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); Bool_tGetEditHistograms() const; Int_tGetEditorMode() const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TROOT.html:4710,load,load,4710,root/html534/TROOT.html,https://root.cern,https://root.cern/root/html534/TROOT.html,2,['load'],['load']
Performance,"reter itself. The Total time to read sample is the execution time of the script $ROOTSYS/test/eventb. This script loops on all events. For each event, the branch containing the number of tracks is read. In case the number of tracks is less than 585, the full event is read in memory. This test is obviously not possible in non-split mode. In non-split mode, the full event must be read in memory. The times reported in the table correspond to complete I/O operations necessary to deal with machine independent binary files. On Linux, this also includes byte-swapping operations. The ROOT file allows for direct access to any event in the file and direct access to any part of an event when split=1.; Note also that the uncompressed file generated with split=0 is 48.7 Mbytes and only 47.17 Mbytes for the option split=1. The difference in size is due to the object identification mechanism overhead when the event is written to a single buffer. This overhead does not exist in split mode because the branch buffers are optimized for homogeneous data types. You can run the test programs on your architecture. The program Event will report the write performance. You can measure the read performance by executing the scripts eventa and eventb. The performance depends not only of the processor type, but also of the disk devices (local, NFS, AFS, etc.).; 12.24 Chains. A TChain object is a list of ROOT files containing the same tree. As an example, assume we have three files called file1.root, file2.root, file3.root. Each file contains one tree called “T”. We can create a chain with the following statements:; TChain chain(""T""); // name of the tree is the argument; chain.Add(""file1.root"");; chain.Add(""file2.root"");; chain.Add(""file3.root"");; The name of the TChain will be the same as the name of the tree; in this case it will be ""T"". Note that twoobjects can have the same name as long as they are not histograms in the same directory, because there, the histogram names are used to build a ha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:650930,optimiz,optimized,650930,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['optimiz'],['optimized']
Performance,"retrieve from the cache the binaries associated with the file TProof::kCpBin; must be set in cpopt; the default is copy everything.; Returns kTRUE in case file needs to be send, returns kFALSE in case; file is already on remote node. Int_t SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); Send a file to master or slave servers. Returns number of slaves; the file was sent to, maybe 0 in case master and slaves have the same; file system image, -1 in case of error.; If defined, send to worker 'wrk' only.; If defined, the full path of the remote path will be rfile.; If rfile = ""cache"" the file is copied to the remote cache instead of the sandbox; (to copy to the cache on a different name use rfile = ""cache:newname"").; The mask 'opt' is an or of ESendFileOpt:. kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run); the bit is set by; UploadPackage, since the check is done elsewhere.; kForward (0x4) if set, ask server to forward the file to slave; or submaster (meaningless for slave servers).; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache. Int_t Echo(const TObject* obj); Sends an object to master and workers and expect them to send back a; message with the output of its TObject::Print(). Returns -1 on error, the; number of workers that received the objects on success. Int_t Echo(const char* str); Sends a string to master and workers and expect them to echo it back to; the client via a message. It is a special case of the generic Echo(); that works with TObjects. Returns -1 on error, the number of workers that; received the message on success. Int_t SendObject(const TObject* obj, TProof::ESlaves list = kActive); Send o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:65838,cache,cache,65838,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,2,['cache'],['cache']
Performance,"retrieve from the cache the binaries associated with the file TProof::kCpBin; must be set in cpopt; the default is copy everything.; Returns kTRUE in case file needs to be send, returns kFALSE in case; file is already on remote node. Int_t SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); Send a file to master or slave servers. Returns number of slaves; the file was sent to, maybe 0 in case master and slaves have the same; file system image, -1 in case of error.; If defined, send to worker 'wrk' only.; If defined, the full path of the remote path will be rfile.; If rfile = ""cache"" the file is copied to the remote cache instead of the sandbox; (to copy to the cache on a different name use rfile = ""cache:newname"").; The mask 'opt' is an or of ESendFileOpt:. kAscii (0x0) if set true ascii file transfer is used; kBinary (0x1) if set true binary file transfer is used; kForce (0x2) if not set an attempt is done to find out; whether the file really needs to be downloaded; (a valid copy may already exist in the cache; from a previous run); the bit is set by; UploadPackage, since the check is done elsewhere.; kForward (0x4) if set, ask server to forward the file to slave; or submaster (meaningless for slave servers).; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache. Int_t SendObject(const TObject* obj, TProof::ESlaves list = kActive); Send object to master or slave servers. Returns number of slaves object; was sent to, -1 in case of error. Int_t SendPrint(Option_t* option = """"); Send print command to master server. Returns number of slaves message; was sent to. Returns -1 in case of error. void SetLogLevel(Int_t level, UInt_t mask = TProofDebug::kAll); Set server logging level. void SetRealTimeLog(Bool_t on = kTRUE); Switch ON/OFF the real-time logging facility. When this option is; ON, log messages from processing are sent back as they come, i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:56871,cache,cache,56871,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['cache'],['cache']
Performance,"return RotationZYX ( Quaternion(*this) * q );; 72}; 73 ; 74RotationZYX RotationZYX::operator * (const RotationX & r) const {; 75 // combine with a RotationX; 76 return RotationZYX ( Quaternion(*this) * r );; 77}; 78 ; 79RotationZYX RotationZYX::operator * (const RotationY & r) const {; 80 // combine with a RotationY; 81 return RotationZYX ( Quaternion(*this) * r );; 82}; 83 ; 84RotationZYX RotationZYX::operator * (const RotationZ & r) const {; 85 // combine with a RotationZ; 86 // TODO -- this can be made much faster because it merely adds; 87 // the r.Angle() to phi.; 88 Scalar newPhi = fPhi + r.Angle();; 89 if ( newPhi <= -Pi()|| newPhi > Pi() ) {; 90 newPhi = newPhi - std::floor( newPhi/(2*Pi()) +.5 ) * 2*Pi();; 91 }; 92 return RotationZYX ( newPhi, fTheta, fPsi );; 93}; 94 ; 95RotationZYX operator * ( RotationX const & r, RotationZYX const & e ) {; 96 return RotationZYX(r) * e; // TODO: improve performance; 97}; 98 ; 99RotationZYX operator * ( RotationY const & r, RotationZYX const & e ) {; 100 return RotationZYX(r) * e; // TODO: improve performance; 101}; 102 ; 103RotationZYX; 104operator * ( RotationZ const & r, RotationZYX const & e ) {; 105 return RotationZYX(r) * e; // TODO: improve performance; 106}; 107 ; 108void RotationZYX::Rectify(); 109{; 110 // rectify . The angle theta must be defined between [-PI/2,PI.2]; 111 // same as Euler- Angles, just here Theta is shifted by PI/2 with respect to; 112 // the theta of the EulerAngles class; 113 ; 114 Scalar theta2 = fTheta + M_PI_2;; 115 if ( theta2 < 0 || theta2 > Pi() ) {; 116 Scalar t = theta2 - std::floor( theta2/(2*Pi() ) ) * 2*Pi();; 117 if ( t <= Pi() ) {; 118 theta2 = t;; 119 } else {; 120 theta2 = 2*Pi() - t;; 121 fPhi = fPhi + Pi();; 122 fPsi = fPsi + Pi();; 123 }; 124 // ftheta is shifted of PI/2 w.r.t theta2; 125 fTheta = theta2 - M_PI_2;; 126 }; 127 ; 128 if ( fPhi <= -Pi()|| fPhi > Pi() ) {; 129 fPhi = fPhi - std::floor( fPhi/(2*Pi()) +.5 ) * 2*Pi();; 130 }; 131 ; 132 if ( fPsi <= -Pi()|| fPsi > P",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RotationZYX_8cxx_source.html:3273,perform,performance,3273,doc/master/RotationZYX_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RotationZYX_8cxx_source.html,3,['perform'],['performance']
Performance,"return fClassVersion; }. Int_t GetClassSize() const; { return Size(); }. const char * GetDeclFileName() const; { return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TVirtualStreamerInfo * GetLastReadInfo() const; { return fLastReadInfo; }. void SetLastReadInfo(TVirtualStreamerInfo* info); { fLastReadInfo = info; }. TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOnHeap; }. TClass ** GetPersistentRef() const; { return fPersistentRef; }. TVirtualRefProxy * GetReferenceProxy() const; { return fRefProxy; }. ShowMembersFunc_t GetShowMembersWrapper() const; { return fShowMembers; }. TObjArray * GetStreamerInfos() const; { return fStreamerInfo; }. const type_info * GetTypeInfo() const; { return fTypeInfo; }. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsVersioned() const; { return !( GetClassVersion()<=1 && IsForeign() ); }. void ResetInstanceCount(); { fInstanceCount = fOnHeap = 0; }. void SetDeclFile(const char* name, int line); { fDeclFileName = name; fDeclFileLine = line; }. void SetImplFileName(const char* implFileName); { fImplFileName = implFileName; }. ENewType IsCallingNew(). void Streamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; Inline for performance, skipping one function call. » Author: Rene Brun 07/01/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-04-25 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TClass.html:52011,perform,performance,52011,root/html534/TClass.html,https://root.cern,https://root.cern/root/html534/TClass.html,2,['perform'],['performance']
Performance,"return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { if (fCanLoadClassInfo && !TestBit(kLoading)) LoadClassInfo(); return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TVirtualStreamerInfo * GetLastReadInfo() const; { return fLastReadInfo; }. void SetLastReadInfo(TVirtualStreamerInfo* info); { fLastReadInfo = info; }. TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOnHeap; }. TClass ** GetPersistentRef() const; { return fPersistentRef; }. TVirtualRefProxy * GetReferenceProxy() const; { return fRefProxy; }. ShowMembersFunc_t GetShowMembersWrapper() const; { return fShowMembers; }. EState GetState() const; { return fState; }. const TObjArray * GetStreamerInfos() const; { return fStreamerInfo; }. const type_info * GetTypeInfo() const; { return fTypeInfo; }. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsVersioned() const; { return !( GetClassVersion()<=1 && IsForeign() ); }. void ResetInstanceCount(); { fInstanceCount = fOnHeap = 0; }. void SetDeclFile(const char* name, int line); { fDeclFileName = name; fDeclFileLine = line; }. void SetImplFileName(const char* implFileName); { fImplFileName = implFileName; }. ENewType IsCallingNew(). void Streamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; Inline for performance, skipping one function call. » Author: Rene Brun 07/01/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 15:39; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TClass.html:67910,perform,performance,67910,root/html604/TClass.html,https://root.cern,https://root.cern/root/html604/TClass.html,2,['perform'],['performance']
Performance,"return fDeclFileName; }. Short_t GetDeclFileLine() const; { return fDeclFileLine; }. ClassInfo_t * GetClassInfo() const; { if (fCanLoadClassInfo && !TestBit(kLoading)) LoadClassInfo(); return fClassInfo; }. const char * GetContextMenuTitle() const; { return fContextMenuTitle; }. TVirtualStreamerInfo * GetCurrentStreamerInfo(). TVirtualStreamerInfo * GetLastReadInfo() const; { return fLastReadInfo; }. void SetLastReadInfo(TVirtualStreamerInfo* info); { fLastReadInfo = info; }. TList * GetListOfRealData() const; { return fRealData; }. const char * GetImplFileName() const; { return fImplFileName; }. Short_t GetImplFileLine() const; { return fImplFileLine; }. UInt_t GetInstanceCount() const; { return fInstanceCount; }. UInt_t GetHeapInstanceCount() const; { return fOnHeap; }. TClass ** GetPersistentRef() const; { return fPersistentRef; }. TVirtualRefProxy * GetReferenceProxy() const; { return fRefProxy; }. ShowMembersFunc_t GetShowMembersWrapper() const; { return fShowMembers; }. EState GetState() const; { return fState; }. const TObjArray * GetStreamerInfos() const; { return fStreamerInfo; }. const type_info * GetTypeInfo() const; { return fTypeInfo; }. Bool_t IsFolder() const; { return kTRUE; }. Bool_t IsVersioned() const; { return !( GetClassVersion()<=1 && IsForeign() ); }. void ResetInstanceCount(); { fInstanceCount = fOnHeap = 0; }. void SetDeclFile(const char* name, int line); { fDeclFileName = name; fDeclFileLine = line; }. void SetImplFileName(const char* implFileName); { fImplFileName = implFileName; }. ENewType IsCallingNew(). void Streamer(void* obj, TBuffer& b, const TClass* onfile_class = 0) const; Inline for performance, skipping one function call. » Author: Rene Brun 07/01/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-30 14:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:66813,perform,performance,66813,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['perform'],['performance']
Performance,"return kFALSE;; 259 if (!fPickleLoads) return kFALSE;; 260 return kTRUE;; 261}; 262 ; 263///////////////////////////////////////////////////////////////////////////////; 264/// Serialize Python object; 265///; 266/// \param[in] path Path where object is written to file; 267/// \param[in] obj Python object; 268///; 269/// The input Python object is serialized and written to a file. The Python; 270/// module `pickle` is used to do so.; 271 ; 272void PyMethodBase::Serialize(TString path, PyObject *obj); 273{; 274 if(!PyIsInitialized()) PyInitialize();; 275 ; 276 PyObject *file_arg = Py_BuildValue(""(ss)"", path.Data(),""wb"");; 277 PyObject *file = PyObject_CallObject(fOpen,file_arg);; 278 PyObject *model_arg = Py_BuildValue(""(OO)"", obj,file);; 279 PyObject *model_data = PyObject_CallObject(fPickleDumps , model_arg);; 280 ; 281 Py_DECREF(file_arg);; 282 Py_DECREF(file);; 283 Py_DECREF(model_arg);; 284 Py_DECREF(model_data);; 285}; 286 ; 287///////////////////////////////////////////////////////////////////////////////; 288/// Unserialize Python object; 289///; 290/// \param[in] path Path to serialized Python object; 291/// \param[in] obj Python object where the unserialized Python object is loaded; 292/// \return Error code; 293 ; 294Int_t PyMethodBase::UnSerialize(TString path, PyObject **obj); 295{; 296 // Load file; 297 PyObject *file_arg = Py_BuildValue(""(ss)"", path.Data(),""rb"");; 298 PyObject *file = PyObject_CallObject(fOpen,file_arg);; 299 if(!file) return 1;; 300 ; 301 // Load object from file using pickle; 302 PyObject *model_arg = Py_BuildValue(""(O)"", file);; 303 *obj = PyObject_CallObject(fPickleLoads , model_arg);; 304 if(!obj) return 2;; 305 ; 306 Py_DECREF(file_arg);; 307 Py_DECREF(file);; 308 Py_DECREF(model_arg);; 309 ; 310 return 0;; 311}; 312 ; 313///////////////////////////////////////////////////////////////////////////////; 314/// Execute Python code from string; 315///; 316/// \param[in] code Python code as string; 317/// \param[in] errorMessage Error",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/PyMethodBase_8cxx_source.html:9977,load,loaded,9977,doc/master/PyMethodBase_8cxx_source.html,https://root.cern,https://root.cern/doc/master/PyMethodBase_8cxx_source.html,1,['load'],['loaded']
Performance,"return ret;; 118 }; 119 ; 120 /// Increment the iterator (prefix ++i).; 121 Iterator_t& operator++() {; 122 if (IsValid()) {; 123 ++fEntry;; 124 // Force validity check of new fEntry.; 125 this->operator*();; 126 // Don't set the old entry: op* will if needed, and; 127 // in most cases it just adds a lot of spinning back; 128 // and forth: in most cases the sequence is ++i; *i.; 129 }; 130 return *this;; 131 }; 132 ; 133 /// Set the entry number in the reader and return it.; 134 const Long64_t& operator*() {; 135 if (IsValid()) {; 136 // If we cannot access that entry, mark the iterator invalid.; 137 if (fReader->SetEntry(fEntry) != kEntryValid) {; 138 fEntry = -1;; 139 }; 140 }; 141 // There really is no data in this iterator; return the number.; 142 return fEntry;; 143 }; 144 ; 145 const Long64_t& operator*() const {; 146 return **const_cast<Iterator_t*>(this);; 147 }; 148 };; 149 ; 150 typedef Iterator_t iterator;; 151 ; 152 enum EEntryStatus {; 153 kEntryValid = 0, ///< data read okay; 154 kEntryNotLoaded, ///< no entry has been loaded yet; 155 kEntryNoTree, ///< the tree does not exist; 156 kEntryNotFound, ///< the tree entry number does not exist; 157 kEntryChainSetupError, ///< problem in accessing a chain element, e.g. file without the tree; 158 kEntryChainFileError, ///< problem in opening a chain's file; 159 kEntryDictionaryError, ///< problem reading dictionary info from tree; 160 kEntryBeyondEnd, ///< last entry loop has reached its end; 161 kEntryBadReader, ///< One of the readers was not successfully initialized.; 162 kIndexedFriendNoMatch, ///< A friend with TTreeIndex doesn't have an entry for this index; 163 kMissingBranchWhenSwitchingTree, ///< A branch was not found when switching to the next TTree in the chain; 164 kEntryUnknownError ///< LoadTree return less than -6, likely a 'newer' error code.; 165 };; 166 ; 167 enum ELoadTreeStatus {; 168 kNoTree = 0, ///< default state, no TTree is connected (formerly 'Zombie' state); 169 kLoadTreeNone, ///<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreeReader_8h_source.html:5145,load,loaded,5145,doc/master/TTreeReader_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreeReader_8h_source.html,1,['load'],['loaded']
Performance,"return true;; 317}; 318 ; 319////////////////////////////////////////////////////////////////////////////////; 320/// This method is called for all selected entries. User fills histograms; 321/// in this function. This method is obsolete, use Process().; 322///; 323/// WARNING when a selector is used with a TChain:; 324/// in the Process, ProcessCut, ProcessFill function, you must use; 325/// the pointer to the current Tree to call GetEntry(entry).; 326/// entry is always the local entry number in the current tree.; 327/// Assuming that fChain is the pointer to the TChain being processed,; 328/// use fChain->GetTree()->GetEntry(entry);; 329 ; 330void TSelector::ProcessFill(Long64_t /*entry*/); 331{; 332 ; 333}; 334 ; 335////////////////////////////////////////////////////////////////////////////////; 336/// The Process() function is called for each entry in the tree (or possibly; 337/// keyed object in the case of PROOF) to be processed. The entry argument; 338/// specifies which entry in the currently loaded tree is to be processed.; 339/// It can be passed to either t01::GetEntry() or TBranch::GetEntry(); 340/// to read either all or the required parts of the data. When processing; 341/// keyed objects with PROOF, the object is already loaded and is available; 342/// via the fObject pointer.; 343///; 344/// This function should contain the ""body"" of the analysis. It can contain; 345/// simple or elaborate selection criteria, run algorithms on the data; 346/// of the event and typically fill histograms.; 347///; 348/// The processing can be stopped by calling Abort().; 349///; 350/// Use fStatus to set the return value of TTree::Process().; 351///; 352/// The return value is currently not used.; 353///; 354/// WARNING when a selector is used with a TChain, you must use; 355/// the pointer to the current TTree to call GetEntry(entry).; 356/// The entry is always the local entry number in the current tree.; 357/// Assuming that fChain is the pointer to the TChain bei",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:13233,load,loaded,13233,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['load'],['loaded']
Performance,"return;; 14548 }; 14549 ; 14550 /* 15. Files with search/replace patterns: LSP and SSI */; 14551 if (is_template_text_file) {; 14552 HTTP1_only;; 14553 handle_file_based_request(conn, path, &file);; 14554 return;; 14555 }; 14556 ; 14557 /* 16. Static file - maybe cached */; 14558#if !defined(NO_CACHING); 14559 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14560 /* Send 304 ""Not Modified"" - this must not send any body data */; 14561 handle_not_modified_static_file_request(conn, &file);; 14562 return;; 14563 }; 14564#endif /* !NO_CACHING */; 14565 ; 14566 /* 17. Static file - not cached */; 14567 handle_static_file_request(conn, path, &file, NULL, NULL);; 14568 ; 14569#endif /* !defined(NO_FILES) */; 14570}; 14571 ; 14572 ; 14573#if !defined(NO_FILESYSTEMS); 14574static void; 14575handle_file_based_request(struct mg_connection *conn,; 14576 const char *path,; 14577 struct mg_file *file); 14578{; 14579#if !defined(NO_CGI); 14580 unsigned char cgi_config_idx, inc, max;; 14581#endif; 14582 ; 14583 if (!conn || !conn->dom_ctx) {; 14584 return;; 14585 }; 14586 ; 14587#if defined(USE_LUA); 14588 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 14589 path); 14590 > 0) {; 14591 if (is_in_script_path(conn, path)) {; 14592 /* Lua server page: an SSI like page containing mostly plain; 14593 * html code plus some tags with server generated contents. */; 14594 handle_lsp_request(conn, path, file, NULL);; 14595 } else {; 14596 /* Script was in an illegal path */; 14597 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14598 }; 14599 return;; 14600 }; 14601 ; 14602 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS], path); 14603 > 0) {; 14604 if (is_in_script_path(conn, path)) {; 14605 /* Lua in-server module script: a CGI like script used to; 14606 * generate the entire reply. */; 14607 mg_exec_lua_script(conn, path, NULL);; 14608 } else {; 14609 /* Script was in an illegal path */; 14610 mg_send_http_error(conn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:429234,cache,cached,429234,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['cache'],['cached']
Performance,"return;; 14549 }; 14550 ; 14551 /* 15. Files with search/replace patterns: LSP and SSI */; 14552 if (is_template_text_file) {; 14553 HTTP1_only;; 14554 handle_file_based_request(conn, path, &file);; 14555 return;; 14556 }; 14557 ; 14558 /* 16. Static file - maybe cached */; 14559#if !defined(NO_CACHING); 14560 if ((!conn->in_error_handler) && is_not_modified(conn, &file.stat)) {; 14561 /* Send 304 ""Not Modified"" - this must not send any body data */; 14562 handle_not_modified_static_file_request(conn, &file);; 14563 return;; 14564 }; 14565#endif /* !NO_CACHING */; 14566 ; 14567 /* 17. Static file - not cached */; 14568 handle_static_file_request(conn, path, &file, NULL, NULL);; 14569 ; 14570#endif /* !defined(NO_FILES) */; 14571}; 14572 ; 14573 ; 14574#if !defined(NO_FILESYSTEMS); 14575static void; 14576handle_file_based_request(struct mg_connection *conn,; 14577 const char *path,; 14578 struct mg_file *file); 14579{; 14580#if !defined(NO_CGI); 14581 unsigned char cgi_config_idx, inc, max;; 14582#endif; 14583 ; 14584 if (!conn || !conn->dom_ctx) {; 14585 return;; 14586 }; 14587 ; 14588#if defined(USE_LUA); 14589 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SERVER_PAGE_EXTENSIONS],; 14590 path); 14591 > 0) {; 14592 if (is_in_script_path(conn, path)) {; 14593 /* Lua server page: an SSI like page containing mostly plain; 14594 * html code plus some tags with server generated contents. */; 14595 handle_lsp_request(conn, path, file, NULL);; 14596 } else {; 14597 /* Script was in an illegal path */; 14598 mg_send_http_error(conn, 403, ""%s"", ""Forbidden"");; 14599 }; 14600 return;; 14601 }; 14602 ; 14603 if (match_prefix_strlen(conn->dom_ctx->config[LUA_SCRIPT_EXTENSIONS], path); 14604 > 0) {; 14605 if (is_in_script_path(conn, path)) {; 14606 /* Lua in-server module script: a CGI like script used to; 14607 * generate the entire reply. */; 14608 mg_exec_lua_script(conn, path, NULL);; 14609 } else {; 14610 /* Script was in an illegal path */; 14611 mg_send_http_error(conn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:429267,cache,cached,429267,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['cache'],['cached']
Performance,"returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3686 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3798 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3827 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populated with all the defined function and currently instantiated function template. ; Definition at line 3812 of file TClass.cxx. ◆ GetListOfRealData(). TList * TClass::GetListOfRealData ; (; ); const. inline . Definition at line 453 of file TClass.h. ◆ GetListOfUsingDataMembers(). TList * TClass::GetListOfUsingDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of using declarations of a class. ; Definition at line 3786 of file TClass.cxx. ◆ GetMenuItems(). void TClass::GetMenuItems ; (; TList * ; listitems). Returns list of methods accessible by context menu. ; Definition at line 3874 of file TClass.cxx. ◆ GetMenuList(). TList * TClass::GetMenuList ; (; ); const. Return the list of menu items associated with the class. ; Definition at line 4341 of file TClass.cxx. ◆ GetMerge(). ROOT::MergeFunc_t TClass::GetMerge ; (; ); const. Return the wrappe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:83592,load,load,83592,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance,"returned list will implicit take the ROOT global lock upon any access (see TListOfEnumsWithLock); In the case the TClass represents a class or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3753 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3865 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3894 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populated with all the defined function and currently instantiated function template. ; Definition at line 3879 of file TClass.cxx. ◆ GetListOfRealData(). TList * TClass::GetListOfRealData ; (; ); const. inline . Definition at line 453 of file TClass.h. ◆ GetListOfUsingDataMembers(). TList * TClass::GetListOfUsingDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of using declarations of a class. ; Definition at line 3853 of file TClass.cxx. ◆ GetMenuItems(). void TClass::GetMenuItems ; (; TList * ; listitems). Returns list of methods accessible by context menu. ; Definition at line 3941 of file TClass.cxx. ◆ GetMenuList(). TList * TClass::GetMenuList ; (; ); const. Return the list of menu items associated with the class. ; Definition at line 4408 of file TClass.cxx. ◆ GetMerge(). ROOT::MergeFunc_t TClass::GetMerge ; (; ); const. Return the wrappe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:83593,load,load,83593,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance,"returns zero; 2397 ; 2398double RooAbsPdf::expectedEvents(const RooArgSet*) const; 2399{; 2400 return 0 ;; 2401}; 2402 ; 2403 ; 2404 ; 2405////////////////////////////////////////////////////////////////////////////////; 2406/// Change global level of verbosity for p.d.f. evaluations; 2407 ; 2408void RooAbsPdf::verboseEval(Int_t stat); 2409{; 2410 _verboseEval = stat ;; 2411}; 2412 ; 2413 ; 2414 ; 2415////////////////////////////////////////////////////////////////////////////////; 2416/// Return global level of verbosity for p.d.f. evaluations; 2417 ; 2418Int_t RooAbsPdf::verboseEval(); 2419{; 2420 return _verboseEval ;; 2421}; 2422 ; 2423 ; 2424 ; 2425////////////////////////////////////////////////////////////////////////////////; 2426/// Destructor of normalization cache element. If this element; 2427/// provides the 'current' normalization stored in RooAbsPdf::_norm; 2428/// zero _norm pointer here before object pointed to is deleted here; 2429 ; 2430RooAbsPdf::CacheElem::~CacheElem(); 2431{; 2432 // Zero _norm pointer in RooAbsPdf if it is points to our cache payload; 2433 if (_owner) {; 2434 RooAbsPdf* pdfOwner = static_cast<RooAbsPdf*>(_owner) ;; 2435 if (pdfOwner->_norm == _norm.get()) {; 2436 pdfOwner->_norm = nullptr ;; 2437 }; 2438 }; 2439}; 2440 ; 2441 ; 2442 ; 2443////////////////////////////////////////////////////////////////////////////////; 2444/// Return a p.d.f that represent a projection of this p.d.f integrated over given observables; 2445 ; 2446RooAbsPdf* RooAbsPdf::createProjection(const RooArgSet& iset); 2447{; 2448 // Construct name for new object; 2449 std::string name = std::string{GetName()} + ""_Proj["" + RooHelpers::getColonSeparatedNameString(iset, ',') + ""]"";; 2450 ; 2451 // Return projected p.d.f.; 2452 return new RooProjectedPdf(name.c_str(),name.c_str(),*this,iset) ;; 2453}; 2454 ; 2455 ; 2456 ; 2457////////////////////////////////////////////////////////////////////////////////; 2458/// Create a cumulative distribution function of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:116883,cache,cache,116883,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cache']
Performance,"rev.nosp@m.@bnl.nosp@m..gov).; The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility.; WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum. They are both used to handle backward compatibility and should both return the same values. TStreamerInfo uses the information in TStreamerElement while TClass uses the information from TClass::GetListOfBases and TClass::GetListOfDataMembers. ; Definition at line 6544 of file TClass.cxx. ◆ GetCheckSum() [3/3]. UInt_t TClass::GetCheckSum ; (; ECheckSum ; code = kCurrentCheckSum); const. Call GetCheckSum with validity check. ; Definition at line 6505 of file TClass.cxx. ◆ GetClass() [1/6]. template<typename T > . TClass * TClass::GetClass ; (; Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Definition at line 655 of file TClass.h. ◆ GetClass() [2/6]. TClass * TClass::GetClass ; (; ClassInfo_t * ; info, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified ClassInfo. ; If load is true an attempt is made to obtain the class by loading the appropriate shared library (directed by the rootmap file). If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members) Returns 0 in case class is not found. ; Definition at line 3351 of file TClass.cxx. ◆ GetClass() [3/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load, . Bool_t ; silent, . size_t ; hint_pair_offset, . size_t ; hint_pair_size . ). static . Definition at line 2973 of file TClass.cxx. ◆ GetClass() [4/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load = kTRUE, . Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:72795,load,load,72795,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance,"rev.nosp@m.@bnl.nosp@m..gov).; The valid range of code is determined by ECheckSum. kNoEnum: data members of type enum are not counted in the checksum; kNoRange: return the checksum of data members and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility.; WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum. They are both used to handle backward compatibility and should both return the same values. TStreamerInfo uses the information in TStreamerElement while TClass uses the information from TClass::GetListOfBases and TClass::GetListOfDataMembers. ; Definition at line 6611 of file TClass.cxx. ◆ GetCheckSum() [3/3]. UInt_t TClass::GetCheckSum ; (; ECheckSum ; code = kCurrentCheckSum); const. Call GetCheckSum with validity check. ; Definition at line 6572 of file TClass.cxx. ◆ GetClass() [1/6]. template<typename T > . TClass * TClass::GetClass ; (; Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Definition at line 655 of file TClass.h. ◆ GetClass() [2/6]. TClass * TClass::GetClass ; (; ClassInfo_t * ; info, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified ClassInfo. ; If load is true an attempt is made to obtain the class by loading the appropriate shared library (directed by the rootmap file). If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members) Returns 0 in case class is not found. ; Definition at line 3418 of file TClass.cxx. ◆ GetClass() [3/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load, . Bool_t ; silent, . size_t ; hint_pair_offset, . size_t ; hint_pair_size . ). static . Definition at line 3040 of file TClass.cxx. ◆ GetClass() [4/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load = kTRUE, . Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:72796,load,load,72796,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance,"revious.; 95 TContext *fNext{nullptr}; //! Pointer to the next TContext in the implied list of context pointing to fPrevious.; 96 ; 97 TContext(TContext&) = delete;; 98 TContext& operator=(TContext&) = delete;; 99 ; 100 void CdNull();; 101 friend class TDirectory;; 102 ; 103 void RegisterCurrentDirectory();; 104 ; 105 public:; 106 // Note: the directory pointed to by `previous` must not be already deleted; 107 // or in the process of being deleted by another thread while this constructor runs.; 108 TContext(TDirectory *previous, TDirectory *newCurrent) : fDirectory(previous); 109 {; 110 // Store the value of `previous` as the directory to return to when; 111 // this object is destructed.; 112 // Then cd to the `newCurrent` directory.; 113 if (fDirectory); 114 (*fDirectory).RegisterContext(this);; 115 if (newCurrent); 116 newCurrent->cd();; 117 else; 118 CdNull();; 119 }; 120 TContext() : fDirectory(TDirectory::CurrentDirectory().load()); 121 {; 122 // Store the current directory so we can restore it; 123 // later and cd to the new directory.; 124 RegisterCurrentDirectory();; 125 }; 126 TContext(TDirectory *newCurrent) : fDirectory(TDirectory::CurrentDirectory().load()); 127 {; 128 // Store the current directory so we can restore it; 129 // later and cd to the new directory.; 130 RegisterCurrentDirectory();; 131 if (newCurrent); 132 newCurrent->cd();; 133 else; 134 CdNull();; 135 }; 136 ~TContext();; 137 };; 138 ; 139protected:; 140 ; 141 TObject *fMother{nullptr}; // pointer to mother of the directory; 142 TList *fList{nullptr}; // List of objects in memory; 143 TUUID fUUID; // Unique identifier; 144 mutable TString fPathBuffer; //! Buffer for GetPath() function; 145 TContext *fContext{nullptr}; //! Pointer to a list of TContext object pointing to this TDirectory; 146 ; 147 using SharedGDirectory_t = std::shared_ptr<std::atomic<TDirectory *>>;; 148 ; 149 static SharedGDirectory_t &GetSharedLocalCurrentDirectory();; 150 ; 151 std::vector<SharedGDirectory_t> fGDirecto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TDirectory_8h_source.html:3493,load,load,3493,doc/master/TDirectory_8h_source.html,https://root.cern,https://root.cern/doc/master/TDirectory_8h_source.html,1,['load'],['load']
Performance,"rfStats.cxx:188; TTreePerfStats::fDiskTimeDouble_t fDiskTimeTime spent in pure raw disk IO.Definition TTreePerfStats.h:60; TTreePerfStats::fRealTimeAxisTGaxis * fRealTimeAxisPointer to TGaxis object showing real-time.Definition TTreePerfStats.h:73; TTreePerfStats::fUnzipTimeDouble_t fUnzipTimeTime spent uncompressing the data.Definition TTreePerfStats.h:61; TTreePerfStats::BasketList_tstd::vector< std::pair< TBranch *, std::vector< size_t > > > BasketList_tDefinition TTreePerfStats.h:48; TTreePerfStats::fPaveTPaveText * fPavePointer to annotation pavetext.Definition TTreePerfStats.h:71; TTreePerfStats::fTreeCacheSizeInt_t fTreeCacheSizeTTreeCache buffer size.Definition TTreePerfStats.h:51; TTreePerfStats::fGraphTimeTGraphErrors * fGraphTimePointer to the graph with timestamp info.Definition TTreePerfStats.h:70; TTreePerfStats::fHostInfoTextTText * fHostInfoTextGraphics Text object with the fHostInfo data.Definition TTreePerfStats.h:74; TTreePerfStats::fBytesReadExtraLong64_t fBytesReadExtraNumber of bytes (overhead) of the read-ahead cache.Definition TTreePerfStats.h:56; TTreePerfStats::UnzipEventvoid UnzipEvent(TObject *tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen) overrideRecord TTree unzip event.Definition TTreePerfStats.cxx:312; TTreePerfStats::TTreePerfStatsTTreePerfStats()default constructor (used when reading an object only)Definition TTreePerfStats.cxx:107; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::GetCurrentFileTFile * GetCurrentFile() constReturn pointer to the current file.Definition TTree.cxx:5479; TTree::GetDirectoryTDirectory * GetDirectory() constDefinition TTree.h:462; TTree::GetReadEntryvirtual Long64_t GetReadEntry() constDefinition TTree.h:549; TTree::GetTreevirtual TTree * GetTree() constDefinition TTree.h:557; TTree::IsATClass * IsA() const overrideDefinition TTree.h:705; TTree::GetCacheSizevirtual Long64_t GetCacheSize() constDefinition TTree.h:453; TVirtualPerfStatsProvides the interface for th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:44601,cache,cache,44601,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,1,['cache'],['cache']
Performance,"rface to TTreeCache to set the number of entries for the learning phase. ; Definition at line 8865 of file TTree.cxx. ◆ SetCacheSize(). Int_t TTree::SetCacheSize ; (; Long64_t ; cacheSize = -1). virtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented in TChain.; Definition at line 8683 of file TTree.cxx. ◆ SetCacheSizeAux(). Int_t TTree::SetCacheSizeAux ; (; bool ; autocache = true, . Long64_t ; cacheSize = 0 . ). protected . Set the size of the file cache and create it if possible. ; If autocache is true: this may be an autocreated cache, possibly enlarging an existing autocreated cache. The size is calculated. The value passed in cacheSize:; cacheSize = 0 make cache if default cache creation is enabled; cacheSize = -1 make a default sized cache in any case. If autocache is false: this is a user requested cache. cacheSize is used to size the cache. This cache should never be automatically adjusted.; The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, or existing autosized cache almost large enough. (cache was created if possible); -1 on error . Definition at line 8711 of file TTree.cxx. ◆ SetChainOffset(). virtual void TTree::SetChainOffset ; (; Long64_t ; offset = 0). inlinevirtual . Definition at line 649 of file TTree.h. ◆ SetCircular(). void TTree::SetCircular ; (; Long64_t ; maxEntries). virtual . Enable/Disable circularity for this tree. ; if maxEntries > 0 a maximum of maxEntries is kept in one buffer/basket per branch in memory. Note that when this function is called (maxEntries>0) the Tree must be empty or having only one basket per branch. if maxEntries <= 0 the tree circularity is disabled.; NOTE 1:; Circular Trees ar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTree.html:210863,cache,cacheSize,210863,doc/master/classTTree.html,https://root.cern,https://root.cern/doc/master/classTTree.html,6,['cache'],"['cache', 'cacheSize']"
Performance,"rface. The modeller uses the following convention: we define as normal ( \(\vec{n}\)) the unit vector perpendicular to a surface in the next crossing point, having the orientation such that: \(\vec{n}.\vec{d}>0\). Here \(\vec{d}\) represents the current direction. The next crossing point represents the point where a ray shot from the current point along the current direction crosses the surface.; Double_t *TGeoManager::FindNormal(Bool_t forward=kTRUE);; TGeoManager::FindNormalDouble_t * FindNormal(Bool_t forward=kTRUE)Computes normal vector to the next surface that will be or was already crossed when propagating on a ...Definition TGeoManager.cxx:2810; The method above computes the normal to the next crossed surface in forward or backward direction (i.e. the current one), assuming the state corresponding to a current arbitrary point is initialized. An example of usage of normal computation is ray tracing.; The two most important features of the geometrical modeller concerning tracking are scalability and performance as function of the total number of physical nodes. The first refers to the possibility to make use of the available memory resources and at the same time be able to resolve any geometrical query, while the second defines the capability of the modeller to respond quickly even for huge geometries. These parameters can become critical when simulating big experiments like those at LHC. Creating and Visualizing Tracks; In case the modeller is interfaced with a tracking engine, one might consider quite useful being able to store and visualize at least a part of the tracks in the context of the geometry. The base class TVirtualGeoTrack provides this functionality. It currently has one implementation inside the drawing package (TGeoTrack class). A track can be defined like:; TVirtualGeoTrack(Int_t id,Int_t pdg,TVirtualGeoTrack *parent=0,; TObject *particle=0);; TObjectMother of all ROOT objects.Definition TObject.h:41; TVirtualGeoTrackBase class for user-defined",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:91712,scalab,scalability,91712,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,2,"['perform', 'scalab']","['performance', 'scalability']"
Performance,"rg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidsetAlwaysStartFromMin(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProfileLL.html:23079,cache,cache,23079,root/html528/RooProfileLL.html,https://root.cern,https://root.cern/root/html528/RooProfileLL.html,1,['cache'],['cache']
Performance,"rg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3Binding<double,double,int,int>&operator=(const RooCFunction3Binding<double,double,int,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_double_int_int_.html:19886,optimiz,optimizeCacheMode,19886,root/html602/RooCFunction3Binding_double_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_double_int_int_.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rg::AClean; static RooAbsArg::OperModeRooAbsArg::ADirty; static RooAbsArg::ConstOpCodeRooAbsArg::Activate; static RooAbsArg::CacheModeRooAbsArg::Always; static RooAbsArg::OperModeRooAbsArg::Auto; static RooAbsPdf::ExtendModeRooAbsPdf::CanBeExtended; static RooAbsPdf::ExtendModeRooAbsPdf::CanNotBeExtended; static RooAbsReal::ErrorLoggingModeRooAbsReal::CollectErrors; static RooAbsArg::ConstOpCodeRooAbsArg::ConfigChange; static RooAbsReal::ErrorLoggingModeRooAbsReal::CountErrors; static RooAbsArg::ConstOpCodeRooAbsArg::DeActivate; static RooAbsReal::ErrorLoggingModeRooAbsReal::Ignore; static RooKeysPdf::MirrorMirrorAsymBoth; static RooKeysPdf::MirrorMirrorAsymLeft; static RooKeysPdf::MirrorMirrorAsymLeftRight; static RooKeysPdf::MirrorMirrorAsymRight; static RooKeysPdf::MirrorMirrorBoth; static RooKeysPdf::MirrorMirrorLeft; static RooKeysPdf::MirrorMirrorLeftAsymRight; static RooKeysPdf::MirrorMirrorRight; static RooAbsPdf::ExtendModeRooAbsPdf::MustBeExtended; static RooAbsArg::CacheModeRooAbsArg::Never; static RooKeysPdf::MirrorNoMirror; static RooAbsArg::CacheModeRooAbsArg::NotAdvised; static RooAbsReal::ScaleTypeRooAbsReal::NumEvent; static RooAbsReal::ErrorLoggingModeRooAbsReal::PrintErrors; static RooAbsReal::ScaleTypeRooAbsReal::Raw; static RooAbsReal::ScaleTypeRooAbsReal::Relative; static RooAbsReal::ScaleTypeRooAbsReal::RelativeExpected; static RooAbsArg::ConstOpCodeRooAbsArg::ValueChange; static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start; static RooPrintable::ContentsOptionRooPrintable::kAddress; static RooPrintable::ContentsOptionRooPrintable::kArgs; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static RooPrintable::ContentsOptionRooPrintable::kClas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooKeysPdf.html:39458,Cache,CacheModeRooAbsArg,39458,root/html602/RooKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooKeysPdf.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,"rg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; Double_tfErrorTol; Bool_tfForceSum; Bool_tfHasIssuedConvWarning; Bool_tfHasIssuedSumWarning; Int_tfMaxIters; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyk; RooRealProxylambda; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooNonCentralChiSquare.html:41438,cache,cache,41438,root/html532/RooNonCentralChiSquare.html,https://root.cern,https://root.cern/root/html532/RooNonCentralChiSquare.html,4,['cache'],['cache']
Performance,"rg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_pdfObsIter! ; RooSetProxy_pdfObsListList of observables mapped onto histogram observables; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Double_t_totVolume! Total volume of space (product of ranges of observables); Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_unitNormAssume contents is unit normalized (for use as pdf cache); Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistPdf.html:39729,cache,cache,39729,root/html526/RooHistPdf.html,https://root.cern,https://root.cern/root/html526/RooHistPdf.html,3,['cache'],['cache']
Performance,"rg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooRealProxyRooLegendre::_ctheta; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; intRooLegendre::_l1; intRooLegendre::_l2; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; intRooLegendre::_m1; intRooLegendre::_m2; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSpHarmonic.html:34389,cache,cache,34389,root/html534/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html534/RooSpHarmonic.html,5,"['Cache', 'cache']","['Cached', 'cache']"
Performance,rg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealProxyRooAbsAnaConvPdf::_convVarConvolution variable; RooRealProxy_delMistag; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooRealProxy_effRatio; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBCPEffDecay.html:42034,cache,cache,42034,root/html534/RooBCPEffDecay.html,https://root.cern,https://root.cern/root/html534/RooBCPEffDecay.html,2,['cache'],['cache']
Performance,"rg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:32127,cache,cache,32127,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,2,['cache'],['cache']
Performance,rg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<s,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedReal.html:32842,cache,cache,32842,root/html530/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,rg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedPdf.html:38739,cache,cache,38739,root/html526/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedPdf.html,1,['cache'],['cache']
Performance,rg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:39169,cache,cache,39169,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,2,['cache'],['cache']
Performance,"rg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsIntegrator*_numIntEngine! do not persist; RooAbsFunc*_numIntegrand! do not persist; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet*_params! cache for set of parameters; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; TNamed*_rangeName; Bool_t_restartNumIntEngine! do not persist; RooArgSet_saveInt! do not persist; RooArgSet_saveSum! do not persist ; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooListProxy_sumCat! do not persist ; TIterator*_sumCatIter!; RooSetProxy_sumListSet of discrete observable over which is summed numerically; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealIntegral.html:35576,cache,cache,35576,root/html534/RooRealIntegral.html,https://root.cern,https://root.cern/root/html534/RooRealIntegral.html,6,['cache'],['cache']
Performance,"rg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCFunction3PdfBinding_double_unsigned_int_double_double_.html:40085,cache,cache,40085,root/html530/RooCFunction3PdfBinding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html530/RooCFunction3PdfBinding_double_unsigned_int_double_double_.html,2,['cache'],['cache']
Performance,"rg::_ownedComponents! Set of owned component; TIterator*_pdfIter! Iterator of PDF list; RooListProxy_pdfListList of PDF components; RooLinkedList_pdfNSetListList of PDF component normalization sets; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; TNamed*_refRangeNameReference range name for interpretation of conditional products; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; Bool_t_selfNormIs self-normalized; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProdPdf.html:48242,cache,cache,48242,root/html602/RooProdPdf.html,https://root.cern,https://root.cern/root/html602/RooProdPdf.html,4,['cache'],['cache']
Performance,"rg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistPdf.html:2385,cache,cacheUniqueSuffix,2385,root/html534/RooHistPdf.html,https://root.cern,https://root.cern/root/html534/RooHistPdf.html,2,['cache'],['cacheUniqueSuffix']
Performance,"rg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:2385,cache,cacheUniqueSuffix,2385,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,2,['cache'],['cacheUniqueSuffix']
Performance,"rg::cleanBranchName() const; virtual voidRooAbsCategoryLValue::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); const RooCatType*RooAbsCategory::defineTypeUnchecked(const char* label, Int_t index); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual RooCatTypeevaluate() const; virtual voidRooAbsCategory::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; const RooCatType*RooAbsCategory::getOrdinal(UInt_t n, const char* rangeName = 0) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsCategory::isValid() const; virtual Bool_tRooAbsCategory::isValid(const RooCatType& value) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); Bool_tRooAbsCategoryLValue::setOrdinal(UInt_t index, const char* rangeName); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCategory.html:18246,optimiz,optimizeDirtyHook,18246,root/html528/RooCategory.html,https://root.cern,https://root.cern/root/html528/RooCategory.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"rg::numCaches() const; static Int_tRooAbsReal::numEvalErrorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsOptTestStatistic.html:19291,optimiz,optimizeCacheMode,19291,root/html530/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html,15,['optimiz'],['optimizeCacheMode']
Performance,"rg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); ParamHistFunc&operator=(const ParamHistFunc&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); ParamHistFunc(); ParamHistFunc(const ParamHistFunc& other, const char* name = 0); ParamHistFunc(const char* name, const char* title, const RooArgList& vars, const RooArgList& paramSet); ParamHistFunc(const char* name, const char* title, const RooArgList& vars, const RooArgList& paramSet, const TH1* hist); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ParamHistFunc.html:19631,optimiz,optimizeCacheMode,19631,root/html602/ParamHistFunc.html,https://root.cern,https://root.cern/root/html602/ParamHistFunc.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction3Binding<double,double,double,double>&operator=(const RooCFunction3Binding<double,double,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_double_double_double_.html:19850,optimiz,optimizeCacheMode,19850,root/html602/RooCFunction3Binding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_double_double_double_.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCachedReal&operator=(const RooCachedReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:19477,optimiz,optimizeCacheMode,19477,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooDerivative&operator=(const RooDerivative&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDerivative.html:19380,optimiz,optimizeCacheMode,19380,root/html602/RooDerivative.html,https://root.cern,https://root.cern/root/html602/RooDerivative.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooSpHarmonic&operator=(const RooSpHarmonic&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSpHarmonic.html:20297,optimiz,optimizeCacheMode,20297,root/html602/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooTFnBinding&operator=(const RooTFnBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnBinding.html:19190,optimiz,optimizeCacheMode,19190,root/html602/RooTFnBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnBinding.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidRooAbsRealLValue::setBinFast(Int_t ibin, const RooAbsBinning& binning); voidsetBinning(const RooAbsBinning& binning, const char* name = 0); voidsetBins(Int_t nBins, const char* name = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidRooAbsRealLValue::setConstant(Bool_t value = kTRUE); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetError(Double_t value); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetMax(Double_t value); voidsetMax(const char* name, Double_t value); voidsetMin(Double_t value); voidsetMin(const char* name, Double_t value); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(Double_t min, Double_t max); voidsetRange(RooAbsReal& min, RooAbsReal& max); voidsetRange(const char* name, Double_t min, Double_t max); voidsetRange(const char* name, RooAbsReal& min, RooAbsReal& max); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealVar.html:28280,cache,cache,28280,root/html532/RooRealVar.html,https://root.cern,https://root.cern/root/html532/RooRealVar.html,2,['cache'],['cache']
Performance,"rg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const char* rangeName = 0); virtual voidRooAbsRealLValue::setBin(Int_t ibin, const RooAbsBinning& binning); virtual voidRooAbsRealLValue::setBinFast(Int_t ibin, const RooAbsBinning& binning); voidsetBinning(const RooAbsBinning& binning, const char* name = 0); voidsetBins(Int_t nBins, const char* name = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidRooAbsRealLValue::setConstant(Bool_t value = kTRUE); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetError(Double_t value); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetMax(Double_t value); voidsetMax(const char* name, Double_t value); voidsetMin(Double_t value); voidsetMin(const char* name, Double_t value); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(Double_t min, Double_t max); voidsetRange(RooAbsReal& min, RooAbsReal& max); voidsetRange(const char* name, Double_t min, Double_t max); voidsetRange(const char* name, RooAbsReal& min, RooAbsReal& max); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRealVar.html:27785,cache,cache,27785,root/html530/RooRealVar.html,https://root.cern,https://root.cern/root/html530/RooRealVar.html,1,['cache'],['cache']
Performance,"rgList & ; varList). Definition at line 60 of file RooAbsDataStore.cxx. ◆ append(). virtual void RooAbsDataStore::append ; (; RooAbsDataStore & ; other). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ attachBuffers(). virtual void RooAbsDataStore::attachBuffers ; (; const RooArgSet & ; extObs). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ attachCache(). virtual void RooAbsDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ cacheArgs(). virtual void RooAbsDataStore::cacheArgs ; (; const RooAbsArg * ; cacheOwner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ cachedVars(). const RooArgSet & RooAbsDataStore::cachedVars ; (; ); const. inline . Definition at line 130 of file RooAbsDataStore.h. ◆ cacheOwner(). virtual const RooAbsArg * RooAbsDataStore::cacheOwner ; (; ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ changeObservableName(). virtual bool RooAbsDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ checkInit(). virtual void RooAbsDataStore::checkInit ; (; ); const. inlinevirtual . Reimplemented in RooTreeDataStore.; Definition at line 137 of file RooAbsDataStore.h. ◆ Class(). static TClass * RooAbsDataStore::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsDataStore::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsDataStore::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsDataStore.html:19266,cache,cachedVars,19266,doc/master/classRooAbsDataStore.html,https://root.cern,https://root.cern/doc/master/classRooAbsDataStore.html,1,['cache'],['cachedVars']
Performance,"rgList& xvec, const RooFitResult& fr). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Analytical integral known over all observables. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Mon Jul 4 15:23:25 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooMultiVarGaussian.html:42550,cache,cache,42550,root/html530/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html530/RooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"rgList& xvec, const RooFitResult& fr). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TVectorD& mu, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const char* name, const char* title, const RooArgList& xvec, const TMatrixDSym& covMatrix). RooMultiVarGaussian(const RooMultiVarGaussian& other, const char* name = 0). void syncMuVec() const. Double_t evaluate() const; Represent observables as vector. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const; Analytical integral known over all observables. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Handle full integral here. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Special case: generate all observables. void initGenerator(Int_t code); Clear the GenData cache as its content is not invariant under changes in; the mu vector. void generateEvent(Int_t code); Retrieve generator config from cache. void decodeCode(Int_t code, vector<int>& map1, vector<int>& map2) const; Decode analytical integration/generation code into index map of integrated/generated (map2); and non-integrated/generated observables (map1). void blockDecompose(const TMatrixD& input, const vector<int>& map1, const vector<int>& map2, TMatrixDSym& S11, TMatrixD& S12, TMatrixD& S21, TMatrixDSym& S22); Block decomposition of covI according to given maps of observables. RooMultiVarGaussian(); {}. void setAnaIntZ(Double_t z); { _z = z ; }. TObject* clone(const char* newname) const; { return new RooMultiVarGaussian(*this,newname); }. virtual ~RooMultiVarGaussian(); { }. const TMatrixDSym& covarianceMatrix() const; { return _cov ; }. AnaIntData& anaIntData(Int_t code) const. GenData& genData(Int_t code) const. » Last changed: Thu Sep 23 20:00:15 2010 » Last generated: 2010-09-23 20:00; This page has been automatically generated. For comments or suggestions regarding the documentation ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooMultiVarGaussian.html:41990,cache,cache,41990,root/html528/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html528/RooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"rgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:44132,cache,cache,44132,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['cache'],['cache']
Performance,"rgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinWidthFunction.html:34535,cache,cache,34535,doc/master/classRooBinWidthFunction.html,https://root.cern,https://root.cern/doc/master/classRooBinWidthFunction.html,132,['cache'],['cache']
Performance,"rgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; virtual void setCachedValue (double, bool=true);  Overwrite the current value stored in this object, making it look lik",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStringVar.html:18793,cache,cache,18793,doc/master/classRooStringVar.html,https://root.cern,https://root.cern/doc/master/classRooStringVar.html,2,['cache'],['cache']
Performance,"rgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TName",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:38461,cache,cache,38461,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['cache'],['cache']
Performance,"rgSet* nset, Bool_t recalculate = kTRUE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); virtual TStringRooAbsCachedPdf::histNameSuffix() const; static Bool_tRooAbsArg::inhibitDirty(); virtual const char*inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedPdf.html:34017,optimiz,optimizeDirtyHook,34017,root/html526/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedPdf.html,13,['optimiz'],['optimizeDirtyHook']
Performance,"rgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionOneDim*funcFunctor; RooRealProxyvarArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFunctor1DPdfBinding.html:40194,cache,cache,40194,root/html530/RooFunctor1DPdfBinding.html,https://root.cern,https://root.cern/root/html530/RooFunctor1DPdfBinding.html,2,['cache'],['cache']
Performance,"rgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of input fractions; TIterator*_setIter1! Iterator over set of input fractions; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFracRemainder(); Default constructor. RooFracRemainder(const char* name, const char* title, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFracRemainder.html:34649,cache,cache,34649,root/html534/RooFracRemainder.html,https://root.cern,https://root.cern/root/html534/RooFracRemainder.html,4,['cache'],['cache']
Performance,"rgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRecursiveFraction(); Default constructor. RooRecursiveFraction(const char* name, const char* title, const RooArgList& fracSet); Constructor of plain RooAd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRecursiveFraction.html:36271,cache,cache,36271,root/html602/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html,8,['cache'],['cache']
Performance,"rgSetfBestFitPoisnapshot of best fitted POI values; boolfIsInitialized! flag to check if calculator is initialized; doublefNLLAsimov; doublefNLLObs; boolfNominalAsimovmake Asimov at nominal parameter values; boolfOneSidedfor one sided PL test statistic (upper limits); boolfOneSidedDiscoveryfor one sided PL test statistic (for discovery); intfUseQTildeflag to indicate if using qtilde or not (-1 (default based on RooRealVar)), 0 false, 1 (true); static intfgPrintLevelcontrol print level (0 minimal, 1 normal, 2 debug). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetPrintLevel(int level); set print level (static function); 0 minimal, 1 normal, 2 debug. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); constructor for asymptotic calculator from Data set and ModelConfig. bool Initialize() const; Initialize the calculator; The initialization will perform a global fit of the model to the data; and build an Asimov data set.; It will then also fit the model to the Asimov data set to find the likelihood value; of the Asimov data set; nominalAsimov is an option for using Asimov data set obtained using nominal nuisance parameter values; By default the nuisance parameters are fitted to the data; NOTE: If a fit has been done before, one for speeding up could set all the initial prameters; to the fit value and in addition set the null snapshot to the best fit. Double_t EvaluateNLL(RooAbsPdf& pdf, RooAbsData& data, const RooArgSet* condObs, const RooArgSet* poiSet = 0). HypoTestResult* GetHypoTest() const; It performs an hypothesis tests using the likelihood function; and computes the p values for the null and the alternate using the asymptotic; formulae for the profile likelihood ratio.; See G. Cowan, K. Cranmer, E. Gross and O. Vitells.; Asymptotic formulae for likelihood- based tests of new physics. Eur. Phys. J., C71:1–19, 2011.; The",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooStats__AsymptoticCalculator.html:6029,perform,perform,6029,root/html604/RooStats__AsymptoticCalculator.html,https://root.cern,https://root.cern/root/html604/RooStats__AsymptoticCalculator.html,2,['perform'],['perform']
Performance,"rge blocks of data and large number of parameters.; The other one is based on calculation of the system of linear equations using Stiefel-Hestens method [10]. It converges faster than awmi algorithm, however it is not suitable to fit large number of parameters.; 5.1 1-DIMENSIONAL SPECTRA. the quantity to be minimized in the fitting procedure for one dimensional spectrum is defined as :. \[ \chi^2 = \frac{1}{N-M}\sum_{i=1}^{N}\frac{[y_i-f(i,a)]^2}{y_i} \]; where \(i\) is the channel in the fitted spectrum, \(N\) is the number of channels in the fitting subregion, \(M\) is the number of free parameters, \(y_i\) is the content of the i-th channel, \(a\) is a vector of the parameters being fitted and \(f(i,a)\) is a fitting or peak shape function.; Instead of the weighting coefficient \(y_i\) in the denominator of the above given formula one can use also the value of \(f(i,a)\). It is suitable for data with poorstatistics [11], [12].; The third statistic to be optimized, which is implemented in the fitting functions is Maximum Likelihood Method. It is of the choice of the user to select suitable statistic.. after differentiating \(\chi^2\) we obtain the following \(M\) simultaneous equations. \[ \sum_{i=1}^{N}; \frac{y_i-f(i,a^{(t)})}{y_i}; \frac{\partial f(i,a^t)}{\partial a_k}=; \sum_{j=1}^{M}\sum_{i=1}^{N}; \frac{\partial f(i,a^{(t)})}{\partial a_j}; \frac{\partial f(i,a^{(t)})}{\partial a_k}; \Delta a_j^{(t)} \]. in \(\gamma\)-ray spectra we have to fit together tens, hundreds of peaks simultaneously that represent sometimes thousands of parameters.; the calculation of the inversion matrix of such a size is practically impossible.; the awmi method is based on the assumption that off-diagonal terms in the matrix A are equal to zero. \[; \Delta a_{k}^{(t+1)} = \alpha^{(t)}; \frac{; \sum_{i=1}^{N} \frac{e_{i}^{(t)}}{y_i}\frac{\partial f(i,a^{(t)})}{\partial a_k}; }{; \sum_{i=1}^{N} \left[ \frac{\partial f(i,a^{(t)})}{\partial a_k}\right]^2\frac{1}{y_i}; }; \]; where th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/spectrum/Spectrum.html:35501,optimiz,optimized,35501,root/html534/guides/spectrum/Spectrum.html,https://root.cern,https://root.cern/root/html534/guides/spectrum/Spectrum.html,2,['optimiz'],['optimized']
Performance,"rge keeps a list of key and deleting the underlying; 6959 // key would invalidate its iteration (or require costly measure to not use the deleted keys).; 6960 // Also since this is part of a merging operation, the output file is not as precious as in; 6961 // the general case since the input file should still be around.; 6962 fAutoSave = 0;; 6963 TIter next(li);; 6964 TTree *tree;; 6965 while ((tree = (TTree*)next())) {; 6966 if (tree==this) continue;; 6967 if (!tree->InheritsFrom(TTree::Class())) {; 6968 Error(""Add"",""Attempt to add object of class: %s to a %s"", tree->ClassName(), ClassName());; 6969 fAutoSave = storeAutoSave;; 6970 return -1;; 6971 }; 6972 ; 6973 CopyEntries(tree, -1, options, true);; 6974 }; 6975 fAutoSave = storeAutoSave;; 6976 return GetEntries();; 6977}; 6978 ; 6979////////////////////////////////////////////////////////////////////////////////; 6980/// Move a cache from a file to the current file in dir.; 6981/// if src is null no operation is done, if dir is null or there is no; 6982/// current file the cache is deleted.; 6983 ; 6984void TTree::MoveReadCache(TFile *src, TDirectory *dir); 6985{; 6986 if (!src) return;; 6987 TFile *dst = (dir && dir != gROOT) ? dir->GetFile() : nullptr;; 6988 if (src == dst) return;; 6989 ; 6990 TTreeCache *pf = GetReadCache(src);; 6991 if (dst) {; 6992 src->SetCacheRead(nullptr,this);; 6993 dst->SetCacheRead(pf, this);; 6994 } else {; 6995 if (pf) {; 6996 pf->WaitFinishPrefetch();; 6997 }; 6998 src->SetCacheRead(nullptr,this);; 6999 delete pf;; 7000 }; 7001}; 7002 ; 7003////////////////////////////////////////////////////////////////////////////////; 7004/// Copy the content to a new new file, update this TTree with the new; 7005/// location information and attach this TTree to the new directory.; 7006///; 7007/// options: Indicates a basket sorting method, see TTreeCloner::TTreeCloner for; 7008/// details; 7009///; 7010/// If new and old directory are in the same file, the data is untouched,; 7011/// this ""ju",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:273438,cache,cache,273438,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cache']
Performance,"rgin(0.15); xframe.GetYaxis().SetTitleOffset(1.4); xframe.Draw(); ; c.SaveAs(""rf202_extendedmlfit.png""); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x79f4920 RooAddPdf::model = 0.885989/1 [Auto,Clean] ; 0x5091a50/V- RooChebychev::bkg = 0.733482 [Auto,Dirty] ; 0x4d77490/V- RooRealVar::x = 5; 0x779ae60/V- RooRealVar::a0 = 0.507382 +/- 0.0795949; 0x76ed210/V- RooRealVar::a1 = 0.266518 +/- 0.133887; 0x797fc10/V- RooRealVar::nbkg = 427.704 +/- 38.0643; 0x77a8710/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7775040/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x4d77490/V- RooRealVar::x = 5; 0x70eb750/V- RooRealVar::mean = 5; 0x3efb120/V- RooRealVar::sigma1 = 0.5; 0x7a11850/V- RooRealVar::sig1frac = 0.640056 +/- 0.0966619; 0x772a3c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf202__extendedmlfit_8py.html:4587,optimiz,optimization,4587,doc/master/rf202__extendedmlfit_8py.html,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8py.html,2,['optimiz'],['optimization']
Performance,"rgs in multi-line collection printing to given amount. ;  ;  Public Attributes inherited from RooAbsArg; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Protected Attributes inherited from RooProjectedPdf; RooObjCacheManager _cacheMgr;  ! The cache manager ;  ; RooSetProxy deps;  dependents of this p.d.f ;  ; RooSetProxy intobs;  observables that p.d.f is integrated over ;  ; RooRealProxy intpdf;  p.d.f that is integrated ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< RooNumGenConfig > _specGeneratorConfig;  ! MC generator configuration specific for this object ;  ; Int_t _traceCount = 0;  Number of traces remaining to print. ;  ;  Protected Attributes inherited from RooAbsReal; bool _forceNumInt = false;  Force numerical integration if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classxRooProjectedPdf.html:70526,cache,cache,70526,doc/master/classxRooProjectedPdf.html,https://root.cern,https://root.cern/doc/master/classxRooProjectedPdf.html,1,['cache'],['cache']
Performance,"rgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTProof::Collect(TProof::ESlaves list = kActive, Long_t timeout = -1, Int_t endtype = -1); Int_tTProof::Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQueryResult* qr, TProof* p, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofSuperMaster.html:19659,cache,cachedir,19659,root/html528/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html528/TProofSuperMaster.html,1,['cache'],['cachedir']
Performance,"rgs(TQObject* sender, TClass* sender_class, const char* signal, TClass* receiver_class, const char* slot); Int_tTProof::Collect(TProof::ESlaves list = kActive, Long_t timeout = -1, Int_t endtype = -1); Int_tTProof::Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TStringGetJobAd(); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::SaveWorkerInfo(); Int_tTProof::SendFile(const char* file, Int_t opt = (kBinary|kForward|kCp|kCpBin), const char* rfile = 0, TSlave* sl = 0); static Int_tTProof::SendInputData(TQ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofCondor.html:19738,cache,cachedir,19738,root/html528/TProofCondor.html,https://root.cern,https://root.cern/root/html528/TProofCondor.html,1,['cache'],['cachedir']
Performance,"ri, Int_t& nparx, Int_t& istat); Returns concerning the current status of the minimization; *-* =========================================================; *-* User-called; *-* Namely, it returns:; *-* FMIN: the best function value found so far; *-* FEDM: the estimated vertical distance remaining to minimum; *-* ERRDEF: the value of UP defining parameter uncertainties; *-* NPARI: the number of currently variable parameters; *-* NPARX: the highest (external) parameter number defined by user; *-* ISTAT: a status integer indicating how good is the covariance; *-* matrix: 0= not calculated at all; *-* 1= approximation only, not accurate; *-* 2= full matrix, but forced positive-definite; *-* 3= full accurate covariance matrix; *. void mntiny(volatile Double_t epsp1, Double_t& epsbak); To find the machine precision*-*-*-*-*-*-*-; *-* =============================; *-* Compares its argument with the value 1.0, and returns; *-* the value .TRUE. if they are equal. To find EPSMAC; *-* safely by foiling the Fortran optimizer; *. Bool_t mnunpt(TString& cfname); -*-*Returns .TRUE. if CFNAME contains unprintable characters; *-* ========================================================; *. void mnvert(Double_t* a, Int_t l, Int_t m, Int_t n, Int_t& ifail); Inverts a symmetric matrix*-; *-* ==========================; *-* inverts a symmetric matrix. matrix is first scaled to; *-* have all ones on the diagonal (equivalent to change of units); *-* but no pivoting is done since matrix is positive-definite.; *. void mnwarn(const char* copt, const char* corg, const char* cmes); Prints Warning messages*-*-; *-* =======================; *-* If COPT='W', CMES is a WARning message from CORG.; *-* If COPT='D', CMES is a DEBug message from CORG.; *-* If SET WARnings is in effect (the default), this routine; *-* prints the warning message CMES coming from CORG.; *-* If SET NOWarnings is in effect, the warning message is; *-* stored in a circular buffer of length kMAXMES.; *-* If called with CORG=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMinuit.html:56168,optimiz,optimizer,56168,root/html604/TMinuit.html,https://root.cern,https://root.cern/root/html604/TMinuit.html,2,['optimiz'],['optimizer']
Performance,"rials/dataframe/df019_Cache.C File Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. df019_Cache.C File ReferenceTutorials » Dataframe tutorials. Detailed Description; Cache a processed RDataFrame in memory for further usage. ; This tutorial shows how the content of a data frame can be cached in memory in form of a dataframe. The content of the columns is stored in memory in contiguous slabs of memory and is ""ready to use"", i.e. no ROOT IO operation is performed.; Creating a cached data frame storing all of its content deserialised and uncompressed in memory is particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now the event l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df019__Cache_8C.html:974,cache,cached,974,doc/master/df019__Cache_8C.html,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html,1,['cache'],['cached']
Performance,"ribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TF1*_func; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooTFnPdfBinding.html:39954,cache,cache,39954,root/html534/RooTFnPdfBinding.html,https://root.cern,https://root.cern/root/html534/RooTFnPdfBinding.html,5,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"ribes an object that can refer to a constant contiguous sequence of char-like objects with the first element of the sequence at position zero.; This type is used throughout the ROOT code to avoid copying strings when a sub-string is needed and to extent interfaces that uses to take a const char* to take a std::string_view as thus be able to be directly directly passed a TString, a std::string or a std::string_view. Usage example:; // With SetName(std::string_view); std::string str; …; obj.SetName( str );; obj.SetName( {str.data()+pos, len} );; Meta library; Backward Incompatibilities; TIsAProxy’s constructor no longer take the optional and unused 2nd argument which was reserved for a ‘context’. This context was unused in TIsAProxy itself and was not accessible from derived classes.; Interpreter; The new interface TInterpreter::Declare(const char* code) will declare the code to the interpreter with all interpreter extensions disabled, i.e. as “proper” C++ code. No autoloading or synamic lookup will be performed.; A new R__LOAD_LIBRARY(libWhatever) will load libWhatever at parse time. This allows ROOT to resolve symbols from this library very early on. It is a work-around for the following code from ROOT 5:; // ROOT 5:; void func() {; gSystem->Load(""libEvent"");; Event* e = new Event;; }; Instead, write:; // ROOT 6:; R__LOAD_LIBRARY(libEvent); #include ""Event.h"". void func() {; Event* e = new Event;; }; TClass; Introduced new overload for calculating the TClass CheckSum:; UInt_t TClass::GetCheckSum(ECheckSum code, Bool_t &isvalid) const;; which indicates via the ‘isvalid’ boolean whether the checksum could be calculated correctly or not.; TROOT; Implemented new gROOT->GetTutorialsDir() static method to return the actual location of the tutorials directory. This is $ROOTSYS/tutorials when not configuring with –prefix or -Dgnuinstall for CMake.; TColor; Add an enum to access the palette by name.; Add new palettes with 255 colors. Names and colors’ definitions have been t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:4396,perform,performed,4396,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['perform'],['performed']
Performance,"ribute . ; Collaborate with Us . You are hereHome » Development » Git Primer Creating a Pull Request. Prerequisites. You have set up git on our system; You have registered a GitHub account and forked the ROOT repository; You have cloned your forked ROOT repository using git clone https://github.com/<your GitHub username>/root. After you have cloned the repository, you will be on the master branch. Do not make changes to the master branch, as this branch will contain the newest changes in ROOT we will later pull in to our feature branch.; Making your changes; Before implementing your changes, create a new branch that we will work on in isolation from master. In this case, we will name it histogram-race-condition-fix, but you may name it differently according to what your contribution will be.; git checkout -b histogram-race-condition-fix; After implementing your changes, add and commit your changes (More about how to use git here):; git add hist/hist/somefile.cxx; git commit -m ""Avoid race condition on Ubuntu 16.04""; git push --set-upstream origin histogram-race-condition-fix; Your changes are now in your forked repository on GitHub. We will now make the pull request.; Making the pull request on GitHub; If you go to https://github.com/<your GitHub username>/root, you will see a notification saying ""Your recently pushed branches: histogram-race-condition-fix (some minutes ago)"":. You can now hit the green ""Compare & pull request"" button which lets you create the pull request.; Fill in a reasonable description of what your new feature is, and hit ""Create pull request"". A project member will later initiate a build of your pull request and then review your pull request before giving feedback and in the end hopefully merge it. More about how what happens after submitting the pull request can be found in the contributing readme.; Pulling the last changes from upstream/master; Often, there might have been changes in the upstream/master repository that you want to have toget",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/creating-pull-request.html:2807,race condition,race condition,2807,d/creating-pull-request.html,https://root.cern,https://root.cern/d/creating-pull-request.html,1,['race condition'],['race condition']
Performance,"ributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooSetProxy_cacheObsObservable to be cached; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Preven",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedPdf.html:41436,cache,cache,41436,root/html534/RooCachedPdf.html,https://root.cern,https://root.cern/root/html534/RooCachedPdf.html,2,['cache'],['cache']
Performance,"ributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; RooIntegralMorph::MorphCacheElem*_cacheCurrent morph cache element in use; Bool_t_cacheAlphaIf true, both (x,alpha) are cached; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooIntegralMorph.html:41660,cache,cache,41660,root/html526/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html526/RooIntegralMorph.html,5,['cache'],['cache']
Performance,"ricGradFunctionMultiDim&operator=(const ROOT::Math::IParametricGradFunctionMultiDim&); doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(const double* x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IParametricGradFunctionMultiDim(). Virtual Destructor (no operations). {}. void ParameterGradient(const double* x, const double* p, double* grad) const. Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const. Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(x, p, ipar). void ParameterGradient(const double* x, double* grad) const. Evaluate all derivatives using cached parameter values. double ParameterDerivative(const double* x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2010-09-23 19:56; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Math__IParametricGradFunctionMultiDim.html:2931,cache,cached,2931,root/html528/ROOT__Math__IParametricGradFunctionMultiDim.html,https://root.cern,https://root.cern/root/html528/ROOT__Math__IParametricGradFunctionMultiDim.html,2,['cache'],['cached']
Performance,"ricGradFunctionMultiDim&operator=(const ROOT::Math::IParametricGradFunctionMultiDim&); doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(const double* x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IParametricGradFunctionMultiDim(). Virtual Destructor (no operations). {}. void ParameterGradient(const double* x, const double* p, double* grad) const. Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const. Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(x, p, ipar). void ParameterGradient(const double* x, double* grad) const. Evaluate all derivatives using cached parameter values. double ParameterDerivative(const double* x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-07-04 15:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html:2933,cache,cached,2933,root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html,https://root.cern,https://root.cern/root/html530/ROOT__Math__IParametricGradFunctionMultiDim.html,2,['cache'],['cached']
Performance,"ricGradFunctionMultiDim&operator=(const ROOT::Math::IParametricGradFunctionMultiDim&); doubleParameterDerivative(const double* x, unsigned int ipar = 0) const; doubleParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const; voidParameterGradient(const double* x, double* grad) const; virtual voidParameterGradient(const double* x, const double* p, double* grad) const; virtual stringROOT::Math::IBaseParam::ParameterName(unsigned int i) const; virtual const double*ROOT::Math::IBaseParam::Parameters() const; virtual voidROOT::Math::IBaseParam::SetParameters(const double* p). private:. virtual doubleDoParameterDerivative(const double* x, const double* p, unsigned int ipar) const. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; virtual ~IParametricGradFunctionMultiDim(). Virtual Destructor (no operations). {}. void ParameterGradient(const double* x, const double* p, double* grad) const. Evaluate the all the derivatives (gradient vector) of the function with respect to the parameters at a point x.; It is optional to be implemented by the derived classes for better efficiency. double ParameterDerivative(const double* x, const double* p, unsigned int ipar = 0) const. Evaluate the partial derivative w.r.t a parameter ipar from values and parameters. return DoParameterDerivative(x, p, ipar). void ParameterGradient(const double* x, double* grad) const. Evaluate all derivatives using cached parameter values. double ParameterDerivative(const double* x, unsigned int ipar = 0) const. Evaluate partial derivative using cached parameter values. » Author: L. Moneta Tue Nov 14 14:20:07 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathcore:$Id: IParamFunction.h 32583 2010-03-12 09:57:42Z moneta $ » Last generated: 2011-11-03 20:04; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__Math__IParametricGradFunctionMultiDim.html:2933,cache,cached,2933,root/html532/ROOT__Math__IParametricGradFunctionMultiDim.html,https://root.cern,https://root.cern/root/html532/ROOT__Math__IParametricGradFunctionMultiDim.html,4,['cache'],['cached']
Performance,"rical coordinates. void SetClippingShape(TGeoShape* clip); Set a user-defined shape as clipping for ray tracing. void SetMaxVisNodes(Int_t maxnodes = 10000); set the maximum number of visible nodes. void SetTopVisible(Bool_t vis = kTRUE); make top volume visible on screen. void SetCheckedNode(TGeoNode* node); Assign a given node to be checked for ovelaps. Any other overlaps will be ignored. void SetNmeshPoints(Int_t npoints = 1000); Set the number of points to be generated on the shape outline when checking; for overlaps. void SetVisOption(Int_t option = 0); set drawing mode :; option=0 (default) all nodes drawn down to vislevel; option=1 leaves and nodes at vislevel drawn; option=2 path is drawn; option=4 visibility changed. void ViewLeaves(Bool_t flag = kTRUE); Set visualization option (leaves only OR all volumes). void SetVisDensity(Double_t dens = 0.01); Set density threshold. Volumes with densities lower than this become; transparent. void SetVisLevel(Int_t level = 3); set default level down to which visualization is performed. void SortOverlaps(); Sort overlaps by decreasing overlap distance. Extrusions comes first. void OptimizeVoxels(const char* filename = ""tgeovox.C""); Optimize voxelization type for all volumes. Save best choice in a macro. Int_t Parse(const char* expr, TString& expr1, TString& expr2, TString& expr3); Parse a string boolean expression and do a syntax check. Find top; level boolean operator and returns its type. Fill the two; substrings to which this operator applies. The returned integer is :; -1 : parse error; 0 : no boolean operator; 1 : union - represented as '+' in expression; 2 : difference (subtraction) - represented as '-' in expression; 3 : intersection - represented as '*' in expression.; Paranthesys should be used to avoid ambiguites. For instance :; A+B-C will be interpreted as (A+B)-C which is not the same as A+(B-C); eliminate not needed paranthesys. void SaveAttributes(const char* filename = ""tgeoatt.C""); Save current attribute",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGeoManager.html:49330,perform,performed,49330,root/html528/TGeoManager.html,https://root.cern,https://root.cern/root/html528/TGeoManager.html,10,['perform'],['performed']
Performance,"rical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; vector<double>_high; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; vector<double>_low; static Int_tRooPrintable::_nameLength; double_nominal; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; TIterator*_paramIter! do not persist; RooListProxy_paramList; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HistFactory__LinInterpVar.html:32152,cache,cache,32152,root/html528/RooStats__HistFactory__LinInterpVar.html,https://root.cern,https://root.cern/root/html528/RooStats__HistFactory__LinInterpVar.html,4,['cache'],['cache']
Performance,"rically, the quaternion multiplication involves 12 additions and 16 multiplications. It is therefore faster than 3x3 matrixes multiplication involving 18 additions and 27 multiplications.; On the contrary, rotation of a vector by the above formula ( \( Q*V*Q^{-1} \) ) involves 18 additions and 24 multiplications, whereas multiplication of a 3-vector by a 3x3 matrix involves only 6 additions and 9 multiplications.; When dealing with numerous composition of space rotation, it is therefore faster to use quaternion product. On the other hand if a huge set of vectors must be rotated by a given quaternion, it is more optimized to convert the quaternion into a rotation matrix once, and then use that later to rotate the set of vectors.; More information :; http://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation; http://en.wikipedia.org/wiki/Quaternion; This Class represents all quaternions (unit or non-unit) It possesses a Normalize() method to make a given quaternion unit The Rotate(TVector3&) and Rotation(TVector3&) methods can be used even for a non-unit quaternion, in that case, the proper normalization is applied to perform the rotation.; A TRotation constructor exists than takes a quaternion for parameter (even non-unit), in that cas the proper normalisation is applied. ; Definition at line 11 of file TQuaternion.h. Public Member Functions;  TQuaternion (const Double_t *);  ;  TQuaternion (const Float_t *);  ;  TQuaternion (const TQuaternion &);  ;  TQuaternion (const TVector3 &vector, Double_t real=0);  ;  TQuaternion (Double_t real=0, Double_t X=0, Double_t Y=0, Double_t Z=0);  ;  ~TQuaternion () override;  ; TQuaternion Conjugate () const;  ; TQuaternion & DivideLeft (const TQuaternion &quaternion);  left division ;  ; TQuaternion & DivideLeft (const TVector3 &vector);  left division ;  ; Double_t GetQAngle () const;  Get angle of quaternion (rad) N.B : this angle is half of the corresponding rotation angle. ;  ; void GetRXYZ (Double_t *carray) const;  ; void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQuaternion.html:4845,perform,perform,4845,doc/master/classTQuaternion.html,https://root.cern,https://root.cern/doc/master/classTQuaternion.html,1,['perform'],['perform']
Performance,"ride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; Double_tfErrorTol; Bool_tfForceSum; Bool_tfHasIssuedConvWarning; Bool_tfHasIssuedSumWarning; Int_tfMaxIters; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyk; RooRealProxylambda; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNonCentralChiSquare.html:43878,cache,cache,43878,root/html534/RooNonCentralChiSquare.html,https://root.cern,https://root.cern/root/html534/RooNonCentralChiSquare.html,2,['cache'],['cache']
Performance,"ridevirtual . Implements TVirtualPad.; Definition at line 276 of file TPad.h. ◆ IsWeb(). Bool_t TPad::IsWeb ; (; ); const. overridevirtual . Is web ? ; Reimplemented from TVirtualPad.; Definition at line 2871 of file TPad.cxx. ◆ LineNotFree(). void TPad::LineNotFree ; (; Int_t ; x1, . Int_t ; x2, . Int_t ; y1, . Int_t ; y2 . ). private . Mark as ""not free"" the cells along a line. ; Definition at line 3274 of file TPad.cxx. ◆ ls(). void TPad::ls ; (; Option_t * ; option = """"); const. overridevirtual . List all primitives in pad. ; Implements TVirtualPad.; Definition at line 3090 of file TPad.cxx. ◆ Modified(). void TPad::Modified ; (; Bool_t ; flag = true). overridevirtual . Mark pad modified Will be repainted when TCanvas::Update() will be called next time. ; Implements TVirtualPad.; Definition at line 7369 of file TPad.cxx. ◆ ModifiedUpdate(). void TPad::ModifiedUpdate ; (; ). overridevirtual . Short cut to call Modified() and Update() in a single call. ; On Mac with Cocoa, it performs an additional ProcessEvents(). ; Implements TVirtualPad.; Definition at line 3530 of file TPad.cxx. ◆ NextPaletteColor(). Int_t TPad::NextPaletteColor ; (; ). overridevirtual . Get the next autocolor in the pad. ; Implements TVirtualPad.; Definition at line 3118 of file TPad.cxx. ◆ OpaqueMoving(). Bool_t TPad::OpaqueMoving ; (; ); const. overridevirtual . Is pad moving in opaque mode ? ; Implements TVirtualPad.; Definition at line 2879 of file TPad.cxx. ◆ OpaqueResizing(). Bool_t TPad::OpaqueResizing ; (; ); const. overridevirtual . Is pad resizing in opaque mode ? ; Implements TVirtualPad.; Definition at line 2887 of file TPad.cxx. ◆ operator=(). TPad & TPad::operator= ; (; const TPad & ; rhs). privatedelete . ◆ PadtoX(). Double_t TPad::PadtoX ; (; Double_t ; x); const. overridevirtual . Convert x from pad to X. ; Implements TVirtualPad.; Definition at line 3542 of file TPad.cxx. ◆ PadtoY(). Double_t TPad::PadtoY ; (; Double_t ; y); const. overridevirtual . Convert y from pad to Y. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:90871,perform,performs,90871,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['perform'],['performs']
Performance,"riend trees are also printed.; If option contains ""toponly"" only the top level branches are printed. Wildcarding can be used to print only a subset of the branches, e.g.,; T.Print(""Elec*"") will print all branches with name starting with ""Elec"". void PrintCacheStats(Option_t* option = """") const; print statistics about the TreeCache for this tree, like; ******TreeCache statistics for file: cms2.root ******; Reading 73921562 bytes in 716 transactions; Average transaction = 103.242405 Kbytes; Number of blocks in current cache: 202, total size : 6001193. if option = ""a"" the list of blocks in the cache is printed. Long64_t Process(const char* filename, Option_t* option = """", Long64_t nentries = 1000000000, Long64_t firstentry = 0); Process this tree executing the TSelector code in the specified filename.; The return value is -1 in case of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called everytime a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:107105,load,loaded,107105,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,1,['load'],['loaded']
Performance,"ries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; 903 ; 904\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 905a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 906~~~{.cpp}; 907ROOT::EnableImplicitMT(i); 908~~~; 909replacing `i` with the number of CPUs/slots that were allocated for this job.; 910 ; 911### Thread-safety of user-defined expressions; 912RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 913User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 914will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 915 ; 916Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 917expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 918which eliminates all risks of race conditions.; 919 ; 920In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 921offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 922will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 923concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 924where `slot` will be a number between ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:51789,concurren,concurrently,51789,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['concurren'],['concurrently']
Performance,"ries: they could be scrambled with respect to the input dataset. The values of the special `rdfentry_` column will also not correspond to the entry numbers in the input dataset (e.g. TChain) in multi-thread runs.; 943 ; 944\warning By default, RDataFrame will use as many threads as the hardware supports, using up **all** the resources on; 945a machine. This might be undesirable on shared computing resources such as a batch cluster. Therefore, when running on shared computing resources, use; 946~~~{.cpp}; 947ROOT::EnableImplicitMT(i); 948~~~; 949replacing `i` with the number of CPUs/slots that were allocated for this job.; 950 ; 951### Thread-safety of user-defined expressions; 952RDataFrame operations such as Histo1D() or Snapshot() are guaranteed to work correctly in multi-thread event loops.; 953User-defined expressions, such as strings or lambdas passed to Filter(), Define(), Foreach(), Reduce() or Aggregate(); 954will have to be thread-safe, i.e. it should be possible to call them concurrently from different threads.; 955 ; 956Note that simple Filter() and Define() transformations will inherently satisfy this requirement: Filter() / Define(); 957expressions will often be *pure* in the functional programming sense (no side-effects, no dependency on external state),; 958which eliminates all risks of race conditions.; 959 ; 960In order to facilitate writing of thread-safe operations, some RDataFrame features such as Foreach(), Define() or \link ROOT::RDF::RResultPtr::OnPartialResult OnPartialResult()\endlink; 961offer thread-aware counterparts (ForeachSlot(), DefineSlot(), \link ROOT::RDF::RResultPtr::OnPartialResultSlot OnPartialResultSlot()\endlink): their only difference is that they; 962will pass an extra `slot` argument (an unsigned integer) to the user-defined expression. When calling user-defined code; 963concurrently, RDataFrame guarantees that different threads will employ different values of the `slot` parameter,; 964where `slot` will be a number between ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:53429,concurren,concurrently,53429,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['concurren'],['concurrently']
Performance,"ries; of 'build_dir' including the full pathname of the script unless a flat; directory structure is requested ('-' option). With the '-' option the libraries; are created directly in the directory 'build_dir'; in particular this means that; 2 scripts with the same name in different source directory will over-write each; other's library.; See also TSystem::SetBuildDir. If dirmode is not zero and we need to create the target directory, the; file mode bit will be change to 'dirmode' using chmod. If library_specified is not specified, CompileMacro generate a default name; for library by taking the name of the file ""filename"" but replacing the; dot before the extension by an underscore and by adding the shared; library extension for the current platform.; For example on most platform, hsimple.cxx will generate hsimple_cxx.so. It uses the directive fMakeSharedLibs to create a shared library.; If loading the shared library fails, it tries to output a list of missing; symbols by creating an executable (on some platforms like OSF, this does; not HAVE to be an executable) containing the script. It uses the; directive fMakeExe to do so.; For both directives, before passing them to TSystem::Exec, it expands the; variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; information on those variables. This method is used to implement the following feature:. Synopsis:. The purpose of this addition is to allow the user to use an external; compiler to create a shared library from its C++ macro (scripts).; Currently in order to execute a script, a user has to type at the root; prompt. .X myfunc.C(arg1,arg2). We allow him to type:. .X myfunc.C++(arg1,arg2); or; .X myfunc.C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:39104,load,loading,39104,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,6,['load'],['loading']
Performance,"ries; of 'build_dir' including the full pathname of the script unless a flat; directory structure is requested ('-' option). With the '-' option the libraries; are created directly in the directory 'build_dir'; in particular this means that; 2 scripts with the same name in different source directory will over-write each; other's library.; See also TSystem::SetBuildDir. If dirmode is not zero and we need to create the target directory, the; file mode bit will be change to 'dirmode' using chmod. If library_specified is not specified, CompileMacro generate a default name; for library by taking the name of the file ""filename"" but replacing the; dot before the extension by an underscore and by adding the shared; library extension for the current platform.; For example on most platform, hsimple.cxx will generate hsimple_cxx.so. It uses the directive fMakeSharedLibs to create a shared library.; If loading the shared library fails, it tries to output a list of missing; symbols by creating an executable (on some platforms like OSF, this does; not HAVE to be an executable) containing the script. It uses the; directive fMakeExe to do so.; For both directives, before passing them to TSystem::Exec, it expands the; variables $SourceFiles, $SharedLib, $LibName, $IncludePath, $LinkedLibs,; $DepLibs, $ExeName and $ObjectFiles. See SetMakeSharedLib() for more; information on those variables. This method is used to implement the following feature:. Synopsis:. The purpose of this addition is to allow the user to use an external; compiler to create a shared library from its C++ macro (scripts).; Currently in order to execute a script, a user has to type at the root; prompt. .X myfunc.C(arg1,arg2). We allow them to type:. .X myfunc.C++(arg1,arg2); or; .X myfunc.C+(arg1,arg2). In which case an external compiler will be called to create a shared; library. This shared library will then be loaded and the function; myfunc will be called with the two arguments. With '++' the shared library; is ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSystem.html:40954,load,loading,40954,root/html602/TSystem.html,https://root.cern,https://root.cern/root/html602/TSystem.html,4,['load'],['loading']
Performance,"rieveErrorMatrix(); get covariance error matrix from TMinuit; when some parameters are fixed filled the corresponding rows and column with zero's. unsigned int NCalls() const; return total number of function calls. double MinValue() const; return minimum function value. double Edm() const; return expected distance from the minimum. unsigned int NFree() const; return number of free parameters. bool GetCovMatrix(double* cov) const; get covariance matrix. bool GetHessianMatrix(double* h) const; get Hessian - inverse of covariance matrix; just invert it; but need to get the compact form to avoid the zero for the fixed parameters. int CovMatrixStatus() const; return status of covariance matrix; status: 0= not calculated at all; 1= approximation only, not accurate; 2= full matrix, but forced positive-definite; 3= full accurate covariance matrix. double GlobalCC(unsigned int ) const; global correlation coefficient for parameter i. bool GetMinosError(unsigned int i, double& errLow, double& errUp, int = 0); Perform Minos analysis for the given parameter i. void DoClear(); reset TMinuit. void DoReleaseFixParameter(int ivar); check if a parameter is defined and in case it was fixed released; TMinuit is not able to release free parameters by redefining them; so we need to force the release. void PrintResults(); print-out results using classic Minuit format (mnprin). void SuppressMinuitWarnings(bool nowarn = true); suppress Minuit2 warnings. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj); contour plot for parameter i and j; need a valid FunctionMinimum otherwise exits. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0); scan a parameter (variable) around the minimum value; the parameters must have been set before; if xmin=0 && xmax == 0 by default scan around 2 sigma of the error; if the errors are also zero then scan from min and max of parameter range; (if parameters are limited Mi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMinuitMinimizer.html:9785,Perform,Perform,9785,root/html532/TMinuitMinimizer.html,https://root.cern,https://root.cern/root/html532/TMinuitMinimizer.html,4,['Perform'],['Perform']
Performance,"rightname, right, _MAX_PATH );; 1832 return ((stricmp(leftname, rightname)==0));; 1833#else; 1834 struct stat rightBuf;; 1835 struct stat leftBuf;; 1836 return ( ( 0 == stat( left, & leftBuf ) ); 1837 && ( 0 == stat( right, & rightBuf ) ); 1838 && ( leftBuf.st_dev == rightBuf.st_dev ) // Files on same device; 1839 && ( leftBuf.st_ino == rightBuf.st_ino ) // Files on same inode (but this is not unique on AFS so we need the next 2 test; 1840 && ( leftBuf.st_size == rightBuf.st_size ) // Files of same size; 1841 && ( leftBuf.st_mtime == rightBuf.st_mtime ) // Files modified at the same time; 1842 );; 1843#endif; 1844}; 1845 ; 1846 ; 1847////////////////////////////////////////////////////////////////////////////////; 1848/// Load a shared library. Returns 0 on successful loading, 1 in; 1849/// case lib was already loaded, -1 in case lib does not exist; 1850/// or in case of error and -2 in case of version mismatch.; 1851/// When entry is specified the loaded lib is; 1852/// searched for this entry point (return -1 when entry does not exist,; 1853/// 0 otherwise). When the system flag is kTRUE, the library is considered; 1854/// a permanent system library that should not be unloaded during the; 1855/// course of the session.; 1856 ; 1857int TSystem::Load(const char *module, const char *entry, Bool_t system); 1858{; 1859 // don't load libraries that have already been loaded; 1860 TString libs( GetLibraries() );; 1861 TString l(BaseName(module));; 1862 ; 1863 Ssiz_t idx = l.Last('.');; 1864 if (idx != kNPOS) {; 1865 l.Remove(idx+1);; 1866 }; 1867 for (idx = libs.Index(l); idx != kNPOS; idx = libs.Index(l,idx+1)) {; 1868 // The libs contains the sub-string 'l', let's make sure it is; 1869 // not just part of a larger name.; 1870 if (idx == 0 || libs[idx-1] == '/' || libs[idx-1] == '\\') {; 1871 Ssiz_t len = libs.Length();; 1872 idx += l.Length();; 1873 if (!l.EndsWith(""."") && libs[idx]=='.'); 1874 idx++;; 1875 // Skip the soversion.; 1876 while (idx < len && isdigit(libs[id",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:59729,load,loaded,59729,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['loaded']
Performance,riginal input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization ; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in whic,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:33031,cache,cache,33031,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,riginal input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgSet_ownedDataObs! Dataset observables we've agreed to own; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of pro,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsOptTestStatistic.html:33803,cache,cache,33803,root/html530/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html530/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,riginal input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_normSetPointer to set with observables used for normalization; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_t_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsOptTestStatistic.html:33641,cache,cache,33641,root/html528/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html528/RooAbsOptTestStatistic.html,1,['cache'],['cache']
Performance,"riginal: public RooStats::HypoTestCalculator, public TNamed. HybridCalculatorOriginal class: this class is a fresh rewrite in RooStats of; 	RooStatsCms/LimitCalculator developped by D. Piparo and G. Schott; Authors: D. Piparo, G. Schott - Universitaet Karlsruhe. The class is born from the need to have an implementation of the CLs; method that could take advantage from the RooFit Package.; The basic idea is the following:; - Instantiate an object specifying a signal+background model, a background model and a dataset.; - Perform toy MC experiments to know the distributions of -2lnQ; - Calculate the CLsb and CLs values as ""integrals"" of these distributions. The class allows the user to input models as RooAbsPdf ( TH1 object could be used; by using the RooHistPdf class); The pdfs must be ""extended"": for more information please refer to; http://roofit.sourceforge.net). The dataset can be entered as a; RooAbsData objects. Unlike the TLimit Class a complete MC generation is performed at each step; and not a simple Poisson fluctuation of the contents of the bins.; Another innovation is the treatment of the nuisance parameters. The user; can input in the constructor nuisance parameters.; To include the information that we have about the nuisance parameters a prior; PDF (RooAbsPdf) should be specified. Different test statistic can be used (likelihood ratio, number of events or; profile likelihood ratio. The default is the likelihood ratio.; See the method SetTestStatistic. The number of toys to be generated is controlled by SetNumberOfToys(n). The result of the calculations is returned as a HybridResult object pointer. see also the following interesting references:; - Alex Read, ""Presentation of search results: the CLs technique"",; Journal of Physics G: Nucl. Part. Phys. 28 2693-2704 (2002).; see http://www.iop.org/EJ/abstract/0954-3899/28/10/313/. - Alex Read, ""Modified Frequentist Analysis of Search Results (The CLs Method)"" CERN 2000-005 (30 May 2000). - V. Bartsch, G.Quas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStats__HybridCalculatorOriginal.html:1316,perform,performed,1316,root/html528/RooStats__HybridCalculatorOriginal.html,https://root.cern,https://root.cern/root/html528/RooStats__HybridCalculatorOriginal.html,10,['perform'],['performed']
Performance,"rilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; vector<double,allocator<double> >**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; T* getObj(const RooArgSet* nset, Int_t* sterileIndex = 0, const TNamed* isetRangeName = 0); Getter function without integration set. return getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0). Int_t setObj(const RooArgSet* nset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0); Setter function without integration set. return setObj(const RooArgSet* nset, const RooArgSet* iset, vector<double,allocator<double> >* obj, const TNamed* isetRangeName = 0). void reset(). void sterilize(). Int_t lastIndex() const; Return index of slot used in last get or set operation. Int_t cacheSize() const; Return size of cache. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface function to intercept server redirects. void operModeHook(); Interface function to intercept cache operation mode changes. void printCompactTreeHook(ostream& , const char* ); Interface function to cache add contents to output in tree printing mode. T* getObjByIndex(Int_t index) const. const RooNameSet* nameSet1ByIndex(Int_t index) const. const RooNameSet* nameSet2ByIndex(Int_t index) const. void insertObjectHook(vector<double,allocator<double> >& ); Interface function to perform post-insert operations on cached object. » Last changed: Thu Sep 23 19:59:10 2010 » Last generated: 2010-09-23 19:59; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCacheManager_vector_double___.html:4068,cache,cacheSize,4068,root/html528/RooCacheManager_vector_double___.html,https://root.cern,https://root.cern/root/html528/RooCacheManager_vector_double___.html,6,"['cache', 'perform']","['cache', 'cacheSize', 'cached', 'perform']"
Performance,"ring &token="""");  Configures connection token (default none) When specified, in URL of webpage such token should be provided as &token=value parameter, otherwise web window will refuse connection. ;  ; void SetDataCallBack (WebWindowDataCallback_t func);  Set call-back function for data, received from the clients via websocket. ;  ; void SetDefaultPage (const std::string &page);  Set content of default window HTML page This page returns when URL address of the window will be requested Either HTML code or file name in the form ""file:/home/user/data/file.htm"" One also can using default locations like ""file:rootui5sys/canv/canvas.html"". ;  ; void SetDisconnectCallBack (WebWindowConnectCallback_t func);  Set call-back function for disconnecting. ;  ; void SetGeometry (unsigned width, unsigned height);  Set window geometry. Will be applied if supported by used web display (like CEF or Chromium) ;  ; void SetMaxQueueLength (unsigned len=10);  configures maximal queue length of data which can be held by window ;  ; void SetNativeOnlyConn (bool on=true);  configures that only native (own-created) connections are allowed ;  ; void SetOperationTmout (float tm=50.);  Set timeout for synchronous WebWindow operations. ;  ; void SetPanelName (const std::string &name);  Configure window to show some of existing JSROOT panels It uses ""file:rootui5sys/panel/panel.html"" as default HTML page At the moment only FitPanel is existing. ;  ; void SetPosition (unsigned x, unsigned y);  Set window position. Will be applied if supported by used web display (like CEF or Chromium) ;  ; void SetRequireAuthKey (bool on);  Configure if authentication key in connection string is required. ;  ; void SetUseCurrentDir (bool on=true);  Configure if window can access local files via currentdir/ path of http server. ;  ; void SetUserArgs (const std::string &args);  Set arbitrary JSON data, which is accessible via conn.getUserArgs() method in JavaScript This JSON code injected into main HTML document into ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:8629,queue,queue,8629,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,2,['queue'],['queue']
Performance,"ring *obj = new TObjString();; 3836 rule->AsString(obj->String());; 3837 listOfRules.Add(obj);; 3838 }; 3839 classSet.insert(clinfo);; 3840 }; 3841 }; 3842 }; 3843 }; 3844 ; 3845 // Write the StreamerInfo list even if it is empty.; 3846 fClassIndex->fArray[0] = 2; //to prevent adding classes in TStreamerInfo::TagFile; 3847 ; 3848 if (listOfRules.GetEntries()) {; 3849 // Only add the list of rules if we have something to say.; 3850 list.Add(&listOfRules);; 3851 }; 3852 ; 3853 //free previous StreamerInfo record; 3854 if (fSeekInfo) MakeFree(fSeekInfo,fSeekInfo+fNbytesInfo-1);; 3855 //Create new key; 3856 TKey key(&list,""StreamerInfo"",GetBestBuffer(), this);; 3857 fKeys->Remove(&key);; 3858 fSeekInfo = key.GetSeekKey();; 3859 fNbytesInfo = key.GetNbytes();; 3860 SumBuffer(key.GetObjlen());; 3861 key.WriteFile(0);; 3862 ; 3863 fClassIndex->fArray[0] = 0;; 3864 ; 3865 list.RemoveLast(); // remove the listOfRules.; 3866}; 3867 ; 3868////////////////////////////////////////////////////////////////////////////////; 3869/// Open a file for reading through the file cache.; 3870///; 3871/// The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""y",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:140654,cache,cache,140654,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"ring is; 366 // incorrect.; 367 settings.optimizer = DNN::EOptimizer::kAdam;; 368 settings.optimizerName = ""ADAM"";; 369 }; 370 // check for specific optimizer parameters; 371 std::vector<TString> optimParamLabels = {""_beta1"", ""_beta2"", ""_eps"", ""_rho""};; 372 //default values; 373 std::map<TString, double> defaultValues = {; 374 {""ADADELTA_eps"", 1.E-8}, {""ADADELTA_rho"", 0.95},; 375 {""ADAGRAD_eps"", 1.E-8},; 376 {""ADAM_beta1"", 0.9}, {""ADAM_beta2"", 0.999}, {""ADAM_eps"", 1.E-7},; 377 {""RMSPROP_eps"", 1.E-7}, {""RMSPROP_rho"", 0.9},; 378 };; 379 for (auto &pN : optimParamLabels) {; 380 TString optimParamName = settings.optimizerName + pN;; 381 // check if optimizer has default values for this specific parameters; 382 if (defaultValues.count(optimParamName) > 0) {; 383 double defValue = defaultValues[optimParamName];; 384 double val = fetchValueTmp(block, optimParamName, defValue);; 385 // create entry in settings for this optimizer parameter; 386 settings.optimizerParams[optimParamName] = val;; 387 }; 388 }; 389 ; 390 fTrainingSettings.push_back(settings);; 391 }; 392 ; 393 // this set fInputShape[0] = batchSize; 394 this->SetBatchSize(fTrainingSettings.front().batchSize);; 395 ; 396 // case inputlayout and batch layout was not given. Use default then; 397 // (1, batchsize, nvariables); 398 // fInputShape[0] -> BatchSize; 399 // fInputShape[1] -> InputDepth; 400 // fInputShape[2] -> InputHeight; 401 // fInputShape[3] -> InputWidth; 402 if (fInputShape[3] == 0 && fInputShape[2] == 0 && fInputShape[1] == 0) {; 403 fInputShape[1] = 1;; 404 fInputShape[2] = 1;; 405 fInputShape[3] = GetNVariables();; 406 }; 407 // case when batch layout is not provided (all zero); 408 // batch layout can be determined by the input layout + batch size; 409 // case DNN : { 1, B, W }; 410 // case CNN : { B, C, H*W}; 411 // case RNN : { B, T, H*W }; 412 ; 413 if (fBatchWidth == 0 && fBatchHeight == 0 && fBatchDepth == 0) {; 414 // case first layer is DENSE; 415 if (fInputShape[2] == 1 && fInputShape[1]",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:15226,optimiz,optimizerParams,15226,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizerParams']
Performance,"ring of sum of parameters in paramSet uniform smearing with mean 'mean' and width 'sigma' in RooMCStudy generation cycle. ;  ; void sampleSumUniform (const RooArgSet &paramSet, double lo, double hi);  Request uniform smearing of sum of parameters in paramSet uniform smearing in range [lo,hi] in RooMCStudy generation cycle. ;  ; void sampleUniform (RooRealVar &param, double lo, double hi);  Request uniform smearing of param in range [lo,hi] in RooMCStudy generation cycle. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsMCStudyModule;  RooAbsMCStudyModule (const char *name, const char *title);  Constructor. ;  ;  RooAbsMCStudyModule (const RooAbsMCStudyModule &other);  Copy constructor. ;  ; bool doInitializeInstance (RooMCStudy &);  Initializer method called upon attachment to given RooMCStudy object. ;  ; virtual bool processAfterFit (Int_t);  Method called after fit has been performed. ;  ; virtual bool processBetweenGenAndFit (Int_t);  Method called after generation of toy data sample and resetting of fit parameters to initial values and before actual fit is performed. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy this to obj. ;  ; virtual void FillBuffer (char *&buffer);  Encode TNamed into output",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRandomizeParamMCSModule.html:3212,perform,performed,3212,doc/master/classRooRandomizeParamMCSModule.html,https://root.cern,https://root.cern/doc/master/classRooRandomizeParamMCSModule.html,1,['perform'],['performed']
Performance,"ring optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAt(Double_t bkgEff = 0.1); calculate the signal efficiency for a given background efficiency. OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); default constructor. MethodBase* GetMethod(); {return fMethod;}. » Last changed: Fri Dec 10 17:05:10 2010 » Last generated: 2010-12-10 17:05; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html:4164,tune,tuneParameters,4164,root/html528/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html,2,"['optimiz', 'tune']","['optimizationType', 'tuneParameters']"
Performance,"ring wconf); voidoperator=(const TSlave&). Data Members; public:. enum ESlaveType { kMaster; kSlave; };; enum ESlaveStatus { kInvalid; kActive; kInactive; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfArchCompBuild architecture, compiler on worker (e.g. linux-gcc345); Long64_tfBytesReadbytes read by slave (info is obtained from slave); Float_tfCpuTimeCPU time spent executing commands (info obtained from slave); TStringfGroupslave's group id; TStringfImageslave's image name; TFileHandler*fInputinput handler related to this slave; TStringfMsdmass storage domain of slave; TStringfNameslave's hostname; TStringfOrdinalslave's ordinal number; Int_tfParallelnumber of active slaves; Int_tfPerfIdxrelative CPU performance index; Int_tfPortslave's port number; TProof*fProofproof cluster to which slave belongs; TStringfProofWorkDirbase proofserv working directory (info obtained from slave); Int_tfProtocolslave's protocol level; TStringfROOTVersROOT version run by worker; Float_tfRealTimereal time spent executing commands (info obtained from slave); TSlave::ESlaveTypefSlaveTypetype of slave (either kMaster or kSlave); TSocket*fSocketsocket to slave; Int_tfStatusremote return status; TStringfUserslave's user id; TStringfWorkDirslave's working directory (info obtained from slave). private:. static TSlave_tfgTXSlaveHook. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TSlave(const char* host, const char* ord, Int_t perf, const char* image, TProof* proof, Int_t stype, const char* workdir, const char* msd); Create a PROOF slave object. Called via the TProof ctor. TSlave(); Default constructor used by derived classes. void Init(const char* host, Int_t port, Int_t stype); Init a PROOF slave object. Called via the TSla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSlave.html:7532,perform,performance,7532,root/html528/TSlave.html,https://root.cern,https://root.cern/root/html528/TSlave.html,1,['perform'],['performance']
Performance,"ring will be passed passed as argument to SETUP. Special option 'chkv=<o>' (or 'checkversion=<o>') can be used to control plugin version checking during building: possible choices are: off no check; failure may occur at loading on check ROOT version [default] svn check ROOT version and Git commit SHA1. (Use ';', ' ' or '|' to separate 'chkv=<o>' from the rest.) If specified, enables packages only on the specified workers. Returns 0 in case of success and -1 in case of error. ; Definition at line 8197 of file TProof.cxx. ◆ EnablePackage() [3/3]. Int_t TProof::EnablePackage ; (; const char * ; package, . TList * ; loadopts, . Bool_t ; notOnClient = kFALSE, . TList * ; workers = 0 . ). Enable specified package. ; Executes the PROOF-INF/BUILD.sh script if it exists followed by the PROOF-INF/SETUP.C script. In case notOnClient = true, don't enable the package on the client. The default is to enable packages also on the client. It is is possible to specify a list of objects to be passed to the SETUP functions via 'loadopts'; the objects must be streamable. Returns 0 in case of success and -1 in case of error. ; Definition at line 8258 of file TProof.cxx. ◆ Exec() [1/3]. Int_t TProof::Exec ; (; const char * ; cmd, . Bool_t ; plusMaster = kFALSE . ). Send command to be executed on the PROOF master and/or slaves. ; If plusMaster is kTRUE then exeucte on slaves and master too. Command can be any legal command line command. Commands like "".x file.C"" or "".L file.C"" will cause the file file.C to be send to the PROOF cluster. Returns -1 in case of error, >=0 in case of succes. ; Definition at line 6521 of file TProof.cxx. ◆ Exec() [2/3]. Int_t TProof::Exec ; (; const char * ; cmd, . const char * ; ord, . Bool_t ; logtomacro = kFALSE . ). Send command to be executed on node of ordinal 'ord' (use ""0"" for master). ; Command can be any legal command line command. Commands like "".x file.C"" or "".L file.C"" will cause the file file.C to be send to the PROOF cluster. If logtomacro is TRUE ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:87863,load,loadopts,87863,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['load'],['loadopts']
Performance,"ring(""NONE""));; 344 if (regularization == ""L1"") {; 345 settings.regularization = DNN::ERegularization::kL1;; 346 } else if (regularization == ""L2"") {; 347 settings.regularization = DNN::ERegularization::kL2;; 348 } else {; 349 settings.regularization = DNN::ERegularization::kNone;; 350 }; 351 ; 352 TString optimizer = fetchValueTmp(block, ""Optimizer"", TString(""ADAM""));; 353 settings.optimizerName = optimizer;; 354 if (optimizer == ""SGD"") {; 355 settings.optimizer = DNN::EOptimizer::kSGD;; 356 } else if (optimizer == ""ADAM"") {; 357 settings.optimizer = DNN::EOptimizer::kAdam;; 358 } else if (optimizer == ""ADAGRAD"") {; 359 settings.optimizer = DNN::EOptimizer::kAdagrad;; 360 } else if (optimizer == ""RMSPROP"") {; 361 settings.optimizer = DNN::EOptimizer::kRMSProp;; 362 } else if (optimizer == ""ADADELTA"") {; 363 settings.optimizer = DNN::EOptimizer::kAdadelta;; 364 } else {; 365 // Make Adam as default choice if the input string is; 366 // incorrect.; 367 settings.optimizer = DNN::EOptimizer::kAdam;; 368 settings.optimizerName = ""ADAM"";; 369 }; 370 // check for specific optimizer parameters; 371 std::vector<TString> optimParamLabels = {""_beta1"", ""_beta2"", ""_eps"", ""_rho""};; 372 //default values; 373 std::map<TString, double> defaultValues = {; 374 {""ADADELTA_eps"", 1.E-8}, {""ADADELTA_rho"", 0.95},; 375 {""ADAGRAD_eps"", 1.E-8},; 376 {""ADAM_beta1"", 0.9}, {""ADAM_beta2"", 0.999}, {""ADAM_eps"", 1.E-7},; 377 {""RMSPROP_eps"", 1.E-7}, {""RMSPROP_rho"", 0.9},; 378 };; 379 for (auto &pN : optimParamLabels) {; 380 TString optimParamName = settings.optimizerName + pN;; 381 // check if optimizer has default values for this specific parameters; 382 if (defaultValues.count(optimParamName) > 0) {; 383 double defValue = defaultValues[optimParamName];; 384 double val = fetchValueTmp(block, optimParamName, defValue);; 385 // create entry in settings for this optimizer parameter; 386 settings.optimizerParams[optimParamName] = val;; 387 }; 388 }; 389 ; 390 fTrainingSettings.push_back(settings);; 391",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:14308,optimiz,optimizer,14308,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizer']
Performance,"ring,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useCdfBoundariesAre c.d.f boundary conditions used by the RooHistFuncs?; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyfuncProxy to function being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedReal(const char* name, const char* title, RooAbsReal& _func); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:38899,cache,cache,38899,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,8,['cache'],['cache']
Performance,"ring::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::UpdateBranchesvirtual void UpdateBranches(TTree *tree)Update pointer to current Tree and recompute pointers to the branches in the cache.Definition TTreeCache.cxx:2211; TTreeCache::ResetCachevirtual void ResetCache()This will simply clear the cache.Definition TTreeCache.cxx:2040; TTree::TClusterIteratorHelper class to iterate over cluster of baskets.Definition TTree.h:270; TTree::TFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends.Definition TTree.h:188; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::AddFriendvirtual TFriendElement * AddFriend(const char *treename, const char *filename="""")Add a TFriendElement to the list of friends.Definition TTree.cxx:1332; TTree::FindBranchvirtual TBranch * FindBranch(const char *name)Return the branch that correspond to the path 'branchname', which can include the name of the tree or...Definition TTree.cxx:4841; TTree::SetBranchStatusvirtual void SetBranchStatus(const char *bname, bool status=true, UInt_t *found=nullptr)Set branch status to Process or DoNotProcess.Definition TTree.cxx:8534; TTree::GetBranchvirtual TBranch * GetBranch(const char *name)Return pointer to the branch with the give",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:143659,cache,cache,143659,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['cache'],['cache']
Performance,"ring>&RooAbsArg::attributes() const; virtual RooAbsGenContext*RooAbsPdf::autoGenContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, Bool_t autoBinned = kTRUE, const char* binnedTag = """") const; const RooFormulaVar&basis() const; virtual Int_tbasisCode(const char* name) const; const RooRealVar&basisConvVar() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; virtual RooAbsGenContext*RooAbsPdf::binnedGenContext(const RooArgSet& vars, Bool_t verbose = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; virtual voidchangeBasis(RooFormulaVar* basis); voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; static voidcleanup(); virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooResolutionModel.html:4280,Cache,CacheModeRooAbsArg,4280,root/html534/RooResolutionModel.html,https://root.cern,https://root.cern/root/html534/RooResolutionModel.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,"ring>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; MINIMIZER*_minimizer! Internal minuit instance; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProfileLL.html:33742,cache,cache,33742,root/html534/RooProfileLL.html,https://root.cern,https://root.cern/root/html534/RooProfileLL.html,7,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"ring>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_errorSymmetric error associated with current value; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealVar.html:40731,cache,cache,40731,root/html602/RooRealVar.html,https://root.cern,https://root.cern/root/html602/RooRealVar.html,10,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"ringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionOneDim*funcFunctor; RooRealProxyvarArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctor1DPdfBinding.html:44722,cache,cache,44722,root/html602/RooFunctor1DPdfBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctor1DPdfBinding.html,4,['cache'],['cache']
Performance,"ringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooTruthModel.html:40787,cache,cache,40787,root/html528/RooTruthModel.html,https://root.cern,https://root.cern/root/html528/RooTruthModel.html,2,['cache'],['cache']
Performance,"ringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction2PdfBinding_double_int_int_.html:42732,cache,cache,42732,root/html534/RooCFunction2PdfBinding_double_int_int_.html,https://root.cern,https://root.cern/root/html534/RooCFunction2PdfBinding_double_int_int_.html,2,['cache'],['cache']
Performance,"ringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction2Ref<double,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2PdfBinding_double_unsigned_int_double_.html:45019,cache,cache,45019,root/html602/RooCFunction2PdfBinding_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2PdfBinding_double_unsigned_int_double_.html,4,['cache'],['cache']
Performance,"ringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyalphaInterpolation parameter; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdf1First input shape; RooRealProxypdf2Second input shape; RooRealProxyxObservable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooIntegralMorph.html:44723,cache,cache,44723,root/html528/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html528/RooIntegralMorph.html,2,['cache'],['cache']
Performance,"ringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsRealLValue(const char* name, const char* title, const char* unit = """"); Constructor. RooAbsRealLValue(const RooAbsRealLValue& other, const char* name =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsRealLValue.html:40201,cache,cache,40201,root/html602/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsRealLValue.html,8,['cache'],['cache']
Performance,"ringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsSelfCachedReal(const char* name, const char* title, Int_t ipOrder = 0); Constructor. RooAbsSelfCachedReal(const RooAbsSelfCachedReal& other, const char",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedReal.html:37945,cache,cache,37945,root/html602/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedReal.html,8,['cache'],['cache']
Performance,"ringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenProdProj(); Default constructor. RooGenProdProj(const char* name, const char* title, const RooArgSet& _prodSet, const RooArgSet& _intSet, const RooArgS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenProdProj.html:36947,cache,cache,36947,root/html602/RooGenProdProj.html,https://root.cern,https://root.cern/root/html602/RooGenProdProj.html,8,['cache'],['cache']
Performance,"ringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProduct(); Default constructor. ~RooProduct(); Destructor. RooProduct(const char* name, const char* title, const RooArgList& _prodSet); Construct function",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProduct.html:36353,cache,cache,36353,root/html602/RooProduct.html,https://root.cern,https://root.cern/root/html602/RooProduct.html,8,['cache'],['cache']
Performance,"ringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_disableCacheFlag to run object in passthrough (= non-caching mode). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedReal.html:37736,cache,cache,37736,root/html602/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html,8,['cache'],['cache']
Performance,"ringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooListProxy_catListAccept/reject categories; RooListProxy_effFuncListEfficiency functions per category; Bool_t_ignoreNonVisibleIgnore combination of only rejects (since invisible). Class Charts. Inheritance; Inherited Members; Includes; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiBinomial.html:36596,cache,cache,36596,root/html602/RooMultiBinomial.html,https://root.cern,https://root.cern/root/html602/RooMultiBinomial.html,8,['cache'],['cache']
Performance,"ringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TIterator*_boundIter! do not persist; RooListProxy_boundaryList; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_t_interpolate; RooRealProxy_x. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStepFunction.html:36497,cache,cache,36497,root/html602/RooStepFunction.html,https://root.cern,https://root.cern/root/html602/RooStepFunction.html,8,['cache'],['cache']
Performance,"ringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; ca",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealIntegral.html:37822,perform,performed,37822,root/html534/RooRealIntegral.html,https://root.cern,https://root.cern/root/html534/RooRealIntegral.html,6,['perform'],['performed']
Performance,"ringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:34447,perform,performed,34447,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,5,['perform'],['performed']
Performance,"ringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_x; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. Bool_t_asymLeft; Bool_t_asymRight; Double_t_binWidth; Double_t*_dataPts[_nEvents]; Double_t*_dataWgts[_nEvents]; Double_t_hi; Double_t_lo; Double_t_lookupTable[1001]; Bool_t_mirrorLeft; Bool_t_mirrorRight; Int_t_nEvents; static const Double_t_nSigma!; Double_t_rho; Double_t_sumWgt; Char_t_varName[128]; Double_t*_weights[_nEvents]. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooKeysPdf(); coverity[UNINIT_CTOR]. RooKeysPdf(const char* name, const char* title, RooAbsReal& x, RooDataSet& data, RooKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1); cache stuff about x. RooKeysPdf(const char* name, const char* title, RooAbsReal& x, RooRealVar& xdata, RooDataSet& data, RooKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1); cache stuff about x. RooKeysPdf(const RooKeysPdf& other, const char* name = 0). ~RooKeysPdf(). void LoadDataSet(RooDataSet& data). Double_t evaluate() const. Int_t getAnalyticalIntegral(RooArgSet& allVars, RooArgSet& analVars, const char* rangeName = 0) const. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const. Int_t getMaxVal(const RooArgSet& vars) const. Double_t maxVal(Int_t code) const. Double_t g(Double_t x, Double_t sigma) const. TObject* clone(const char* newname) const; {return new RooKeysPdf(*this,newname); }. » Last changed: Tue Mar 10 17:17:29 2015 » Last generated: 2015-03-10 17:17; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooKeysPdf.html:44857,cache,cache,44857,root/html534/RooKeysPdf.html,https://root.cern,https://root.cern/root/html534/RooKeysPdf.html,3,"['Load', 'cache']","['LoadDataSet', 'cache']"
Performance,"ringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimizeConstantTerms(Bool_t ); Driver function to activate global constant term optimization.; If activated constant terms are found and cached with the dataset; The operation mode of cached nodes is set to AC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:36203,optimiz,optimizations,36203,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,3,['optimiz'],['optimizations']
Performance,"ring_view destFileName);  Opens the input file for reading and the output file for writing (update). ;  ; static std::unique_ptr< RNTupleImporter > Create (TTree *sourceTree, std::string_view destFileName);  Directly uses the provided tree and opens the output file for writing (update). ;  . Private Member Functions;  RNTupleImporter ()=default;  ; ROOT::Experimental::RResult< void > InitDestination (std::string_view destFileName);  ; RResult< void > PrepareSchema ();  Sets up the connection from TTree branches to RNTuple fields, including initialization of the memory buffers used for reading and writing. ;  ; void ReportSchema ();  ; void ResetSchema ();  . Private Attributes; bool fConvertDotsInBranchNames = false;  Whether or not dot characters in branch names should be converted to underscores. ;  ; std::unique_ptr< TFile > fDestFile;  ; std::string fDestFileName;  ; std::unique_ptr< REntry > fEntry;  ; FieldModifier_t fFieldModifier;  ; std::vector< RImportBranch > fImportBranches;  ; std::vector< RImportField > fImportFields;  ; std::vector< std::unique_ptr< RImportTransformation > > fImportTransformations;  The list of transformations to be performed for every entry. ;  ; bool fIsQuiet = false;  No standard output, conversely if set to false, schema information and progress is printed. ;  ; std::map< std::string, RImportLeafCountCollection > fLeafCountCollections;  Maps the count leaf to the information about the corresponding untyped collection. ;  ; std::int64_t fMaxEntries = -1;  The maximum number of entries to import. When this value is -1 (default), import all entries. ;  ; std::unique_ptr< RNTupleModel > fModel;  ; std::string fNTupleName;  ; std::unique_ptr< RProgressCallback > fProgressCallback;  ; std::unique_ptr< TFile > fSourceFile;  ; TTree * fSourceTree;  ; RNTupleWriteOptions fWriteOptions;  . #include <ROOT/RNTupleImporter.hxx>; Member Typedef Documentation. ◆ FieldModifier_t. using ROOT::Experimental::RNTupleImporter::FieldModifier_t = std::fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleImporter.html:6534,perform,performed,6534,doc/master/classROOT_1_1Experimental_1_1RNTupleImporter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleImporter.html,1,['perform'],['performed']
Performance,"rintf(""ReadCP = %7.3f MBytes/s\n"",1e-6*fBytesRead/fCpuTime);; 570 if (unzip) {; 571 printf(""ReadStrCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/(fCpuTime-fUnzipTime));; 572 printf(""ReadZipCP = %7.3f MBytes/s\n"",1e-6*fCompress*fBytesRead/fUnzipTime);; 573 }; 574 if (basket); 575 PrintBasketInfo(option);; 576}; 577 ; 578////////////////////////////////////////////////////////////////////////////////; 579/// Print the TTree basket information; 580 ; 581void TTreePerfStats::PrintBasketInfo(Option_t *option) const; 582{; 583 ; 584 TString opts(option);; 585 opts.ToLower();; 586 bool all = opts.Contains(""allbasketinfo"");; 587 ; 588 TFile *file = fTree->GetCurrentFile();; 589 if (!file); 590 return;; 591 ; 592 TTreeCache *cache = dynamic_cast<TTreeCache *>(file->GetCacheRead(fTree));; 593 if (!cache); 594 return;; 595 ; 596 auto branches = cache->GetCachedBranches();; 597 for (size_t i = 0; i < fBasketsInfo.size(); ++i) {; 598 const char *branchname = branches->At(i)->GetName();; 599 ; 600 printf("" br=%zu %s read not cached: "", i, branchname);; 601 if (fBasketsInfo[i].empty()) {; 602 printf(""none"");; 603 } else; 604 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 605 if (fBasketsInfo[i][j].fMissed); 606 printf(""%zu "", j);; 607 }; 608 printf(""\n"");; 609 ; 610 printf("" br=%zu %s cached more than once: "", i, branchname);; 611 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 612 auto &info(fBasketsInfo[i][j]);; 613 if ((info.fLoaded + info.fLoadedMiss) > 1); 614 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 615 }; 616 printf(""\n"");; 617 ; 618 printf("" br=%zu %s cached but not used: "", i, branchname);; 619 for (size_t j = 0; j < fBasketsInfo[i].size(); ++j) {; 620 auto &info(fBasketsInfo[i][j]);; 621 if ((info.fLoaded + info.fLoadedMiss) && !info.fUsed) {; 622 if (info.fLoadedMiss); 623 printf(""%zu[%d,%d] "", j, info.fLoaded, info.fLoadedMiss);; 624 else; 625 printf(""%zu "", j);; 626 }; 627 }; 628 printf(""\n"");; 629 ; 630 if (all) {; 631 printf("" br=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html:21279,cache,cached,21279,doc/master/TTreePerfStats_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8cxx_source.html,1,['cache'],['cached']
Performance,"riptor.hxx. ◆ fFieldDescriptors. std::unordered_map<DescriptorId_t, RFieldDescriptor> ROOT::Experimental::RNTupleDescriptor::fFieldDescriptors. private . Definition at line 560 of file RNTupleDescriptor.hxx. ◆ fFieldZeroId. DescriptorId_t ROOT::Experimental::RNTupleDescriptor::fFieldZeroId = kInvalidDescriptorId. private . Set by the descriptor builder. ; Definition at line 548 of file RNTupleDescriptor.hxx. ◆ fGeneration. std::uint64_t ROOT::Experimental::RNTupleDescriptor::fGeneration = 0. private . Once constructed by an RNTupleDescriptorBuilder, the descriptor is mostly immutable except for set of active the page locations. ; During the lifetime of the descriptor, page location information for clusters can be added or removed. When this happens, the generation should be increased, so that users of the descriptor know that the information changed. The generation is increased, e.g., by the page source's exclusive lock guard around the descriptor. It is used, e.g., by the descriptor cache in RNTupleReader. ; Definition at line 557 of file RNTupleDescriptor.hxx. ◆ fHeaderExtension. std::unique_ptr<RHeaderExtension> ROOT::Experimental::RNTupleDescriptor::fHeaderExtension. private . Definition at line 567 of file RNTupleDescriptor.hxx. ◆ fName. std::string ROOT::Experimental::RNTupleDescriptor::fName. private . The ntuple name needs to be unique in a given storage location (file) ; Definition at line 536 of file RNTupleDescriptor.hxx. ◆ fNClusters. std::uint64_t ROOT::Experimental::RNTupleDescriptor::fNClusters = 0. private . Updated by the descriptor builder when the cluster groups are added. ; Definition at line 545 of file RNTupleDescriptor.hxx. ◆ fNEntries. std::uint64_t ROOT::Experimental::RNTupleDescriptor::fNEntries = 0. private . Updated by the descriptor builder when the cluster groups are added. ; Definition at line 544 of file RNTupleDescriptor.hxx. ◆ fNPhysicalColumns. std::uint64_t ROOT::Experimental::RNTupleDescriptor::fNPhysicalColumns = 0. private . Upd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html:22937,cache,cache,22937,doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RNTupleDescriptor.html,1,['cache'],['cache']
Performance,"ritance; Inherited Members; Includes; Libraries. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id$ » Last generated: 2015-03-13 19:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLAxis.html:4877,optimiz,optimized,4877,root/html534/TGLAxis.html,https://root.cern,https://root.cern/root/html534/TGLAxis.html,4,['optimiz'],['optimized']
Performance,"riteCache(); voidTObject::MakeZombie(); voidTNetFile::PrintError(const char* where, Int_t err); Int_tTFile::ReadBufferViaCache(char* buf, Int_t len); Int_tTNetFile::Recv(Int_t& status, EMessageTypes& kind); voidTDirectory::RegisterContext(TDirectory::TContext* ctxt); virtual Int_tTFile::SysRead(Int_t fd, void* buf, Int_t len); virtual Long64_tTFile::SysSeek(Int_t fd, Long64_t offset, Int_t whence); virtual Int_tTFile::SysSync(Int_t fd); virtual Int_tTFile::SysWrite(Int_t fd, const void* buf, Int_t len); voidTDirectory::UnregisterContext(TDirectory::TContext* ctxt); Int_tTFile::WriteBufferViaCache(const char* buf, Int_t len). private:. TXNetFile(const TXNetFile&); voidCreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); static voidFormUrl(TUrl uut, TString& uu); static Int_tGetRootdProtocol(TSocket* s); virtual voidInit(Bool_t create); Bool_tOpen(Option_t* option, Bool_t parallelopen); TXNetFile&operator=(const TXNetFile&); Int_tParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); static voidSetEnv(); voidSynchronizeCacheSize(); virtual Int_tSysClose(Int_t fd); virtual Int_tSysOpen(const char* pathname, Int_t flags, UInt_t mode); virtual Int_tSysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime). Data Members; public:. enum TFile::EAsyncOpenStatus { kAOSNotAsync; kAOSFailure; kAOSInProgress; kAOSSuccess; };; enum TFile::EOpenTimeOut { kInstantTimeout; kEternalTimeout; };; enum TFile::EStatusBits { kRecovered; kHasReferences; kDevNull; kWriteError; kBinaryFile; kRedirected; };; enum TFile::ERelativeTo { kBeg; kCur; kEnd; };; enum TFile::[unnamed] { kStartBigFile; };; enum TFile::EFileType { kDefault; kLocal; kNet; kWeb; kFile; };; enum TDirectoryFile::[unnamed] { kCloseDirectory; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXNetFile.html:17195,cache,cachesz,17195,root/html528/TXNetFile.html,https://root.cern,https://root.cern/root/html528/TXNetFile.html,2,['cache'],['cachesz']
Performance,"rited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). Bool_t ProcessCut(Long64_t ); This method is called before processing entry. It is the user's responsability to read; the corresponding entry in memory (may be just a partial read).; The function returns kTRUE if the entry must be processed,; kFALSE otherwise. This method is obsolete, use Process(). WARNING when a selector is used with a TChain:; in the Process, ProcessCut, ProcessFill function, you must use; the pointer to the current Tree to call ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSelector.html:9959,load,loaded,9959,root/html534/TSelector.html,https://root.cern,https://root.cern/root/html534/TSelector.html,2,['load'],['loaded']
Performance,"rited Members; Includes; Libraries. Function documentation; TSelector(); Default selector ctor. ~TSelector(); Selector destructor. void Abort(const char* why, TSelector::EAbort what = kAbortProcess); Abort processing. If what = kAbortProcess, the Process() loop will be; aborted. If what = kAbortFile, the current file in a chain will be; aborted and the processing will continue with the next file, if there; is no next file then Process() will be aborted. Abort() can also be; called from Begin(), SlaveBegin(), Init() and Notify(). After abort; the SlaveTerminate() and Terminate() are always called. The abort flag; can be checked in these methods using GetAbort(). TSelector * GetSelector(const char* filename); The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded. The corresponding binary file and shared; library will be deleted at the end of the function.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. The static function returns a pointer to a TSelector object. Bool_t IsStandardDraw(const char* selec); Find out if this is a standard selection used for Draw actions; (either TSelectorDraw, TProofDraw or deriving from them). TSelector(const TSelector& ). TSelector& operator=(const TSelector& ). int Version() const; { return 0; }. void Init(TTree* ); { }. void Begin(TTree* ); { }. void SlaveBegin(TTree* ); { }. Bool_t Notify(); { return kTRUE; }. const char * GetOption() const; { return fOption; }. Long64_t GetStatus() const; { return fStatus; }. Int_t GetEntry(Long64_t , Int_t = 0); { return 0; }. Bool_t ProcessCut(Long64_t ); { return kTRUE; }. void ProcessFill(Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSelector.html:9835,load,loaded,9835,root/html528/TSelector.html,https://root.cern,https://root.cern/root/html528/TSelector.html,4,['load'],['loaded']
Performance,"rited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Observable to be cached for given choice of normalization. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Parameters of the cache. ;  ; PdfCacheElem * createCache (const RooArgSet *nset) const override;  Create and return a derived MorphCacheElem. ;  ; double evaluate () const override;  Dummy. ;  ; void fillCacheObject (PdfCacheElem &cache) const override;  Fill the cache with the interpolated shape. ;  ; const char * inputBaseName () const override;  Return base name component for cache components in this case a string encoding the names of both end point p.d.f.s. ;  ;  Protected Member Functions inherited from RooAbsCachedPdf; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; PdfCacheElem * getCache (const RooArgSet *nset, bool recalculate=true) const;  Retrieve cache object associated with given choice of observables. ;  ; virtual TString histNameSuffix () const;  ; virtual const char * payloadUniqueSuffix () const;  ; virtual RooAbsArg & pdfObservable (RooAbsArg &histObservable) const;  ;  Protected Mem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:65077,cache,cache,65077,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,2,['cache'],['cache']
Performance,"rithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The linked list of FREE segments is written.; The file header is written (",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:39064,cache,cache,39064,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,3,['cache'],['cache']
Performance,"rivate; fVerboseLevelTMVA::Factoryprivate; GetConfigDescription() constTMVA::Configurableinline; GetConfigName() constTMVA::Configurableinline; GetDrawOption() constTObjectvirtual; GetDtorOnly()TObjectstatic; GetIconName() constTObjectvirtual; GetImportance(const int nbits, std::vector< Double_t > importances, std::vector< TString > varNames)TMVA::Factoryprivate; GetMethod(const TString &datasetname, const TString &title) constTMVA::Factory; GetName() const overrideTNamedinlinevirtual; GetObjectInfo(Int_t px, Int_t py) constTObjectvirtual; GetObjectStat()TObjectstatic; GetOption() constTObjectinlinevirtual; GetOptions() constTMVA::Configurableinline; GetReferenceFile() constTMVA::Configurableinlineprotected; GetROC(DataLoader *loader, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factoryprivate; GetROC(TString datasetname, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factoryprivate; GetROCCurve(DataLoader *loader, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCCurve(TString datasetname, TString theMethodName, Bool_t setTitles=kTRUE, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCCurve(DataLoader *loader, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCCurve(TString datasetname, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCCurveAsMultiGraph(DataLoader *loader, UInt_t iClass, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCCurveAsMultiGraph(TString datasetname, UInt_t iClass, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCIntegral(DataLoader *loader, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetROCIntegral(TString datasetname, TString theMethodName, UInt_t iClass=0, Types::ETreeType type=Types::kTesting)TMVA::Factory; GetTitle() const overrideTNamedinlinevirtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory-members.html:5704,load,loader,5704,doc/master/classTMVA_1_1Factory-members.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory-members.html,1,['load'],['loader']
Performance,"rivatives of theoretical function. ; Input:; fX - vector of data point. Output:; DF - array of derivatives. ARITHM.F: Converted from CERNLIB ; Definition at line 291 of file TFumili.cxx. ◆ Eval(). Int_t TFumili::Eval ; (; Int_t & ; npar, . Double_t * ; grad, . Double_t & ; fval, . Double_t * ; par, . Int_t ; flag . ). Evaluate the minimisation function. ; Input parameters:; npar: number of currently variable parameters; par: array of (constant and variable) parameters; flag: Indicates what is to be calculated; grad: array of gradients. Output parameters:; fval: The calculated function value.; grad: The vector of first derivatives. The meaning of the parameters par is of course defined by the user, who uses the values of those parameters to calculate their function value. The starting values must be specified by the user.; Inside FCN user has to define Z-matrix by means TFumili::GetZ and TFumili::Derivatives, set theoretical function by means of TFumili::SetUserFunc, but first - pass number of parameters by TFumili::SetParNumber; Later values are determined by Fumili as it searches for the minimum or performs whatever analysis is requested by the user.; The default function calls the function specified in SetFCN ; Definition at line 350 of file TFumili.cxx. ◆ EvalTFN(). Double_t TFumili::EvalTFN ; (; Double_t * ; , . Double_t * ; X . ). Evaluate theoretical function. . df: array of partial derivatives; X: vector of theoretical function argument . Definition at line 362 of file TFumili.cxx. ◆ ExecuteCommand(). Int_t TFumili::ExecuteCommand ; (; const char * ; command, . Double_t * ; args, . Int_t ; nargs . ). overridevirtual . Execute MINUIT commands. ; MINImize, SIMplex, MIGrad and FUMili all will call TFumili::Minimize method.; For full command list see MINUIT. Reference Manual. CERN Program Library Long Writeup D506.; Improvement and errors calculation are not yet implemented as well as Monte-Carlo seeking and minimization. Contour commands are also unsupported. com",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFumili.html:28416,perform,performs,28416,doc/master/classTFumili.html,https://root.cern,https://root.cern/doc/master/classTFumili.html,1,['perform'],['performs']
Performance,"rix * GetCurrentMatrix() constDefinition TGeoManager.h:496. One often needs to perform master-to-local and local-to-master point and vector conversions to get from MARS to the local node coordinates. This can be done by using the global transformation or directly the **TGeoManager** corresponding interfaces:. Double_t *glob_pt = gGeoManager->GetCurrentPoint();; Double_t *glob_dir = gGeoManager->GetCurrentDirection();; Double_t loc_pt[3], loc_dir[3];; // Go from MARS to local coordinates:; gGeoManager->MasterToLocal(glob_pt,loc_pt); // or:; global->MasterToLocal(glob_pt,loc_pt); // will be omitted from now; TGeoManager::MasterToLocalvoid MasterToLocal(const Double_t *master, Double_t *local) constDefinition TGeoManager.h:538. Saving and Restoring the Current State; As we already described, saving and restoring modeller states can be quite useful during tracking and is a feature extensively used by external tracking engines. We will call this navigation history management, which in most of the cases can be performed by handling the state identifiers. For quite big geometries, state indexing is not possible anymore and will be automatically disabled by the modeller. Fortunately there is a backup solution working in any condition: the modeller maintains a stack of states that is internally used by its own navigation algorithms, but user code is also allowed to access it. This works on any stack principle by using PUSH and POP calls and user code is responsible for popping the pushed states in order to keep the stack clean.; // push the current state in the stack; Int_t index = gGeoManager->PushPath();; // push state and current point; Int_t index = gGeoManager->PushPoint();; // retrieves the last pushed state (decrements stack index); gGeoManager->PopPath();; // the same but retrieves also the point location; gGeoManager->PopPoint();; // just decrement stack index without changing state; gGeoManager->PopDummy();; // retrieves a state at given index without changing stac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:78968,perform,performed,78968,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performed']
Performance,"rix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixTSym<Element> Determinant() const. void TMatrixTSym<Element> Determinant(Double_t& d1, Double_t& d2) const. TMatrixTSym<Element> &TMatrixTSym<Element> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant; Notice that the LU decomposition is used instead of Bunch-Kaufman; Bunch-Kaufman guarantees a symmetric inverted matrix but is slower than LU .; The user can access Bunch-Kaufman through the TDecompBK class . TMatrixTSym<Element> &TMatrixTSym<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixTSym<Element> &TMatrixTSym<Element> Transpose(const TMatrixTSym<float>& source); Transpose a matrix. TMatrixTSym<Element> &TMatrixTSym<Element> Rank1Update(const TVectorT<float>& v, float alpha = 1.); Perform a rank 1 operation on the matrix:; A += alpha * v * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixT<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . TMatrixTSym<Element> &TMatrixTSym<Element> Similarity(const TMatrixTSym<Element> &b); Calculate B * (*this) * B^T , final matrix will be (nrowsb x nrowsb); This is a similarity transform when B is orthogonal . It is more; efficient than applying the actual multiplication because this; routine realizes that the final matrix is symmetric . Element TMatrixTSym<Element> Similarity(const TVectorT<float>& v) const; Calculate scalar v * (*this) * v^T. TMatrixTSym<Element> &TMatrixTSym<Element> SimilarityT(const TMatrixT<float>& n); Calculate B^T * (*this) * B , final matrix will be (ncolsb x ncolsb); It is more efficient than ap",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMatrixTSym_float_.html:18421,Perform,Perform,18421,root/html602/TMatrixTSym_float_.html,https://root.cern,https://root.cern/root/html602/TMatrixTSym_float_.html,2,['Perform'],['Perform']
Performance,"rixMethodHMatrix(TMVA::DataSetInfo& theData, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodHMatrixMethodHMatrix(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = """", TDirectory* theTargetDir = 0); virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandler(TMVA::Transformatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodHMatrix.html:9699,Optimiz,OptimizeTuningParameters,9699,root/html532/TMVA__MethodHMatrix.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodHMatrix.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"rization);; 1343 }; 1344 // add Regularization term; 1345 Double_t regzTerm = (includeRegularization) ? deepNet.RegularizationTerm() : 0.0;; 1346 minValError /= (Double_t)(nValidationSamples / settings.batchSize);; 1347 minValError += regzTerm;; 1348 ; 1349 ; 1350 // create a pointer to base class VOptimizer; 1351 std::unique_ptr<DNN::VOptimizer<Architecture_t, Layer_t, DeepNet_t>> optimizer;; 1352 ; 1353 // initialize the base class pointer with the corresponding derived class object.; 1354 switch (O) {; 1355 ; 1356 case EOptimizer::kSGD:; 1357 optimizer = std::unique_ptr<DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>>(; 1358 new DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>(settings.learningRate, deepNet, settings.momentum));; 1359 break;; 1360 ; 1361 case EOptimizer::kAdam: {; 1362 optimizer = std::unique_ptr<DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>>(; 1363 new DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>(; 1364 deepNet, settings.learningRate, settings.optimizerParams[""ADAM_beta1""],; 1365 settings.optimizerParams[""ADAM_beta2""], settings.optimizerParams[""ADAM_eps""]));; 1366 break;; 1367 }; 1368 ; 1369 case EOptimizer::kAdagrad:; 1370 optimizer = std::unique_ptr<DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>>(; 1371 new DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1372 settings.optimizerParams[""ADAGRAD_eps""]));; 1373 break;; 1374 ; 1375 case EOptimizer::kRMSProp:; 1376 optimizer = std::unique_ptr<DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>>(; 1377 new DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate, settings.momentum,; 1378 settings.optimizerParams[""RMSPROP_rho""],; 1379 settings.optimizerParams[""RMSPROP_eps""]));; 1380 break;; 1381 ; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>>(; 1384 new DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1385 settings.optimizerParams[""ADADEL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:54033,optimiz,optimizerParams,54033,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizerParams']
Performance,"rks are stable and performing for a large variety of ; : linear and non-linear classification problems. However, in contrast; : to (e.g.) boosted decision trees, the user is advised to reduce the ; : number of input variables that have only little discrimination power. ; : ; : In the tests we have carried out so far, the MLP and ROOT networks; : (TMlpANN, interfaced via TMVA) performed equally well, with however; : a clear speed advantage for the MLP. The Clermont-Ferrand neural ; : net (CFMlpANN) exhibited worse classification performance in these; : tests, which is partly due to the slow convergence of its training; : (at least 10k training cycles are required to achieve approximately; : competitive results).; : ; : ␛[1mOvertraining: ␛[0monly the TMlpANN performs an explicit separation of the; : full training sample into independent training and validation samples.; : We have found that in most high-energy physics applications the ; : available degrees of freedom (training events) are sufficient to ; : constrain the weights of the relatively simple architectures required; : to achieve good performance. Hence no overtraining should occur, and ; : the use of validation samples would only reduce the available training; : information. However, if the performance on the training sample is ; : found to be significantly better than the one found with the inde-; : pendent test sample, caution is needed. The results for these samples ; : are printed to standard output at the end of each training job.; : ; : ␛[1m--- Performance tuning via configuration options:␛[0m; : ; : The hidden layer architecture for all ANNs is defined by the option; : ""HiddenLayers=N+1,N,..."", where here the first hidden layer has N+1; : neurons and the second N neurons (and so on), and where N is the number ; : of input variables. Excessive numbers of hidden layers should be avoided,; : in favour of more neurons in the first hidden layer.; : ; : The number of cycles should be above 500. As said, if ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:43260,perform,performance,43260,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,"rks for more than 95% and is much faster than the usual shape-to-shape comparison. For a 100% reliability, one can perform the check at the level of a single volume by using option=“d” or option=“d<number>” to perform overlap checking by sampling the volume with <number> random points (default 1 million). This produces also a picture showing in red the overlapping region and estimates the volume of the overlaps.; An extrusion A) is declared in any of the following cases:. At least one of the vertices of the daughter mesh representation is outside the mother volume (in fact its shape) and having a safety distance to the mother greater than the desired value;; At least one of the mother vertices is contained also by one of its daughters, in the same conditions. An overlap B) is declared if:. At least one vertex of a positioned volume mesh is contained (having a safety bigger than the accepted maximum value) by other positioned volume inside the same container. The check is performed also by inverting the candidates. The code is highly optimized to avoid checking candidates that are far away in space by performing a fast check on their bounding boxes. Once the checking tool is fired-up inside a volume or at top level, the list of overlaps (visible as Illegal overlaps inside a TBrowser) held by the manager class will be filled with TGeoOverlap objects containing a full description of the detected overlaps. The list is sorted in the decreasing order of the overlapping distance, extrusions coming first. An overlap object name represents the full description of the overlap, containing both candidate node names and a letter (x-extrusion, o-overlap) representing the type. Double-clicking an overlap item in a TBrowser produces a picture of the overlap containing only the two overlapping nodes (one in blue and one in green) and having the critical vertices represented by red points. The picture can be rotated/zoomed or drawn in X3d as any other view. Calling gGeoManager->PrintO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1002285,perform,performed,1002285,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['performed']
Performance,"rkspace::import(w) importing RooRealVar::a1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::bkgfrac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::sig; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::mean; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma1; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sig1frac; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooGaussian::sig2; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::sigma2; ; RooWorkspace(w) w contents; ; variables; ---------; (a0,a1,bkgfrac,mean,sig1frac,sigma1,sigma2,x); ; p.d.f.s; -------; RooChebychev::bkg[ x=x coefList=(a0,a1) ] = 0.8; RooAddPdf::model[ bkgfrac * bkg + [%] * sig ] = 0.9/1; RooAddPdf::sig[ sig1frac * sig1 + [%] * sig2 ] = 1/1; RooGaussian::sig1[ x=x mean=mean sigma=sigma1 ] = 1; RooGaussian::sig2[ x=x mean=mean sigma=sigma2 ] = 1; ; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); DateApril 2009 ; AuthorWouter Verkerke ; Definition in file rf509_wsinteractive.C. tutorialsroofitrf509_wsinteractive.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:30 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf509__wsinteractive_8C.html:9125,optimiz,optimization,9125,doc/master/rf509__wsinteractive_8C.html,https://root.cern,https://root.cern/doc/master/rf509__wsinteractive_8C.html,2,['optimiz'],['optimization']
Performance,"rlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooXYChi2Var&operator=(const RooXYChi2Var&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:20272,optimiz,optimizeCacheMode,20272,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rm=None,Decorrelated,PCA to use transformed variables; instead of the original ones; VariableTransformType=Signal,Background which decorrelation matrix to use; in the method. Only the Likelihood; Method can make proper use of independent; transformations of signal and background; fNbinsMVAPdf = 50 Number of bins used to create a PDF of MVA; fNsmoothMVAPdf = 2 Number of times a histogram is smoothed before creating the PDF; fHasMVAPdfs create PDFs for the MVA outputs; V for Verbose output (!V) for non verbos; H for Help message. void ProcessBaseOptions(); the option string is decoded, for availabel options see ""DeclareOptions"". void CreateVariableTransforms(const TString& trafoDefinition). void DeclareCompatibilityOptions(). std::map<TString,Double_t> OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); call the Optimzier with the set of paremeters and ranges that; are meant to be tuned. void SetTuneParameters(map<TString,Double_t> tuneParameters); set the tuning parameters accoding to the argument; This is just a dummy .. have a look at the MethodBDT how you could; perhaps implment the same thing for the other Classifiers.. void TrainMethod(). void GetRegressionDeviation(UInt_t tgtNum, TMVA::Types::ETreeType type, Double_t& stddev, Double_t& stddev90Percent) const. void AddRegressionOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddMulticlassOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void NoErrorCalc(Double_t *const err, Double_t *const errUpper). Double_t GetMvaValue(const TMVA::Event *const ev, Double_t* err = 0, Double_t* errUpper = 0). void AddClassifierOutput(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void AddClassifierOutputProb(TMVA::Types::ETreeType type); prepare tree branch with the method's discriminating variable. void TestRegression(Double_t& bias, Double_t& b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodBase.html:21073,tune,tuneParameters,21073,root/html528/TMVA__MethodBase.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodBase.html,1,['tune'],['tuneParameters']
Performance,"rmMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooListProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooUniform.html:38976,cache,cache,38976,root/html528/RooUniform.html,https://root.cern,https://root.cern/root/html528/RooUniform.html,2,['cache'],['cache']
Performance,"rmRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxyc; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxym; RooRealProxym0; RooRealProxyp.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooArgusBG.html:40158,cache,cache,40158,root/html532/RooArgusBG.html,https://root.cern,https://root.cern/root/html532/RooArgusBG.html,2,['cache'],['cache']
Performance,"rmRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooBDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBDecay.html:42295,cache,cache,42295,root/html532/RooBDecay.html,https://root.cern,https://root.cern/root/html532/RooBDecay.html,2,['cache'],['cache']
Performance,rmSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_correctQ; RooRealProxy_delC; RooRealProxy_delS; RooRealProxy_delW; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; Double_t_genRhoPlusFrac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerR,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNonCPEigenDecay.html:39939,cache,cache,39939,root/html526/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html526/RooNonCPEigenDecay.html,1,['cache'],['cache']
Performance,rmSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_correctQ; RooRealProxy_delC; RooRealProxy_delS; RooRealProxy_delW; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; Double_t_genRhoPlusFrac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of pl,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNonCPEigenDecay.html:40513,cache,cache,40513,root/html528/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html528/RooNonCPEigenDecay.html,4,['cache'],['cache']
Performance,"rmalise the raw values returned by; 416/// getVal(). Note that `getVal(normalisationVariables)` will automatically; 417/// apply the normalisation term returned here.; 418/// \param nset Set of variables to normalise over.; 419double RooAbsPdf::getNorm(const RooArgSet* nset) const; 420{; 421 if (!nset) return 1 ;; 422 ; 423 syncNormalization(nset,true) ;; 424 if (_verboseEval>1) cxcoutD(Tracing) << ClassName() << ""::getNorm("" << GetName() << ""): norm("" << _norm << "") = "" << _norm->getVal() << endl ;; 425 ; 426 double ret = _norm->getVal() ;; 427 if (ret==0.) {; 428 if(++_errorCount <= 10) {; 429 coutW(Eval) << ""RooAbsPdf::getNorm("" << GetName() << "":: WARNING normalization is zero, nset = "" ; nset->Print(""1"") ;; 430 if(_errorCount == 10) coutW(Eval) << ""RooAbsPdf::getNorm("" << GetName() << "") INFO: no more messages will be printed "" << endl ;; 431 }; 432 }; 433 ; 434 return ret ;; 435}; 436 ; 437 ; 438 ; 439////////////////////////////////////////////////////////////////////////////////; 440/// Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; 441/// rangeName, optionally taking the integrand normalized over observables nset; 442 ; 443const RooAbsReal* RooAbsPdf::getNormObj(const RooArgSet* nset, const RooArgSet* iset, const TNamed* rangeName) const; 444{; 445 // Check normalization is already stored; 446 CacheElem* cache = static_cast<CacheElem*>(_normMgr.getObj(nset,iset,nullptr,rangeName)) ;; 447 if (cache) {; 448 return cache->_norm.get();; 449 }; 450 ; 451 // If not create it now; 452 RooArgSet depList;; 453 getObservables(iset, depList);; 454 ; 455 // Normalization is always over all pdf components. Overriding the global; 456 // component selection temporarily makes all RooRealIntegrals created during; 457 // that time always include all components.; 458 GlobalSelectComponentRAII globalSelComp(true);; 459 RooAbsReal* norm = std::unique_ptr<RooAbsReal>{createIntegral(depList,*nset, *getIntegratorConfig()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:16755,cache,cache,16755,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cache']
Performance,"rmalization cache element.Definition RooAbsPdf.cxx:2430; RooAbsPdf::GenSpecDefinition RooAbsPdf.h:72; RooAbsPdf::GenSpec::_genContextstd::unique_ptr< RooAbsGenContext > _genContextDefinition RooAbsPdf.h:83; RooAbsPdf::GenSpec::~GenSpecvirtual ~GenSpec(); RooAbsPdf::GenSpec::_whatVarsRooArgSet _whatVarsDefinition RooAbsPdf.h:84; RooAbsPdf::GenSpec::_initbool _initDefinition RooAbsPdf.h:91; RooAbsPdf::GenSpec::_extendedbool _extendedDefinition RooAbsPdf.h:87; RooAbsPdf::GenSpec::_nGenInt_t _nGenDefinition RooAbsPdf.h:86; RooAbsPdf::GenSpec::GenSpecGenSpec()=default; RooAbsPdf::GenSpec::_randProtobool _randProtoDefinition RooAbsPdf.h:88; RooAbsPdf::GenSpec::_resampleProtobool _resampleProtoDefinition RooAbsPdf.h:89; RooAbsPdf::GenSpec::_protoDataRooDataSet * _protoDataDefinition RooAbsPdf.h:85; RooAbsPdfAbstract interface for all probability density functions.Definition RooAbsPdf.h:40; RooAbsPdf::syncNormalizationvirtual bool syncNormalization(const RooArgSet *dset, bool adjustProxies=true) constVerify that the normalization integral cached with this PDF is valid for given set of normalization o...Definition RooAbsPdf.cxx:481; RooAbsPdf::getNormdouble getNorm(const RooArgSet &nset) constGet normalisation term needed to normalise the raw values returned by getVal().Definition RooAbsPdf.h:195; RooAbsPdf::compileForNormSetstd::unique_ptr< RooAbsArg > compileForNormSet(RooArgSet const &normSet, RooFit::Detail::CompileContext &ctx) const overrideDefinition RooAbsPdf.cxx:2788; RooAbsPdf::_normMgrRooObjCacheManager _normMgrDefinition RooAbsPdf.h:329; RooAbsPdf::_specGeneratorConfigstd::unique_ptr< RooNumGenConfig > _specGeneratorConfig! MC generator configuration specific for this objectDefinition RooAbsPdf.h:340; RooAbsPdf::getValVdouble getValV(const RooArgSet *set=nullptr) const overrideReturn current value, normalized by integrating over the observables in nset.Definition RooAbsPdf.cxx:319; RooAbsPdf::fitToImplvirtual std::unique_ptr< RooFitResult > fitToImpl(RooAbsData &",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:143155,cache,cached,143155,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cached']
Performance,"rmalization integral (owned by _normMgr); RooObjCacheManager_normMgrThe cache manager; TString_normRangeNormalization range; static TString_normRangeOverride; RooArgSet*_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_t_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_t_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_t_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsPdf.html:42592,cache,cache,42592,root/html530/RooAbsPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsPdf.html,2,['cache'],['cache']
Performance,"rmalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; const RooArgSet*_nset! Normalization set to be used in evaluation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooRealProxy_pdfProbability Density function; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooEffProd.html:44731,cache,cache,44731,root/html602/RooEffProd.html,https://root.cern,https://root.cern/root/html602/RooEffProd.html,4,['cache'],['cache']
Performance,rmalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealVar*_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:39639,cache,cache,39639,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,1,['cache'],['cache']
Performance,rmalization that applies to convolutions; RooListProxy_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*_convSetIter! Iterator over _convNormSet; RooRealVar*_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_t_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotM,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:40021,cache,cache,40021,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,2,['cache'],['cache']
Performance,"rmalizedName.c_str());; 3089// }; 3090 ; 3091 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3092 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3093 // and we want to make that the TClass for the pair goes through the regular creation; 3094 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3095 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3096 // will be used to create the TProtoClass (if one is requested for the pair).; 3097 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3098 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3099 ; 3100 TClass *loadedcl = nullptr;; 3101 if (checkTable) {; 3102 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3103 } else {; 3104 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3105 // At this point more information has been loaded. This; 3106 // information might be pertinent to the normalization of the name.; 3107 // For example it might contain or be a typedef for which we don't; 3108 // have a forward declaration (eg. typedef to instance of class; 3109 // template with default parameters). So let's redo the normalization; 3110 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3111 // lead to a different value.; 3112 {; 3113 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3114 TClassEdit::GetNormalizedName(normalizedName, name);; 3115 }; 3116 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3117 }; 3118 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3119 if (e); 3120 return nullptr;; 3121 // Maybe this was a typedef: let's try to see if this is the case; 3122 if (!loadedcl && !ispair && !ispairbase) {; 3123 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3124 // We have a typedef: we ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:117552,load,loaded,117552,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"rmalizedName.c_str());; 3156// }; 3157 ; 3158 // We want to avoid auto-parsing due to intentionally missing dictionary for std::pair.; 3159 // However, we don't need this special treatement in rootcling (there is no auto-parsing); 3160 // and we want to make that the TClass for the pair goes through the regular creation; 3161 // mechanism (i.e. in rootcling they should be in kInterpreted state and never in; 3162 // kEmulated state) so that they have proper interpreter (ClassInfo) information which; 3163 // will be used to create the TProtoClass (if one is requested for the pair).; 3164 const bool ispair = TClassEdit::IsStdPair(normalizedName) && !IsFromRootCling();; 3165 const bool ispairbase = TClassEdit::IsStdPairBase(normalizedName) && !IsFromRootCling();; 3166 ; 3167 TClass *loadedcl = nullptr;; 3168 if (checkTable) {; 3169 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3170 } else {; 3171 if (gInterpreter->AutoLoad(normalizedName.c_str(),kTRUE)) {; 3172 // At this point more information has been loaded. This; 3173 // information might be pertinent to the normalization of the name.; 3174 // For example it might contain or be a typedef for which we don't; 3175 // have a forward declaration (eg. typedef to instance of class; 3176 // template with default parameters). So let's redo the normalization; 3177 // as the new information (eg. typedef in TROOT::GetListOfTypes) might; 3178 // lead to a different value.; 3179 {; 3180 TInterpreter::SuspendAutoLoadingRAII autoloadOff(gInterpreter);; 3181 TClassEdit::GetNormalizedName(normalizedName, name);; 3182 }; 3183 loadedcl = LoadClassDefault(normalizedName.c_str(),silent);; 3184 }; 3185 auto e = TEnum::GetEnum(normalizedName.c_str(), TEnum::kNone);; 3186 if (e); 3187 return nullptr;; 3188 // Maybe this was a typedef: let's try to see if this is the case; 3189 if (!loadedcl && !ispair && !ispairbase) {; 3190 if (TDataType* theDataType = gROOT->GetType(normalizedName.c_str())){; 3191 // We have a typedef: we ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:120303,load,loaded,120303,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"rmat.; Click in the canvas area, near the edges, with the right mouse button and select the Print context menu entry. This will generate a file of canvas pointed to by c1. You can select the name of the PostScript file. If the file name is xxx.ps, you will generate a PostScript file named xxx.ps. If the file name is xxx.eps, you generate an encapsulated Postscript file instead. In your program (or script), you can type:. c1->Print(""xxx.ps"") // or; c1->Print(""xxx.eps""); Next example prints the picture in the pad pointed by pad1.; pad1->Print(""xxx.ps""); The TPad::Print method has a second parameter called option. Its value can be:. 0 which is the default and is the same as “ps”; “ps” a Postscript file is produced; “Portrait” a Postscript file is produced with Portrait orientation; “Landscape” a Postscript file is produced with Landscape orientation; “eps”an Encapsulated Postscript file; “Preview”an Encapsulated Postscript file with preview is produced; “gif” a Graphics Interchange Format file; “cxx” a C++ macro file is generated; “pdf”a Portable Document Format file; “xml” a eXtensible Mark-up Language file; “jpg”a Joint Photographic Experts Group file; “png” a Portable Network Graphics Format (PNG file); “xpm” a X11 Pixel Map Format; “svg” a Scalable Vector Graphics file; “tiff” a Tagged-Image File Format; “root”a ROOT binary file is produced. You do not need to specify this second parameter; you can indicate by the filename extension what format you want to save a canvas in (i.e. canvas.ps, canvas.gif, canvas.C, etc).; The size of the PostScript picture, by default, is computed to keep the aspect ratio of the picture on the screen, where the size along x is always 20 cm. You can set the size of the PostScript picture before generating the picture with a command such as:; TPostScript myps(""myfile.ps"",111); myps.Range(xsize,ysize);; object->Draw();; myps.Close();; The first parameter in the TPostScript constructor is the name of the file; the second one is the format o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:374592,Scalab,Scalable,374592,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Scalab'],['Scalable']
Performance,"rmed */; 13378 return -1;; 13379}; 13380 ; 13381 ; 13382static int; 13383set_throttle(const char *spec, const union usa *rsa, const char *uri); 13384{; 13385 int throttle = 0;; 13386 struct vec vec, val;; 13387 char mult;; 13388 double v;; 13389 ; 13390 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13391 mult = ',';; 13392 if ((val.ptr == NULL); 13393 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13394 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13395 // to an integer value, but function will not report; 13396 // conversion errors; consider using 'strtol' instead; 13397 || (v < 0); 13398 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13399 && (mult != ','))) {; 13400 continue;; 13401 }; 13402 v *= (lowercase(&mult) == 'k'); 13403 ? 1024; 13404 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13405 if (vec.len == 1 && vec.ptr[0] == '*') {; 13406 throttle = (int)v;; 13407 } else {; 13408 int matched = parse_match_net(&vec, rsa, 0);; 13409 if (matched >= 0) {; 13410 /* a valid IP subnet */; 13411 if (matched) {; 13412 throttle = (int)v;; 13413 }; 13414 } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {; 13415 throttle = (int)v;; 13416 }; 13417 }; 13418 }; 13419 ; 13420 return throttle;; 13421}; 13422 ; 13423 ; 13424/* The mg_upload function is superseeded by mg_handle_form_request. */; 13425#include ""handle_form.inl""; 13426 ; 13427 ; 13428static int; 13429get_first_ssl_listener_index(const struct mg_context *ctx); 13430{; 13431 unsigned int i;; 13432 int idx = -1;; 13433 if (ctx) {; 13434 for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {; 13435 idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;; 13436 }; 13437 }; 13438 return idx;; 13439}; 13440 ; 13441 ; 13442/* Return host (without port) */; 13443static void; 13444get_host_from_request_info(struct vec *host, const struct mg_request_info *ri); 13445{; 13446 const char *host_header =; 13447 get_header(ri->http_headers, ri->num_headers, ""Host"");; 13448 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:391898,throttle,throttle,391898,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,2,['throttle'],['throttle']
Performance,"rmed */; 13379 return -1;; 13380}; 13381 ; 13382 ; 13383static int; 13384set_throttle(const char *spec, const union usa *rsa, const char *uri); 13385{; 13386 int throttle = 0;; 13387 struct vec vec, val;; 13388 char mult;; 13389 double v;; 13390 ; 13391 while ((spec = next_option(spec, &vec, &val)) != NULL) {; 13392 mult = ',';; 13393 if ((val.ptr == NULL); 13394 || (sscanf(val.ptr, ""%lf%c"", &v, &mult); 13395 < 1) // NOLINT(cert-err34-c) 'sscanf' used to convert a string; 13396 // to an integer value, but function will not report; 13397 // conversion errors; consider using 'strtol' instead; 13398 || (v < 0); 13399 || ((lowercase(&mult) != 'k') && (lowercase(&mult) != 'm'); 13400 && (mult != ','))) {; 13401 continue;; 13402 }; 13403 v *= (lowercase(&mult) == 'k'); 13404 ? 1024; 13405 : ((lowercase(&mult) == 'm') ? 1048576 : 1);; 13406 if (vec.len == 1 && vec.ptr[0] == '*') {; 13407 throttle = (int)v;; 13408 } else {; 13409 int matched = parse_match_net(&vec, rsa, 0);; 13410 if (matched >= 0) {; 13411 /* a valid IP subnet */; 13412 if (matched) {; 13413 throttle = (int)v;; 13414 }; 13415 } else if (match_prefix(vec.ptr, vec.len, uri) > 0) {; 13416 throttle = (int)v;; 13417 }; 13418 }; 13419 }; 13420 ; 13421 return throttle;; 13422}; 13423 ; 13424 ; 13425/* The mg_upload function is superseeded by mg_handle_form_request. */; 13426#include ""handle_form.inl""; 13427 ; 13428 ; 13429static int; 13430get_first_ssl_listener_index(const struct mg_context *ctx); 13431{; 13432 unsigned int i;; 13433 int idx = -1;; 13434 if (ctx) {; 13435 for (i = 0; ((idx == -1) && (i < ctx->num_listening_sockets)); i++) {; 13436 idx = ctx->listening_sockets[i].is_ssl ? ((int)(i)) : -1;; 13437 }; 13438 }; 13439 return idx;; 13440}; 13441 ; 13442 ; 13443/* Return host (without port) */; 13444static void; 13445get_host_from_request_info(struct vec *host, const struct mg_request_info *ri); 13446{; 13447 const char *host_header =; 13448 get_header(ri->http_headers, ri->num_headers, ""Host"");; 13449 ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:391931,throttle,throttle,391931,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['throttle'],['throttle']
Performance,"rms; of parameters only, which can serve as constraints p.d.f.s. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t stripDisconnected) const. void selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); Interface function used by test statistics to freeze choice of range; for interpretation of conditional product terms. void fixRefRange(const char* rangeName). std::list<Double_t>* plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. Bool_t isBinnedDistribution(const RooArgSet& obs) const; If all components that depend on obs are binned that so is the product. std::list<Double_t>* binBoundaries(RooAbsRealLValue& , Double_t , Double_t ) const; Forward the plot sampling hint from the p.d.f. that defines the observable obs. void setCacheAndTrackHints(RooArgSet& ); Label OK'ed components of a RooProdPdf with cache-and-track, _and_ label all RooProdPdf; descendants with extra informationa about (conditional) normalization, needed to be able; to Cache-And-Track them outside the RooprodPdf context. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProdPdf to more intuitively reflect the contents of the; product operator construction. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Implement support for node removal. TObject* clone(const char* newname) const; { return new RooProdPdf(*this,newname) ; }. Bool_t selfNormalized() const; { return _selfNorm ; }. Double_t expectedEvents(const RooArgSet* nset) const. const RooArgList& pdfList() const; { return _pdfList ; }. void setSelfNormalized(Bool_t flag); { _selfNorm = flag ; }. void setDefNormSet(const RooArgSet& nset); { _defNormSet.removeAll() ; _defNormSet.addClone(nset) ; }. CacheMode canNodeBeCached() const; { return RooAbsArg::NotAdvised ; }. void useDefaultGen(Bool_t flag = kTRUE); { _useDefaultGen = flag ; }. » Last changed: T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:59118,cache,cache-and-track,59118,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,9,"['Cache', 'cache']","['Cache-And-Track', 'cache-and-track']"
Performance,"rmula. class TTreeFormula: public TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. TTreeFormula(); TTreeFormula(const char* name, const char* formula, TTree* tree); virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeFormula.html:1536,load,loading,1536,root/html528/TTreeFormula.html,https://root.cern,https://root.cern/root/html528/TTreeFormula.html,6,['load'],['loading']
Performance,"rmula. class TTreeFormula: public TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidTFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tTFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tTFormula::Compile(const char* expression = """"); virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeFormula.html:1560,load,loading,1560,root/html602/TTreeFormula.html,https://root.cern,https://root.cern/root/html602/TTreeFormula.html,2,['load'],['loading']
Performance,"rmulaManager ();  Tree FormulaManger default constructor. ;  ;  ~TTreeFormulaManager () override;  Tree FormulaManager default destructor. ;  ; virtual void Add (TTreeFormula *);  Add a new formula to the list of formulas managed The manager of the formula will be changed and the old one will be deleted if it is empty. ;  ; virtual Int_t GetMultiplicity () const;  ; virtual Int_t GetNdata (bool forceLoadDim=false);  Return number of available instances in the formulas. ;  ; TClass * IsA () const override;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; virtual void Remove (TTreeFormula *);  Remove a formula from this manager. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool Sync ();  Synchronize all the formulae. ;  ; virtual void UpdateFormulaLeaves ();  This function could be called TTreePlayer::UpdateFormulaLeaves, itself called by TChain::LoadTree when a new Tree is loaded. ;  ;  Public Member Functions inherited from TObject;  TObject ();  TObject constructor. ;  ;  TObject (const TObject &object);  TObject copy ctor. ;  ; virtual ~TObject ();  TObject destructor. ;  ; void AbstractMethod (const char *method) const;  Use this method to implement an ""abstract"" method that you don't want to leave purely abstract. ;  ; virtual void AppendPad (Option_t *option="""");  Append graphics object to current pad. ;  ; virtual void Browse (TBrowser *b);  Browse object. May be overridden for another default action. ;  ; ULong_t CheckedHash ();  Check and record whether this class has a consistent Hash/RecursiveRemove setup (*) and then return the regular Hash value for this object. ;  ; virtual const char * ClassName () const;  Returns name of class to which the object belongs. ;  ; virtual void Clear (Option_t *="""");  ; virtual TObject * Clone (const char *newname="""") const;  Make a c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormulaManager.html:1684,load,loaded,1684,doc/master/classTTreeFormulaManager.html,https://root.cern,https://root.cern/doc/master/classTTreeFormulaManager.html,1,['load'],['loaded']
Performance,"rn 0;; 2447 }; 2448 return TTree::Scan(varexp, selection, option, nentries, firstentry);; 2449}; 2450 ; 2451////////////////////////////////////////////////////////////////////////////////; 2452/// Set the global branch kAutoDelete bit.; 2453///; 2454/// When LoadTree loads a new Tree, the branches for which; 2455/// the address is set will have the option AutoDelete set; 2456/// For more details on AutoDelete, see TBranch::SetAutoDelete.; 2457 ; 2458void TChain::SetAutoDelete(bool autodelete); 2459{; 2460 if (autodelete) {; 2461 SetBit(kAutoDelete, true);; 2462 } else {; 2463 SetBit(kAutoDelete, false);; 2464 }; 2465}; 2466 ; 2467Int_t TChain::SetCacheSize(Long64_t cacheSize); 2468{; 2469 // Set the cache size of the underlying TTree,; 2470 // See TTree::SetCacheSize.; 2471 // Returns 0 cache state ok (exists or not, as appropriate); 2472 // -1 on error; 2473 ; 2474 Int_t res = 0;; 2475 ; 2476 // remember user has requested this cache setting; 2477 fCacheUserSet = true;; 2478 ; 2479 if (fTree) {; 2480 res = fTree->SetCacheSize(cacheSize);; 2481 } else {; 2482 // If we don't have a TTree yet only record the cache size wanted; 2483 res = 0;; 2484 }; 2485 fCacheSize = cacheSize; // Record requested size.; 2486 return res;; 2487}; 2488 ; 2489////////////////////////////////////////////////////////////////////////////////; 2490/// Reset the addresses of the branch.; 2491 ; 2492void TChain::ResetBranchAddress(TBranch *branch); 2493{; 2494 TChainElement* element = (TChainElement*) fStatus->FindObject(branch->GetName());; 2495 if (element) {; 2496 element->SetBaddress(nullptr);; 2497 }; 2498 if (fTree) {; 2499 fTree->ResetBranchAddress(branch);; 2500 }; 2501}; 2502 ; 2503////////////////////////////////////////////////////////////////////////////////; 2504/// Reset the addresses of the branches.; 2505 ; 2506void TChain::ResetBranchAddresses(); 2507{; 2508 TIter next(fStatus);; 2509 TChainElement* element = nullptr;; 2510 while ((element = (TChainElement*) next())) {; 2511 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:89131,cache,cache,89131,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,5,['cache'],"['cache', 'cacheSize']"
Performance,"rn a p.d.f that represent a projection of this p.d.f integrated over given observables. RooAbsReal* createCdf(const RooArgSet& iset, const RooArgSet& nset = RooArgSet()); Create a cumulative distribution function of this p.d.f in terms; of the observables listed in iset. If no nset argument is given; the c.d.f normalization is constructed over the integrated; observables, so that its maximum value is precisely 1. It is also; possible to choose a different normalization for; multi-dimensional p.d.f.s: eg. for a pdf f(x,y,z) one can; construct a partial cdf c(x,y) that only when integrated itself; over z results in a maximum value of 1. To construct such a cdf pass; z as argument to the optional nset argument. RooAbsReal* createCdf(const RooArgSet& iset, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); Create an object that represents the integral of the function over one or more observables listed in iset; The actual integration calculation is only performed when the return object is evaluated. The name; of the integral object is automatically constructed from the name of the input function, the variables; it integrates and the range integrates over. The following named arguments are accepted. SupNormSet(const RooArgSet&) -- Observables over which should be normalized _in_addition_ to the; integration observables; ScanNumCdf() -- Apply scanning technique if cdf integral involves numeric integration [ default ]; ScanAllCdf() -- Always apply scanning technique; ScanNoCdf() -- Never apply scanning technique; ScanParameters(Int_t nbins, -- Parameters for scanning technique of making CDF: number; Int_t intOrder) of sampled bins and order of interpolation applied on numeric cdf. RooAbsReal* createScanCd",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:76242,perform,performed,76242,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,9,['perform'],['performed']
Performance,"rn are the main components of the geometrical tree. A specific shape can be created stand-alone:; TGeoBBox *box = new TGeoBBox(""s_box"",halfX,halfY,halfZ); // named; TGeoTube *tub = new TGeoTube(rmin,rmax,halfZ); // no name; //... (See all specific shape constructors); Sometimes it is much easier to create a volume having a given shape in one step, since shapes are not directly linked in the geometrical tree but volumes are:; TGeoVolume *vol_box = gGeoManager->MakeBox(""BOX_VOL"",pmed,halfX,; halfY,halfZ);; TGeoVolume *vol_tub = gGeoManager->MakeTube(""TUB_VOL"",pmed,rmin,; rmax,halfZ);; // ...(See MakeXXX() utilities in TGeoManager class); 18.3.6 Dividing Shapes; Shapes can generally be divided along a given axis. Supported axes are: X, Y, Z, Rxy, Phi, Rxyz. A given shape cannot be divided however on any axis. The general rule is that that divisions are possible on whatever axis that produces still known shapes as slices. The division of shapes are performed by the call TGeoShape::Divide(), but this operation can be done only via TGeoVolume::Divide() method. In other words, the algorithm for dividing a specific shape is known by the shape object, but is always invoked in a generic way from the volume level. Details on how to do that can be found in the paragraph ‘Dividing volumes’. One can see how all division options are interpreted and which their result inside specific shape classes is.; 18.3.7 Parametric Shapes; Shapes generally have a set of parameters that is well defined at build time. In fact, when the final geometrical hierarchy is assembled and the geometry is closed, all constituent shapes MUST**have well defined and valid parameters. In order to ease-up geometry creation, some parameterizations are however allowed.; For instance let’s suppose that we need to define several volumes having exactly the same properties but different sizes. A way to do this would be to create as many different volumes and shapes. The modeller allows however the definition of a sin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:925294,perform,performed,925294,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['performed']
Performance,"rn fgGrayscaleMode;; 2588}; 2589 ; 2590////////////////////////////////////////////////////////////////////////////////; 2591/// Set whether all colors should return grayscale values.; 2592 ; 2593void TColor::SetGrayscale(Bool_t set /*= kTRUE*/); 2594{; 2595 if (fgGrayscaleMode == set) return;; 2596 ; 2597 fgGrayscaleMode = set;; 2598 ; 2599 if (!gVirtualX || gROOT->IsBatch()) return;; 2600 ; 2601 TColor::InitializeColors();; 2602 TIter iColor(gROOT->GetListOfColors());; 2603 TColor* color = nullptr;; 2604 while ((color = (TColor*) iColor())); 2605 color->Allocate();; 2606}; 2607 ; 2608////////////////////////////////////////////////////////////////////////////////; 2609/// \brief Static function creating a color palette based on an input text file.; 2610///; 2611/// Every color in the file will take the same amount of space in the palette.; 2612///; 2613/// \see https://doi.org/10.1038/s41467-020-19160-7; 2614/// \note This function is designed to load into ROOT the colour-vision; 2615/// deficiency friendly and perceptually uniform colour maps specially designed; 2616/// in https://doi.org/10.5281/zenodo.4491293, namely the .txt files stored; 2617/// in the subfolders of ScientificColourMaps7.zip, e.g. batlow/batlow.txt; 2618///; 2619/// \param fileName: Name of a .txt file (ASCII) containing three floats per; 2620/// line, separated by spaces, namely the r g b fractions of the color, each; 2621/// value being in the range [0,1].; 2622/// \param alpha the global opacity for all colors within this palette; 2623/// \return a positive value on success and -1 on error.; 2624/// \author Fernando Hueso-González; 2625Int_t TColor::CreateColorTableFromFile(TString fileName, Float_t alpha); 2626{; 2627 std::ifstream f(fileName.Data());; 2628 if (!f.good()) {; 2629 ::Error(""TColor::CreateColorPalette(const TString)"", ""%s does not exist or cannot be opened"", fileName.Data());; 2630 return -1;; 2631 }; 2632 ; 2633 Int_t nLines = 0;; 2634 Float_t r, g, b;; 2635 std::vector<Flo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TColor_8cxx_source.html:94688,load,load,94688,doc/master/TColor_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TColor_8cxx_source.html,1,['load'],['load']
Performance,"rn pointer to object identified by namecycle. ;  ; template<class T > ; T * Get (const char *namecycle);  See documentation of TDirectoryFile::Get(const char *namecycle) ;  ; virtual Int_t GetBufferSize () const;  ; virtual TDirectory * GetDirectory (const char *namecycle, Bool_t printError=false, const char *funcname=""GetDirectory"");  Find a directory using apath. ;  ; virtual TKey * GetKey (const char *, Short_t=9999) const;  ; virtual TList * GetList () const;  ; virtual TList * GetListOfKeys () const;  ; TObject * GetMother () const;  ; TDirectory * GetMotherDir () const;  ; virtual Int_t GetNbytesKeys () const;  ; virtual Int_t GetNkeys () const;  ; template<class T > ; void GetObject (const char *namecycle, T *&ptr);  Get an object with proper type checking. ;  ; virtual void * GetObjectChecked (const char *namecycle, const char *classname);  See documentation of TDirectory::GetObjectCheck(const char *namecycle, const TClass *cl) ;  ; virtual void * GetObjectChecked (const char *namecycle, const TClass *cl);  Return pointer to object identified by namecycle if and only if the actual object is a type suitable to be stored as a pointer to a ""expectedClass"" If expectedClass is null, no check is performed. ;  ; virtual void * GetObjectUnchecked (const char *namecycle);  Return pointer to object identified by namecycle. ;  ; virtual const char * GetPath () const;  Returns the full path of the directory. ;  ; virtual const char * GetPathStatic () const;  Returns the full path of the directory. ;  ; virtual Long64_t GetSeekDir () const;  ; virtual Long64_t GetSeekKeys () const;  ; virtual Long64_t GetSeekParent () const;  ; TUUID GetUUID () const;  ; Bool_t IsBuilt () const;  ; virtual Bool_t IsModified () const;  ; virtual Bool_t IsWritable () const;  ; virtual TDirectory * mkdir (const char *name, const char *title="""", Bool_t returnExistingDirectory=kFALSE);  Create a sub-directory ""a"" or a hierarchy of sub-directories ""a/b/c/..."". ;  ; virtual TFile * OpenFile (con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:16091,perform,performed,16091,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['perform'],['performed']
Performance,"rn the build node name.; 3906 ; 3907const char *TSystem::GetBuildNode() const; 3908{; 3909 return fBuildNode;; 3910}; 3911 ; 3912////////////////////////////////////////////////////////////////////////////////; 3913/// Return the path of the build directory.; 3914 ; 3915const char *TSystem::GetBuildDir() const; 3916{; 3917 if (fBuildDir.Length()==0) {; 3918 if (!gEnv) return """";; 3919 const_cast<TSystem*>(this)->fBuildDir = gEnv->GetValue(""ACLiC.BuildDir"","""");; 3920 }; 3921 return fBuildDir;; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Return the debug flags.; 3926 ; 3927const char *TSystem::GetFlagsDebug() const; 3928{; 3929 return fFlagsDebug;; 3930}; 3931 ; 3932////////////////////////////////////////////////////////////////////////////////; 3933/// Return the optimization flags.; 3934 ; 3935const char *TSystem::GetFlagsOpt() const; 3936{; 3937 return fFlagsOpt;; 3938}; 3939 ; 3940////////////////////////////////////////////////////////////////////////////////; 3941/// AclicMode indicates whether the library should be built in; 3942/// debug mode or optimized. The values are:; 3943/// - TSystem::kDefault : compile the same as the current ROOT; 3944/// - TSystem::kDebug : compiled in debug mode; 3945/// - TSystem::kOpt : optimized the library; 3946 ; 3947TSystem::EAclicMode TSystem::GetAclicMode() const; 3948{; 3949 return fAclicMode;; 3950}; 3951 ; 3952////////////////////////////////////////////////////////////////////////////////; 3953/// Return the command line use to make a shared library.; 3954/// See TSystem::CompileMacro for more details.; 3955 ; 3956const char *TSystem::GetMakeSharedLib() const; 3957{; 3958 return fMakeSharedLib;; 3959}; 3960 ; 3961////////////////////////////////////////////////////////////////////////////////; 3962/// Return the command line use to make an executable.; 3963/// See TSystem::CompileMacro for more details.; 3964 ; 3965const char *TSystem::GetMakeExe() const; 3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:133605,optimiz,optimized,133605,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"rn the current Process-ID.Definition TBuffer.cxx:344; TBuffer::WriteProcessIDvirtual UShort_t WriteProcessID(TProcessID *pid)=0Always return 0 (current processID).Definition TBuffer.cxx:353; TBuffer::fBufSizeInt_t fBufSizeDefinition TBuffer.h:50; TBuffer::SetParentvoid SetParent(TObject *parent)Set parent owning this buffer.Definition TBuffer.cxx:270; TBuffer::GetParentTObject * GetParent() constReturn pointer to parent of this buffer.Definition TBuffer.cxx:262; TBuffer::GetCurrentchar * GetCurrent() constDefinition TBuffer.h:97; TBuffer::Expandvoid Expand(Int_t newsize, Bool_t copy=kTRUE)Expand (or shrink) the I/O buffer to newsize bytes.Definition TBuffer.cxx:223; TBuffer::kIsOwner@ kIsOwnerDefinition TBuffer.h:75; TBuffer::SetBuffervoid SetBuffer(void *buf, UInt_t bufsiz=0, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr)Sets a new buffer in an existing TBuffer object.Definition TBuffer.cxx:187; TBuffer::PushDataCachevirtual void PushDataCache(TVirtualArray *)Push a new data cache area onto the list of area to be used for temporarily store 'missing' data memb...Definition TBuffer.cxx:362; TBuffer::SetReAllocFuncvoid SetReAllocFunc(ReAllocCharFun_t reallocfunc=nullptr)Set which memory reallocation method to use.Definition TBuffer.cxx:286; TBuffer::PopDataCachevirtual TVirtualArray * PopDataCache()Pop and Return the 'current' data cache area from the list of area to be used for temporarily store '...Definition TBuffer.cxx:381; TBuffer::EModeEModeDefinition TBuffer.h:73; TBuffer::kWrite@ kWriteDefinition TBuffer.h:73; TBuffer::kRead@ kReadDefinition TBuffer.h:73; TBuffer::fBufMaxchar * fBufMaxDefinition TBuffer.h:53; TBuffer::fBufCurchar * fBufCurDefinition TBuffer.h:52; TBuffer::AutoExpandvoid AutoExpand(Int_t size_needed)Automatically calculate a new size and expand the buffer to fit at least size_needed.Definition TBuffer.cxx:158; TBuffer::PeekDataCachevirtual TVirtualArray * PeekDataCache() constReturn the 'current' data cache area from the list of area",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:18371,cache,cache,18371,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['cache'],['cache']
Performance,"rn the string that is used to identify the object and, potentially, perform wildcard/regexp filtering on. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from TQObject; virtual void * GetSender ();  ; virtual const char * GetSenderClassName () const;  . Protected Attributes; TQCommand * fCurrent;  ; TObjLink * fCursor;  ; UInt_t fLimit;  ; TList * fLogBook;  ; Bool_t fLogging;  ;  Protected Attributes inherited from TQCommand; TString fName;  ; Bool_t fNewDelete;  ; Int_t fNRargs;  ; Int_t fNUargs;  ; void * fObject;  ; TQConnection * fRedo;  ; Long_t * fRedoArgs;  ; Int_t fState;  ; Int_t fStatus;  ; TString fTitle;  ; TQConnection * fUndo;  ; Long_t * fUndoArgs;  ;  Protected Attributes inherited from TList; Bool_t fAscending;  cache to speedup sequential calling of Before() and After() functions ;  ; TObjLinkWeakPtr_t fCache;  pointer to last entry in linked list ;  ; TObjLinkPtr_t fFirst;  ; TObjLinkPtr_t fLast;  pointer to first entry in linked list ;  ;  Protected Attributes inherited from TSeqCollection; Bool_t fSorted;  ;  Protected Attributes inherited from TCollection; TString fName;  ; Int_t fSize;  ;  Protected Attributes inherited from TQObject; TList * fListOfConnections;  list of signals from this object ;  ; TList * fListOfSignals;  ; Bool_t fSignalsBlocked;  list of connections to this object ;  . Additional Inherited Members;  Public Types inherited from TList; typedef TListIter Iterator_t;  ;  Public Types inherited from TCollection; enum  { kInitCapacity = 16; , kInitHashTableCapacity = 17; };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL <<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTQUndoManager.html:25621,cache,cache,25621,doc/master/classTQUndoManager.html,https://root.cern,https://root.cern/doc/master/classTQUndoManager.html,1,['cache'],['cache']
Performance,"rn true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulated: the class is missing its shared library. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function for this class.; The global IsA function will be used if there is no local IsA function (fIsA). A global IsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TClass.html:34577,cache,cache,34577,root/html526/TClass.html,https://root.cern,https://root.cern/root/html526/TClass.html,7,['cache'],['cache']
Performance,"rn true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the following code is proper for this class:; ThisClass *ptr;; void *void_ptr = (void)ptr;; TObject *obj = (TObject*)void_ptr;; This code would be wrong if 'ThisClass' did not inherit 'first' from; TObject. Bool_t IsTObject() const; Return kTRUE is the class inherits from TObject. Bool_t IsForeign() const; Return kTRUE is the class is Foreign (the class does not have a Streamer method). void PostLoadCheck(); Do the initialization that can only be done after the CINT dictionary has; been fully populated and can not be delayed efficiently. Long_t Property() const; Set TObject::fBits and fStreamerType to cache information about the; class. The bits are; kIsTObject : the class inherits from TObject; kStartWithTObject: TObject is the left-most class in the inheritance tree; kIsForeign : the class doe not have a Streamer method; The value of fStreamerType are; kTObject : the class inherits from TObject; kForeign : the class does not have a Streamer method; kInstrumented: the class does have a Streamer method; kExternal: the class has a free standing way of streaming itself; kEmulatedStreamer: the class is missing its shared library. void SetStreamerImpl(); Internal routine to set fStreamerImpl based on the value of; fStreamerType. void SetCollectionProxy(const ROOT::TCollectionProxyInfo& ); Create the collection proxy object (and the streamer object) from; using the information in the TCollectionProxyInfo. void SetContextMenuTitle(const char* title); Change (i.e. set) the title of the TNamed. void SetGlobalIsA(IsAGlobalFunc_t ); This function installs a global IsA function ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:54228,cache,cache,54228,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['cache'],['cache']
Performance,"rn value is the int value corresponding to the result of the executed command (float and double return values will be truncated). ; Definition at line 2423 of file TCling.cxx. ◆ HasASTFileOnDisk(). static bool HasASTFileOnDisk ; (; clang::Module * ; M, . const clang::Preprocessor & ; PP, . std::string * ; FullFileName = nullptr . ). static . Checks if there is an ASTFile on disk for the given module M. ; Definition at line 1065 of file TCling.cxx. ◆ hasParsedRootmapForLibrary(). static bool hasParsedRootmapForLibrary ; (; llvm::StringRef ; lib). static . Definition at line 7252 of file TCling.cxx. ◆ hasPrecomputedLibraryDeps(). static bool hasPrecomputedLibraryDeps ; (; llvm::StringRef ; lib). static . Definition at line 7273 of file TCling.cxx. ◆ IsFromRootCling(). static bool IsFromRootCling ; (; ). static . Definition at line 1058 of file TCling.cxx. ◆ IsTupleAscending(). static ETupleOrdering IsTupleAscending ; (; ). static . Definition at line 3923 of file TCling.cxx. ◆ loadGlobalModuleIndex(). static GlobalModuleIndex * loadGlobalModuleIndex ; (; cling::Interpreter & ; interp). static . Definition at line 1080 of file TCling.cxx. ◆ LoadModule(). static bool LoadModule ; (; const std::string & ; ModuleName, . cling::Interpreter & ; interp . ). static . Returnstrue if the module was loaded. ; Definition at line 1030 of file TCling.cxx. ◆ LoadModules(). static void LoadModules ; (; const std::vector< std::string > & ; modules, . cling::Interpreter & ; interp . ). static . Loads the C++ modules that we require to run any ROOT program. ; This is just supposed to make a C++ module from a modulemap available to the interpreter. ; Definition at line 1052 of file TCling.cxx. ◆ PrintDlError(). static void PrintDlError ; (; const char * ; dyLibName, . const char * ; modulename . ). static . Definition at line 1964 of file TCling.cxx. ◆ R__InitStreamerInfoFactory(). static bool R__InitStreamerInfoFactory ; (; ). static . Helper to initialize TVirtualStreamerInfo's factor e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx.html:14735,load,loadGlobalModuleIndex,14735,doc/master/TCling_8cxx.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx.html,1,['load'],['loadGlobalModuleIndex']
Performance,"rnPrefill ; Definition at line 68 of file TTreeCache.h. ◆ fMissCache. std::unique_ptr<MissCache> TTreeCache::fMissCache. protected . ! Cache contents for misses ; Definition at line 105 of file TTreeCache.h. ◆ fNbranches. Int_t TTreeCache::fNbranches {0}. protected . ! Number of branches in the cache ; Definition at line 44 of file TTreeCache.h. ◆ fNextClusterStart. Long64_t TTreeCache::fNextClusterStart {-1}. protected . ! End+1 of the cluster(s) where the current content was picked out ; Definition at line 43 of file TTreeCache.h. ◆ fNMissReadMiss. Int_t TTreeCache::fNMissReadMiss {0}. protected . Number of blocks read and not found in either cache. ; Definition at line 48 of file TTreeCache.h. ◆ fNMissReadOk. Int_t TTreeCache::fNMissReadOk {0}. protected . Number of blocks read, not found in the primary cache, and found in the secondary cache. ; Definition at line 46 of file TTreeCache.h. ◆ fNMissReadPref. Int_t TTreeCache::fNMissReadPref {0}. protected . Number of blocks read into the secondary (""miss"") cache. ; Definition at line 50 of file TTreeCache.h. ◆ fNReadMiss. Int_t TTreeCache::fNReadMiss {0}. protected . Number of blocks read and not found in the cache. ; Definition at line 47 of file TTreeCache.h. ◆ fNReadOk. Int_t TTreeCache::fNReadOk {0}. protected . Number of blocks read and found in the cache. ; Definition at line 45 of file TTreeCache.h. ◆ fNReadPref. Int_t TTreeCache::fNReadPref {0}. protected . Number of blocks that were prefetched. ; Definition at line 49 of file TTreeCache.h. ◆ fOneTime. bool TTreeCache::fOneTime {false}. protected . ! used in the learning phase ; Definition at line 57 of file TTreeCache.h. ◆ fOptimizeMisses. bool TTreeCache::fOptimizeMisses {false}. protected . ! true if we should optimize cache misses. ; Definition at line 72 of file TTreeCache.h. ◆ fPrefillType. EPrefillType TTreeCache::fPrefillType. protected . Whether a pre-filling is enabled (and if applicable which type) ; Definition at line 64 of file TTreeCache.h. ◆ f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:55733,cache,cache,55733,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"rnal scheduler, setting a value for 'numthreads' might not have any effect. The maximum number of threads can be influenced by the environment variable ROOT_MAX_THREADS: export ROOT_MAX_THREADS=2 will try to set the maximum number of active threads to 2, if the scheduling library (such as tbb) ""permits"".; NoteUse DisableImplicitMT() to disable multi-threading (some locks will remain in place as described in EnableThreadSafety()). EnableImplicitMT(1) creates a thread-pool of size 1. ; Definition at line 539 of file TROOT.cxx. ◆ EnableThreadSafety(). void ROOT::EnableThreadSafety ; (; ). Enable support for multi-threading within the ROOT code in particular, enables the global mutex to make ROOT thread safe/aware. ; Enables the global mutex to make ROOT thread safe/aware.; The following becomes safe:; concurrent construction and destruction of TObjects, including the ones registered in ROOT's global lists (e.g. gROOT->GetListOfCleanups(), gROOT->GetListOfFiles()); concurrent usage of different ROOT objects from different threads, including ones with global state (e.g. TFile, TTree, TChain) with the exception of graphics classes (e.g. TCanvas); concurrent calls to ROOT's type system classes, e.g. TClass and TEnum; concurrent calls to the interpreter through gInterpreter; concurrent loading of ROOT plug-ins. In addition, gDirectory, gFile and gPad become a thread-local variable. In all threads, gDirectory defaults to gROOT, a singleton which supports thread-safe insertion and deletion of contents. gFile and gPad default to nullptr, as it is for single-thread programs.; The ROOT graphics subsystem is not made thread-safe by this method. In particular drawing or printing different canvases from different threads (and analogous operations such as invoking Draw on a TObject) is not thread-safe.; Note that there is no DisableThreadSafety(). ROOT's thread-safety features cannot be disabled once activated. ; Definition at line 501 of file TROOT.cxx. ◆ FindEndSymbol(). static st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT.html:33559,concurren,concurrent,33559,doc/master/namespaceROOT.html,https://root.cern,https://root.cern/doc/master/namespaceROOT.html,3,['concurren'],['concurrent']
Performance,"rnal viewer clients use it. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLLogicalShape(); voidAddRef(TGLPhysicalShape* phys) const; virtual Bool_tAlwaysSecondarySelect() const; const TGLBoundingBox&BoundingBox() const; static TClass*Class(); voidDestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidDLCacheDrop(); virtual voidDLCachePurge(); virtual UInt_tDLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*GetExternal() const; const TGLPhysicalShape*GetFirstPhysical() const; static Bool_tGetIgnoreSizeForCameraInterest(); TGLScene*GetScene() const; TObject*ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tRef() const; Bool_tSetDLCache(Bool_t cached); static voidSetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidStrongRef(Bool_t strong) const; voidSubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesSupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; UInt_tUnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidUpdateBoundingBoxesOfPhysicals(). protected:. voidPurgeDLRange(UInt_t base, Int_t size) const. private:. TGLLogicalShape&operator=(const TGLLogicalShape&). Data Members; public:. enum ELODAxes { kLODAxesNone; kLODAxesX; kLODAxes",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLLogicalShape.html:3295,cache,cached,3295,root/html534/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html534/TGLLogicalShape.html,2,['cache'],['cached']
Performance,"rnally, randomly, and by accept/reject sampling; Int_t_updateFMaxPerEventIf true, maximum p.d.f value needs to be recalculated for each event; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Initialize a new context for generating events with the specified; variables, using the specified PDF model. A prototype dataset (if provided); is not cloned and still belongs to the caller. The contents and shape; of this dataset can be changed between calls to generate() as long as the; expected columns to be copied to the generated dataset are present.; Any argument supplied in the forceDirect RooArgSet are always offered; for internal generation to the p.d.f., even if this is deemed unsafe by; the logic of RooGenContext. ~RooGenContext(); Destructor. void attach(const RooArgSet& params); Attach the cloned model to the event buffer we will be filling. void initGenerator(const RooArgSet& theEvent); Perform one-time initialization of the generator context. void generateEvent(RooArgSet& theEvent, Int_t remaining); Generate one event. The 'remaining' integer is not used other than; for printing messages. void printMultiline(ostream& os, Int_t content, Bool_t verbose = kFALSE, TString indent = """") const; Printing interface. RooGenContext(const RooAbsPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0). » Last changed: Tue Jun 30 14:33:14 2015 » Last generated: 2015-06-30 14:33; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenContext.html:11808,Perform,Perform,11808,root/html602/RooGenContext.html,https://root.cern,https://root.cern/root/html602/RooGenContext.html,1,['Perform'],['Perform']
Performance,"rned when window URL is opened ; Definition at line 139 of file RWebWindow.hxx. ◆ fDisconnCallback. WebWindowConnectCallback_t ROOT::RWebWindow::fDisconnCallback. private . ! callback for disconnect event ; Definition at line 159 of file RWebWindow.hxx. ◆ fHasWindowThrd. bool ROOT::RWebWindow::fHasWindowThrd {false}. private . ! indicate if special window thread was started ; Definition at line 162 of file RWebWindow.hxx. ◆ fHeight. unsigned ROOT::RWebWindow::fHeight {0}. private . ! initial window width and height when displayed, zeros are ignored ; Definition at line 166 of file RWebWindow.hxx. ◆ fId. unsigned ROOT::RWebWindow::fId {0}. private . ! unique identifier ; Definition at line 141 of file RWebWindow.hxx. ◆ fInputQueue. std::queue<QueueEntry> ROOT::RWebWindow::fInputQueue. private . ! input queue for all callbacks ; Definition at line 164 of file RWebWindow.hxx. ◆ fInputQueueMutex. std::mutex ROOT::RWebWindow::fInputQueueMutex. private . ! mutex to protect input queue ; Definition at line 165 of file RWebWindow.hxx. ◆ fMaster. std::shared_ptr<RWebWindow> ROOT::RWebWindow::fMaster. private . ! master window where this window is embedded ; Definition at line 137 of file RWebWindow.hxx. ◆ fMasterConns. std::vector<MasterConn> ROOT::RWebWindow::fMasterConns. private . ! master connections ; Definition at line 138 of file RWebWindow.hxx. ◆ fMaxQueueLength. unsigned ROOT::RWebWindow::fMaxQueueLength {10}. private . ! maximal number of queue entries ; Definition at line 156 of file RWebWindow.hxx. ◆ fMgr. std::shared_ptr<RWebWindowsManager> ROOT::RWebWindow::fMgr. private . ! display manager ; Definition at line 136 of file RWebWindow.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native connection are allowed, created by Show() method ; Definition at line 154 of file RWebWindow.hxx. ◆ fOperationTmout. float ROOT::RWebWindow::fOperationTmout {50.}. private . ! timeout in seconds to perform synchronous operation, default ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html:56230,queue,queue,56230,doc/v632/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindow.html,1,['queue'],['queue']
Performance,"rned when window URL is opened ; Definition at line 142 of file RWebWindow.hxx. ◆ fDisconnCallback. WebWindowConnectCallback_t ROOT::RWebWindow::fDisconnCallback. private . ! callback for disconnect event ; Definition at line 162 of file RWebWindow.hxx. ◆ fHasWindowThrd. bool ROOT::RWebWindow::fHasWindowThrd {false}. private . ! indicate if special window thread was started ; Definition at line 165 of file RWebWindow.hxx. ◆ fHeight. unsigned ROOT::RWebWindow::fHeight {0}. private . ! initial window width and height when displayed, zeros are ignored ; Definition at line 169 of file RWebWindow.hxx. ◆ fId. unsigned ROOT::RWebWindow::fId {0}. private . ! unique identifier ; Definition at line 144 of file RWebWindow.hxx. ◆ fInputQueue. std::queue<QueueEntry> ROOT::RWebWindow::fInputQueue. private . ! input queue for all callbacks ; Definition at line 167 of file RWebWindow.hxx. ◆ fInputQueueMutex. std::mutex ROOT::RWebWindow::fInputQueueMutex. private . ! mutex to protect input queue ; Definition at line 168 of file RWebWindow.hxx. ◆ fMaster. std::shared_ptr<RWebWindow> ROOT::RWebWindow::fMaster. private . ! master window where this window is embedded ; Definition at line 140 of file RWebWindow.hxx. ◆ fMasterConns. std::vector<MasterConn> ROOT::RWebWindow::fMasterConns. private . ! master connections ; Definition at line 141 of file RWebWindow.hxx. ◆ fMaxQueueLength. unsigned ROOT::RWebWindow::fMaxQueueLength {10}. private . ! maximal number of queue entries ; Definition at line 159 of file RWebWindow.hxx. ◆ fMgr. std::shared_ptr<RWebWindowsManager> ROOT::RWebWindow::fMgr. private . ! display manager ; Definition at line 139 of file RWebWindow.hxx. ◆ fNativeOnlyConn. bool ROOT::RWebWindow::fNativeOnlyConn {false}. private . ! only native connection are allowed, created by Show() method ; Definition at line 157 of file RWebWindow.hxx. ◆ fOperationTmout. float ROOT::RWebWindow::fOperationTmout {50.}. private . ! timeout in seconds to perform synchronous operation, default ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RWebWindow.html:55114,queue,queue,55114,doc/master/classROOT_1_1RWebWindow.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RWebWindow.html,1,['queue'],['queue']
Performance,"rned, with ""http:"" a TWebFile, with ""file:"" a local TFile,; etc. (see the list of TFile plugin handlers in $ROOTSYS/etc/system.rootrc; for regular expressions that will be checked) and as last a local file will; be tried.; Before opening a file via TNetFile a check is made to see if the URL; specifies a local file. If that is the case the file will be opened; via a normal TFile. To force the opening of a local file via a; TNetFile use either TNetFile directly or specify as host ""localhost"".; The netopt argument is only used by TNetFile. For the meaning of the; options and other arguments see the constructors of the individual; file classes. In case of error returns 0. For TFile implementations supporting asynchronous file open, see; TFile::AsyncOpen(...), it is possible to request a timeout with the; option:; TIMEOUT=<secs> the timeout must be specified in seconds and; it will be internally checked with granularity of; one millisec. For remote files there is the option:; CACHEREAD opens an existing file for reading through the file cache.; The file will be downloaded to the cache and opened from there.; If the download fails, it will be opened remotely.; The file will be downloaded to the directory specified by; SetCacheFileDir(). TFileOpenHandle * AsyncOpen(const char* name, Option_t* option = """", const char* ftitle = """", Int_t compress = 1, Int_t netopt = 0); Static member function to submit an open request. The request will be; processed asynchronously. See TFile::Open(const char *, ...) for an; explanation of the arguments. A handler is returned which is to be passed; to TFile::Open(TFileOpenHandle *) to get the real TFile instance once; the file is open.; This call never blocks and it is provided to allow parallel submission; of file opening operations expected to take a long time.; TFile::Open(TFileOpenHandle *) may block if the file is not yet ready.; The sequence; TFile::Open(TFile::AsyncOpen(const char *, ...)); is equivalent to; TFile::Open(const char *, .",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:45935,cache,cache,45935,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,14,"['CACHE', 'cache']","['CACHEREAD', 'cache']"
Performance,"rned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* nset); Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); Activate caching of normalization integral values in a interpolated histogram; for integrals that exceed the specified minimum number of numerically integrated; dimensions, _and_ of which the integral has at most 2 parameters. The cache is scanned with a granularity defined by a binning named ""cache"" in the; scanned integral parameters and is interpolated to given order.; The cache values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. is persisted; in a RooWorkspace. This feature can substantially speed up fits and improve convergence with slow; multi-dimensional integrals whose value varies slowly with the parameters so th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:43978,cache,cached,43978,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['cache'],['cached']
Performance,"rning(Bool_t state); static voidSetRotationMatrix(Float_t angle); static voidSetSmoothing(Bool_t state); static voidSetTextFont(Font_t fontnumber); static Int_tSetTextFont(const char* fontname, Int_t italic = 0); static voidSetTextSize(Float_t textsize); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); TTF(); TTF(const TTF&); static voidVersion(Int_t& major, Int_t& minor, Int_t& patch). Data Members; protected:. static Int_tfgAscentstring ascent, used to compute Y alignment; static FT_BBoxfgCBoxstring control box; static FT_CharMapfgCharMap[32]font character map; static Int_tfgCurFontIdxcurrent font index; static FT_FacefgFace[32]font face; static Int_tfgFontCountnumber of fonts loaded; static char*fgFontName[32]font name; static TTGlyphfgGlyphs[1024]glyphs; static Bool_tfgHintinguse hinting (true by default); static Bool_tfgInittrue if the Init has been called; static Bool_tfgKerninguse kerning (true by default); static FT_LibraryfgLibraryFreeType font library; static Int_tfgNumGlyphsnumber of glyphs in the string; static FT_Matrix*fgRotMatrixrotation matrix; static Bool_tfgSmoothinguse anti-aliasing (true when >8 planes, false otherwise); static Int_tfgSymbItaFontIdxSymbol italic font index; static Int_tfgTBlankWtrailing blanks width; static Int_tfgWidthstring width, used to compute X alignment; static TTF::(anonymous)kMaxGlyphs; static TTF::(anonymous)kTTMaxFonts. Class Charts. Inheritance Chart:. TTF. Function documentation; ~TTF(); Cleanup TTF environment. void Init(); Initialise the TrueType fonts interface. void Cleanup(); Cleanup. Is called by the gCleanupTTF destructor. Short_t CharToUnicode(UInt_t code); Map char to unicode. Returns 0 in case no mapping exists. void GetTextExtent(UInt_t& w, UInt_t& h, char* text); Get width (w) and height (h) when text is horizontal. void GetTextAdvance(UInt_t& a, char* text); Get advance (a) when text is horizontal. void GetT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTF.html:1951,load,loaded,1951,root/html602/TTF.html,https://root.cern,https://root.cern/root/html602/TTF.html,4,['load'],['loaded']
Performance,"rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; TGLObject&operator=(const TGLObject&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLObject(); TGLObject(const TGLObject&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLObject.html:2429,cache,cached,2429,root/html602/TGLObject.html,https://root.cern,https://root.cern/root/html602/TGLObject.html,4,['cache'],['cached']
Performance,"rns kTRUE in case of success, kFALSE otherwise. ; Reimplemented from TVirtualX.; Definition at line 4230 of file TGCocoa.mm. ◆ ReconfigureDisplay(). void TGCocoa::ReconfigureDisplay ; (; ). Definition at line 595 of file TGCocoa.mm. ◆ RemoveWindow(). void TGCocoa::RemoveWindow ; (; ULong_t ; qwid). overridevirtual . Removes the created by Qt window ""qwid"". ; Reimplemented from TVirtualX.; Definition at line 856 of file TGCocoa.mm. ◆ ReparentChild(). void TGCocoa::ReparentChild ; (; Window_t ; wid, . Window_t ; pid, . Int_t ; x, . Int_t ; y . ). Definition at line 1042 of file TGCocoa.mm. ◆ ReparentTopLevel(). void TGCocoa::ReparentTopLevel ; (; Window_t ; wid, . Window_t ; pid, . Int_t ; x, . Int_t ; y . ). Definition at line 1089 of file TGCocoa.mm. ◆ ReparentWindow(). void TGCocoa::ReparentWindow ; (; Window_t ; id, . Window_t ; pid, . Int_t ; x, . Int_t ; y . ). overridevirtual . If the specified window is mapped, ReparentWindow automatically performs an UnmapWindow request on it, removes it from its current position in the hierarchy, and inserts it as the child of the specified parent. ; The window is placed in the stacking order on top with respect to sibling windows. ; Reimplemented from TVirtualX.; Definition at line 1111 of file TGCocoa.mm. ◆ RequestLocator(). Int_t TGCocoa::RequestLocator ; (; Int_t ; mode, . Int_t ; ctyp, . Int_t & ; x, . Int_t & ; y . ). overridevirtual . Requests Locator position. ; Parameters. [in]x,ycursor position at moment of button press (output) ; [in]ctypcursor type (input); ctyp = 1 tracking cross; ctyp = 2 cross-hair; ctyp = 3 rubber circle; ctyp = 4 rubber band; ctyp = 5 rubber rectangle. [in]modeinput mode; mode = 0 request; mode = 1 sample. Returns; in request mode:; 1 = left is pressed; 2 = middle is pressed; 3 = right is pressed. in sample mode:; 11 = left is released; 12 = middle is released; 13 = right is released; -1 = nothing is pressed or released; -2 = leave the window; else = keycode (keyboard is pressed) . Reimplemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGCocoa.html:108090,perform,performs,108090,doc/master/classTGCocoa.html,https://root.cern,https://root.cern/doc/master/classTGCocoa.html,1,['perform'],['performs']
Performance,rns; Parameters. dfltif result is not defined ; namename of the env variable . Definition at line 47 of file RWebWindowsManager.cxx. ◆ GetCodeVersion(). std::string ROOT::RWebWindowWSHandler::GetCodeVersion ; (; ). inlineoverrideprotectedvirtual . Method generate extra suffix for all kinds of loaded code. ; Reimplemented from THttpWSHandler.; Definition at line 38 of file RWebWindowWSHandler.hxx. ◆ GetDefaultPageContent(). TString ROOT::RWebWindowWSHandler::GetDefaultPageContent ; (; ). inlineoverridevirtual . returns content of default web-page THttpWSHandler interface ; Reimplemented from THttpWSHandler.; Definition at line 135 of file RWebWindowWSHandler.hxx. ◆ ProcessBatchHolder(). Bool_t ROOT::RWebWindowWSHandler::ProcessBatchHolder ; (; std::shared_ptr< THttpCallArg > & ; ). inlineoverrideprotectedvirtual . Method used to accept or reject root_batch_holder.js request. ; Reimplemented from THttpWSHandler.; Definition at line 33 of file RWebWindowWSHandler.hxx. ◆ ProcessWS(). Bool_t ROOT::RWebWindowWSHandler::ProcessWS ; (; THttpCallArg * ; arg). inlineoverridevirtual . Process websocket request - called from THttpServer thread THttpWSHandler interface. ; Implements THttpWSHandler.; Definition at line 142 of file RWebWindowWSHandler.hxx. ◆ VerifyDefaultPageContent(). void ROOT::RWebWindowWSHandler::VerifyDefaultPageContent ; (; std::shared_ptr< THttpCallArg > & ; arg). inlineoverrideprotectedvirtual . Method called when default page content is prepared for use By default no-cache header is provided. ; Reimplemented from THttpWSHandler.; Definition at line 41 of file RWebWindowWSHandler.hxx. Member Data Documentation. ◆ fWindow. RWebWindow& ROOT::RWebWindowWSHandler::fWindow. ! window reference ; Definition at line 123 of file RWebWindowWSHandler.hxx. gui/webdisplay/src/RWebWindowWSHandler.hxx; gui/webdisplay/src/RWebWindowsManager.cxx. ROOTRWebWindowWSHandler. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:13:37 (GVA Time) using Doxygen 1.9.8   ; . ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowWSHandler.html:17671,cache,cache,17671,doc/v632/classROOT_1_1RWebWindowWSHandler.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowWSHandler.html,1,['cache'],['cache']
Performance,"ro, Bool_t notOnClient = kFALSE, Bool_t uniqueOnly = kTRUE, TList* wrks = 0); Copy the specified macro in the cache directory. The macro file is; uploaded if new or updated. If existing, the corresponding header; basename(macro).h or .hh, is also uploaded. For the other arguments; see TProof::Load().; Returns 0 in case of success and -1 in case of error. Int_t CopyMacroToCache(const char* macro, Int_t headerRequired = 0, TSelector** selector = 0, Int_t opt = 0); Copy a macro, and its possible associated .h[h] file,; to the cache directory, from where the workers can get the file.; If headerRequired is 1, return -1 in case the header is not found.; If headerRequired is 0, try to copy header too.; If headerRequired is -1, don't look for header, only copy macro.; If the selector pionter is not 0, consider the macro to be a selector; and try to load the selector and set it to the pointer.; The mask 'opt' is an or of ESendFileOpt:; kCpBin (0x8) Retrieve from the cache the binaries associated; with the file; kCp (0x10) Retrieve the files from the cache; Return -1 in case of error, 0 otherwise. Int_t CleanupSandbox(); Remove old sessions dirs keep at most 'Proof.MaxOldSessions' (default 10). TList * GetListOfQueries(Option_t* opt = """"); Get the list of queries. Bool_t RegisterDataSet(const char* dsName, TFileCollection* ds, const char* opt = """"); Register the 'dataSet' on the cluster under the current; user, group and the given 'dataSetName'.; Fails if a dataset named 'dataSetName' already exists, unless 'optStr'; contains 'O', in which case the old dataset is overwritten.; If 'optStr' contains 'V' the dataset files are verified (default no; verification).; Returns kTRUE on success. Int_t SetDataSetTreeName(const char* dataset, const char* treename); Set/Change the name of the default tree. The tree name may contain; subdir specification in the form ""subdir/name"".; Returns 0 on success, -1 otherwise. Bool_t ExistsDataSet(const char* uri); Returns kTRUE if 'dataset' describe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofLite.html:29376,cache,cache,29376,root/html528/TProofLite.html,https://root.cern,https://root.cern/root/html528/TProofLite.html,12,['cache'],['cache']
Performance,"robabilities.; 869 * <tr><td> **codegen** <td> **Experimental** - Generates and compiles minimal C++ code for the NLL on-the-fly and wraps it in the returned RooAbsReal.; 870 * Also generates and compiles the code for the gradient using Automatic Differentiation (AD) with [Clad](https://github.com/vgvassilev/clad).; 871 * This analytic gradient is passed to the minimizer, which can result in significant speedups for many-parameter fits,; 872 * even compared to the **cpu** backend. However, if one of the RooAbsArg objects in the model does not support the code generation,; 873 * this backend can't be used.; 874 * <tr><td> **codegen_no_grad** <td> **Experimental** - Same as **codegen**, but doesn't generate and compile the gradient code and use the regular numerical differentiation instead.; 875 * This is expected to be slower, but useful for debugging problems with the analytic gradient.; 876 * </table>; 877 * <tr><td> `Optimize(bool flag)` <td> Activate constant term optimization (on by default); 878 * <tr><td> `SplitRange(bool flag)` <td> Use separate fit ranges in a simultaneous fit. Actual range name for each subsample is assumed to; 879 * be `rangeName_indexState`, where `indexState` is the state of the master index category of the simultaneous fit.; 880 * Using `Range(""range""), SplitRange()` as switches, different ranges could be set like this:; 881 * ```; 882 * myVariable.setRange(""range_pi0"", 135, 210);; 883 * myVariable.setRange(""range_gamma"", 50, 210);; 884 * ```; 885 * <tr><td> `Constrain(const RooArgSet&pars)` <td> For p.d.f.s that contain internal parameter constraint terms (that is usually product PDFs, where one; 886 * term of the product depends on parameters but not on the observable(s),), only apply constraints to the given subset of parameters.; 887 * <tr><td> `ExternalConstraints(const RooArgSet& )` <td> Include given external constraints to likelihood by multiplying them with the original likelihood.; 888 * <tr><td> `GlobalObservables(const RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:38101,optimiz,optimization,38101,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"rocess this tree executing the TSelector code in the specified filename. ; The return value is -1 in case of error and TSelector::GetStatus() in in case of success.; The code in filename is loaded (interpreted or compiled, see below), filename must contain a valid class implementation derived from TSelector, where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts, a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the slave servers.; Process(): called for each event, in this function you decide what to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF called only on the slave servers.; Terminate(): called at the end of the loop on the tree, a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted. If filename is of the form file.C++, the file file.C will be compiled and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled and dynamically loaded. At next call, if file.C is older than file.o and file.so, the file.C is not compiled, only file.so is loaded. NOTE 1; It may be more interesting to invoke directly the other Process function accepting a TSelector* as argument.eg MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);; filenameOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding cha",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreePlayer.html:40367,load,loaded,40367,doc/master/classTTreePlayer.html,https://root.cern,https://root.cern/doc/master/classTTreePlayer.html,1,['load'],['loaded']
Performance,"rocessIDs!Array of pointers to TProcessIDs; Int_tfReadCallsNumber of read calls ( not counting the cache calls ); TStringfRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tfSeekFreeLocation on disk of free segments structure; Long64_tfSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Double_tfSum2BufferSum of squares of buffer sizes of objects written so far; Double_tfSumBufferSum of buffer sizes of objects written so far; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tfUnitsNumber of bytes for file pointers; TUrlfUrl!URL of file; Int_tfVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tfWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>fgBytesWriteNumber of bytes written by all TFile objects; static TStringfgCacheFileDirDirectory where to locally stage files; static Bool_tfgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tfgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>fgFileCounterCounter for all opened files; static Bool_tfgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tfgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>fgReadCallsNumber of bytes read from all TFile objects; static Bool_tfgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tfgReadaheadSizeReadahead buffer size.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TFile.html:23497,cache,cache,23497,root/html602/TFile.html,https://root.cern,https://root.cern/root/html602/TFile.html,10,"['CACHE', 'cache']","['CACHEREAD', 'cache', 'cached']"
Performance,"rogram for the class TUnfoldSys ;  testUnfold5a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold5d.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold6.C Test program for the class TUnfoldBinning ;  testUnfold7a.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7b.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  testUnfold7c.C Test program for the classes TUnfoldDensity and TUnfoldBinning ;  ► unuran;  unuranDemo.CExample macro to show unuran capabilities The results are compared with what is obtained using TRandom or TF1::GetRandom The macro is divided in 3 parts: ;  unuranFoamTest.CThis program must be compiled and executed with Aclic as follows ;  ► v7;  box.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 boxes in it (RBox) ;  concurrentfill.cxx;  draw.cxx;  draw_mt.cxxThis macro demonstrate usage of ROOT7 graphics from many threads Three different canvases in three different threads are started and regularly updated ;  draw_rh1.cxxThis macro generates a small V7 TH1D, fills it and draw it in a V7 canvas ;  draw_subpads.cxx;  draw_v6.cxx;  fitpanel.cxx;  histops.cxx;  line.cxxThis ROOT 7 example demonstrates how to create a ROOT 7 canvas (RCanvas) and draw ROOT 7 lines in it (RLine) ;  lineStyle.cxx;  lineWidth.cxx;  markerStyle.cxx;  pad.cxx;  perf.cxx;  perfcomp.cxx;  simple.cxx;  text.cxx;  ► vecops;  vo001_AdoptOrOwnMemory.C In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo001_AdoptOrOwnMemory.py In this tutorial we learn how the RVec class can be used to adopt existing memory or allocate some ;  vo002_VectorCalculations.C In this tutorial we learn how the RVec class can be used to express easily mathe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/files.html:171451,concurren,concurrentfill,171451,doc/v616/files.html,https://root.cern,https://root.cern/doc/v616/files.html,1,['concurren'],['concurrentfill']
Performance,"rojX == GetZaxis() ) {; 2074 stats[2] = stats[7];; 2075 stats[3] = stats[8];; 2076 }; 2077 h1->PutStats(stats);; 2078 }; 2079 else {; 2080 // reset statistics; 2081 h1->ResetStats();; 2082 }; 2083 if (resetEntries) {; 2084 // in case of error calculation (i.e. when Sumw2() is set); 2085 // use the effective entries for the entries; 2086 // since this is the only way to estimate them; 2087 Double_t entries = TMath::Floor( totcont + 0.5); // to avoid numerical rounding; 2088 if (computeErrors) entries = h1->GetEffectiveEntries();; 2089 h1->SetEntries( entries );; 2090 }; 2091 else {; 2092 h1->SetEntries( fEntries );; 2093 }; 2094 ; 2095 return h1;; 2096}; 2097 ; 2098 ; 2099////////////////////////////////////////////////////////////////////////////////; 2100/// internal method performing the projection to a 2D histogram; 2101/// called from TH3::Project3D; 2102 ; 2103TH2D *TH3::DoProject2D(const char* name, const char * title, const TAxis* projX, const TAxis* projY,; 2104 bool computeErrors, bool originalRange,; 2105 bool useUF, bool useOF) const; 2106{; 2107 TH2D *h2 = nullptr;; 2108 ; 2109 // Get range to use as well as bin limits; 2110 Int_t ixmin = std::max(projX->GetFirst(),1);; 2111 Int_t ixmax = std::min(projX->GetLast(),projX->GetNbins());; 2112 Int_t iymin = std::max(projY->GetFirst(),1);; 2113 Int_t iymax = std::min(projY->GetLast(),projY->GetNbins());; 2114 ; 2115 Int_t nx = ixmax-ixmin+1;; 2116 Int_t ny = iymax-iymin+1;; 2117 ; 2118 // Create the histogram, either reseting a preexisting one; 2119 // or creating one from scratch.; 2120 // Does an object with the same name exists?; 2121 TObject *h2obj = gROOT->FindObject(name);; 2122 if (h2obj && h2obj->InheritsFrom(TH1::Class())) {; 2123 if ( h2obj->IsA() != TH2D::Class() ) {; 2124 Error(""DoProject2D"",""Histogram with name %s must be a TH2D and is a %s"",name,h2obj->ClassName());; 2125 return nullptr;; 2126 }; 2127 h2 = (TH2D*)h2obj;; 2128 // reset histogram and its axes; 2129 h2->Reset();; 2130 const TArrayD ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TH3_8cxx_source.html:82795,perform,performing,82795,doc/master/TH3_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TH3_8cxx_source.html,1,['perform'],['performing']
Performance,"rojected is used as secondary inheritance. ; Reimplemented from TEveProjected.; Definition at line 142 of file TEveStraightLineSet.h. ◆ IsA(). TClass * TEveStraightLineSetProjected::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TEveStraightLineSet.; Definition at line 144 of file TEveStraightLineSet.h. ◆ operator=(). TEveStraightLineSetProjected & TEveStraightLineSetProjected::operator= ; (; const TEveStraightLineSetProjected & ; ). private . ◆ SetDepthLocal(). void TEveStraightLineSetProjected::SetDepthLocal ; (; Float_t ; d). overrideprotectedvirtual . Set depth (z-coordinate) of the projected points. ; Reimplemented from TEveProjected.; Definition at line 229 of file TEveStraightLineSet.cxx. ◆ SetProjection(). void TEveStraightLineSetProjected::SetProjection ; (; TEveProjectionManager * ; mng, . TEveProjectable * ; model . ). overridevirtual . Set projection manager and model object. ; Reimplemented from TEveProjected.; Definition at line 218 of file TEveStraightLineSet.cxx. ◆ Streamer(). void TEveStraightLineSetProjected::Streamer ; (; TBuffer & ; ). overridevirtual . Reimplemented from TEveStraightLineSet. ◆ StreamerNVirtual(). void TEveStraightLineSetProjected::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 144 of file TEveStraightLineSet.h. ◆ UpdateProjection(). void TEveStraightLineSetProjected::UpdateProjection ; (; ). overridevirtual . Callback that actually performs the projection. ; Called when projection parameters have been updated. ; Implements TEveProjected.; Definition at line 253 of file TEveStraightLineSet.cxx. Libraries for TEveStraightLineSetProjected:. [legend]; The documentation for this class was generated from the following files:; graf3d/eve/inc/TEveStraightLineSet.h; graf3d/eve/src/TEveStraightLineSet.cxx. TEveStraightLineSetProjected. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:42:44 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveStraightLineSetProjected.html:48929,perform,performs,48929,doc/master/classTEveStraightLineSetProjected.html,https://root.cern,https://root.cern/doc/master/classTEveStraightLineSetProjected.html,1,['perform'],['performs']
Performance,"rols the maximum number of iteration of the Brent algorithm If the flag logx is set the grid search is done in log step size This is done automatically if the log scale is set in the current Pad; NOTE: see also TF1::GetMaximumX and TF1::GetX ; Reimplemented from TF1.; Definition at line 497 of file TF1.cxx. ◆ GetMaximumXY(). Double_t TF2::GetMaximumXY ; (; Double_t & ; x, . Double_t & ; y . ); const. virtual . Compute the X and Y values corresponding to the maximum value of the function. ; Return the maximum value of the function See TF2::GetMinimumXY ; Definition at line 440 of file TF2.cxx. ◆ GetMinimum() [1/2]. Double_t TF2::GetMinimum ; (; Double_t * ; x); const. virtual . Return minimum/maximum value of the function. ; To find the minimum on a range, first set this range via the SetRange function If a vector x of coordinate is passed it will be used as starting point for the minimum. In addition on exit x will contain the coordinate values at the minimuma If x is NULL or x is infinity or NaN, first, a grid search is performed to find the initial estimate of the minimum location. The range of the function is divided into fNpx and fNpy sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed by SetNpx and SetNpy functions Then, a minimization is used with starting values found by the grid search The minimizer algorithm used (by default Minuit) can be changed by callinga ROOT::Math::Minimizer::SetDefaultMinimizerType("".."") Other option for the minimizer can be set using the static method of the MinimizerOptions class ; Definition at line 465 of file TF2.cxx. ◆ GetMinimum() [2/2]. Double_t TF1::GetMinimum ; (; Double_t ; xmin = 0, . Double_t ; xmax = 0, . Double_t ; epsilon = 1.E-10, . Int_t ; maxiter = 100, . Bool_t ; logx = false . ); const. virtual . Returns the minimum value of the function on the (xmin, xmax) interval. ; Method: First, the grid search is used to bracket the maximum with the step size = (xmax-xmin)/fNpx. This way, the step s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTF2.html:58394,perform,performed,58394,doc/master/classTF2.html,https://root.cern,https://root.cern/doc/master/classTF2.html,1,['perform'],['performed']
Performance,"rom POINT. Bool_t Contains(const Double_t* point) const; test if point is inside this shape; check total z range. Double_t DistFromInside(const Double_t* point, const Double_t* dir, Int_t iact = 1, Double_t step = TGeoShape::Big(), Double_t* safe = 0) const; compute distance from inside point to surface of the polygone; first find out in which Z section the point is in. void LocatePhi(const Double_t* point, Int_t& ipsec) const; Locates index IPSEC of the phi sector containing POINT. Int_t GetPhiCrossList(const Double_t* point, const Double_t* dir, Int_t istart, Double_t* sphi, Int_t* iphi, Double_t stepmax = TGeoShape::Big()) const; Returns lists of PGON phi crossings for a ray starting from POINT. Bool_t SliceCrossingInZ(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingZ(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Performs ray propagation between Z segments. Bool_t SliceCrossingIn(const Double_t* point, const Double_t* dir, Int_t ipl, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Check boundary crossing inside phi slices. Return distance snext to first crossing; if smaller than stepmax.; Protection in case point is in phi gap or close to phi boundaries and exiting. Bool_t SliceCrossing(const Double_t* point, const Double_t* dir, Int_t nphi, Int_t* iphi, Double_t* sphi, Double_t& snext, Double_t stepmax) const; Check boundary crossing inside phi slices. Return distance snext to first crossing; if smaller than stepmax. Bool_t IsCrossingSlice(const Double_t* point, const Double_t* dir, Int_t iphi, Double_t sstart, Int_t& ipl, Double_t& snext, Double_t stepmax) const; Check crossing of a given pgon slice, from a starting point inside the slice. Double_t DistFromOutside(const Double_t* point, const Double_t* dir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGeoPgon.html:17191,Perform,Performs,17191,root/html534/TGeoPgon.html,https://root.cern,https://root.cern/root/html534/TGeoPgon.html,3,['Perform'],['Performs']
Performance,rom TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Attributes; bool fAsyncReading;  ; Int_t fCycle;  ; bool fEmpty;  ; std::unique_ptr< TMutex > fIOMutex;  ; Int_t fNFound;  ! number of blocks that were found in the cache ;  ; Int_t fNMissed;  ! number of blocks that were not found in the cache and were unzipped ;  ; Int_t fNseekMax;  ! fNseek can change so we need to know its max size ;  ; Int_t fNStalls;  ! number of hits which caused a stall ;  ; Int_t fNUnzip;  ! number of blocks that were unzipped ;  ; bool fParallel;  Indicate if we want to activate the parallelism (for this instance) ;  ; Long64_t fUnzipBufferSize;  ! Max Size for the ready unzipped blocks (default is 2*fBufferSize) ;  ; Int_t fUnzipGroupSize;  ! Min accumulated size of a group of baskets ready to be unzipped by a IMT task ;  ; UnzipState_t fUnzipState;  ; std::unique_ptr< ROOT::Experimental::TTaskGroup > fUnzipTaskGroup;  ;  Protected Attributes inherited from TTreeCache; bool fAutoCreated {false};  ! true if cache was automatically created ;  ; TObjArray * fBranches {nullptr};  ! List of branches to be stored in the cache ;  ; TList * fBrNames {nullptr};  ! list of branch names in the cache ;  ; Long64_t fCurrentClusterStart {-1};  ! Start of the cluster(s) where the current content was picked out ;  ; bool fEnabled {true};  ! cache enabled for cached reading ;  ; Long64_t fEntryCurrent {-1};  ! current lowest entry number in the cache ;  ; Long64_t fEntryMax {1};  ! last entry in the cache ;  ; Long64_t fEntryMin {0};  ! first entry in the cache ;  ; Long64_t fEntryNext {-1};  ! next entry number where cache must be filled ;  ; Int_t fFillTimes {0};  ! how many times we can fill the current buffer ;  ; bool fFirstBuffer {true};  ! true if first buffer is used for prefetching ;  ; Long64_t fFirstEntry {-1};  ! save the value of the first entry ;  ; Long64_t fFirstMiss {-1};  ! set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we proc,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:19225,cache,cache,19225,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,22,['cache'],"['cache', 'cached']"
Performance,rom XML file. ; Called from MethodBase::ProcessSetup that is called from Factory::BookMethod ; Implements TMVA::PyMethodBase.; Definition at line 166 of file MethodPyKeras.cxx. ◆ ReadModelFromFile(). void MethodPyKeras::ReadModelFromFile ; (; ). virtual . Implements TMVA::PyMethodBase.; Definition at line 791 of file MethodPyKeras.cxx. ◆ ReadWeightsFromStream() [1/2]. virtual void TMVA::MethodPyKeras::ReadWeightsFromStream ; (; std::istream & ; ). inlinevirtual . Implements TMVA::PyMethodBase.; Definition at line 67 of file MethodPyKeras.h. ◆ ReadWeightsFromStream() [2/2]. virtual void TMVA::MethodPyKeras::ReadWeightsFromStream ; (; TFile & ; ). inlinevirtual . Reimplemented from TMVA::PyMethodBase.; Definition at line 68 of file MethodPyKeras.h. ◆ ReadWeightsFromXML(). virtual void TMVA::MethodPyKeras::ReadWeightsFromXML ; (; void * ; ). inlinevirtual . Implements TMVA::PyMethodBase.; Definition at line 66 of file MethodPyKeras.h. ◆ SetupKerasModel(). void MethodPyKeras::SetupKerasModel ; (; Bool_t ; loadTrainedModel). private . Definition at line 323 of file MethodPyKeras.cxx. ◆ SetupKerasModelForEval(). void MethodPyKeras::SetupKerasModelForEval ; (; ). private . Setting up model for evaluation Add here some needed optimizations like disabling eager execution. ; Definition at line 378 of file MethodPyKeras.cxx. ◆ TestClassification(). void MethodPyKeras::TestClassification ; (; ). virtual . initialization ; Reimplemented from TMVA::MethodBase.; Definition at line 653 of file MethodPyKeras.cxx. ◆ Train(). void MethodPyKeras::Train ; (; void ; ). virtual . Implements TMVA::PyMethodBase.; Definition at line 431 of file MethodPyKeras.cxx. ◆ UseTFKeras(). Bool_t TMVA::MethodPyKeras::UseTFKeras ; (; ); const. inline . Definition at line 80 of file MethodPyKeras.h. Member Data Documentation. ◆ fBatchSize. UInt_t TMVA::MethodPyKeras::fBatchSize {0}. private . Definition at line 85 of file MethodPyKeras.h. ◆ fContinueTraining. Bool_t TMVA::MethodPyKeras::fContinueTraining.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodPyKeras.html:35911,load,loadTrainedModel,35911,doc/master/classTMVA_1_1MethodPyKeras.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodPyKeras.html,1,['load'],['loadTrainedModel']
Performance,"rom the branches being processed (TTree::Draw or; TTree::Process and TSelectors) when in the learning phase.; The learning phase is by default 100 entries.; It can be changed via TTreeCache::SetLearnEntries. This cache speeds-up considerably the performance, in particular; when the Tree is accessed remotely via a high latency network. The default cache size (10 Mbytes) may be changed via the function; TTreeCache::SetCacheSize. Only the baskets for the requested entry range are put in the cache. For each Tree being processed a TTreeCache object is created.; This object is automatically deleted when the Tree is deleted or; when the file is deleted. -Special case of a TChain; Once the training is done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - A TTree automatically creates a cache; - TTree::SetCacheSize is called for the first time.; - TTree::SetCacheSize is called a second time with a different size.; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:1446,cache,cache,1446,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,4,['cache'],['cache']
Performance,"rom the fit result, and \( Z \) = requested signifance ( \( Z \sigma \) band); The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made; Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111) Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate. ; Definition at line 2601 of file RooAbsReal.cxx. ◆ plotSamplingHint(). std::list< double > * RooAbsReal::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. virtual . Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ; Parameters. [in]obsObservable to retrieve sampling hint for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented in RooLagrangianMorphFunc, RooAddition, RooFormulaVar, RooProduct, RooRealSumFunc, RooRealSumPdf, ParamHistFunc, PiecewiseInterpolation, RooMomentMorphFunc, RooParametricStepFunction, RooParamHistFunc, RooStepFunction, RooAddPdf, RooBinSamplingPdf, RooBinWidthFunction, RooHistFunc, RooHistPdf, RooLinearCombination, RooProdPdf, RooRangeBoolean, RooRealIntegral, and RooWrapperPdf.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:139191,perform,perform,139191,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['perform'],['perform']
Performance,"rom the fit result, and \( Z \) = requested signifance ( \( Z \sigma \) band); The linear method is fast (required 2*N evaluations of the curve, where N is the number of parameters), but may not be accurate in the presence of strong correlations (~>0.9) and at Z>2 due to linear and Gaussian approximations made; Alternatively, a more robust error is calculated using a sampling method. In this method a number of curves is calculated with variations of the parameter values, as drawn from a multi-variate Gaussian p.d.f. that is constructed from the fit results covariance matrix. The error(x) is determined by calculating a central interval that capture N% of the variations for each value of x, where N% is controlled by Z (i.e. Z=1 gives N=68%). The number of sampling curves is chosen to be such that at least 30 curves are expected to be outside the N% interval, and is minimally 100 (e.g. Z=1->Ncurve=100, Z=2->Ncurve=659, Z=3->Ncurve=11111) Intervals from the sampling method can be asymmetric, and may perform better in the presence of strong correlations, but may take (much) longer to calculate. ; Definition at line 2686 of file RooAbsReal.cxx. ◆ plotSamplingHint(). std::list< double > * RooAbsReal::plotSamplingHint ; (; RooAbsRealLValue & ; obs, . double ; xlo, . double ; xhi . ); const. virtual . Interface for returning an optional hint for initial sampling points when constructing a curve projected on observable obs. ; Parameters. [in]obsObservable to retrieve sampling hint for. ; [in]xloBeginning of range. ; [in]xhiEnd of range. . ReturnsThe caller owns the returned std::list. ; Reimplemented in RooLagrangianMorphFunc, RooAddition, RooFormulaVar, RooProduct, RooRealSumFunc, RooRealSumPdf, ParamHistFunc, PiecewiseInterpolation, RooMomentMorphFunc, RooParametricStepFunction, RooParamHistFunc, RooStepFunction, RooAddPdf, RooBinSamplingPdf, RooBinWidthFunction, RooHistFunc, RooHistPdf, RooLinearCombination, RooProdPdf, RooRangeBoolean, RooRealIntegral, and RooWrapperPdf.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:140618,perform,perform,140618,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['perform'],['perform']
Performance,"rom this dataset. void ShowQuota(const char* opt); Display quota information. void PrintUsedSpace(). Prints the quota. void MonitorUsedSpace(TVirtualMonitoringWriter* monitoring). Log info to the monitoring server. Long64_t GetGroupUsed(const char* group). Returns the used space of that group. Long64_t GetGroupQuota(const char* group). returns the quota a group is allowed to have. void UpdateUsedSpace(); updates the used space maps. Int_t RegisterDataSet(const char* uri, TFileCollection* dataSet, const char* opt); Register a dataset, perfoming quota checkings, if needed.; Returns 0 on success, -1 on failure. Int_t NotifyUpdate(const char* group = 0, const char* user = 0, const char* dspath = 0, Long_t mtime = 0, const char* checksum = 0); Save into the <datasetdir>/dataset.list file the name of the last updated; or created or modified dataset; Returns 0 on success, -1 on error. Int_t ClearCache(const char* uri); Clear cached information matching uri. Int_t ShowCache(const char* uri); Show cached information matching uri. TString CreateUri(const char* dsGroup = 0, const char* dsUser = 0, const char* dsName = 0, const char* dsTree = 0); Creates URI for the dataset manger in the form '[[/dsGroup/]dsUser/]dsName[#dsObjPath]',; The optional dsObjPath can be in the form [subdir/]objname]'. Bool_t ParseUri(const char* uri, TString* dsGroup = 0, TString* dsUser = 0, TString* dsName = 0, TString* dsTree = 0, Bool_t onlyCurrent = kFALSE, Bool_t wildcards = kFALSE); Parses a (relative) URI that describes a DataSet on the cluster.; The input 'uri' should be in the form '[[/group/]user/]dsname[#[subdir/]objname]',; where 'objname' is the name of the object (e.g. the tree name) and the 'subdir'; is the directory in the file wher it should be looked for.; After resolving against a base URI consisting of proof://masterhost/group/user; - meaning masterhost, group and user of the current session -; the path is checked to contain exactly three elements separated by '/':; group/user/ds",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManager.html:14224,cache,cached,14224,root/html528/TDataSetManager.html,https://root.cern,https://root.cern/root/html528/TDataSetManager.html,10,['cache'],['cached']
Performance,"rom tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooArgList_ownedListList of owned components; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_setset of terms to be summed; TIterator*_setIter! Iterator over set; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAddition.html:32359,cache,cache,32359,root/html530/RooAddition.html,https://root.cern,https://root.cern/root/html530/RooAddition.html,1,['cache'],['cache']
Performance,"rom tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.d.f being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:41356,cache,cache,41356,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,4,['cache'],['cache']
Performance,"romCache"", ""the header of the cache and/or ""; 4003 ""remote file are not readable - forcing an update"");; 4004 need2copy = kTRUE;; 4005 }; 4006 ; 4007 delete remotfile;; 4008 delete cachefile;; 4009 }; 4010 } else {; 4011 need2copy = kTRUE;; 4012 }; 4013 ; 4014 // try to fetch the file (disable now the forced caching); 4015 Bool_t forcedcache = fgCacheFileForce;; 4016 fgCacheFileForce = kFALSE;; 4017 if (need2copy) {; 4018 const auto cachefilepathtmp = cachefilepath + std::to_string(gSystem->GetPid()) + "".tmp"";; 4019 if (!TFile::Cp(name, cachefilepathtmp)) {; 4020 ::Warning(""TFile::OpenFromCache"",; 4021 ""you want to read through a cache, but I ""; 4022 ""cannot make a cache copy of %s - CACHEREAD disabled"",; 4023 cachefilepathbasedir.Data());; 4024 fgCacheFileForce = forcedcache;; 4025 return nullptr;; 4026 }; 4027 if (gSystem->AccessPathName(cachefilepath)) // then file _does not_ exist (weird convention); 4028 gSystem->Rename(cachefilepathtmp, cachefilepath);; 4029 else // another process or thread already wrote a file with the same name while we were copying it; 4030 gSystem->Unlink(cachefilepathtmp);; 4031 }; 4032 fgCacheFileForce = forcedcache;; 4033 ::Info(""TFile::OpenFromCache"", ""using local cache copy of %s [%s]"", name, cachefilepath.Data());; 4034 // finally we have the file and can open it locally; 4035 fileurl.SetProtocol(""file"");; 4036 fileurl.SetFile(cachefilepath);; 4037 ; 4038 TString tagfile;; 4039 tagfile = cachefilepath;; 4040 tagfile += "".ROOT.cachefile"";; 4041 // we symlink this file as a ROOT cached file; 4042 gSystem->Symlink(gSystem->BaseName(cachefilepath), tagfile);; 4043 return TFile::Open(fileurl.GetUrl(), ""READ"", ftitle, compress, netopt);; 4044 }; 4045 }; 4046 }; 4047 ; 4048 // Failed; 4049 return f;; 4050}; 4051 ; 4052////////////////////////////////////////////////////////////////////////////////; 4053/// Create / open a file; 4054///; 4055/// The type of the file can be either a; 4056/// TFile, TNetFile, TWebFile or any TFile derived cla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:146223,cache,cachefilepath,146223,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,6,['cache'],"['cache', 'cachefilepath', 'cachefilepathtmp']"
Performance,"romDir(TObject* obj); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable ; RooRealVar*_wgtVarPointer to weight variable (if set) ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDataSet(); Default constructor for persistence. RooDataSet(const char* name, const char* title, const RooArgSet& vars, RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); Construct an unbinned dataset from a RooArgSet defining the dimensions of the data space. Optionally, data; can be imported at the time of construction. This constructor takes the following optional arguments. Import(TTree*) -- Import contents of given TTree",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:16365,cache,cached,16365,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,2,['cache'],['cached']
Performance,"romDir(TObject* obj); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum RooAbsData::ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; TDirectory*RooDirItem::_dir! Associated directory; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSetRooAbsData::_varsDimensions of this data set; RooArgSet_varsNoWgtVars without weight variable ; RooRealVar*_wgtVarPointer to weight variable (if set) ; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooDataSet(); Default constructor for persistence. RooDataSet(const char* name, const char* title, const RooArgSet& vars, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Construct an unbinned dataset from a RooArgSet defining the dimensions of the data space. Optionally, data; can be imported at the time of construction. This constructor takes the following optional arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooDataSet.html:16383,cache,cached,16383,root/html528/RooDataSet.html,https://root.cern,https://root.cern/root/html528/RooDataSet.html,2,['cache'],['cached']
Performance,"rome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ EState. enum TCondor::EState. EnumeratorkFree ; kSuspended ; kActive . Definition at line 54 of file TCondor.h. Constructor & Destructor Documentation. ◆ TCondor(). TCondor::TCondor ; (; const char * ; pool = """"). Create Condor interface object. ; Uses Condor apps since there is no API yet. ; Definition at line 42 of file TCondor.cxx. ◆ ~TCondor(). TCondor::~TCondor ; (; ). override . Cleanup Condor interface. ; Definition at line 75 of file TCondor.cxx. Member Function Documentation. ◆ Claim() [1/2]. TCondorSlave * TCondor::Claim ; (; const char * ; vmname, . const char * ; cmd . ). Claim virtual machine with name vmname This function does not figure out the image and performance index before returning the condor slave. ; Definition at line 268 of file TCondor.cxx. ◆ Claim() [2/2]. TList * TCondor::Claim ; (; Int_t ; n, . const char * ; cmd . ). Claim n virtual machines This function figures out the image and performance index before returning the list of condor slaves. ; Definition at line 233 of file TCondor.cxx. ◆ ClaimVM(). TCondorSlave * TCondor::ClaimVM ; (; const char * ; vm, . const char * ; cmd . ). protected . Claim a VirtualMachine for PROOF usage. ; Definition at line 101 of file TCondor.cxx. ◆ Class(). static TClass * TCondor::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TCondor::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TCondor::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 88 of file TCondor.h. ◆ DeclFileName(). static const char * TCondor::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 88 of file TCondor.h. ◆ GetImage(). TString TCondor::GetImage ; (; const char * ; host); const. Get image of the worker. ; Definition at line 440 of file TCondor.cxx",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCondor.html:12167,perform,performance,12167,doc/master/classTCondor.html,https://root.cern,https://root.cern/doc/master/classTCondor.html,1,['perform'],['performance']
Performance,"roof to be used for dataset actions; TPBReadType*fReadTypeType of read (partial, full); Bool_tfReleaseCacheRelease cache for data reads between runs; TProofBenchRunCPU*fRunCPUInstance to run CPU scans; TProofBenchRunDataRead*fRunDSInstance to run data-read scans; TStringfSelOptionOption field for processing the selector; static TF1*fgFioFunction used for I/O rate fits; static TF1*fgFioVFunction used for I/O rate fits with non-constant Rcpu; static TF1*fgFp1Simple 1st degree polynomial; static TF1*fgFp1nNormalized 1st degree; static TF1*fgFp2Simple 2nd degree polynomial; static TF1*fgFp2nNormalized 2nd degree; static TF1*fgFp3Function with varying Rcpu; static TF1*fgFp3nNormalized Function with varying Rcpu; static TList*fgGraphsList of TGraphErrors created by Draw actions. private:. Bool_tfUnlinkOutfileWhether to remove empty output files. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBench(const char* url, const char* outfile = ""<default>"", const char* proofopt = 0); Constructor: check PROOF and load selectors PAR. ~TProofBench(); Destructor. Int_t OpenOutFile(Bool_t wrt = kFALSE, Bool_t verbose = kTRUE); Set the otuput file; Return 0 on success, -1 on error. Int_t SetOutFile(const char* outfile, Bool_t verbose = kTRUE); Set the output file; Return 0 on success, -1 on error. void CloseOutFile(); Close output file. Int_t RunCPU(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1, Int_t step = -1); Perform the CPU run; Return 0 on success, -1 on error. Int_t RunCPUx(Long64_t nevents = -1, Int_t start = -1, Int_t stop = -1); Perform the CPU run scanning over the number of workers per node; Return 0 on success, -1 on error. void DrawCPU(const char* outfile, const char* opt = ""std:"", Bool_t verbose = kFALSE, Int_t dofit = 0, Int_t n0 = -1, Int_t n1 = -1); Draw the CPU speedup plot.; opt = 'typewhat', e.g. 'std:max:'; type = 'std:' draw standard evt/s plot; 'stdx:' draw standard evt/s plot, 1 worker per node; 'norm:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProofBench.html:9802,load,load,9802,root/html602/TProofBench.html,https://root.cern,https://root.cern/root/html602/TProofBench.html,4,['load'],['load']
Performance,"roof::ESlaves list = kActive, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tCollect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd, Int_t nwk = 1); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*GetEnabledPackages() const; static Bool_tGetFileInCmd(const char* cmd, TString& fn); static Int_tGetInputData(TList* input, const char* cachedir, TString& emsg); TList*GetListOfActiveSlaves() const; TVirtualProofPlayer*GetPlayer() const; TPluginHandler*GetProgressDialog() const; Int_tGetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidHandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tHandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tInit(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidInitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tPollForNewWorkers(); voidPrepareInputDataFile(TString& dataFile); Int_tRemoveWorkers(TList* wrks); static Int_tSaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidSaveWorkerInfo(); Int_tSendFile(const char* file, Int_t opt = (kBinary | kForward | kCp | kCpBin), const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProof.html:19946,cache,cachedir,19946,root/html604/TProof.html,https://root.cern,https://root.cern/root/html604/TProof.html,2,['cache'],['cachedir']
Performance,"roofChain::Progress ; (; Long64_t ; total, . Long64_t ; processed . ). virtual . Changes the number of processed entries. ; Definition at line 425 of file TProofChain.cxx. ◆ ReleaseProof(). void TProofChain::ReleaseProof ; (; ). virtual . Releases PROOF. Disconnect the ""progress"" signal. ; Definition at line 445 of file TProofChain.cxx. ◆ SetDebug(). void TProofChain::SetDebug ; (; Int_t ; level = 1, . Long64_t ; min = 0, . Long64_t ; max = 9999999 . ). overridevirtual . See TTree::SetDebug. ; Reimplemented from TTree.; Definition at line 381 of file TProofChain.cxx. ◆ SetEntryList(). void TProofChain::SetEntryList ; (; TEntryList * ; enlist, . const Option_t * ;  . ). inlineoverride . Definition at line 84 of file TProofChain.h. ◆ SetEventList(). void TProofChain::SetEventList ; (; TEventList * ; evlist). inlineoverridevirtual . This function transfroms the given TEventList into a TEntryList. ; NOTE, that this function loads all tree headers, because the entry numbers in the TEventList are global and have to be recomputed, taking into account the number of entries in each tree.; The new TEntryList is owned by the TChain and gets deleted when the chain is deleted. This TEntryList is returned by GetEntryList() function, and after GetEntryList() function is called, the TEntryList is not owned by the chain any more and will not be deleted with it. ; Reimplemented from TChain.; Definition at line 83 of file TProofChain.h. ◆ SetName(). void TProofChain::SetName ; (; const char * ; name). overridevirtual . See TTree::GetName. ; Reimplemented from TChain.; Definition at line 389 of file TProofChain.cxx. ◆ Streamer(). void TProofChain::Streamer ; (; TBuffer & ; b). overridevirtual . Stream a class object. ; Reimplemented from TChain. ◆ StreamerNVirtual(). void TProofChain::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 89 of file TProofChain.h. Member Data Documentation. ◆ fChain. TChain* TProofChain::fChain. protected . Definitio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofChain.html:63223,load,loads,63223,doc/master/classTProofChain.html,https://root.cern,https://root.cern/doc/master/classTProofChain.html,1,['load'],['loads']
Performance,"roofDrawProfile Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TProofDrawProfile Class Reference. . Definition at line 165 of file TProofDraw.h. Public Member Functions;  TProofDrawProfile ();  ; void Begin (TTree *t) override;  See TProofDraw::Begin(). ;  ; void Init (TTree *) override;  See TProofDraw::Init(). ;  ; TClass * IsA () const override;  ; void SlaveBegin (TTree *) override;  See TProofDraw::SlaveBegin(). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  See TProofDraw::Terminate(). ;  ;  Public Member Functions inherited from TProofDraw;  TProofDraw ();  Constructor. ;  ;  ~TProofDraw () override;  Destructor. ;  ; Bool_t Notify () override;  Called when a new tree is loaded. ;  ; Bool_t Process (Long64_t) override;  Executed for each entry. ;  ; void SlaveTerminate () override;  Executed by each slave after the processing has finished, before returning the results to the client. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual TList * GetOutputList () const;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawProfile.html:1037,load,loaded,1037,doc/master/classTProofDrawProfile.html,https://root.cern,https://root.cern/doc/master/classTProofDrawProfile.html,1,['load'],['loaded']
Performance,"roofinfdir); voidTObject::MakeZombie(); voidTNetFile::PrintError(const char* where, Int_t err); Int_tTFile::ReadBufferViaCache(char* buf, Int_t len); Int_tTNetFile::Recv(Int_t& status, EMessageTypes& kind); voidTDirectory::RegisterContext(TDirectory::TContext* ctxt); virtual Int_tTFile::SysRead(Int_t fd, void* buf, Int_t len); virtual Long64_tTFile::SysSeek(Int_t fd, Long64_t offset, Int_t whence); virtual Int_tTFile::SysSync(Int_t fd); virtual Int_tTFile::SysWrite(Int_t fd, const void* buf, Int_t len); voidTDirectory::UnregisterContext(TDirectory::TContext* ctxt); Int_tTFile::WriteBufferViaCache(const char* buf, Int_t len). private:. TXNetFile(const TXNetFile&); voidCreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); static voidFormUrl(TUrl uut, TString& uu); static Int_tGetRootdProtocol(TSocket* s); virtual voidInit(Bool_t create); Bool_tOpen(Option_t* option, Bool_t parallelopen); TXNetFile&operator=(const TXNetFile&); Int_tParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); static voidSetEnv(); voidSynchronizeCacheSize(); virtual Int_tSysClose(Int_t fd); virtual Int_tSysOpen(const char* pathname, Int_t flags, UInt_t mode); virtual Int_tSysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime). Data Members; public:. enum TFile::EAsyncOpenStatus { kAOSNotAsync; kAOSFailure; kAOSInProgress; kAOSSuccess; };; enum TFile::EOpenTimeOut { kInstantTimeout; kEternalTimeout; };; enum TFile::ECacheAction { kDisconnect; kDoNotDisconnect; };; enum TFile::EStatusBits { kRecovered; kHasReferences; kDevNull; kWriteError; kBinaryFile; kRedirected; };; enum TFile::ERelativeTo { kBeg; kCur; kEnd; };; enum TFile::[unnamed] { kStartBigFile; };; enum TFile::EFileType { kDefault; kLocal; kNet; kWeb; kFile; kMerge; };; enum TDirectoryFile::[unnamed] { kCloseDirectory; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsRefe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXNetFile.html:18088,cache,cachesz,18088,root/html534/TXNetFile.html,https://root.cern,https://root.cern/root/html534/TXNetFile.html,2,['cache'],['cachesz']
Performance,"roofinfdir); voidTObject::MakeZombie(); voidTNetFile::PrintError(const char* where, Int_t err); Int_tTFile::ReadBufferViaCache(char* buf, Int_t len); Int_tTNetFile::Recv(Int_t& status, EMessageTypes& kind); voidTDirectory::RegisterContext(TDirectory::TContext* ctxt); virtual Int_tTFile::SysRead(Int_t fd, void* buf, Int_t len); virtual Long64_tTFile::SysSeek(Int_t fd, Long64_t offset, Int_t whence); virtual Int_tTFile::SysSync(Int_t fd); virtual Int_tTFile::SysWrite(Int_t fd, const void* buf, Int_t len); voidTDirectory::UnregisterContext(TDirectory::TContext* ctxt); Int_tTFile::WriteBufferViaCache(const char* buf, Int_t len). private:. TXNetFile(const TXNetFile&); voidCreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); static voidFormUrl(TUrl uut, TString& uu); static Int_tGetRootdProtocol(TSocket* s); virtual voidInit(Bool_t create); Bool_tOpen(Option_t* option, Bool_t parallelopen); TXNetFile&operator=(const TXNetFile&); Int_tParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); static voidSetEnv(); voidSynchronizeCacheSize(); virtual Int_tSysClose(Int_t fd); virtual Int_tSysOpen(const char* pathname, Int_t flags, UInt_t mode); virtual Int_tSysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime). Data Members; public:. enum TFile::EAsyncOpenStatus { kAOSNotAsync; kAOSFailure; kAOSInProgress; kAOSSuccess; };; enum TFile::EOpenTimeOut { kInstantTimeout; kEternalTimeout; };; enum TFile::EStatusBits { kRecovered; kHasReferences; kDevNull; kWriteError; kBinaryFile; kRedirected; };; enum TFile::ERelativeTo { kBeg; kCur; kEnd; };; enum TFile::[unnamed] { kStartBigFile; };; enum TFile::EFileType { kDefault; kLocal; kNet; kWeb; kFile; kMerge; };; enum TDirectoryFile::[unnamed] { kCloseDirectory; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TXNetFile.html:17929,cache,cachesz,17929,root/html532/TXNetFile.html,https://root.cern,https://root.cern/root/html532/TXNetFile.html,2,['cache'],['cachesz']
Performance,"roofinfdir); voidTObject::MakeZombie(); voidTNetFile::PrintError(const char* where, Int_t err); Int_tTFile::ReadBufferViaCache(char* buf, Int_t len); Int_tTNetFile::Recv(Int_t& status, EMessageTypes& kind); voidTDirectory::RegisterContext(TDirectory::TContext* ctxt); virtual Int_tTFile::SysRead(Int_t fd, void* buf, Int_t len); virtual Long64_tTFile::SysSeek(Int_t fd, Long64_t offset, Int_t whence); virtual Int_tTFile::SysSync(Int_t fd); virtual Int_tTFile::SysWrite(Int_t fd, const void* buf, Int_t len); voidTDirectory::UnregisterContext(TDirectory::TContext* ctxt); Int_tTFile::WriteBufferViaCache(const char* buf, Int_t len). private:. voidCreateXClient(const char* url, Option_t* option, Int_t netopt, Bool_t parallelopen); static voidFormUrl(TUrl uut, TString& uu); static Int_tGetRootdProtocol(TSocket* s); virtual voidInit(Bool_t create); Bool_tOpen(Option_t* option, Bool_t parallelopen); TXNetFile&operator=(const TXNetFile&); Int_tParseOptions(const char* opts, Int_t& cachesz, Int_t& readaheadsz, Int_t& rmpolicy, Int_t& mxredir, Int_t& rastrategy, Int_t& readtrimblksz); static voidSetEnv(); voidSynchronizeCacheSize(); virtual Int_tSysClose(Int_t fd); virtual Int_tSysOpen(const char* pathname, Int_t flags, UInt_t mode); virtual Int_tSysStat(Int_t fd, Long_t* id, Long64_t* size, Long_t* flags, Long_t* modtime); TXNetFile(const TXNetFile&). Data Members; public:. static TFile::EAsyncOpenStatusTFile::kAOSFailure; static TFile::EAsyncOpenStatusTFile::kAOSInProgress; static TFile::EAsyncOpenStatusTFile::kAOSNotAsync; static TFile::EAsyncOpenStatusTFile::kAOSSuccess; static TFile::ERelativeToTFile::kBeg; static TFile::EStatusBitsTFile::kBinaryFile; static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TDirectoryFile::(anonymous)TDirectoryFile::kCloseDirectory; static TFile::ERelativeToTFile::kCur; static TFile::EFileTypeTFile::kDefault; static TFile::EStatusBitsTFile::kDevNull; s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXNetFile.html:17878,cache,cachesz,17878,root/html602/TXNetFile.html,https://root.cern,https://root.cern/root/html602/TXNetFile.html,4,['cache'],['cachesz']
Performance,"root session. We will now load MyClass and experiment with its methods.; 12.21.5 Loading MyClass; The first step is to load the library and the class file. Then we can instantiate a MyClass object.; root[] .L libEvent.so; root[] .L MyClass.C; root[] MyClass m; Now we can get a specific entry and populate the event leaf. In the code snipped below, we get entry 0, and print the number of tracks (594). Then we get entry 1 and print the number of tracks (597).; root[] m.GetEntry(0); (int)57503; root[] m.fNtrack(); (Int_t)594; root[] m.GetEntry(1); (int)48045; root[] m.fNtrack(); (Int_t)597; Now we can call the Loop method, which will build and display the two histograms.; root[] m.Loop(); You should now see a canvas that looks like this. To conclude the discussion on MakeClass let us lists the steps that got us here. Call TTree::MakeClass, which automatically creates a class to loop over the tree.; Modify the MyClass::Loop() method in MyClass.C to fit your task.; Load and instantiate MyClass, and run MyClass::Loop(). 12.22 Using TTree::MakeSelector. With a TTree we can make a selector and use it to process a limited set of entries. This is especially important in a parallel processing configuration where the analysis is distributed over several processors and we can specify which entries to send to each processor. The TTree::Process method is used to specify the selector and the entries. Before we can use TTree::Process we need to make a selector. We can call the TTree::MakeSelector method. It creates two files similar to TTree::MakeClass.; In the resulting files is a class that is a descendent of TSelector and implements the following methods:. TSelector::Begin() - this method is called every time a loop over the tree starts. This is a convenient place to create your histograms.; TSelector::Notify() - it is called at the first entry of a new tree in a chain.; TSelector::Process() - it is called to process an event. It is the user’s responsibility to read the correspond",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:643190,Load,Load,643190,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Load'],['Load']
Performance,"rootlogon.C; Rint.Logoff: rootlogoff.C; ...; Rint.Canvas.MoveOpaque: false; Rint.Canvas.HighLightColor: 5; The various options are explained in $ROOTSYS/etc/system.rootrc. The .rootrc file contents are combined. For example, if the flag to use true type fonts is set to true in the system.rootrc file, you have to set explicitly it false in your local .rootrc file if you do not want to use true type fonts. Removing the UseTTFontsstatement in the local .rootrc file will not disable true fonts. The value of the environment variable ROOTDEBUG overrides the value in the .rootrc file at startup. Its value is used to set gDebug and helps for quick turn on debug mode in TROOT startup.; ROOT looks for scripts in the path specified in the .rootrc file in the Root.Macro.Path variable. You can expand this path to hold your own directories.; 2.7.1 Logon and Logoff Scripts; The rootlogon.C and rootlogoff.C files are scripts loaded and executed at start-up and shutdown. The rootalias.C file is loaded but not executed. It typically contains small utility functions. For example, the rootalias.C script that comes with the ROOT distributions (located in $ROOTSYS/tutorials) defines the function edit(char *file). This allows the user to call the editor from the command line. This particular function will start the VI editor if the environment variable EDITOR is not set.; root[0] edit(""c1.C""); For more details, see $ROOTSYS/tutorials/rootalias.C.; 2.7.2 History File; You can use the up and down arrow at the command line, to access the previous and next command. The commands are recorded in the history file $HOME/.root_hist. It is a text file, and you can edit, cut, and paste from it. You can specify the history file in the system.rootrc file, by setting the Rint.Historyoption. You can also turn off the command logging in the system.rootrc file with the option: Rint.History: -; The number of history lines to be kept can be set also in .rootrc by:; Rint.HistSize: 500; Rint.HistSave: 400; Th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:64898,load,loaded,64898,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loaded']
Performance,"rop = kTRUE, Bool_t shapeProp = kFALSE); virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Double_tbufferFraction() const; RooFFTConvPdf::BufStratbufferStrategy() const; const RooArgSet&cacheObservables() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:6613,cache,cacheObservables,6613,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,1,['cache'],['cacheObservables']
Performance,"rop, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistFunc.html:22983,cache,cache,22983,root/html530/RooHistFunc.html,https://root.cern,https://root.cern/root/html530/RooHistFunc.html,1,['cache'],['cache']
Performance,"rop<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate, settings.momentum,; 1378 settings.optimizerParams[""RMSPROP_rho""],; 1379 settings.optimizerParams[""RMSPROP_eps""]));; 1380 break;; 1381 ; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>>(; 1384 new DNN::TAdadelta<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1385 settings.optimizerParams[""ADADELTA_rho""],; 1386 settings.optimizerParams[""ADADELTA_eps""]));; 1387 break;; 1388 }; 1389 ; 1390 ; 1391 // Initialize the vector of batches, one batch for one slave network; 1392 std::vector<TTensorBatch<Architecture_t>> batches{};; 1393 ; 1394 bool converged = false;; 1395 size_t convergenceCount = 0;; 1396 size_t batchesInEpoch = nTrainingSamples / deepNet.GetBatchSize();; 1397 ; 1398 // start measuring; 1399 std::chrono::time_point<std::chrono::system_clock> tstart, tend;; 1400 tstart = std::chrono::system_clock::now();; 1401 ; 1402 // function building string with optimizer parameters values for logging; 1403 auto optimParametersString = [&]() {; 1404 TString optimParameters;; 1405 for ( auto & element : settings.optimizerParams) {; 1406 TString key = element.first;; 1407 key.ReplaceAll(settings.optimizerName + ""_"", """"); // strip optimizerName_; 1408 double value = element.second;; 1409 if (!optimParameters.IsNull()); 1410 optimParameters += "","";; 1411 else; 1412 optimParameters += "" ("";; 1413 optimParameters += TString::Format(""%s=%g"", key.Data(), value);; 1414 }; 1415 if (!optimParameters.IsNull()); 1416 optimParameters += "")"";; 1417 return optimParameters;; 1418 };; 1419 ; 1420 Log() << ""Training phase "" << trainingPhase << "" of "" << this->GetTrainingSettings().size() << "": ""; 1421 << "" Optimizer "" << settings.optimizerName; 1422 << optimParametersString(); 1423 << "" Learning rate = "" << settings.learningRate << "" regularization "" << (char)settings.regularization; 1424 << "" minimum error = "" << minValError << En",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:55628,optimiz,optimizer,55628,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizer']
Performance,"roperties. This task is done by:; TGeoNode *TGeoManager::FindNode(x,y,z); Note that the current particle position can be set using SetCurrentPosition(x,y,z) method of the manager class, in which case FindNode() can be called without arguments. The method returns a pointer to the ""deepest node"" that geometrically contains P (in our case let us suppose it is B\_3). Since a node is just a positioned volume, we can then get a pointer to the volume, medium or material objects related to it. ""Deepest"" means that B\_3 still contains point P (as well as A\_1 and TOP\_1), but none of the daughters of volume B does. After finding out the node containing the particle, one can check if the geometry state is different compared to the last located point:; Bool_t *TGeoManager::IsSameLocation(); The algorithm for finding where a point is located in geometry is presented in the figure 17-36.; It always starts by checking if the last computed modeller state is the answer. This optimizes the search when continuously tracking a particle. The main actions performed are:. moving up and down in the logical node tree while updating the current node and its global matrix; converting the global position into the local frame of the current node/volume; checking whether the local position lies within the geometrical shape of the current volume - if this is the case continue the search downwards for the daughters of the current node, otherwise search upwards its containers until the top level is reached.; the number of candidate nodes to be checked at a given level is minimized by an additional optimization structure: voxels. This is effective even in case there is only one daughter of the current volume.; in case the current node is declared as possibly overlapping, the method FindInCluster() is invoked. This method checks all different possibilities within the cluster of overlapping candidates. One of the candidates is prioritized if one of the following conditions id fulfilled (in order):; Is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:128294,optimiz,optimizes,128294,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['optimiz'],['optimizes']
Performance,"roposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average only in case the number of daughters is greater than 4. For fewer nodes, a simple loop is performed and the minimum distance (from a point outside each shape) is taken and compared to the maximum allowed step. The step value is again updated if step<stepmax .; A special case is when the current node is declared as possibly overl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:133888,perform,performed,133888,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,3,['perform'],['performed']
Performance,"rorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; Float_t * fArgs;  ! [fNvar] Array of variables ;  ; Int_t fNvar;  Number of columns. ;  ;  Protected Attributes inherited from TTree; TList * fAliases;  List of aliases for expressions based on the tree branches. ;  ; std::atomic< UInt_t > fAllocationCount {0};  indicates basket should be resized to exact memory usage, but causes significant ;  ; Long64_t fAutoFlush;  Auto-flush tree when fAutoFlush entries written or -fAutoFlush (compressed) bytes produced. ;  ; Long64_t fAutoSave;  Autosave tree when fAutoSave entries written or -fAutoSave (compressed) bytes produced. ;  ; TObjArray fBranches;  List of Branches. ;  ; TBranchRef * fBranchRef;  Branch supporting the TRefTable (if any) ;  ; bool fCacheDoAutoInit;  ! true if cache auto creation or resize check is needed ;  ; bool fCacheDoClusterPrefetch;  ! true if cache is prefetching whole clusters ;  ; Long64_t fCacheSize;  ! Maximum size of file buffers ;  ; bool fCacheUserSet;  ! true if the cache setting was explicitly given by user ;  ; Long64_t fChainOffset;  ! Offset of 1st entry of this Tree in a TChain ;  ; TList * fClones;  ! List of cloned trees which share our addresses ;  ; Long64_t * fClusterRangeEnd;  [fNClusterRange] Last entry of a cluster range. ;  ; Long64_t * fClusterSize;  [fNClusterRange] Number of entries in each cluster for a given range. ;  ; Int_t fDebug;  ! Debug level ;  ; Long64_t fDebugMax;  ! Last entry number to debug ;  ; Long64_t fDebugMin;  ! First entry number to debug ;  ; Int_t fDefaultEntryOffsetLen;  Initial Length of fEntryOffset table in the basket buffers. ;  ; TDirectory * fDirectory;  ! Pointer to directory holding this tree ;  ; Long64_t fEntries;  Number of entries. ;  ; TEntryList * fEntryList;  ! Pointer to event selection list (if one) ;  ; Long64_t fEstimate;  Number of entries to estimate histogram limits. ;  ; TEventList * fEventList;  ! Pointer to event selection list (if one) ;  ; TList * f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNtuple.html:42476,cache,cache,42476,doc/master/classTNtuple.html,https://root.cern,https://root.cern/doc/master/classTNtuple.html,3,['cache'],['cache']
Performance,"rorIf option ""sync"" was chosen and either:; elist doesn't have sub entry lists.; the number of sub entry lists in elist is different than the number of trees in the chain.; any of the sub entry lists in elist doesn't correspond to the tree of the chain with the same index (i.e. it doesn't share the same tree name and file name). This function finds correspondence between the sub-lists of the TEntryList and the trees of the TChain. ; Reimplemented from TTree.; Definition at line 2677 of file TChain.cxx. ◆ SetEntryListFile(). void TChain::SetEntryListFile ; (; const char * ; filename = """", . Option_t * ; opt = """" . ). virtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; This function creates a special kind of entry list (TEntryListFromFile object) that loads lists, corresponding to the chain elements, one by one, so that only one list is in memory at a time.; If there is an error opening one of the files, this file is skipped and the next file is loaded; File naming convention:. by default, filename_elist.root is used, where filename is the name of the chain element; xxx$xxx.root - $ sign is replaced by the name of the chain element. If the list name is not specified (by passing filename_elist.root/listname to the TChain::SetEntryList() function, the first object of class TEntryList in the file is taken.; It is assumed, that there are as many list files, as there are elements in the chain and they are in the same order ; Definition at line 2822 of file TChain.cxx. ◆ SetEventList(). void TChain::SetEventList ; (; TEventList * ; evlist). overridevirtual . This function transfroms the given TEventList into a TEntryList. ; NOTE, that this function loads all tree headers, because the entry numbers in the TEventList are global and have to be recomputed, taking into account the number of entries in each tree.; The new TEntryList is owned by the TChain and gets deleted when the chain is deleted. This TEntry",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:99303,load,loaded,99303,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['load'],['loaded']
Performance,"rorIf option ""sync"" was chosen and either:; elist doesn't have sub entry lists.; the number of sub entry lists in elist is different than the number of trees in the chain.; any of the sub entry lists in elist doesn't correspond to the tree of the chain with the same index (i.e. it doesn't share the same tree name and file name). This function finds correspondence between the sub-lists of the TEntryList and the trees of the TChain. ; Reimplemented from TTree.; Definition at line 2703 of file TChain.cxx. ◆ SetEntryListFile(). void TChain::SetEntryListFile ; (; const char * ; filename = """", . Option_t * ; opt = """" . ). virtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; This function creates a special kind of entry list (TEntryListFromFile object) that loads lists, corresponding to the chain elements, one by one, so that only one list is in memory at a time.; If there is an error opening one of the files, this file is skipped and the next file is loaded; File naming convention:. by default, filename_elist.root is used, where filename is the name of the chain element; xxx$xxx.root - $ sign is replaced by the name of the chain element. If the list name is not specified (by passing filename_elist.root/listname to the TChain::SetEntryList() function, the first object of class TEntryList in the file is taken.; It is assumed, that there are as many list files, as there are elements in the chain and they are in the same order ; Definition at line 2848 of file TChain.cxx. ◆ SetEventList(). void TChain::SetEventList ; (; TEventList * ; evlist). overridevirtual . This function transfroms the given TEventList into a TEntryList. ; NOTE, that this function loads all tree headers, because the entry numbers in the TEventList are global and have to be recomputed, taking into account the number of entries in each tree.; The new TEntryList is owned by the TChain and gets deleted when the chain is deleted. This TEntry",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:99924,load,loaded,99924,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,1,['load'],['loaded']
Performance,"rorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedReal&operator=(const RooAbsCachedReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedReal.html:20045,optimiz,optimizeCacheMode,20045,root/html602/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsHiddenReal&operator=(const RooAbsHiddenReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsHiddenReal.html:19603,optimiz,optimizeCacheMode,19603,root/html602/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooChangeTracker&operator=(const RooChangeTracker&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooArgSetparameters() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChangeTracker.html:19743,optimiz,optimizeCacheMode,19743,root/html602/RooChangeTracker.html,https://root.cern,https://root.cern/root/html602/RooChangeTracker.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooConstraintSum&operator=(const RooConstraintSum&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConstraintSum.html:19445,optimiz,optimizeCacheMode,19445,root/html602/RooConstraintSum.html,https://root.cern,https://root.cern/root/html602/RooConstraintSum.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFracRemainder&operator=(const RooFracRemainder&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFracRemainder.html:19378,optimiz,optimizeCacheMode,19378,root/html602/RooFracRemainder.html,https://root.cern,https://root.cern/root/html602/RooFracRemainder.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooMultiBinomial&operator=(const RooMultiBinomial&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiBinomial.html:19745,optimiz,optimizeCacheMode,19745,root/html602/RooMultiBinomial.html,https://root.cern,https://root.cern/root/html602/RooMultiBinomial.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNumRunningInt&operator=(const RooNumRunningInt&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumRunningInt.html:19885,optimiz,optimizeCacheMode,19885,root/html602/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html602/RooNumRunningInt.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooParamHistFunc&operator=(const RooParamHistFunc&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; vi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParamHistFunc.html:19188,optimiz,optimizeCacheMode,19188,root/html602/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html602/RooParamHistFunc.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rorItems(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUnblindOffset&operator=(const RooUnblindOffset&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindOffset.html:19721,optimiz,optimizeCacheMode,19721,root/html602/RooUnblindOffset.html,https://root.cern,https://root.cern/root/html602/RooUnblindOffset.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rotected . Definition at line 497 of file MethodBase.h. ◆ SetSignalReferenceCut(). void TMVA::MethodBase::SetSignalReferenceCut ; (; Double_t ; cut). inline . Definition at line 364 of file MethodBase.h. ◆ SetSignalReferenceCutOrientation(). void TMVA::MethodBase::SetSignalReferenceCutOrientation ; (; Double_t ; cutOrientation). inline . Definition at line 365 of file MethodBase.h. ◆ SetSilentFile(). void TMVA::MethodBase::SetSilentFile ; (; Bool_t ; status). inline . Definition at line 378 of file MethodBase.h. ◆ SetTestTime(). void TMVA::MethodBase::SetTestTime ; (; Double_t ; testTime). inline . Definition at line 165 of file MethodBase.h. ◆ SetTestvarName(). void TMVA::MethodBase::SetTestvarName ; (; const TString & ; v = """"). inline . Definition at line 341 of file MethodBase.h. ◆ SetTrainTime(). void TMVA::MethodBase::SetTrainTime ; (; Double_t ; trainTime). inline . Definition at line 161 of file MethodBase.h. ◆ SetTuneParameters(). void TMVA::MethodBase::SetTuneParameters ; (; std::map< TString, Double_t > ; tuneParameters). virtual . set the tuning parameters according to the argument This is just a dummy . ; . have a look at the MethodBDT how you could perhaps implement the same thing for the other Classifiers.. ; Reimplemented in TMVA::MethodBDT, and TMVA::MethodSVM.; Definition at line 644 of file MethodBase.cxx. ◆ SetupMethod(). void TMVA::MethodBase::SetupMethod ; (; ). setup of methods ; Definition at line 406 of file MethodBase.cxx. ◆ SetWeightFileDir(). void TMVA::MethodBase::SetWeightFileDir ; (; TString ; fileDir). protected . set directory of weight file ; Definition at line 2059 of file MethodBase.cxx. ◆ SetWeightFileName(). void TMVA::MethodBase::SetWeightFileName ; (; TString ; theWeightFile). protected . set the weight file name (depreciated) ; Definition at line 2068 of file MethodBase.cxx. ◆ Statistics(). void TMVA::MethodBase::Statistics ; (; Types::ETreeType ; treeType, . const TString & ; theVarName, . Double_t & ; meanS, . Double_t & ; m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBase.html:73645,tune,tuneParameters,73645,doc/master/classTMVA_1_1MethodBase.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBase.html,1,['tune'],['tuneParameters']
Performance,"rotected methods.; 3844 ; 3845const TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */); 3846{; 3847 R__LOCKGUARD(gInterpreterMutex);; 3848 ; 3849 if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);; 3850 if (load) {; 3851 if (gDebug>0) Info(""GetListOfAllPublicMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3852 fAllPubMethod->Load();; 3853 }; 3854 return fAllPubMethod;; 3855}; 3856 ; 3857////////////////////////////////////////////////////////////////////////////////; 3858/// Returns a list of all public data members of this class and its base; 3859/// classes. Refers to a subset of the data members in GetListOfDatamembers(); 3860/// so don't do GetListOfAllPublicDataMembers()->Delete().; 3861 ; 3862TList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */); 3863{; 3864 R__LOCKGUARD(gInterpreterMutex);; 3865 ; 3866 if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);; 3867 if (load) fAllPubData->Load();; 3868 return fAllPubData;; 3869}; 3870 ; 3871////////////////////////////////////////////////////////////////////////////////; 3872/// Returns list of methods accessible by context menu.; 3873 ; 3874void TClass::GetMenuItems(TList *list); 3875{; 3876 if (!HasInterpreterInfo()) return;; 3877 ; 3878 // get the base class; 3879 TIter nextBase(GetListOfBases(), kIterBackward);; 3880 TBaseClass *baseClass;; 3881 while ((baseClass = (TBaseClass *) nextBase())) {; 3882 TClass *base = baseClass->GetClassPointer();; 3883 if (base) base->GetMenuItems(list);; 3884 }; 3885 ; 3886 // remove methods redefined in this class with no menu; 3887 TMethod *method, *m;; 3888 TIter next(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs());",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:146393,load,load,146393,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,2,['load'],['load']
Performance,"rotected methods.; 3911 ; 3912const TList *TClass::GetListOfAllPublicMethods(Bool_t load /* = kTRUE */); 3913{; 3914 R__LOCKGUARD(gInterpreterMutex);; 3915 ; 3916 if (!fAllPubMethod) fAllPubMethod = new TViewPubFunctions(this);; 3917 if (load) {; 3918 if (gDebug>0) Info(""GetListOfAllPublicMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3919 fAllPubMethod->Load();; 3920 }; 3921 return fAllPubMethod;; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Returns a list of all public data members of this class and its base; 3926/// classes. Refers to a subset of the data members in GetListOfDatamembers(); 3927/// so don't do GetListOfAllPublicDataMembers()->Delete().; 3928 ; 3929TList *TClass::GetListOfAllPublicDataMembers(Bool_t load /* = kTRUE */); 3930{; 3931 R__LOCKGUARD(gInterpreterMutex);; 3932 ; 3933 if (!fAllPubData) fAllPubData = new TViewPubDataMembers(this);; 3934 if (load) fAllPubData->Load();; 3935 return fAllPubData;; 3936}; 3937 ; 3938////////////////////////////////////////////////////////////////////////////////; 3939/// Returns list of methods accessible by context menu.; 3940 ; 3941void TClass::GetMenuItems(TList *list); 3942{; 3943 if (!HasInterpreterInfo()) return;; 3944 ; 3945 // get the base class; 3946 TIter nextBase(GetListOfBases(), kIterBackward);; 3947 TBaseClass *baseClass;; 3948 while ((baseClass = (TBaseClass *) nextBase())) {; 3949 TClass *base = baseClass->GetClassPointer();; 3950 if (base) base->GetMenuItems(list);; 3951 }; 3952 ; 3953 // remove methods redefined in this class with no menu; 3954 TMethod *method, *m;; 3955 TIter next(GetListOfMethods(), kIterBackward);; 3956 while ((method = (TMethod*)next())) {; 3957 m = (TMethod*)list->FindObject(method->GetName());; 3958 if (method->IsMenuItem() != kMenuNoMenu) {; 3959 if (!m); 3960 list->AddFirst(method);; 3961 } else {; 3962 if (m && m->GetNargs() == method->GetNargs());",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:149144,load,load,149144,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,2,['load'],['load']
Performance,"rotected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooDataHist_dh; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooParamHistFunc.html:32533,cache,cache,32533,root/html534/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html534/RooParamHistFunc.html,13,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"rotectedvirtual . Base function for computing multiple values of a RooAbsReal. ; Parameters. ctxAn evaluation context object . Reimplemented from RooAbsReal.; Definition at line 403 of file RooAbsCachedPdf.cxx. ◆ fillCacheObject(). virtual void RooAbsCachedPdf::fillCacheObject ; (; PdfCacheElem & ; cache); const. protectedpure virtual . Implemented in RooIntegralMorph, RooFFTConvPdf, and RooCachedPdf. ◆ forceAnalyticalInt(). bool RooAbsCachedPdf::forceAnalyticalInt ; (; const RooAbsArg & ; dep); const. overridevirtual . Force RooRealIntegral to offer all our actual observable for internal integration. ; Reimplemented from RooAbsReal.; Definition at line 322 of file RooAbsCachedPdf.cxx. ◆ getAnalyticalIntegralWN(). int RooAbsCachedPdf::getAnalyticalIntegralWN ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const RooArgSet * ; normSet, . const char * ; rangeName = nullptr . ); const. overridevirtual . Advertises internal (analytical) integration capabilities. ; Call is forwarded to RooHistPdf cache p.d.f of cache that is used for given choice of observables ; Reimplemented from RooAbsReal.; Definition at line 334 of file RooAbsCachedPdf.cxx. ◆ getCache(). RooAbsCachedPdf::PdfCacheElem * RooAbsCachedPdf::getCache ; (; const RooArgSet * ; nset, . bool ; recalculate = true . ); const. protected . Retrieve cache object associated with given choice of observables. ; If cache object does not exist, create and fill and register it on the fly. If recalculate=false recalculation of cache contents of existing caches that are marked dirty due to dependent parameter changes is suppressed. ; Definition at line 113 of file RooAbsCachedPdf.cxx. ◆ getCacheHist() [1/2]. RooDataHist * RooAbsCachedPdf::getCacheHist ; (; const RooArgSet & ; nset); const. inline . Definition at line 43 of file RooAbsCachedPdf.h. ◆ getCacheHist() [2/2]. RooDataHist * RooAbsCachedPdf::getCacheHist ; (; const RooArgSet * ; nset = nullptr); const. Return pointer to RooDataHist cache histogram for given",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:81218,cache,cache,81218,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,1,['cache'],['cache']
Performance,"rotectedvirtual . Return true if the expression at the index 'oper' is to be treated as as string. ; Reimplemented from ROOT::v5::TFormula.; Definition at line 4736 of file TTreeFormula.cxx. ◆ LoadBranches(). void TTreeFormula::LoadBranches ; (; ). protected . Make sure that all the branches have been loaded properly. ; Definition at line 5369 of file TTreeFormula.cxx. ◆ LoadCurrentDim(). bool TTreeFormula::LoadCurrentDim ; (; ). protected . Calculate the actual dimension for the current entry. ; Definition at line 5393 of file TTreeFormula.cxx. ◆ Notify(). bool TTreeFormula::Notify ; (; ). inlineoverridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject.; Definition at line 206 of file TTreeFormula.h. ◆ operator=(). TTreeFormula & TTreeFormula::operator= ; (; const TTreeFormula & ; ). privatedelete . ◆ ParseWithLeaf(). Int_t TTreeFormula::ParseWithLeaf ; (; TLeaf * ; leaf, . const char * ; subExpression, . bool ; final, . UInt_t ; paran_level, . TObjArray & ; castqueue, . bool ; useLeafCollectionObject, . const char * ; fullExpression . ). protected . Decompose 'expression' as pointing to something inside the leaf Returns: . -2 Error: some information is missing (message already printed); -1 Error: Syntax is incorrect (message already printed); 0; >0 the value returns is the action code. . Definition at line 764 of file TTreeFormula.cxx. ◆ PrintValue() [1/2]. char * TTreeFormula::PrintValue ; (; Int_t ; mode, . Int_t ; instance, . const char * ; decform = ""9.9"" . ); const. virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeFormula.html:45366,load,load,45366,doc/master/classTTreeFormula.html,https://root.cern,https://root.cern/doc/master/classTTreeFormula.html,2,['load'],['load']
Performance,"rototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); virtual Bool_timportWorkspaceHook(RooWorkspace& ws); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistPdf.html:33332,optimiz,optimizeDirtyHook,33332,root/html528/RooHistPdf.html,https://root.cern,https://root.cern/root/html528/RooHistPdf.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"roundTree = inputFile->Get<TTree>(""bkg_tree"");; ; if (!signalTree) {; Error(""TMVA_CNN_Classification"", ""Could not find signal tree in file '%s'"", inputFileName.Data());; return;; }; if (!backgroundTree) {; Error(""TMVA_CNN_Classification"", ""Could not find background tree in file '%s'"", inputFileName.Data());; return;; }; ; int nEventsSig = signalTree->GetEntries();; int nEventsBkg = backgroundTree->GetEntries();; ; // global event weights per tree (see below for setting event-wise weights); Double_t signalWeight = 1.0;; Double_t backgroundWeight = 1.0;; ; // You can add an arbitrary number of signal or background trees; loader.AddSignalTree(signalTree, signalWeight);; loader.AddBackgroundTree(backgroundTree, backgroundWeight);; ; /// add event variables (image); /// use new method (from ROOT 6.20 to add a variable array for all image data); loader.AddVariablesArray(""vars"", imgSize);; ; // Set individual event weights (the variables must exist in the original TTree); // for signal : factory->SetSignalWeightExpression (""weight1*weight2"");; // for background: factory->SetBackgroundWeightExpression(""weight1*weight2"");; // loader.SetBackgroundWeightExpression( ""weight"" );; ; // Apply additional cuts on the signal and background samples (can be different); TCut mycuts = """"; // for example: TCut mycuts = ""abs(var1)<0.5 && abs(var2-0.5)<1"";; TCut mycutb = """"; // for example: TCut mycutb = ""abs(var1)<0.5"";; ; // Tell the factory how to use the training and testing events; //; // If no numbers of events are given, half of the events in the tree are used; // for training, and the other half for testing:; // loader.PrepareTrainingAndTestTree( mycut, ""SplitMode=random:!V"" );; // It is possible also to specify the number of training and testing events,; // note we disable the computation of the correlation matrix of the input variables; ; int nTrainSig = 0.8 * nEventsSig;; int nTrainBkg = 0.8 * nEventsBkg;; ; // build the string options for DataLoader::PrepareTrainingAndTestTree; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:52239,load,loader,52239,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['load'],['loader']
Performance,"rovided by the GNU C Library. //; 28// //; 29// The set of host2net() and net2host() routines convert a basic type //; 30// value from host to network byte order and vice versa. On BIG ENDIAN //; 31// machines this is a no op. //; 32// //; 33//////////////////////////////////////////////////////////////////////////; 34 ; 35#include ""RtypesCore.h""; 36 ; 37#include <cstring>; 38 ; 39#if (defined(__linux) || defined(__APPLE__)) && \; 40 (defined(__i386__) || defined(__x86_64__)) && \; 41 defined(__GNUC__); 42#define R__USEASMSWAP; 43#endif; 44 ; 45//Big bug in inline byte swapping code with Intel's icc; 46#if defined(__INTEL_COMPILER) && __INTEL_COMPILER < 1000; 47#undef R__USEASMSWAP; 48#endif; 49 ; 50#if defined(R__USEASMSWAP); 51#include ""Byteswap.h""; 52#endif; 53 ; 54//______________________________________________________________________________; 55inline void tobuf(char *&buf, Bool_t x); 56{; 57 UChar_t x1 = x;; 58 *buf++ = x1;; 59}; 60 ; 61inline void tobuf(char *&buf, UChar_t x); 62{; 63 *buf++ = x;; 64}; 65 ; 66inline void tobuf(char *&buf, UShort_t x); 67{; 68#ifdef R__BYTESWAP; 69# if defined(R__USEASMSWAP); 70 *((UShort_t *)buf) = Rbswap_16(x);; 71# else; 72 // To work around a stupid optimization bug in MSVC++ 6.0; 73 const UShort_t *intermediary = &x;; 74 const char *sw = (const char *) intermediary;; 75 buf[0] = sw[1];; 76 buf[1] = sw[0];; 77# endif; 78#else; 79 memcpy(buf, &x, sizeof(UShort_t));; 80#endif; 81 buf += sizeof(UShort_t);; 82}; 83 ; 84inline void tobuf(char *&buf, UInt_t x); 85{; 86#ifdef R__BYTESWAP; 87# if defined(R__USEASMSWAP); 88 *((UInt_t *)buf) = Rbswap_32(x);; 89# else; 90 // To work around a stupid optimization bug in MSVC++ 6.0; 91 const UInt_t *intermediary = &x;; 92 const char *sw = (const char *)intermediary;; 93 buf[0] = sw[3];; 94 buf[1] = sw[2];; 95 buf[2] = sw[1];; 96 buf[3] = sw[0];; 97# endif; 98#else; 99 memcpy(buf, &x, sizeof(UInt_t));; 100#endif; 101 buf += sizeof(UInt_t);; 102}; 103 ; 104inline void tobuf(char *&buf, U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Bytes_8h_source.html:2379,optimiz,optimization,2379,doc/master/Bytes_8h_source.html,https://root.cern,https://root.cern/doc/master/Bytes_8h_source.html,1,['optimiz'],['optimization']
Performance,"row_upb, Int_t col_lwb, Int_t col_upb, Int_t = -1); Set size of the matrix to [row_lwb:row_upb] x [col_lwb:col_upb]; New dynamic elemenst are created, the overlapping part of the old ones are; copied to the new structures, then the old elements are deleted. Double_t TMatrixT<Element> Determinant() const; Return the matrix determinant. void TMatrixT<Element> Determinant(Double_t& d1, Double_t& d2) const; Return the matrix determinant as d1,d2 where det = d1*TMath::Power(2.0,d2). TMatrixT<Double_t> &TMatrixT<Double_t> Invert(Double_t* det = 0); Invert the matrix and calculate its determinant. TMatrixT<Element> &TMatrixT<Element> InvertFast(Double_t* det = 0); Invert the matrix and calculate its determinant, however upto (6x6); a fast Cramer inversion is used . TMatrixT<Element> &TMatrixT<Element> Transpose(const TMatrixT<double>& source); Transpose matrix source. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v, double alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v * v^T. TMatrixT<Element> &TMatrixT<Element> Rank1Update(const TVectorT<double>& v1, const TVectorT<double>& v2, double alpha = 1.0); Perform a rank 1 operation on matrix A:; A += alpha * v1 * v2^T. Element TMatrixT<Element> Similarity(const TVectorT<double>& v) const; Calculate scalar v * (*this) * v^T. TMatrixT<Element> &TMatrixT<Element> NormByColumn(const TVectorT<double>& v, Option_t* option = ""D""); Multiply/divide matrix columns by a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(i) i = 0,fNrows-1 (default); else : b(i,j) = a(i,j)*v(i). TMatrixT<Element> &TMatrixT<Element> NormByRow(const TVectorT<double>& v, Option_t* option = ""D""); Multiply/divide matrix rows with a vector:; option:; ""D"" : b(i,j) = a(i,j)/v(j) i = 0,fNcols-1 (default); else : b(i,j) = a(i,j)*v(j). TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixT<Element> &source); Assignment operator. TMatrixT<Element> &TMatrixT<Element> operator=(const TMatrixTSym<Element> &source); Assignment",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMatrixT_double_.html:20393,Perform,Perform,20393,root/html534/TMatrixT_double_.html,https://root.cern,https://root.cern/root/html534/TMatrixT_double_.html,1,['Perform'],['Perform']
Performance,"rowser to browse non-split branches as if they were split ;  CTNotifyLinkLinks multiple listeners to be notified on TChain file changes ;  CTNotifyLinkBase;  CTNtupleA simple TTree restricted to a list of float variables only ;  CTNtupleDA simple TTree restricted to a list of double variables only ;  CTObjArrayAn array of TObjects ;  CTObjArrayIterIterator of object array ;  CTObjectMother of all ROOT objects ;  CTObjectRefSpy;  CTObjectSet;  CTObjectSpyMonitors objects for deletion and reflects the deletion by reverting the internal pointer to zero ;  CTObjectTableThis class registers all instances of TObject and its derived classes in a hash table ;  CTObjLinkWrapper around a TObject so it can be stored in a TList ;  CTObjOptLink;  CTObjStringCollectable string class ;  CTOCCToStepThis class contains implementation of writing OpenCascade's geometry shapes to the STEP file reproducing the original ROOT geometry tree ;  CTODBCResult;  CTODBCRow;  CTODBCServer;  ►CTODBCStatement;  CODBCBufferRec_t;  CToolBarData_t;  CTOptionListItem;  CTOracleResult;  CTOracleRow;  CTOracleServer;  ►CTOracleStatement;  CTBufferRec;  CTOrdCollectionOrdered collection ;  CTOrdCollectionIterIterator of ordered collection ;  CTOutputListSelectorDataMapSet the selector's data members to the corresponding elements of the output list ;  CTPackageDescription;  CTPacketizerThis class generates packets to be processed on PROOF worker servers ;  CTPacketizerAdaptiveThis packetizer is based on TPacketizer but uses different load-balancing algorithms and data structures ;  CTPacketizerFileThis packetizer generates packets which contain a single file path to be used in process ;  CTPacketizerMultiThis class allows to do multiple runs in the same query; each run can be a, for example, different dataset or the same dataset with entry list ;  CTPacketizerUnitThis packetizer generates packets of generic units, representing the number of times an operation cycle has to be repeated by the worker node, e.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:198357,load,load-balancing,198357,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['load'],['load-balancing']
Performance,"rowser to browse non-split branches as if they were split. More...;  ; class  TNtuple;  A simple TTree restricted to a list of float variables only. More...;  ; class  TNtupleD;  A simple TTree restricted to a list of double variables only. More...;  ; class  TQueryResult;  A container class for query results. More...;  ; class  TreeUtils;  Different standalone functions to work with trees and tuples, not reqiuired to be a member of any class. More...;  ; class  TSelector;  A TSelector object is used by the TTree::Draw, TTree::Scan, TTree::Process to navigate in a TTree and make selections. More...;  ; class  TSelectorList;  A TList derived class that makes sure that objects added to it are not linked to the currently open file (like histograms, eventlists and trees). More...;  ; class  TSelectorScalar;  Named scalar type, based on Long64_t, streamable, storable and mergeable. More...;  ; class  TTree;  A TTree represents a columnar dataset. More...;  ; class  TTreeCache;  A cache to speed-up the reading of ROOT datasets. More...;  ; class  TTreeCacheUnzip;  A TTreeCache which exploits parallelized decompression of its own content. More...;  ; class  TTreeCloner;  Class implementing or helping the various TTree cloning method. More...;  ; class  TTreeResult;  Class defining interface to a TTree query result with the same interface as for SQL databases. More...;  ; class  TTreeRow;  Class defining interface to a row of a TTree query result. More...;  ; class  TTreeSQL;  A TTree object is a list of TBranch. More...;  ; class  TVirtualBranchBrowsable;  TVirtualBranchBrowsable is a base class (not really abstract, but useless by itself) for helper objects that extend TBranch's browsing support. More...;  ; class  TVirtualIndex;  Abstract interface for Tree Index. More...;  ; class  TVirtualTreePlayer;  Abstract base class defining the interface for the plugins that implement Draw, Scan, Process, MakeProxy, etc. More...;  . ROOT master - Reference Guide Generated on Tue ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tree.html:5788,cache,cache,5788,doc/master/group__tree.html,https://root.cern,https://root.cern/doc/master/group__tree.html,1,['cache'],['cache']
Performance,"roxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; double _bufFrac;  ; BufStrat _bufStrat;  ; RooSetProxy _cacheObs;  Non-convolution observables that are also cached. ;  ; RooSetProxy _params;  Effective parameters of this p.d.f. ;  ; RooRealProxy _pdf1;  First input p.d.f. ;  ; RooRealProxy _pdf2;  Second input p.d.f. ;  ; double _shift1;  ; double _shift2;  ; RooRealProxy _x;  Convolution observable. ;  ; RooRealProxy _xprime;  Input function representing value of convolution observable. ;  ;  Protected Attributes inherited from RooAbsCachedPdf; std::map< Int_t, AnaIntConfig > _anaIntMap;  ! Map for analytical integration codes ;  ; RooAICRegistry _anaReg;  ! Registry for analytical integration codes ;  ; RooObjCacheManager _cacheMgr;  ; Int_t _ipOrder;  The cache manager. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:79002,cache,cached,79002,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cached']
Performance,"roxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. TString_bnameName of the binning specification to be used to perform the mapping; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooBinningCategory.html:19563,Cache,CacheMode,19563,root/html534/RooBinningCategory.html,https://root.cern,https://root.cern/root/html534/RooBinningCategory.html,1,['Cache'],['CacheMode']
Performance,"roxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooThresholdCategory.html:19598,Cache,CacheMode,19598,root/html534/RooThresholdCategory.html,https://root.cern,https://root.cern/root/html534/RooThresholdCategory.html,1,['Cache'],['CacheMode']
Performance,"roxy*TEmulatedCollectionProxy::InitializeEx(Bool_t silent); voidTEmulatedCollectionProxy::ReadItems(int nElements, TBuffer& b); voidReadMap(UInt_t nElements, TBuffer& b); voidTEmulatedCollectionProxy::Shrink(UInt_t nCurr, UInt_t left, Bool_t force); voidTEmulatedCollectionProxy::WriteItems(int nElements, TBuffer& b); voidWriteMap(UInt_t nElements, TBuffer& b). private:. TEmulatedMapProxy&operator=(const TEmulatedMapProxy& rhs). Data Members; public:. enum TGenCollectionProxy::[unnamed] { kBIT_ISSTRING; kBIT_ISTSTRING; kBOOL_t; };; enum TVirtualCollectionProxy::EProperty { kIsInitialized; kIsAssociative; kIsEmulated; kNeedDelete; };. public:. static const Int_tTVirtualCollectionProxy::fgIteratorArenaSizegreater than sizeof(void*) + sizeof(UInt_t). protected:. TClassRefTVirtualCollectionProxy::fClass; TGenCollectionProxy::MethodTGenCollectionProxy::fClearMethod cache for container accessors: clear container; void*TGenCollectionProxy::fCollectMethod to collect objects from container; void*TGenCollectionProxy::fConstructContainer accessors: block construct; map<std::string,TObjArray*>*TGenCollectionProxy::fConversionReadMemberWiseArray of bundle of TStreamerInfoActions to stream out (read) derived from another class.; TGenCollectionProxy::Method0TGenCollectionProxy::fCreateEnvMethod to allocate an Environment holder.; void*TGenCollectionProxy::fDestructContainer accessors: block destruct; ROOT::TCollectionProxyInfo::EnvironBase*TGenCollectionProxy::fEnvAddress of the currently proxied object; void*TGenCollectionProxy::fFeedContainer accessors: block feed; TGenCollectionProxy::MethodTGenCollectionProxy::fFirstContainer accessors: generic iteration: first; void*TGenCollectionProxy::fFunctionCopyIterator; void*TGenCollectionProxy::fFunctionCreateIterators; void*TGenCollectionProxy::fFunctionDeleteIterator; void*TGenCollectionProxy::fFunctionDeleteTwoIterators; void*TGenCollectionProxy::fFunctionNextIterator; TGenCollectionProxy::Value*TGenCollectionProxy::fKeyDescriptor of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEmulatedMapProxy.html:4692,cache,cache,4692,root/html534/TEmulatedMapProxy.html,https://root.cern,https://root.cern/root/html534/TEmulatedMapProxy.html,2,['cache'],['cache']
Performance,"rranty; and distribute a copy of this License along with the; Library. You may charge a fee for the physical act of transferring a copy,; and you may at your option offer warranty protection in exchange for a; fee.; ; 2. You may modify your copy or copies of the Library or any portion; of it, thus forming a work based on the Library, and copy and; distribute such modifications or work under the terms of Section 1; above, provided that you also meet all of these conditions:. a) The modified work must itself be a software library. b) You must cause the files modified to carry prominent notices; stating that you changed the files and the date of any change. c) You must cause the whole of the work to be licensed at no; charge to all third parties under the terms of this License. d) If a facility in the modified Library refers to a function or a; table of data to be supplied by an application program that uses; the facility, other than as an argument passed when the facility; is invoked, then you must make a good faith effort to ensure that,; in the event an application does not supply such function or; table, the facility still operates, and performs whatever part of; its purpose remains meaningful. (For example, a function in a library to compute square roots has; a purpose that is entirely well-defined independent of the; application. Therefore, Subsection 2d requires that any; application-supplied function or table used by this function must; be optional: if the application does not supply it, the square; root function must still compute square roots.). These requirements apply to the modified work as a whole. If; identifiable sections of that work are not derived from the Library,; and can be reasonably considered independent and separate works in; themselves, then this License, and its terms, do not apply to those; sections when you distribute them as separate works. But when you; distribute the same sections as part of a whole which is a work based; on the Library",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/license.html:11681,perform,performs,11681,d/license.html,https://root.cern,https://root.cern/d/license.html,1,['perform'],['performs']
Performance,"rrent basket number when reading; Long64_tTBranch::fReadEntry! Current entry number when reading; Int_tfSTLtype! STL container type; Bool_tTBranch::fSkipZip!After being read, the buffer will not be unziped.; Int_tTBranch::fSplitLevelBranch split level; Int_tfStreamerTypebranch streamer type; TStringfTargetClassName! Name of the target in-memory class; TStringTNamed::fTitleobject title; Long64_tTBranch::fTotBytesTotal number of bytes in all leaves before compression; TTree*TBranch::fTree! Pointer to Tree header; Int_tfTypebranch type; Int_tTBranch::fWriteBasketLast basket number written; Long64_tTBranch::fZipBytesTotal number of bytes in all leaves after compression; static Int_tTBranch::fgCount! branch counter. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchElement(); -- Default and I/O constructor. TBranchElement(TTree *tree, const char* bname, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize, Int_t splitlevel, Int_t btype); FIXME: What if the streamer info is optimized here?; -- Constructor when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. TBranchElement(TBranch *parent, const char* bname, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize, Int_t splitlevel, Int_t btype); FIXME: What if the streamer info is optimized here?; -- Constructor when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. void Init(TTree* tree, TBranch* parent, const char* name, TStreamerInfo* sinfo, Int_t id, char* pointer, Int_t basketsize = 32000, Int_t splitlevel = 0, Int_t btype = 0); -- Init when the branch object is not a TClonesArray nor an STL container. If splitlevel > 0 this branch in turn is split into sub-branches. TBranchElement(TTree *tree, const char* bname, TClonesArray* clones, Int_t basketsize, Int_t splitlevel, Int_t compress); FIXME: Bad,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchElement.html:16253,optimiz,optimized,16253,root/html526/TBranchElement.html,https://root.cern,https://root.cern/root/html526/TBranchElement.html,1,['optimiz'],['optimized']
Performance,"rrentVersion = kTRUE;; 5456 break;; 5457 }; 5458 }; 5459 }; 5460 }; 5461 ; 5462 if (!inRepo || currentVersion) {; 5463 // The object was allocated using code for the same class version; 5464 // as is loaded now. We may proceed without worry.; 5465 TVirtualStreamerInfo* si = GetStreamerInfo();; 5466 if (si) {; 5467 si->Destructor(p, dtorOnly);; 5468 } else {; 5469 Error(""Destructor"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct emulated object!"", GetName(), fClassVersion, p);; 5470 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5471 Int_t i = fStreamerInfo->LowerBound();; 5472 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5473 Error(""Destructor"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5474 if (fStreamerInfo->At(i) != nullptr) {; 5475 Error(""Destructor"", ""Doing Dump() ..."");; 5476 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5477 }; 5478 }; 5479 }; 5480 } else {; 5481 // The loaded class version is not the same as the version of the code; 5482 // which was used to allocate this object. The best we can do is use; 5483 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5484 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5485 if (si) {; 5486 si->Destructor(p, dtorOnly);; 5487 } else {; 5488 Error(""Destructor"", ""No streamer info available for class '%s' version %d, cannot destruct object at addr: %p"", GetName(), objVer, p);; 5489 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5490 Int_t i = fStreamerInfo->LowerBound();; 5491 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5492 Error(""Destructor2"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5493 if (fStreamerInfo->At(i) != nullptr) {; 5494 // Do some debugging output.; 5495 Error(""Destructor2"", ""Doing Dump() ..."");; 5496 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5497 }; 5498 }; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:209626,load,loaded,209626,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"rrentVersion = kTRUE;; 5523 break;; 5524 }; 5525 }; 5526 }; 5527 }; 5528 ; 5529 if (!inRepo || currentVersion) {; 5530 // The object was allocated using code for the same class version; 5531 // as is loaded now. We may proceed without worry.; 5532 TVirtualStreamerInfo* si = GetStreamerInfo();; 5533 if (si) {; 5534 si->Destructor(p, dtorOnly);; 5535 } else {; 5536 Error(""Destructor"", ""No streamer info available for class '%s' version %d at address %p, cannot destruct emulated object!"", GetName(), fClassVersion, p);; 5537 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5538 Int_t i = fStreamerInfo->LowerBound();; 5539 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5540 Error(""Destructor"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5541 if (fStreamerInfo->At(i) != nullptr) {; 5542 Error(""Destructor"", ""Doing Dump() ..."");; 5543 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5544 }; 5545 }; 5546 }; 5547 } else {; 5548 // The loaded class version is not the same as the version of the code; 5549 // which was used to allocate this object. The best we can do is use; 5550 // the TVirtualStreamerInfo to try to free up some of the allocated memory.; 5551 TVirtualStreamerInfo* si = (TVirtualStreamerInfo*) fStreamerInfo->At(objVer);; 5552 if (si) {; 5553 si->Destructor(p, dtorOnly);; 5554 } else {; 5555 Error(""Destructor"", ""No streamer info available for class '%s' version %d, cannot destruct object at addr: %p"", GetName(), objVer, p);; 5556 Error(""Destructor"", ""length of fStreamerInfo is %d"", fStreamerInfo->GetSize());; 5557 Int_t i = fStreamerInfo->LowerBound();; 5558 for (Int_t v = 0; v < fStreamerInfo->GetSize(); ++v, ++i) {; 5559 Error(""Destructor2"", ""fStreamerInfo->At(%d): %p"", i, fStreamerInfo->At(i));; 5560 if (fStreamerInfo->At(i) != nullptr) {; 5561 // Do some debugging output.; 5562 Error(""Destructor2"", ""Doing Dump() ..."");; 5563 ((TVirtualStreamerInfo*)fStreamerInfo->At(i))->Dump();; 5564 }; 5565 }; 5",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:212377,load,loaded,212377,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"rresponds to given method title. ; Definition at line 566 of file Factory.cxx. ◆ GetROC() [1/2]. TMVA::ROCCurve * TMVA::Factory::GetROC ; (; TMVA::DataLoader * ; loader, . TString ; theMethodName, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). private . Private method to generate a ROCCurve instance for a given method. ; Handles the conversion from TMVA ResultSet to a format the ROCCurve class understands.; NoteYou own the retured pointer. ; Definition at line 749 of file Factory.cxx. ◆ GetROC() [2/2]. TMVA::ROCCurve * TMVA::Factory::GetROC ; (; TString ; datasetname, . TString ; theMethodName, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). private . Private method to generate a ROCCurve instance for a given method. ; Handles the conversion from TMVA ResultSet to a format the ROCCurve class understands.; NoteYou own the retured pointer. ; Definition at line 762 of file Factory.cxx. ◆ GetROCCurve() [1/4]. TGraph * TMVA::Factory::GetROCCurve ; (; DataLoader * ; loader, . TString ; theMethodName, . Bool_t ; setTitles = kTRUE, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). Argument iClass specifies the class to generate the ROC curve in a multiclass setting. ; It is ignored for binary classification.; Returns a ROC graph for a given method, or nullptr on error.; Note: Evaluation of the given method must have been run prior to ROC generation through Factory::EvaluateAllMetods.; NOTE: The ROC curve is 1 vs. all where the given class is considered signal and the others considered background. This is ok in binary classification but in in multi class classification, the ROC surface is an N dimensional shape, where N is number of classes - 1. ; Definition at line 912 of file Factory.cxx. ◆ GetROCCurve() [2/4]. TCanvas * TMVA::Factory::GetROCCurve ; (; TMVA::DataLoader * ; loader, . UInt_t ; iClass = 0, . Types::ETreeType ; type = Types::kTesting . ). Draws ROC curves for all methods booked with the fac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Factory.html:26441,load,loader,26441,doc/master/classTMVA_1_1Factory.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Factory.html,1,['load'],['loader']
Performance,"rride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,int,int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_int_int_.html:44980,cache,cache,44980,root/html602/RooCFunction3PdfBinding_double_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3PdfBinding_double_double_int_int_.html,4,['cache'],['cache']
Performance,"rride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigma; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooVoigtian.html:40579,cache,cache,40579,root/html532/RooVoigtian.html,https://root.cern,https://root.cern/root/html532/RooVoigtian.html,4,['cache'],['cache']
Performance,"rride;  Destructor. ;  ; Int_t cacheSize () const;  Return size of cache. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIdx, const char *isetRangeName);  ; RooAbsCacheElement * getObj (const RooArgSet *nset, const RooArgSet *iset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Retrieve payload object indexed on nset,uset amd isetRangeName If sterileIdx is not null, it is set to the index of the sterile slot in cacse such a slot is recycled. ;  ; RooAbsCacheElement * getObj (const RooArgSet *nset, Int_t *sterileIndex=nullptr, const TNamed *isetRangeName=nullptr);  Getter function without integration set. ;  ; RooAbsCacheElement * getObjByIndex (Int_t index) const;  Retrieve payload object by slot index. ;  ; Int_t lastIndex () const;  Return index of slot used in last get or set operation. ;  ; void reset ();  Clear the cache. ;  ; RooArgSet selectFromSet1 (RooArgSet const &argSet, int index) const;  Create RooArgSet containing the objects that are both in the cached set 1 with a given index and an input argSet. ;  ; RooArgSet selectFromSet2 (RooArgSet const &argSet, int index) const;  Create RooArgSet containing the objects that are both in the cached set 2 with a given index and an input argSet. ;  ; Int_t setObj (const RooArgSet *nset, const RooArgSet *iset, RooAbsCacheElement *obj, const TNamed *isetRangeName=nullptr);  Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. ;  ; Int_t setObj (const RooArgSet *nset, RooAbsCacheElement *obj, const TNamed *isetRangeName=nullptr);  Setter function without integration set. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void wireCache () override;  ;  Public Member Functions inherited from RooAbsCache;  RooAbsCache (const RooAbsCache &, RooAbsArg *owner=nullptr);  Copy constructor. Takes owner as argument and registers cache with owne. ;  ;  RooAbsCache (RooAbsArg *owner=nullptr);  Constructor. Takes owner a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:3859,cache,cached,3859,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['cache'],['cached']
Performance,"rride;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillCacheObject (PdfCacheElem &cachePdf) const override;  Update contents of cache histogram by resampling the input p.d.f. ;  ; const char * inputBaseName () const override;  Return the base name for cache objects, in this case the name of the cached p.d.f. ;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedPdf; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; virtual PdfCacheElem * createCache (const RooArgSet *nset) const;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; PdfCacheElem * getCache (const RooArgSet *nset, bool recalculate=true) const;  Retrieve cache object associated with given choice of observables. ;  ; virtual TString histNameSuffix () const;  ; virtual RooAbsArg & pdfObservable (RooAbsArg &histObservable) const;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, double normVal) const;  ; RooPlot * plotOn (RooPlot *f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCachedPdf.html:62090,cache,cache,62090,doc/master/classRooCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooCachedPdf.html,1,['cache'],['cache']
Performance,"rride;  Get full type description of global variable, e,g.: ""class TDirectory*"". ;  ; const TEnum * GetType () const;  ; const char * GetTypeName () const override;  Get type of global variable, e,g.: ""class TDirectory*"" -> ""TDirectory"". ;  ; Long64_t GetValue () const;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TGlobal;  TGlobal (const TGlobal &);  Copy constructor. ;  ;  TGlobal (DataMemberInfo_t *info=nullptr);  pointer to CINT data member info ;  ; virtual ~TGlobal ();  TGlobal dtor deletes adopted CINT DataMemberInfo object. ;  ; virtual Int_t GetArrayDim () const;  Return number of array dimensions. ;  ; virtual DeclId_t GetDeclId () const;  ; virtual Int_t GetMaxIndex (Int_t dim) const;  Return maximum index for array dimension ""dim"". ;  ; TClass * IsA () const override;  ; virtual Bool_t IsValid ();  Return true if this global object is pointing to a currently loaded global. ;  ; TGlobal & operator= (const TGlobal &);  Assignment operator. ;  ; Long_t Property () const override;  Get property description word. For meaning of bits see EProperty. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual bool Update (DataMemberInfo_t *info);  Update the TFunction to reflect the new info. ;  ;  Public Member Functions inherited from TDictionary;  TDictionary ();  ;  TDictionary (const char *name);  ;  TDictionary (const TDictionary &dict);  ; virtual ~TDictionary ();  ; void CreateAttributeMap ();  ; TDictAttributeMap * GetAttributeMap () const;  ; TDictionary & operator= (const TDictionary &other);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEnumConstant.html:1785,load,loaded,1785,doc/master/classTEnumConstant.html,https://root.cern,https://root.cern/doc/master/classTEnumConstant.html,1,['load'],['loaded']
Performance,"rride;  Returns name of object. ;  ; Int_t GetPackDir (const char *pack, TString &pdir);  Method to get the path of the dir for package 'pack'. ;  ; Int_t GetParPath (const char *pack, TString &path);  Method to get the path of the PAR file for package 'pack'. ;  ; const char * GetTitle () const override;  Returns title of object. ;  ; Bool_t Has (const char *pack);  Method to check if this package manager has package 'pack'. ;  ; Int_t Install (const char *par, Bool_t rmold=kFALSE);  Install package from par (unpack the file in the directory); par can be an URL for remote retrieval. ;  ; TClass * IsA () const override;  ; Bool_t IsInDir (const char *path);  Method to check if 'path' is in the managed directory Return kTRUE or kFALSE. ;  ; Bool_t IsPackageEnabled (const char *pack);  ; Int_t Load (const char *pack, const char *opts);  Method to load a package taking an option const char * Return -1 on error, 0 otherwise. ;  ; Int_t Load (const char *pack, TList *optls=0);  Method to load a package taking an option list Return -1 on error, 0 otherwise. ;  ; TMD5 * ReadMD5 (const char *pack);  Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ;  ; Int_t Remove (const char *pack=0, Bool_t dolock=kTRUE);  Remove package 'pack' If 'pack' is null or empty all packages are cleared. ;  ; void SetLogger (TPackMgrLog_t logger);  ; void SetName (const char *name) override;  Set the name of the TNamed. ;  ; void SetPrefix (const char *pfx);  ; void Show (const char *title=0);  Show available packages. ;  ; void ShowEnabled (const char *title=0);  Show enabled packages. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; Int_t Unload (const char *pack);  Method to unload a package. ;  ; Int_t Unpack (const char *pack, TMD5 *sum=0);  Read MD5 checksum of the PAR file from the PROOF-INF/md5.txt file. ;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPackMgr.html:3534,load,load,3534,doc/master/classTPackMgr.html,https://root.cern,https://root.cern/doc/master/classTPackMgr.html,1,['load'],['load']
Performance,"rride;  Sort selected cells in eta or phi bins for selection and highlight. ;  ; void ComputeBBox () override;  Fill bounding-box information of the base-class TAttBBox (virtual method). ;  ; const TEveCalo2D::vBinCells_t & GetBinLists () const;  ; Float_t GetValToHeight () const override;  Virtual function of TEveCaloViz. ;  ; TClass * IsA () const override;  ; void SetProjection (TEveProjectionManager *proj, TEveProjectable *model) override;  Set projection manager and model object. ;  ; void SetScaleAbs (Bool_t) override;  Set absolute scale in projected calorimeter. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void UpdateProjection () override;  This is virtual method from base-class TEveProjected. ;  ;  Public Member Functions inherited from TEveCaloViz;  TEveCaloViz (TEveCaloData *data=nullptr, const char *n=""TEveCaloViz"", const char *t="""");  ;  ~TEveCaloViz () override;  Destructor. ;  ; Bool_t AssertCellIdCache () const;  Assert cell id cache is ok. ;  ; TEveRGBAPalette * AssertPalette ();  Make sure the TEveRGBAPalette pointer is not null. ;  ; Bool_t CellInEtaPhiRng (TEveCaloData::CellData_t &) const;  Returns true if given cell is in the ceta phi range. ;  ; void DataChanged ();  Update setting and cache on data changed. ;  ; TEveElement * ForwardEdit () override;  Management of selection state and ownership of selected cell list is done in TEveCaloData. ;  ; TEveElement * ForwardSelection () override;  Management of selection state and ownership of selected cell list is done in TEveCaloData. ;  ; Bool_t GetAutoRange () const;  ; Float_t GetBackwardEndCapPos () const;  ; Float_t GetBarrelRadius () const;  ; TEveCaloData * GetData () const;  ; Color_t GetDataSliceColor (Int_t slice) const;  Get slice color from data. ;  ; Float_t GetDataSliceThreshold (Int_t slice) const;  Get threshold for given slice. ;  ; Float_t GetEndCapPos () const;  ; Float_t GetEta () const;  ; Float_t GetEtaMax () cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveCalo2D.html:3356,cache,cache,3356,doc/master/classTEveCalo2D.html,https://root.cern,https://root.cern/doc/master/classTEveCalo2D.html,1,['cache'],['cache']
Performance,"rride;  Zoom the camera - 'adjust lens focal length, retaining camera position'. ;  ;  Public Member Functions inherited from TGLCamera;  TGLCamera ();  Default base camera constructor. ;  ;  TGLCamera (const TGLVector3 &hAxis, const TGLVector3 &vAxis);  Default base camera constructor. ;  ;  ~TGLCamera () override;  Base camera destructor. ;  ; Bool_t AdjustAndClampVal (Double_t &val, Double_t min, Double_t max, Int_t screenShift, Int_t screenShiftRange, Bool_t mod1, Bool_t mod2) const;  Adjust a passed REFERENCE value 'val', based on screenShift delta. ;  ; Double_t AdjustDelta (Double_t screenShift, Double_t deltaFactor, Bool_t mod1, Bool_t mod2) const;  Adjust a passed screen value and apply modifiers. ;  ; virtual Bool_t Dolly (Int_t delta, Bool_t mod1, Bool_t mod2);  Dolly the camera - 'move camera along eye line, retaining lens focal length'. ;  ; void DrawDebugAids () const;  Draw out some debugging aids for the camera: ;  ; TGLVector3 EyeDirection () const;  Extract the camera eye direction (vector), running from EyePoint() Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 EyePoint () const;  Return the camera eye point (vertex) in world space Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; TGLVertex3 FrustumCenter () const;  Find the center of the camera frustum from intersection of planes This method will work even with parallel left/right & top/bottom and infinite eye point of ortho cameras Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; Rgl::EOverlap FrustumOverlap (const TGLBoundingBox &box) const;  Calculate overlap (kInside, kOutside, kPartial) of box with camera frustum Camera must have valid frustum cache - call Apply() after last modification, before using. ;  ; const TGLPlane & FrustumPlane (EFrustumPlane plane) const;  ; const TGLMatrix & GetCamBase () const;  ; const TGLMatrix & GetCamTrans () ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLPerspectiveCamera.html:3179,cache,cache,3179,doc/master/classTGLPerspectiveCamera.html,https://root.cern,https://root.cern/doc/master/classTGLPerspectiveCamera.html,1,['cache'],['cache']
Performance,"rror are set. ;  ; double chopAt (double what, Int_t where) const;  Utility to calculate number of decimals to show based on magnitude of error. ;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache Warning: This function copies the cached values of source, it is the callers responsibility to make sure the cache is clean. ;  ; double evaluate () const override;  Evaluate this PDF / function / constant. Needs to be overridden by all derived classes. ;  ; void fillTreeBranch (TTree &t) override;  Overload RooAbsReal::fillTreeBranch to also fill tree branches with (asymmetric) errors if requested. ;  ; void installSharedProp (std::shared_ptr< RooRealVarSharedProperties > &&prop);  Install the shared property into the member _sharedProp. ;  ; void setExpensiveObjectCache (RooExpensiveObjectCache &) override;  variables don't need caches ;  ; void setValFast (double value) override;  ; std::shared_ptr< RooRealVarSharedProperties > sharedProp () const;  Hand out our shared property, create on the fly and register in shared map if necessary. ;  ;  Protected Member Functions inherited from RooAbsRealLValue; bool fitRangeOKForPlotting () const;  Check if fit range is usable as plot range, i.e. ;  ;  Protected Member Functions inherited from RooAbsReal; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealVar.html:60504,cache,caches,60504,doc/master/classRooRealVar.html,https://root.cern,https://root.cern/doc/master/classRooRealVar.html,1,['cache'],['caches']
Performance,"rror is extremely small compared to the bin content; (see TProfile2D::GetBinError). Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is filled from the buffer; action = 1 histogram is filled and buffer is deleted; The buffer is automatically deleted when the number of entries; in the buffer is greater than the number of entries in the histogram. Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w); accumulate arguments in buffer. When buffer is full, empty the buffer; fBuffer[0] = number of entries in buffer; fBuffer[1] = w of first entry; fBuffer[2] = x of first entry; fBuffer[3] = y of first entry; fBuffer[4] = z of first entry. void Copy(TObject& hnew) const; -*-*-*-*Copy a Profile2D histogram to a new profile2D histogram; *-* =======================================================. void Divide(TF1* h1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1). void Divide(const TH1* h1); Divide this profile2D by h1*-*-; *-* ===========================. this = this/h1. void Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*Replace contents of this profile2D by the division of h1 by h2; *-* ==============================================================. this = c1*h1/(c2*h2). TH1 * DrawCopy(Option_t* option = """") const; Draw a copy of this profile2D histogram*-*-*-; *-* =======================================. Int_t Fill(Double_t x, Double_t y, Double_t z); -*-*-*Fill a Profile2D histogram (no weights); *-* =======================================. Int_t Fill(Double_t x, const char* namey, Double_t z); Fill a Profile2D histogram (no weights). Int_t Fill(const char* namex, const char* namey, Double_t z); Fill a Profile2D histogram (no weights). Int_t Fill(const char* namex, Double_t y, Double_t z); Fill a Profile2D histogram (no weights). Int_t Fill(Double",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProfile2D.html:34842,Perform,Performs,34842,root/html532/TProfile2D.html,https://root.cern,https://root.cern/root/html532/TProfile2D.html,1,['Perform'],['Performs']
Performance,"rror(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t isWeighted() const. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all; arguments, but only does for the first one here... RooArgSet* addColumns(const RooArgList& varList); WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all; arguments, but only does for the first one here... RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList). void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0). void setArgStatus(const RooArgSet& set, Bool_t active). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). RooAbsDataStore* clone(const char* newname = 0) const; Empty ctor. { return new RooCompositeDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooCompositeDataStore(*this,vars,newname) ; }. RooCategory* index(); { return _indexCat ; }. const RooAbsArg* cacheOwner(); { return 0 ; }. » Last changed: Fri Dec 2 14:26:43 2011 » Last generated: 2011-12-02 14:26; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCompositeDataStore.html:11956,cache,cacheArgs,11956,root/html532/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html532/RooCompositeDataStore.html,10,['cache'],"['cache', 'cacheArgs', 'cacheOwner', 'cachedVars']"
Performance,"rror. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackage(const char* package); Unload specified package.; Returns 0 in case of success and -1 in case of error. Int_t UnloadPackageOnClient(const char* package); Unload a specific package on the client.; Returns ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:62699,load,loadopts,62699,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['load'],['loadopts']
Performance,"rrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsCachedPdf::setInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsSelfCachedPdf.html:28176,cache,cache,28176,root/html530/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html530/RooAbsSelfCachedPdf.html,2,['cache'],['cache']
Performance,rrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _allExtendable = false;  Flag indicating if all PDF components are extendable. ;  ; RooAICRegistry _codeReg = 10;  ! Registry of component analytical integration codes ;  ; std::vector< double > _coefCache;  ! Transient cache with transformed values of coefficients ;  ; Int_t _coefErrCount;  ! Coefficient error counter ;  ; RooListProxy _coefList;  List of coefficients. ;  ; bool _haveLastCoef = false;  Flag indicating if last PDFs coefficient was supplied in the constructor. ;  ; RooObjCacheManager _intCacheMgr;  ! Manager of cache with integrals ;  ; RooArgSet _ownedComps;  ! Owned components ;  ; RooListProxy _pdfList;  List of component PDFs. ;  ; RooObjCacheManager _projCacheMgr;  ! Manager of cache with coefficient projections and transformations ;  ; RooSetProxy _refCoefNorm;  ! Reference observable set for coefficient interpretation ;  ; TNamed * _refCoefRangeName = nullptr;  ! Reference range name for coefficient interpretation ;  ; RooArgList * _snormList {nullptr};  ! List of supplemental normalization factors ;  ;  Protected Attributes inherited from RooResolutionModel; RooFormulaVar * _basis = nullptr;  Basis function convolved with this resolution model. ;  ; Int_t _basisCode;  Identifier code for selected basis function. ;  ; bool _ownBasis;  Flag indicating ownership of _basis. ;  ; RooTemplateProxy< RooAbsRealLValue > x;  Dependent/convolution variable. ;  ;  Protected Attributes inherited from RooAbsPdf; Int_t _errorCount = 0;  Number of errors remaining to print. ;  ; Int_t _negCount = 0;  Number of negative probabilities remaining to print. ;  ; RooAbsReal * _norm = nullptr;  ; RooObjCacheManager _normMgr;  ; TString _normRange;  Normalization range. ;  ; RooArgSet const * _normSet = nullptr;  Normalization integral (owned by _normMgr) ;  ; double _rawValue = 0;  ; bool _selectComp = false;  Component selection flag for RooAbsPdf::plotCompOn. ;  ; std::unique_ptr< Roo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:72085,cache,cache,72085,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['cache'],['cache']
Performance,"rrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&RooAbsRealLValue::operator=(const RooAbsReal& other); virtual RooAbsArg&RooAbsRealLValue::operator=(Double_t newValue); virtual RooAbsArg&RooAbsRealLValue::operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t scaleFactor = 1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooErrorVar.html:21463,optimiz,optimizeCacheMode,21463,root/html526/RooErrorVar.html,https://root.cern,https://root.cern/root/html526/RooErrorVar.html,6,['optimiz'],['optimizeCacheMode']
Performance,"rs ; ROOT::RDataFrame Class ReferenceDataframe. ; ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. ; In addition, multi-threading and other low-level optimisations allow users to exploit all the resources available on their machines completely transparently.; Skip to the class reference or keep reading for the user guide.; In a nutshell: ROOT::EnableImplicitMT(); // Tell ROOT you want to go parallel; ROOT::RDataFrame d(""myTree"", ""file_*.root""); // Interface to TTree and TChain; auto myHisto = d.Histo1D(""Branch_A""); // This books the (lazy) filling of a histogram; myHisto->Draw(); // Event loop is run here, upon first access to a result; d#define d(i)Definition RSha256.hxx:102; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::EnableImplicitMTvoid EnableImplicitMT(UInt_t numthreads=0)Enable ROOT's implicit multi-threading for all objects and methods that provide an internal paralleli...Definition TROOT.cxx:539; Calculations are expressed in terms of a type-safe functional chain of actions and transformations, RDataFrame takes care of their execution. The implementation automatically puts in place several low level optimisations such as multi-thread parallelization and caching. For the impatient user; You can directly see RDataFrame in action in our tutorials, in C++ or Python. Table of Contents. Cheat sheet; Introduction; Crash course; Working with collections; Transformations: manipulating data; Actions: getting results; Distributed execution in Python; Performance tips and parallel execution; More features; Systematic variations; RDataFrame objects as function arguments and return values; Storing RDataFrame objects in collections; Executing callbacks every N events; Default column lists; Special helper columns: `rdfentry_` and `rdfslot_`; Just-in-time compilation: column type i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html:1213,multi-thread,multi-threading,1213,doc/v632/classROOT_1_1RDataFrame.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RDataFrame.html,2,['multi-thread'],['multi-threading']
Performance,"rs ;  CGeneticMinimizerGeneticMinimizer ;  CGeneticMinimizerParameters;  CGenVector_exception;  CGlobalCoordinateSystemTagTag for identifying vectors based on a global coordinate system ;  CGoFTest;  CGradFunctorGradFunctor class for Multidimensional gradient functions ;  CGradFunctor1DGradFunctor1D class for one-dimensional gradient functions ;  CGSL1DMinimizerWrapperWrapper class for gsl_min_fminimizer structure ;  CGSLChebSeriesWrapper class for C struct gsl_cheb_series ;  CGSLDerivatorClass for computing numerical derivative of a function based on the GSL numerical algorithm This class is implemented using the numerical derivatives algorithms provided by GSL (see GSL Online Manual ) ;  CGSLFunctionAdapterClass for adapting any C++ functor class to C function pointers used by GSL ;  CGSLFunctionDerivWrapperClass to wrap a gsl_function_fdf (with derivatives) ;  CGSLFunctionWrapperWrapper class to the gsl_function C structure ;  CGSLIntegrationWorkspace;  CGSLIntegratorClass for performing numerical integration of a function in one dimension ;  CGSLInterpolatorInterpolation class based on GSL interpolation functions ;  CGSLMCIntegrationWorkspace;  CGSLMCIntegrator;  CGSLMinimizerGSLMinimizer class ;  CGSLMinimizer1DMinimizer for arbitrary one dimensional functions ;  CGSLMiserIntegrationWorkspaceWorkspace for MISER ;  CGSLMonteFunctionAdapter;  CGSLMonteFunctionWrapperWrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm ;  CGSLMultiFitGSLMultiFit, internal class for implementing GSL non linear least square GSL fitting ;  CGSLMultiFitFunctionAdapterClass for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement: ;  CGSLMultiFitFunctionWrapperWrapper to a multi-dim function withtout derivatives for multi-dimensional minimization algorithm ;  CGSLMultiMinDerivFunctionWrapperWrapper for a multi-dimensional function with derivatives used in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:31033,perform,performing,31033,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,4,['perform'],['performing']
Performance,"rs R,; O and T. Why one have to define so many volumes to make an R?""; A: Well, in real life some objects have much more complex shapes that an ""R"". The modeller cannot just know all of them; the idea is to make a complex object by using elementary building blocks that have known shapes (called ""primitive shapes""). Gluing these together in the appropriate way is the user responsibility.; Q: ""I am getting the global picture but not making much out of it... There; are also a lot of calls to TGeoVolume::AddNode() that I do not understand.""; A: A volume is positioned inside another one by using this method. The relative geometrical transformation as well as a copy number must be specified. When positioned, a volume becomes a ""node"" of its container and a new object of the class TGeoNode is automatically created. This method is therefore the key element for the creation of a hierarchical link between two volumes. As it will be described further on in this document, there are few other methods performing similar actions, but let us keep things simple for the time being. In addition, notice that there are some visualization-related calls in the example followed by a final TGeoVolume::Draw() call for the top volume. These are explained in details in the section ""Visualization Settings and Attributes"". At this point, you will probably like to see how this geometry looks like. You just need to run the example and you will get the following picture that you can rotate using the mouse; or you can zoom / move it around (see what the Help menu of the GL window displays).; % root rootgeom.C; rootgeomTGeoNode * rootgeom()Definition eveGeoBrowser.C:47. Now let us browse the hierarchy that was just created. Start a browser and double-click on the item simple1 representing the gGeoManager object. Note that right click opens the context menu of the manager class where several global methods are available.; root[] new TBrowser;; TBrowserUsing a TBrowser one can browse all ROOT objects.De",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:10937,perform,performing,10937,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performing']
Performance,"rs a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Definition at line 66 of file RDFHelpers.cxx. ◆ SaveGraph() [1/2]. template<typename NodeType > . std::string ROOT::RDF::SaveGraph ; (; NodeType ; node). Create a graphviz representation of the dataframe computation graph, return it as a string. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be called concurrently from different threads. ; Definition at line 120 of file RDFHelpers.hxx. ◆ SaveGraph() [2/2]. template<typename NodeType > . void ROOT::RDF::SaveGraph ; (; NodeType ; node, . const std::string & ; outputFile . ). Create a graphviz representation of the dataframe computation graph, write it to the specified file. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. ; [in]outputFilefile where to save the representation. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be called concurrently from different threads. ; Definition at line 139 of file RDFHelpers.hxx. ◆ splitInEqualRanges(). v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:15437,concurren,concurrently,15437,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,2,['concurren'],['concurrently']
Performance,"rs by a constant c1.Definition TGraphErrors.cxx:752; TGraphErrors::CalculateScanfFieldsstatic Int_t CalculateScanfFields(const char *fmt)Calculate scan fields.Definition TGraphErrors.cxx:449; TGraphErrors::FillZerovoid FillZero(Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) overrideSet zero values for point arrays in the range [begin, end].Definition TGraphErrors.cxx:598; TGraphErrors::AddPointErrorvirtual void AddPointError(Double_t x, Double_t y, Double_t ex=0., Double_t ey=0.)Add a point with errorbars to the graph.Definition TGraphErrors.cxx:377; TGraphErrors::fEXDouble_t * fEX[fNpoints] array of X errorsDefinition TGraphErrors.h:29; TGraphErrors::Printvoid Print(Option_t *chopt="""") const overridePrint graph and errors values.Definition TGraphErrors.cxx:711; TGraphErrors::SetPointErrorvirtual void SetPointError(Double_t ex, Double_t ey)Set ex and ey values for point pointed by the mouse.Definition TGraphErrors.cxx:769; TGraphErrors::DoMergeBool_t DoMerge(const TGraph *g) overrideProtected function to perform the merge operation of a graph with errors.Definition TGraphErrors.cxx:573; TGraphErrors::GetEYDouble_t * GetEY() const overrideDefinition TGraphErrors.h:70; TGraphErrors::AllocateDouble_t ** Allocate(Int_t size) overrideAllocate internal data structures for newsize points.Definition TGraphErrors.h:81; TGraphErrors::SwapPointsvoid SwapPoints(Int_t pos1, Int_t pos2) overrideSwap points.Definition TGraphErrors.cxx:856; TGraphErrors::ApplyXvirtual void ApplyX(TF1 *f)Apply function to all the data points .Definition TGraphErrors.cxx:426; TGraphErrors::GetErrorXhighDouble_t GetErrorXhigh(Int_t bin) const overrideIt returns the error along X at point i.Definition TGraphErrors.cxx:635; TGraphErrors::GetErrorYlowDouble_t GetErrorYlow(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors.cxx:671; TGraphErrors::GetErrorYhighDouble_t GetErrorYhigh(Int_t bin) const overrideIt returns the error along Y at point i.Definition TGraphErrors",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphErrors_8h_source.html:8415,perform,perform,8415,doc/master/TGraphErrors_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphErrors_8h_source.html,1,['perform'],['perform']
Performance,"rs normalized of size fNpoints; 47 Double_t fXNmin; ///<! Minimum value of fXN; 48 Double_t fXNmax; ///<! Maximum value of fXN; 49 Double_t fYNmin; ///<! Minimum value of fYN; 50 Double_t fYNmax; ///<! Maximum value of fYN; 51 Double_t fXoffset; ///<!; 52 Double_t fYoffset; ///<! Parameters used to normalize user data; 53 Double_t fXScaleFactor; ///<!; 54 Double_t fYScaleFactor; ///<!; 55 Double_t fZout; ///<! Histogram bin height for points lying outside the convex hull; 56 Double_t *fDist; ///<! Array used to order mass points by distance; 57 Int_t fMaxIter; ///<! Maximum number of iterations to find Delaunay triangles; 58 Int_t fTriedSize; ///<! Real size of the fxTried arrays; 59 Int_t *fPTried; ///<!; 60 Int_t *fNTried; ///<! Delaunay triangles storage of size fNdt; 61 Int_t *fMTried; ///<!; 62 Int_t *fHullPoints; ///<! Hull points of size fNhull; 63 Int_t *fOrder; ///<! Array used to order mass points by distance; 64 Bool_t fAllTri; ///<! True if FindAllTriangles() has been performed on fGraph2D; 65 Bool_t fInit; ///<! True if CreateTrianglesDataStructure() and FindHull() have been performed; 66 TGraph2D *fGraph2D; ///<! 2D graph containing the user data; 67 ; 68 void CreateTrianglesDataStructure();; 69 Bool_t Enclose(Int_t T1, Int_t T2, Int_t T3, Int_t Ex) const;; 70 void FileIt(Int_t P, Int_t N, Int_t M);; 71 void FindHull();; 72 Bool_t InHull(Int_t E, Int_t X) const;; 73 Double_t InterpolateOnPlane(Int_t TI1, Int_t TI2, Int_t TI3, Int_t E) const;; 74 ; 75public:; 76 ; 77 TGraphDelaunay();; 78 TGraphDelaunay(TGraph2D *g);; 79 ; 80 ~TGraphDelaunay() override;; 81 ; 82 Double_t ComputeZ(Double_t x, Double_t y);; 83 void FindAllTriangles();; 84 TGraph2D *GetGraph2D() const {return fGraph2D;}; 85 Double_t GetMarginBinsContent() const {return fZout;}; 86 Int_t GetNdt() const {return fNdt;}; 87 Int_t *GetPTried() const {return fPTried;}; 88 Int_t *GetNTried() const {return fNTried;}; 89 Int_t *GetMTried() const {return fMTried;}; 90 Double_t *GetXN() const {return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGraphDelaunay_8h_source.html:2775,perform,performed,2775,doc/master/TGraphDelaunay_8h_source.html,https://root.cern,https://root.cern/doc/master/TGraphDelaunay_8h_source.html,1,['perform'],['performed']
Performance,"rs of RooAbsArgs that cache other (composite) RooAbsArg expressions. ; The RooAbsCache interface defines the interaction between the owning RooAbsArg object and the cache data member to communicate server redirects, operation mode changes and constant term optimization management calls. ; Definition at line 27 of file RooAbsCache.h. Public Member Functions;  RooAbsCache (const RooAbsCache &, RooAbsArg *owner=nullptr);  Copy constructor. Takes owner as argument and registers cache with owne. ;  ;  RooAbsCache (RooAbsArg *owner=nullptr);  Constructor. Takes owner as argument and register cache with owner. ;  ; virtual ~RooAbsCache ();  Destructor. Unregisters cache with owner. ;  ; virtual void findConstantNodes (const RooArgSet &, RooArgSet &, RooLinkedList &);  Interface for constant term node finding calls. ;  ; virtual TClass * IsA () const;  ; virtual void operModeHook ();  Interface for operation mode changes. ;  ; virtual void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &);  Interface for processing of cache mode optimization calls. ;  ; virtual void printCompactTreeHook (std::ostream &, const char *);  Interface for printing of cache guts in tree mode printing. ;  ; virtual bool redirectServersHook (const RooAbsCollection &, bool, bool, bool);  Interface for server redirect calls. ;  ; void setOwner (RooAbsArg *owner);  Reset the owner, triggering the owner to register this cache in its list of caches. ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void wireCache ();  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  . Protected Attributes; RooAbsArg * _owner;  Pointer to owning RooAbsArg. ;  . #include <RooAbsCache.h>. Inheritance diagram for RooAbsCache:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCache.html:1279,optimiz,optimizeCacheMode,1279,doc/master/classRooAbsCache.html,https://root.cern,https://root.cern/doc/master/classRooAbsCache.html,3,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"rs |; Classes |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; PiecewiseInterpolation Class ReferenceRooFit » RooStats » HistFactory. ; The PiecewiseInterpolation is a class that can morph distributions into each other, which is useful to estimate systematic uncertainties. ; Given a nominal distribution and one or more altered or distorted ones, it computes a new shape depending on the value of the nuisance parameters \( \alpha_i \): ; \[; A = \sum_i \mathrm{Interpolate}(\mathrm{low}_i, \mathrm{nominal}, \mathrm{high}_i, \alpha_i).; \]. If an \( \alpha_i \) is zero, the distribution is identical to the nominal distribution, at \( \pm 1 \) it is identical to the up/down distribution for that specific \( i \).; The class supports several interpolation methods, which can be selected for each parameter separately using setInterpCode(). The default interpolation code is 4. This performs; \( |\alpha | > 1 \): Linear extrapolation.; \( |\alpha | < 1 \): Polynomial interpolation. A sixth-order polynomial is used. Its coefficients are chosen such that function, first, and second derivative at \( \alpha \pm 1 \) match the values that the extrapolation procedure uses. . Definition at line 30 of file PiecewiseInterpolation.h. Classes; class  CacheElem;  . Public Member Functions;  PiecewiseInterpolation ();  ;  PiecewiseInterpolation (const char *name, const char *title, const RooAbsReal &nominal, const RooArgList &lowSet, const RooArgList &highSet, const RooArgList &paramSet);  Construct a new interpolation. ;  ;  PiecewiseInterpolation (const PiecewiseInterpolation &other, const char *name=nullptr);  Copy constructor. ;  ;  ~PiecewiseInterpolation () override;  Destructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Implement analytical integrations by doing appropriate weighting from component integrals functio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classPiecewiseInterpolation.html:1123,perform,performs,1123,doc/master/classPiecewiseInterpolation.html,https://root.cern,https://root.cern/doc/master/classPiecewiseInterpolation.html,1,['perform'],['performs']
Performance,"rs |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TProofDrawEntryList Class Reference. . Definition at line 145 of file TProofDraw.h. Public Member Functions;  TProofDrawEntryList ();  ;  ~TProofDrawEntryList () override;  ; void Init (TTree *) override;  See TProofDraw::Init(). ;  ; TClass * IsA () const override;  ; void SlaveBegin (TTree *) override;  See TProofDraw::SlaveBegin(). ;  ; void SlaveTerminate () override;  See TProofDraw::SlaveTerminate(). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  See TProofDraw::Terminate(). ;  ;  Public Member Functions inherited from TProofDraw;  TProofDraw ();  Constructor. ;  ;  ~TProofDraw () override;  Destructor. ;  ; void Begin (TTree *) override;  Executed by the client before processing. ;  ; Bool_t Notify () override;  Called when a new tree is loaded. ;  ; Bool_t Process (Long64_t) override;  Executed for each entry. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual TList * GetOutputList () const;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; virtual bool ProcessCut (Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawEntryList.html:1170,load,loaded,1170,doc/master/classTProofDrawEntryList.html,https://root.cern,https://root.cern/doc/master/classTProofDrawEntryList.html,1,['load'],['loaded']
Performance,"rs |; Public Member Functions |; Static Public Member Functions |; Protected Member Functions |; Protected Attributes |; List of all members ; TProofDrawEventList Class Reference. . Definition at line 124 of file TProofDraw.h. Public Member Functions;  TProofDrawEventList ();  ;  ~TProofDrawEventList () override;  ; void Init (TTree *) override;  See TProofDraw::Init(). ;  ; TClass * IsA () const override;  ; void SlaveBegin (TTree *) override;  See TProofDraw::SlaveBegin(). ;  ; void SlaveTerminate () override;  See TProofDraw::SlaveTerminate(). ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Terminate () override;  See TProofDraw::Terminate(). ;  ;  Public Member Functions inherited from TProofDraw;  TProofDraw ();  Constructor. ;  ;  ~TProofDraw () override;  Destructor. ;  ; void Begin (TTree *) override;  Executed by the client before processing. ;  ; Bool_t Notify () override;  Called when a new tree is loaded. ;  ; Bool_t Process (Long64_t) override;  Executed for each entry. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; int Version () const override;  ;  Public Member Functions inherited from TSelector;  TSelector ();  Default selector ctor. ;  ;  ~TSelector () override;  Selector destructor. ;  ; virtual void Abort (const char *why, EAbort what=kAbortProcess);  Abort processing. ;  ; virtual EAbort GetAbort () const;  ; virtual Int_t GetEntry (Long64_t, Int_t=0);  ; virtual TList * GetInputList () const;  ; const char * GetOption () const override;  ; virtual TList * GetOutputList () const;  ; virtual Long64_t GetStatus () const;  ; virtual void ImportOutput (TList *output);  Imports the content of 'output' in the internal output list. ;  ; TClass * IsA () const override;  ; bool Notify () override;  This method must be overridden to handle object notification (the base implementation is no-op). ;  ; virtual bool ProcessCut (Long64_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofDrawEventList.html:1170,load,loaded,1170,doc/master/classTProofDrawEventList.html,https://root.cern,https://root.cern/doc/master/classTProofDrawEventList.html,1,['load'],['loaded']
Performance,"rs(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCou",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistPdf.html:28175,cache,cache,28175,root/html532/RooHistPdf.html,https://root.cern,https://root.cern/root/html532/RooHistPdf.html,2,['cache'],['cache']
Performance,"rs(const RooArgSet& ) const; check that the parameters are correct. Double_t LowerLimit(const RooRealVar& param); compute the interval lower limit for the specified confidence level; or size using MINOS; Note that both lower and upper limit are computed and cached internally so; any subsequent calls (for the same CL will be fast to execute). Double_t UpperLimit(const RooRealVar& param); compute the interval upper limit for the specified confidence level; or size using MINOS.; Note that both lower and upper limit are computed and cached internally so; any subsequent calls (for the same CL will be fast to execute). void ResetLimits(); reset map with cached limits - called every time the test size or CL has been changed. bool CreateMinimizer(); internal function to create minimizer object needed to find contours or interval limits; (running MINOS).; Minimizer must be Minuit or Minuit2. bool FindLimits(const RooRealVar& param, double& lower, double& upper); Method to find both lower and upper limits using MINOS; If cached values exist (limits have been already found) return them in that case. Int_t GetContourPoints(const RooRealVar& paramX, const RooRealVar& paramY, Double_t* x, Double_t* y, Int_t npoints = 30); use Minuit to find the contour of the likelihood function at the desired CL. explicit LikelihoodInterval(const char* name = 0); defult constructor. void SetConfidenceLevel(Double_t cl); set the confidence level for the interval (e.g 0.682 for a 1-sigma interval). {fConfidenceLevel = cl; ResetLimits(); }. Double_t ConfidenceLevel() const; return confidence level. {return fConfidenceLevel;}. RooAbsReal* GetLikelihoodRatio(); return the profile log-likelihood ratio function. {return fLikelihoodRatio;}. const RooArgSet * GetBestFitParameters() const; return a pointer to a snapshot with best fit parameter of interest. { return fBestFitParams; }. » Author: Kyle Cranmer, Lorenzo Moneta, Gregory Schott, Wouter Verkerke » Copyright (C) 1995-2008, Rene Brun and Fons Radem",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStats__LikelihoodInterval.html:9961,cache,cached,9961,root/html526/RooStats__LikelihoodInterval.html,https://root.cern,https://root.cern/root/html526/RooStats__LikelihoodInterval.html,1,['cache'],['cached']
Performance,"rs, const RooAbsDataStore& tds, const RooFormulaVar& select, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, const RooArgSet& vars, const RooAbsDataStore& tds, const char* selExpr = 0, const char* wgtVarName = 0); RooTreeDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t, const char* wgtVarName = 0); virtual~RooTreeDataStore(); voidTObject::AbstractMethod(const char* method) const; virtual RooAbsArg*addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); virtual RooArgSet*addColumns(const RooArgList& varList); virtual voidappend(RooAbsDataStore& other); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidattachBuffers(const RooArgSet& extObs); virtual voidTObject::Browse(TBrowser* b); virtual voidcacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); const RooArgSet&RooAbsDataStore::cachedVars() const; virtual const RooAbsArg*cacheOwner(); virtual Bool_tchangeObservableName(const char* from, const char* to); virtual voidcheckInit() const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual RooAbsDataStore*clone(const char* newname = 0) const; virtual TObject*TNamed::Clone(const char* newname = """") const; virtual RooAbsDataStore*clone(const RooArgSet& vars, const char* newname = 0) const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual voidTNamed::Copy(TObject& named) const; virtual Int_tRooAbsDataStore::defaultPrintContents(Option_t* opt) const; static ostream&RooPrintable::defaultPrintStream(ostream* os = 0); virtual RooPrintable::StyleOptionRooPrintable::defaultPrintStyle(Option_t* opt) const; virtual voidTObject::Delete(Option_t* option = """")MENU ; Bool_tRooAbsDataStore::dirtyProp() const; virtual Int_tTObject::DistancetoPrimitive(Int_t px, Int_t py); virtual voidDraw(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooTreeDataStore.html:2207,cache,cachedVars,2207,root/html532/RooTreeDataStore.html,https://root.cern,https://root.cern/root/html532/RooTreeDataStore.html,2,['cache'],['cachedVars']
Performance,"rs, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; Double_tlastBinValue() const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooParametricStepFunction.html:33408,optimiz,optimizeDirtyHook,33408,root/html526/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html526/RooParametricStepFunction.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"rs, const RooFormulaVar* cutVar, const char* cutRange, int nStart, int nStop, Bool_t copyCache, const char* wgtVarName = 0); RooArgSetaddWgtVar(const RooArgSet& origVars, const RooAbsArg* wgtVar); Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); voidRooDirItem::appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kFALSE); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); static voidcleanup(); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidinitialize(const char* wgtVarName); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataSet.html:15662,optimiz,optimizeReadingWithCaching,15662,root/html534/RooDataSet.html,https://root.cern,https://root.cern/root/html534/RooDataSet.html,4,"['cache', 'optimiz']","['cacheList', 'optimizeReadingWithCaching']"
Performance,"rs, list<RooAbsDataStore*> dstoreList); Merge columns of supplied data set(s) with this data set. All; data sets must have equal number of entries. In case of; duplicate columns the column of the last dataset in the list; prevails. void reserve(Int_t nEvt). void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0, Bool_t skipZeroWeights = kTRUE); Cache given RooAbsArgs with this tree: The tree is; given direct write access of the args internal cache; the args values is pre-calculated for all data points; in this data collection. Upon a get() call, the; internal cache of 'newVar' will be loaded with the; precalculated value and it's dirty flag will be cleared. void forceCacheUpdate(). void recalculateCache(const RooArgSet* , Int_t firstEvent, Int_t lastEvent, Int_t stepSize, Bool_t skipZeroWeights). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of cache ArgSet; to the corresponding TTree branches. void resetCache(). void setArgStatus(const RooArgSet& set, Bool_t active); Disabling of branches is (intentionally) not implemented in vector; data stores (as the doesn't result in a net saving of time). void attachBuffers(const RooArgSet& extObs). void resetBuffers(). void dump(). void Streamer(TBuffer& ); Stream an object of class RooVectorDataStore. RooAbsDataStore* clone(const char* newname = 0) const; { return new RooVectorDataStore(*this,newname) ; }. RooAbsDataStore* clone(const RooArgSet& vars, const char* newname = 0) const; { return new RooVectorDataStore(*this,vars,newname) ; }. Bool_t isWeighted() const; { return (_wgtVar!=0||_extWgtArray!=0) ; }. Double_t sumEntries() const; { return _sumWeight ; }. const RooAbsArg* cacheOwner(); Constant term optimizer interface. { return _cacheOwner ; }. const RooVectorDataStore* cache() const; { return _cache ; }. void setExternalWeightArray(Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooVectorDataStore.html:16195,cache,cachedVars,16195,root/html534/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html534/RooVectorDataStore.html,18,['cache'],"['cache', 'cachedVars']"
Performance,"rs. ; headers is a 0-terminated array of header files to #include after loading the module. The module is searched for in all $LD_LIBRARY_PATH entries (or PATH% on Windows). This function gets called by the static initialization of dictionary libraries. The payload code is injected ""as is"" in the interpreter. The value of 'triggerFunc' is used to find the shared library location. ; Implements TInterpreter.; Definition at line 2010 of file TCling.cxx. ◆ RegisterPrebuiltModulePath(). bool TCling::RegisterPrebuiltModulePath ; (; const std::string & ; FullPath, . const std::string & ; ModuleMapName = ""module.modulemap"" . ); const. finalvirtual . Returnstrue if the module map was loaded, false on error or if the map was already loaded. ; Implements TInterpreter.; Definition at line 1906 of file TCling.cxx. ◆ RegisterRdictForLoadPCM(). void TCling::RegisterRdictForLoadPCM ; (; const std::string & ; pcmFileNameFullPath, . llvm::StringRef * ; pcmContent . ). private . Register Rdict data for future loading by LoadPCM;. ; Definition at line 1678 of file TCling.cxx. ◆ RegisterTClassUpdate(). void TCling::RegisterTClassUpdate ; (; TClass * ; oldcl, . DictFuncPtr_t ; dict . ). finalvirtual . Register classes that already existed prior to their dictionary loading and that already had a ClassInfo (and thus would not be refresh via UpdateClassInfo. ; Implements TInterpreter.; Definition at line 2384 of file TCling.cxx. ◆ RegisterTemporary() [1/2]. void TCling::RegisterTemporary ; (; const cling::Value & ; value). Register value as a temporary, extending its lifetime to that of the interpreter. ; This is needed for TCling's compatibility interfaces returning long - the address of the temporary objects. As such, ""simple"" types don't need to be stored; they are returned by value; only pointers / references / objects need to be stored. ; Definition at line 7701 of file TCling.cxx. ◆ RegisterTemporary() [2/2]. void TCling::RegisterTemporary ; (; const TInterpreterValue & ; value). Defi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCling.html:125923,load,loading,125923,doc/master/classTCling.html,https://root.cern,https://root.cern/doc/master/classTCling.html,1,['load'],['loading']
Performance,"rs; Includes; Libraries. Function documentation; TEnum(const char* name, void* info, TClass* cls); Constructor for TEnum class.; It take the name of the TEnum type, specification if it is global; and interpreter info.; Constant List is owner if enum not on global scope (thus constants not; in TROOT::GetListOfGlobals). ~TEnum(); Destructor. void AddConstant(TEnumConstant* constant); Add a EnumConstant to the list of constants of the Enum Type. Bool_t IsValid(); Return true if this enum object is pointing to a currently; loaded enum. If a enum is unloaded after the TEnum; is created, the TEnum will be set to be invalid. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void Update(TDictionary::DeclId_t id). TEnum * GetEnum(const std::type_info &ti, ESearchAction sa). TEnum * GetEnum(const char* enumName, TEnum::ESearchAction sa = kALoadAndInterpLookup); Static function to retrieve enumerator from the ROOT's typesystem.; It has no side effect, except when the load flag is true. In this case,; the load of the library containing the scope of the enumerator is attempted.; There are two top level code paths: the enumerator is scoped or isn't.; If it is not, a lookup in the list of global enums is performed.; If it is, two lookups are carried out for its scope: one in the list of; classes and one in the list of protoclasses. If a scope with the desired name; is found, the enum is searched. If the scope is not found, and the load flag is; true, the aforementioned two steps are performed again after an autoload attempt; with the name of the scope as key is tried out.; If the interpreter lookup flag is false, the ListOfEnums objects are not treated; as such, but rather as THashList objects. This prevents any flow of information; from the interpreter into the ROOT's typesystem: a snapshot of the typesystem; status is taken. TEnum(); {}. TEnum(const char* name, void* info, TClass* cls). TClass * GetClass() const. const TSeqCollection * Get",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEnum.html:8615,load,load,8615,root/html602/TEnum.html,https://root.cern,https://root.cern/root/html602/TEnum.html,4,['load'],['load']
Performance,"rs; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_tRooAbsGenContext::_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooArgSet*_cloneSetInternal clone of p.d.f.; RooAbsReal*_effPointer to efficiency function; RooAbsGenContext*_generatorGenerator context for p.d.f. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooEffGenContext(const RooAbsPdf& model, const RooAbsPdf& pdf, const RooAbsReal& eff, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE, const RooArgSet* forceDirect = 0); Constructor of generator context for RooEffProd products. ~RooEffGenContext(); Destructor. void initGenerator(const RooArgSet& theEvent); One-time initialization of generator. void ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooEffGenContext.html:8077,load,load,8077,root/html526/RooEffGenContext.html,https://root.cern,https://root.cern/root/html526/RooEffGenContext.html,1,['load'],['load']
Performance,"rs; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fBinData! binary data, assigned with http call; Long_tfBinDataLength! length of binary data; TConditionfCond! condition used to wait for processing; TStringfContent! text content (if any); TStringfContentType! type of content; TStringfFileName! file name; TStringfHeader! response header like ContentEncoding, Cache-Control and so on; TStringfPathName! item path; TStringfQuery! additional arguments; TStringfTopName! top item name; Int_tfZipping! indicate if content should be zipped. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpCallArg(); constructor. ~THttpCallArg(); destructor. void SetBinData(void* data, Long_t length); set binary data, which will be returned as reply body. void SetPathAndFileName(const char* fullpath); set complete path of requested http element; For instance, it could be ""/folder/subfolder/get.bin""; Here ""/folder/subfolder/"" is element path and ""get.bin"" requested file.; One could set path and file name separately. void FillHttpHeader(TString& buf, const char* header = 0); fill HTTP header. Bool_t CompressWithGzip(); compress reply data with gzip compression. Bool_t IsBinData() const. THttpCallArg(). void SetTopName(const char* topname); these methods ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/THttpCallArg.html:6978,Cache,Cache-Control,6978,root/html602/THttpCallArg.html,https://root.cern,https://root.cern/root/html602/THttpCallArg.html,1,['Cache'],['Cache-Control']
Performance,"rse.h:40; TMatrixTSparse::fColIndexInt_t * fColIndexDefinition TMatrixTSparse.h:41; As an example how to access all sparse data elements:; for (Int_t irow = 0; irow < this->fNrows; irow++) {; const Int_t sIndex = fRowIndex[irow];; const Int_t eIndex = fRowIndex[irow+1];; for (Int_t index = sIndex; index < eIndex; index++) {; const Int_t icol = fColIndex[index];; const Element data = fElements[index];; printf(""data(%d,%d) = %.4e\n"",irow+this->fRowLwb,icol+; this->fColLwb,data);; }; }; TMatrixTBase::fColLwbInt_t fColLwbDefinition TMatrixTBase.h:93; TMatrixTBase::fRowLwbInt_t fRowLwbDefinition TMatrixTBase.h:92; TMatrixTSparse::fElementsElement * fElementsDefinition TMatrixTSparse.h:42; int; When checking whether sparse matrices are compatible (like in an assignment !), not only the shape parameters are compared but also the sparse structure through fRowIndex and fColIndex .; Several methods exist to fill a sparse matrix with data entries. Most are the same like for dense matrices but some care has to be taken with regard to performance. In the constructor, always the shape of the matrix has to be specified in some form . Data can be entered through the following methods :; constructor from COO matrix format TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,Int_t nr_nonzeros,; Int_t *row, Int_t *col,Element *data);; TMatrixTSparse::TMatrixTSparseTMatrixTSparse()Definition TMatrixTSparse.h:83; It uses SetMatrixArray(..), see below; constructor from Harwell-Boeing (CSR) matrix format TMatrixTSparse(Int_t row_lwb,Int_t row_upb,Int_t dol_lwb,; Int_t col_upb,; Int_t *rowptr, Int_t *col,Element *data);; It copies input arrays into matrix .; copy constructors; SetMatrixArray(Int_t nr,Int_t *irow,Int_t *icol,Element *data) where it is expected that the irow,icol and data array contain nr entries . Only the entries with non-zero data[i] value are inserted. Be aware that the input data array will be modified inside the routine for doing the necessary sorti",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMatrixTSparse.html:2617,perform,performance,2617,doc/master/classTMatrixTSparse.html,https://root.cern,https://root.cern/doc/master/classTMatrixTSparse.html,1,['perform'],['performance']
Performance,"rsion (AWMI) allows fitting tens, hundreds; of peaks simultaneously that represent sometimes thousands of parameters [2],; [5]. ; Function:; void TSpectrumFit::FitAwmi(double *fSource). This function fits the source; spectrum using AWMI algorithm. The calling program should fill in input fitting; parameters of the TSpectrumFit class using a set of TSpectrumFit setters. The; fitted parameters are written into the class and the fitted data are written; into source spectrum. ;  ; Parameter:; ������� fSource-pointer to; the vector of source spectrum����������������� ; ������� ; Member variables of the; TSpectrumFit class:; ��; Int_t���� fNPeaks;������������������� //number of peaks present in fit, input; parameter, it should be > 0; ��; Int_t���� fNumberIterations;��������� //number of iterations in fitting; procedure, input parameter, it should be > 0; ��; Int_t���� fXmin;��������������������� //first fitted channel; ��; Int_t���� fXmax;��������������������� //last fitted channel; ��; Int_t���� fStatisticType;������������ //type of statistics, possible values; kFitOptimChiCounts (chi square statistics with counts as weighting; coefficients), kFitOptimChiFuncValues (chi square statistics with function; values as weighting coefficients),kFitOptimMaxLikelihood; ��; Int_t���� fAlphaOptim;��������������� //optimization of convergence algorithm, possible; values kFitAlphaHalving, kFitAlphaOptimal; ��; Int_t���� fPower;�������������������� //possible values kFitPower2,4,6,8,10,12,; for details see references. It applies only for Awmi fitting function.; ��; Int_t���� fFitTaylor;���������������� //order of Taylor expansion, possible; values kFitTaylorOrderFirst, kFitTaylorOrderSecond. It applies only for Awmi; fitting function.; ��; Double_t� fAlpha;�������������������� //convergence coefficient, input; parameter, it should be positive number and <=1, for details see references; ��; Double_t� fChi;���������������������� //here the fitting functions return; resulting chi square�",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrumFit.html:22570,optimiz,optimization,22570,root/html602/TSpectrumFit.html,https://root.cern,https://root.cern/root/html602/TSpectrumFit.html,4,['optimiz'],['optimization']
Performance,"rsion, ""1.1""))) {; 4008 /* HTTP 1.1 default is keep alive */; 4009 return 1;; 4010 }; 4011 ; 4012 /* HTTP 1.0 (and earlier) default is to close the connection */; 4013 return 0;; 4014}; 4015 ; 4016 ; 4017static int; 4018should_decode_url(const struct mg_connection *conn); 4019{; 4020 if (!conn || !conn->dom_ctx) {; 4021 return 0;; 4022 }; 4023 ; 4024 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4025}; 4026 ; 4027 ; 4028static int; 4029should_decode_query_string(const struct mg_connection *conn); 4030{; 4031 if (!conn || !conn->dom_ctx) {; 4032 return 0;; 4033 }; 4034 ; 4035 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_QUERY_STRING], ""yes""); 4036 == 0);; 4037}; 4038 ; 4039 ; 4040static const char *; 4041suggest_connection_header(const struct mg_connection *conn); 4042{; 4043 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4044}; 4045 ; 4046 ; 4047#include ""response.inl""; 4048 ; 4049 ; 4050static void; 4051send_no_cache_header(struct mg_connection *conn); 4052{; 4053 /* Send all current and obsolete cache opt-out directives. */; 4054 mg_response_header_add(conn,; 4055 ""Cache-Control"",; 4056 ""no-cache, no-store, ""; 4057 ""must-revalidate, private, max-age=0"",; 4058 -1);; 4059 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4060 ; 4061 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4062 /* Obsolete, but still send it for HTTP/1.0 */; 4063 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4064 }; 4065}; 4066 ; 4067 ; 4068static void; 4069send_static_cache_header(struct mg_connection *conn); 4070{; 4071#if !defined(NO_CACHING); 4072 int max_age;; 4073 char val[64];; 4074 ; 4075 const char *cache_control =; 4076 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4077 ; 4078 /* If there is a full cache-control option configured,0 use it */; 4079 if (cache_control != NULL) {; 4080 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4081 return;; 4082 }; 4083 ; 4084 /* Read the server config to check how lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:119776,cache,cache,119776,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['cache'],['cache']
Performance,"rsion, ""1.1""))) {; 4009 /* HTTP 1.1 default is keep alive */; 4010 return 1;; 4011 }; 4012 ; 4013 /* HTTP 1.0 (and earlier) default is to close the connection */; 4014 return 0;; 4015}; 4016 ; 4017 ; 4018static int; 4019should_decode_url(const struct mg_connection *conn); 4020{; 4021 if (!conn || !conn->dom_ctx) {; 4022 return 0;; 4023 }; 4024 ; 4025 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_URL], ""yes"") == 0);; 4026}; 4027 ; 4028 ; 4029static int; 4030should_decode_query_string(const struct mg_connection *conn); 4031{; 4032 if (!conn || !conn->dom_ctx) {; 4033 return 0;; 4034 }; 4035 ; 4036 return (mg_strcasecmp(conn->dom_ctx->config[DECODE_QUERY_STRING], ""yes""); 4037 == 0);; 4038}; 4039 ; 4040 ; 4041static const char *; 4042suggest_connection_header(const struct mg_connection *conn); 4043{; 4044 return should_keep_alive(conn) ? ""keep-alive"" : ""close"";; 4045}; 4046 ; 4047 ; 4048#include ""response.inl""; 4049 ; 4050 ; 4051static void; 4052send_no_cache_header(struct mg_connection *conn); 4053{; 4054 /* Send all current and obsolete cache opt-out directives. */; 4055 mg_response_header_add(conn,; 4056 ""Cache-Control"",; 4057 ""no-cache, no-store, ""; 4058 ""must-revalidate, private, max-age=0"",; 4059 -1);; 4060 mg_response_header_add(conn, ""Expires"", ""0"", -1);; 4061 ; 4062 if (conn->protocol_type == PROTOCOL_TYPE_HTTP1) {; 4063 /* Obsolete, but still send it for HTTP/1.0 */; 4064 mg_response_header_add(conn, ""Pragma"", ""no-cache"", -1);; 4065 }; 4066}; 4067 ; 4068 ; 4069static void; 4070send_static_cache_header(struct mg_connection *conn); 4071{; 4072#if !defined(NO_CACHING); 4073 int max_age;; 4074 char val[64];; 4075 ; 4076 const char *cache_control =; 4077 conn->dom_ctx->config[STATIC_FILE_CACHE_CONTROL];; 4078 ; 4079 /* If there is a full cache-control option configured,0 use it */; 4080 if (cache_control != NULL) {; 4081 mg_response_header_add(conn, ""Cache-Control"", cache_control, -1);; 4082 return;; 4083 }; 4084 ; 4085 /* Read the server config to check how lo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:119808,cache,cache,119808,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['cache'],['cache']
Performance,"rsiveRemove(TObject* obj); virtual TObject*TDirectory::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtual voidSetReadCalls(Int_t readcalls = 0); static voidSetReadStre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:12835,cache,cache,12835,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['cache'],['cache']
Performance,"rst Reduce overload for more information. ; Definition at line 1711 of file RInterface.hxx. ◆ Reduce() [2/2]. template<typename Proxied , typename DataSource = void> . template<typename F , typename T = typename TTraits::CallableTraits<F>::ret_type> . RResultPtr< T > ROOT::RDF::RInterface< Proxied, DataSource >::Reduce ; (; F ; f, . std::string_view ; columnName = """" . ). inline . Execute a user-defined reduce operation on the values of a column. ; Template Parameters. FThe type of the reduce callable. Automatically deduced. ; TThe type of the column to apply the reduction to. Automatically deduced. . Parameters. [in]fA callable with signature T(T,T) ; [in]columnNameThe column to be reduced. If omitted, the first default column is used instead. . Returnsthe reduced quantity wrapped in a ROOT::RDF:RResultPtr.; A reduction takes two values of a column and merges them into one (e.g. by summing them, taking the maximum, etc). This action performs the specified reduction operation on all processed column values, returning a single value of the same type. The callable f must satisfy the general requirements of a processing function besides having signature T(T,T) where T is the type of column columnName.; The returned reduced value of each thread (e.g. the initial value of a sum) is initialized to a default-constructed T object. This is commonly expected to be the neutral/identity element for the specific reduction operation f (e.g. 0 for a sum, 1 for a product). If a default-constructed T does not satisfy this requirement, users should explicitly specify an initialization value for T by calling the appropriate Reduce overload. Example usage:; auto sumOfIntCol = d.Reduce([](int x, int y) { return x + y; }, ""intCol"");; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr. ; Definition at line 1688 of file RInterface.hxx. ◆ Report(). template<typename Proxied , typename DataSource = void> . RResultPtr< RCutFlowR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:120892,perform,performs,120892,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['perform'],['performs']
Performance,"rst and second file; to be read to find the number of entries in these files.; Note that if one calls TChain::GetEntriesFast() after having created; a chain with this default, GetEntriesFast will return kBigNumber!; TChain::GetEntries will force of the Tree headers in the chain to be; read to read the number of entries in each Tree. D- The TChain data structure; Each TChainElement has a name equal to the tree name of this TChain; and a title equal to the file name. So, to loop over the; TFiles that have been added to this chain:. TObjArray *fileElements=chain->GetListOfFiles();; TIter next(fileElements);; TChainElement *chEl=0;; while (( chEl=(TChainElement*)next() )) {; TFile f(chEl->GetTitle());; ... do something with f ...; }. The function returns the total number of files connected. Int_t AddFile(const char* name, Long64_t nentries = kBigNumber, const char* tname = """"); -- Add a new file to this chain. If tname is specified, the chain will load the tree named tname; from the file, otherwise the original treename specified in the; TChain constructor will be used. A. If nentries <= 0, the file is opened and the tree header read; into memory to get the number of entries. B. If nentries > 0, the file is not opened, and nentries is assumed; to be the number of entries in the file. In this case, no check; is made that the file exists nor that the tree exists in the file.; This second mode is interesting in case the number of entries in; the file is already stored in a run database for example. C. If nentries == kBigNumber (default), the file is not opened.; The number of entries in each file will be read only when the file; is opened to read an entry. This option is the default and very; efficient if one processes the chain sequentially. Note that in; case GetEntry(entry) is called and entry refers to an entry in the; third file, for example, this forces the tree headers in the first; and second file to be read to find the number of entries in those; files. Note that i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:28321,load,load,28321,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,3,['load'],['load']
Performance,"rst one in the fViewers list. TGLViewer* GetDefaultGLViewer() const; Get TGLViewer of the default TEveViewer. TEveGedEditor* GetEditor() const; Returns main object editor. TGStatusBar* GetStatusBar() const; Returns main window status bar. TCanvas* AddCanvasTab(const char* name); Add a new canvas tab. TEveViewer* SpawnNewViewer(const char* name, const char* title = """", Bool_t embed = kTRUE); Create a new GL viewer. TEveScene* SpawnNewScene(const char* name, const char* title = """"); Create a new scene. TMacro* GetMacro(const char* name) const; Find macro in fMacroFolder by name. void EditElement(TEveElement* element); Show element in default editor. void RegisterRedraw3D(); Register a request for 3D redraw. void DoRedraw3D(); Perform 3D redraw of scenes and viewers whose contents has; changed. void FullRedraw3D(Bool_t resetCameras = kFALSE, Bool_t dropLogicals = kFALSE); Perform 3D redraw of all scenes and viewers. void ElementChanged(TEveElement* element, Bool_t update_scenes = kTRUE, Bool_t redraw = kFALSE); Element was changed, perform framework side action.; Called from TEveElement::ElementChanged(). void ScenesChanged(TEveElement::List_t& scenes); Mark all scenes from the given list as changed. void ElementStamped(TEveElement* element); Mark element as changed -- it will be processed on next redraw. TGListTree* GetListTree() const; Get default list-tree widget. AddToListTree(TEveElement* re, Bool_t open, TGListTree* lt = 0); Add element as a top-level to a list-tree.; Only add a single copy of a render-element as a top level. void RemoveFromListTree(TEveElement* element, TGListTree* lt, TGListTreeItem* lti); Remove top-level element from list-tree with specified tree-item. TGListTreeItem* AddEvent(TEveEventManager* event); Add a new event and make it the current event.; It is added into the event-scene and as a top-level list-tree; item. void AddElement(TEveElement* element, TEveElement* parent = 0); Add an element. If parent is not specified it is added into; cur",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEveManager.html:6253,perform,perform,6253,root/html528/TEveManager.html,https://root.cern,https://root.cern/root/html528/TEveManager.html,10,['perform'],['perform']
Performance,"rst; the most performant nodes. Returns the number of active slaves.; If random is TRUE, and nodes is less than the number of available workers,; a random selection is done.; Returns -1 in case of error. void ShowData(); List contents of the data directory in the sandbox.; This is the place where files produced by the client queries are kept. void ClearData(UInt_t what = kUnregistered, const char* dsname = 0); Remove files for the data directory.; The option 'what' can take the values:; kPurge remove all files and directories under '~/data'; kUnregistered remove only files not in registered datasets (default); kDataset remove files belonging to dataset 'dsname'; User is prompt for confirmation, unless kForceClear is ORed with the option. Bool_t Prompt(const char* p); Prompt the question 'p' requiring an answer y,Y,n,N; Return kTRUE is the answer was y or Y, kFALSE in all other cases. void ClearDataProgress(Int_t r, Int_t t); Progress bar for clear data. void ShowCache(Bool_t all = kFALSE); List contents of file cache. If all is true show all caches also on; slaves. If everything is ok all caches are to be the same. void ClearCache(const char* file = 0); Remove file from all file caches. If file is 0 or """" or ""*"", remove all; the files. void SystemCmd(const char* cmd, Int_t fdout); Exec system command 'cmd'. If fdout > -1, append the output to fdout. void ShowPackages(Bool_t all = kFALSE, Bool_t redirlog = kFALSE); List contents of package directory. If all is true show all package; directories also on slaves. If everything is ok all package directories; should be the same. If redir is kTRUE the result is redirected to the log; file (option available for internal actions). void ShowEnabledPackages(Bool_t all = kFALSE); List which packages are enabled. If all is true show enabled packages; for all active slaves. If everything is ok all active slaves should; have the same packages enabled. Int_t ClearPackages(); Remove all packages.; Returns 0 in case of success and -1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:59720,cache,cache,59720,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,10,['cache'],['cache']
Performance,"rt is written to file.; For a detailed description of the interface, the user should look at the root reference guide at: http://root.cern.ch/root/Reference.html; 14.1 Overview of Matrix Classes; The figure below shows an overview of the classes available in the linear algebra library,libMatrix.so. At the center is the base class TMatrixDBase from which three different matrix classes, TMatrixD, TMatrixDSym and TMatrixDFSparse derive. The user can define customized matrix operations through the classes TElementActionD and TElementsPosActionD. Overview of matrix classes. Reference to different views of the matrix can be created through the classes on the right-hand side, see “Matrix Views”. These references provide a natural connection to vectors.; Matrix decompositions (used in equation solving and matrix inversion) are available through the classes on the left-hand side (see “Matrix Decompositions”). They inherit from the TDecompBase class. The Eigen Analysis is performed through the classes at the top, see “Matrix Eigen Analysis”. In both cases, only some matrix types can be analyzed. For instance, TDecompChol will only accept symmetric matrices as defined TMatrixDSym. The assignment operator behaves somewhat different than of most other classes. The following lines will result in an error:; TMatrixD a(3,4);; TMatrixD b(5,6);; b = a;; It required to first resize matrix b to the shape of a.; TMatrixD a(3,4);; TMatrixD b(5,6);; b.ResizeTo(a);; b = a;; 14.2 Matrix Properties; A matrix has five properties, which are all set in the constructor:. precision - float or double. In the first case you will use the TMatrixF class family, in the latter case the TMatrixD one;; type - general (TMatrixD), symmetric (TMatrixDSym) or sparse (TMatrixDSparse);; size - number of rows and columns;; index - range start of row and column index. By default these start at zero;; sparse map - this property is only relevant for a sparse matrix. It indicates where elements are unequal zero. 14.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:770278,perform,performed,770278,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['performed']
Performance,"rt); 2226 return EvaluateImportanceShort(loader, theMethod, methodTitle, theOption);; 2227 else if (vitype == VIType::kAll); 2228 return EvaluateImportanceAll(loader, theMethod, methodTitle, theOption);; 2229 else if (vitype == VIType::kRandom) {; 2230 if ( nbits > 10 && nbits < 30) {; 2231 // limit nbits to less than 30 to avoid error converting from double to uint and also cannot deal with too many combinations; 2232 return EvaluateImportanceRandom(loader, static_cast<UInt_t>( pow(2, nbits) ), theMethod, methodTitle, theOption);; 2233 } else if (nbits < 10) {; 2234 Log() << kERROR << ""Error in Variable Importance: Random mode require more that 10 variables in the dataset.""; 2235 << Endl;; 2236 } else if (nbits > 30) {; 2237 Log() << kERROR << ""Error in Variable Importance: Number of variables is too large for Random mode""; 2238 << Endl;; 2239 }; 2240 }; 2241 return nullptr;; 2242}; 2243 ; 2244////////////////////////////////////////////////////////////////////////////////; 2245 ; 2246TH1F *TMVA::Factory::EvaluateImportanceAll(DataLoader *loader, Types::EMVA theMethod, TString methodTitle,; 2247 const char *theOption); 2248{; 2249 ; 2250 uint64_t x = 0;; 2251 uint64_t y = 0;; 2252 ; 2253 // getting number of variables and variable names from loader; 2254 const int nbits = loader->GetDataSetInfo().GetNVariables();; 2255 std::vector<TString> varNames = loader->GetDataSetInfo().GetListOfVariables();; 2256 ; 2257 if (nbits > 60) {; 2258 Log() << kERROR << ""Number of combinations is too large , is 2^"" << nbits << Endl;; 2259 return nullptr;; 2260 }; 2261 if (nbits > 20) {; 2262 Log() << kWARNING << ""Number of combinations is very large , is 2^"" << nbits << Endl;; 2263 }; 2264 uint64_t range = static_cast<uint64_t>(pow(2, nbits));; 2265 ; 2266 ; 2267 // vector to save importances; 2268 std::vector<Double_t> importances(nbits);; 2269 // vector to save ROC; 2270 std::vector<Double_t> ROC(range);; 2271 ROC[0] = 0.5;; 2272 for (int i = 0; i < nbits; i++); 2273 importances[i] ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:94871,load,loader,94871,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,3,['load'],['loader']
Performance,"rt; 122#else; 123char static_assert_replacement[1];; 124#define mg_static_assert(cond, txt) \; 125 extern char static_assert_replacement[(cond) ? 1 : -1]; 126#endif; 127 ; 128mg_static_assert(sizeof(int) == 4 || sizeof(int) == 8,; 129 ""int data type size check"");; 130mg_static_assert(sizeof(void *) == 4 || sizeof(void *) == 8,; 131 ""pointer data type size check"");; 132mg_static_assert(sizeof(void *) >= sizeof(int), ""data type size check"");; 133 ; 134 ; 135/* Select queue implementation. Diagnosis features originally only implemented; 136 * for the ""ALTERNATIVE_QUEUE"" have been ported to the previous queue; 137 * implementation (NO_ALTERNATIVE_QUEUE) as well. The new configuration value; 138 * ""CONNECTION_QUEUE_SIZE"" is only available for the previous queue; 139 * implementation, since the queue length is independent from the number of; 140 * worker threads there, while the new queue is one element per worker thread.; 141 *; 142 */; 143#if defined(NO_ALTERNATIVE_QUEUE) && defined(ALTERNATIVE_QUEUE); 144/* The queues are exclusive or - only one can be used. */; 145#error \; 146 ""Define ALTERNATIVE_QUEUE or NO_ALTERNATIVE_QUEUE (or none of them), but not both""; 147#endif; 148#if !defined(NO_ALTERNATIVE_QUEUE) && !defined(ALTERNATIVE_QUEUE); 149/* Use a default implementation */; 150#define NO_ALTERNATIVE_QUEUE; 151#endif; 152 ; 153#if defined(NO_FILESYSTEMS) && !defined(NO_FILES); 154/* File system access:; 155 * NO_FILES = do not serve any files from the file system automatically.; 156 * However, with NO_FILES CivetWeb may still write log files, read access; 157 * control files, default error page files or use API functions like; 158 * mg_send_file in callbacks to send files from the server local; 159 * file system.; 160 * NO_FILES only disables the automatic mapping between URLs and local; 161 * file names.; 162 * NO_FILESYSTEM = do not access any file at all. Useful for embedded; 163 * devices without file system. Logging to files in not available; 164 * (use callba",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:6040,queue,queues,6040,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,2,['queue'],['queues']
Performance,"rtTSelector::fAbortabort status; Int_tfDimensionDimension of the current expression; TStringfInitialExp; TList*TSelector::fInputlist of objects available during processing; TTreeFormulaManager*fManager; Int_tfMultiplicityIndicator of the variability of the size of entries; Bool_tfObjEvaltrue if fVar1 returns an object (or pointer to).; TObject*TSelector::fObjectcurrent object if processing object (vs. TTree); TStringTSelector::fOptionoption given to TTree::Process; TSelectorList*TSelector::fOutputlist of objects created during processing; TTreeFormula*fSelectPointer to selection formula; TStringfSelection; TStatus*fStatus; Long64_tTSelector::fStatusselector status; TTree*fTree; TTreeDrawArgsParserfTreeDrawArgsParser; TTreeFormula*fVar[4]Pointer to variable formula; Double_tfWeightGlobal weight for fill actions. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofDraw(); Destructor. void Init(TTree* ); Init the tree. Bool_t Notify(); Called when a new tree is loaded. void Begin(TTree* ); Executed by the client before processing. void SlaveBegin(TTree* ); Executed by each slave before processing. void FillWeight(); Get weight from input list, if any. Bool_t ProcessSingle(Long64_t , Int_t ); Processes a single variable from an entry. Bool_t Process(Long64_t ); Executed for each entry. void SlaveTerminate(void); Executed by each slave after the processing has finished,; before returning the results to the client. void Terminate(void); Executed by the client after getting the processing retults. void ClearFormula(); Delete internal buffers. void SetCanvas(const char* objname); Move to a canvas named <name>_canvas; create the canvas if not existing.; Used to avoid screwing up existing plots when non default names are used; for the final objects. void SetDrawAtt(TObject* o); Set the drawing attributes from the input list. void SetError(const char* sub, const char* mesg); Sets the error status. Bool_t CompileVariables(); Compiles",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofDraw.html:7605,load,loaded,7605,root/html530/TProofDraw.html,https://root.cern,https://root.cern/root/html530/TProofDraw.html,3,['load'],['loaded']
Performance,"rt_t b)Returns the largest of a and b.Definition TMathBase.h:250; TMath::AbsShort_t Abs(Short_t d)Returns the absolute value of parameter Short_t d.Definition TMathBase.h:123; For the last case, a=b, the algorithm advances each array by one index in an attempt to move through the equality. However, this is incorrect when one or the other of a or b (or both) have a repeated value, call it x. For the KS statistic to be computed properly, rdiff needs to be calculated after all of the a and b at x have been tallied (this is due to the definition of the empirical distribution function; another way to convince yourself that the old CERNLIB method is wrong is that it implies that the function defined as the difference between a and b is multi-valued at x – besides being ugly, this would invalidate Kolmogorov's theorem).; The solution is to just add while-loops into the equality-case handling to perform the tally:; } else {; double x = a[ia-1];; while(a[ia-1] == x && ia <= na) {; rdiff -= sa;; ia++;; }; while(b[ib-1] == x && ib <= nb) {; rdiff += sb;; ib++;; }; if (ia > na) {ok = kTRUE; break;}; if (ib > nb) {ok = kTRUE; break;}; }; xDouble_t x[n]Definition legend1.C:17. Note:; A good description of the Kolmogorov test can be seen at: http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm ; Definition at line 805 of file TMath.cxx. ◆ KOrdStat(). template<class Element , typename Size > . Element TMath::KOrdStat ; (; Size ; n, . const Element * ; a, . Size ; k, . Size * ; work = 0 . ). Returns k_th order statistic of the array a of size n (k_th smallest element out of n elements). ; C-convention is used for array indexing, so if you want the second smallest element, call KOrdStat(n, a, 1).; If work is supplied, it is used to store the sorting index and assumed to be >= n. If work=0, local storage is used, either on the stack if n < kWorkMax or on the heap for n >= kWorkMax. Note that the work index array will not contain the sorted indices but all indices of the sma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceTMath.html:54370,perform,perform,54370,doc/master/namespaceTMath.html,https://root.cern,https://root.cern/doc/master/namespaceTMath.html,1,['perform'],['perform']
Performance,"rties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but usually a subroutine returning a thread-specific errno value. Some other systems may provide other implementations of errno. With respect to ROOT, a thread specific data is for example the gPad pointer, which is treated in a different way, whether it is accessed from any thread or the main thread.; Threads within a process must not be considered as a group of processes (even though in Linux each thread receives an own process id, so that it can be scheduled by the kernel scheduler). All threads share the same address space. This means that two pointers having the same value in two threads refer to the same data. Also, if any thread changes one of the shared system resources, all threads within the process are affected. For example, if a thread closes a file, the file is closed for all threads.; 23.1.3 The Initial Thread; When a process is created, one thread is automatically created. This thread is called the initial thread or the main thread. The initial thread executes the main r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1102437,multi-thread,multi-threaded,1102437,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['multi-thread'],['multi-threaded']
Performance,"rties of the underlying phenomenon(variable), or be due to measurement errors or anomalies which shouldn't be modelled. (StatSoft electronic textbook); Even a single gross outlier can greatly influence the results of least- squares fitting procedure, and in this case use of robust(resistant) methods is recommended.; The method implemented here is based on the article and algorithm: ""Computing LTS Regression for Large Data Sets"" by P.J.Rousseeuw and Katrien Van Driessen The idea of the method is to find the fitting coefficients for a subset of h observations (out of n) with the smallest sum of squared residuals. The size of the subset h should lie between (npoints + nparameters +1)/2 and n, and represents the minimal number of good points in the dataset. The default value is set to (npoints + nparameters +1)/2, but of course if you are sure that the data contains less outliers it's better to change h according to your data.; To perform a robust fit, call EvalRobust() function instead of Eval() after adding the points and setting the fitting function. Note, that standard errors on parameters are not computed! ; Definition at line 153 of file TLinearFitter.h. Public Member Functions;  TLinearFitter ();  default c-tor, input data is stored If you don't want to store the input data, run the function StoreData(kFALSE) after constructor ;  ;  TLinearFitter (const TLinearFitter &tlf);  Copy ctor. ;  ;  TLinearFitter (Int_t ndim);  The parameter stands for number of dimensions in the fitting formula The input data is stored. ;  ;  TLinearFitter (Int_t ndim, const char *formula, Option_t *opt=""D"");  First parameter stands for number of dimensions in the fitting formula Second parameter is the fitting formula: see class description for formula syntax Options: The option is to store or not to store the data If you don't want to store the data, choose """" for the option, or run StoreData(kFalse) member function after the constructor. ;  ;  TLinearFitter (TFormula *function, Option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTLinearFitter.html:7844,perform,perform,7844,doc/master/classTLinearFitter.html,https://root.cern,https://root.cern/doc/master/classTLinearFitter.html,1,['perform'],['perform']
Performance,"rts of the geometry, or it may simply happen that they really represent a single object, too complex to be described by a primitive shape.; Usually handling structures like these can be easily done by positioning all components in the same container volume, then positioning the container itself. However, there are many practical cases when defining such a container is not straightforward or even possible without generating overlaps with the rest of the geometry. There are few ways out of this:. Defining the container for the structure as ""overlapping"" (see also ""Overlapping Volumes""); Representing the container as a composite shape - the Boolean union of all components (see also ""Composite Shapes""); Using an assembly volume - this will be described in the following. The first two approaches have the disadvantage of penalizing the navigation performance with a factor increasing more than linear of the number of components in the structure. The best solution is the third one because it uses all volume-related navigation optimizations. The class TGeoVolumeAssembly represents an assembly volume. Its shape is represented by TGeoShapeAssembly class that is the union of all components. It uses volume voxelization to perform navigation tasks.; An assembly volume creates a hierarchical level and it geometrically insulates the structure from the rest (as a normal volume). Physically, a point that is INSIDE a TGeoShapeAssembly is always inside one of the components, so a TGeoVolumeAssembly does not need to have a medium. Due to the self-containment of assemblies, they are very practical to use when a container is hard to define due to possible overlaps during positioning. For instance, it is very easy creating honeycomb structures. A very useful example for creating and using assemblies can be found at: assembly.C.; Creation of an assembly is very easy: one has just to create a TGeoVolumeAssembly object and position the components inside as for any volume:; TGeoVolume *vol = n",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:51519,optimiz,optimizations,51519,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['optimiz'],['optimizations']
Performance,"rts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsString(); Destructor. const char* getVal() const; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. » Last changed: Mon Jul 4 15:21:31 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsString.html:20211,cache,cache,20211,root/html530/RooAbsString.html,https://root.cern,https://root.cern/root/html530/RooAbsString.html,5,['cache'],"['cache', 'cached']"
Performance,"rts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsString(); Destructor. const char* getVal() const; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. » Last changed: Sat Oct 9 22:38:32 2010 » Last generated: 2010-10-09 22:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsString.html:20089,cache,cache,20089,root/html528/RooAbsString.html,https://root.cern,https://root.cern/root/html528/RooAbsString.html,5,['cache'],"['cache', 'cached']"
Performance,"rtual . Map window on screen. ; Reimplemented from TVirtualX.; Definition at line 217 of file GX11Gui.cxx. ◆ MoveResizeWindow(). void TGX11::MoveResizeWindow ; (; Window_t ; id, . Int_t ; x, . Int_t ; y, . UInt_t ; w, . UInt_t ; h . ). overridevirtual . Move and resize a window. ; Reimplemented from TVirtualX.; Definition at line 307 of file GX11Gui.cxx. ◆ MoveWindow() [1/2]. void TGX11::MoveWindow ; (; Int_t ; wid, . Int_t ; x, . Int_t ; y . ). overridevirtual . Move the window wid. ; Parameters. [in]wid: Window identifier. ; [in]x: x new window position ; [in]y: y new window position . Reimplemented from TVirtualX.; Definition at line 1080 of file TGX11.cxx. ◆ MoveWindow() [2/2]. void TGX11::MoveWindow ; (; Window_t ; id, . Int_t ; x, . Int_t ; y . ). overridevirtual . Move a window. ; Reimplemented from TVirtualX.; Definition at line 297 of file GX11Gui.cxx. ◆ NextEvent(). void TGX11::NextEvent ; (; Event_t & ; event). overridevirtual . Copies first pending event from event queue to Event_t structure and removes event from queue. ; Not all of the event fields are valid for each event type, except fType and fWindow. ; Reimplemented from TVirtualX.; Definition at line 1411 of file GX11Gui.cxx. ◆ OpenDisplay() [1/2]. Int_t TGX11::OpenDisplay ; (; const char * ; dpyName). overridevirtual . Open connection to display server (if such a thing exist on the current platform). ; On X11 this method returns on success the X display socket descriptor (> 0), 0 in case of batch mode and < 0 in case of failure (cannot connect to display dpyName). It also initializes the TGX11 class via Init(). Called from TGClient ctor. ; Reimplemented from TVirtualX.; Definition at line 809 of file GX11Gui.cxx. ◆ OpenDisplay() [2/2]. Int_t TGX11::OpenDisplay ; (; void * ; display). Open the display. Return -1 if the opening fails, 0 when ok. ; Definition at line 1091 of file TGX11.cxx. ◆ OpenPixmap(). Int_t TGX11::OpenPixmap ; (; UInt_t ; w, . UInt_t ; h . ). overridevirtual . Open a new pixmap.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGX11.html:94523,queue,queue,94523,doc/master/classTGX11.html,https://root.cern,https://root.cern/doc/master/classTGX11.html,2,['queue'],['queue']
Performance,"rtual . Move content to a new file. (NOT IMPLEMENTED for TChain) ; Reimplemented from TTree.; Definition at line 1233 of file TChain.cxx. ◆ InvalidateCurrentTree(). void TChain::InvalidateCurrentTree ; (; ). protected . Set the TTree to be reloaded as soon as possible. ; In particular this is needed when adding a Friend.; If the tree has clones, copy them into the chain clone list so we can change their branch addresses when necessary.; This is to support the syntax: TTree* clone = chain->GetTree()->CloneTree(0);; cloneTObject * clone(const char *newname) const overrideDefinition RooChi2Var.h:9. Definition at line 1252 of file TChain.cxx. ◆ IsA(). TClass * TChain::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Reimplemented in TProofChain.; Definition at line 173 of file TChain.h. ◆ LoadBaskets(). Int_t TChain::LoadBaskets ; (; Long64_t ; maxmemory). overridevirtual . Dummy function. ; It could be implemented and load all baskets of all trees in the chain. For the time being use TChain::Merge and TTree::LoadBasket on the resulting tree. ; Reimplemented from TTree.; Definition at line 1270 of file TChain.cxx. ◆ LoadTree(). Long64_t TChain::LoadTree ; (; Long64_t ; entry). overridevirtual . Find the tree which contains entry, and set it as the current tree. ; Returns the entry number in that tree.; The input argument entry is the entry serial number in the whole chain.; In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number is less than zero or too large for the chain.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or the TTree is missing from the file.; -5: Internal error, please report the circumstance when this happen as a ROOT issue.; -6: An error occurred within the notify callback. Calls fNotify->Notify() (if fNotify is not null) when starting the processing o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:80452,load,load,80452,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,1,['load'],['load']
Performance,"rtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 77 of file h1analysisTreeReader.h. ◆ Notify(). Bool_t h1analysisTreeReader::Notify ; (; ). overridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject. ◆ Process(). Bool_t h1analysisTreeReader::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return value is currently not used.; WARNING when a selector is used with a TChain, you must use the pointer to the current TTree to call GetEntry(entry). The entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use: fChain->GetTree()->GetEntry(entry). ; Reimplemented from TSelector. ◆ Reset(). void h1analysisTreeReader::Reset ; (; ). Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classh1analysisTreeReader.html:16191,load,loaded,16191,doc/master/classh1analysisTreeReader.html,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html,1,['load'],['loaded']
Performance,"rtual Bool_tTTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = 30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTTree::SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tSetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidSetHbookFile(THbookFile* file); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THbookTree.html:15892,cache,cachesize,15892,root/html528/THbookTree.html,https://root.cern,https://root.cern/root/html528/THbookTree.html,1,['cache'],['cachesize']
Performance,"rtual Bool_tTTree::SetAlias(const char* aliasName, const char* aliasFormula); virtual voidTTree::SetAutoFlush(Long64_t autof = 30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidTTree::SetBranchAddress(const char* bname, void** add, TBranch** ptr = 0); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tTTree::SetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidTTree::SetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidTTree::SetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidTTree::SetEntryList(TEntryList* list, Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidTTree::SetEventList(TEventList* list); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttributes()MENU ; virtual voidTAttLine::SetLineColor(Color_t lcolo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TNtuple.html:15414,cache,cachesize,15414,root/html528/TNtuple.html,https://root.cern,https://root.cern/root/html528/TNtuple.html,3,['cache'],['cachesize']
Performance,"rtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/PiecewiseInterpolation.html:1931,Cache,CacheModeRooAbsArg,1931,root/html602/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html602/PiecewiseInterpolation.html,4,['Cache'],['CacheModeRooAbsArg']
Performance,"rtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; virtual list<Double_t>*binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddition.html:2132,Cache,CacheModeRooAbsArg,2132,root/html602/RooAddition.html,https://root.cern,https://root.cern/root/html602/RooAddition.html,4,['Cache'],['CacheModeRooAbsArg']
Performance,"rtual StyleOption defaultPrintStyle (Option_t *opt) const;  ; virtual void printExtras (std::ostream &os) const;  Interface to print extras of object. ;  ; virtual void printStream (std::ostream &os, Int_t contents, StyleOption style, TString indent="""") const;  Print description of object on ostream, printing contents set by contents integer, which is interpreted as an OR of 'enum ContentsOptions' values and in the style given by 'enum StyleOption'. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Protected Types; enum  Message { ;   SendReal =0; , SendCat; , Calculate; , Retrieve; , ;   ReturnValue; , Terminate; , ConstOpt; , Verbose; , ;   LogEvalError; , ApplyNLLW2; , EnableOffset; , CalculateNoOffset. };  ; enum  State { Initialize; , Client; , Server; , Inline; };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  . Protected Member Functions; void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTracking=true) override;  Intercept call to optimize constant term in test statistics and forward it to object on server side. ;  ; void doApplyNLLW2 (bool flag);  ; double evaluate () const override;  Send message to server process to retrieve output value If error were logged use logEvalError() on remote side transfer those errors to the local eval error queue. ;  ; virtual double getCarry () const;  ; void initialize ();  Initialize the remote process and message passing pipes between current process and remote process. ;  ; void initVars ();  Initialize list of variables of front-end argument 'arg'. ;  ; void serverLoop ();  Server loop of remote processes. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached valu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:46946,optimiz,optimize,46946,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['optimiz'],['optimize']
Performance,"rtual T ROOT::Math::IGradientFunctionMultiDimTempl< T >::DoDerivativeWithPrevResult ; (; const T * ; x, . unsigned int ; icoord, . T * ; , . T * ; , . T * ;  . ); const. inlineprivatevirtual . In some cases, the derivative algorithm will use information from the previous step, these can be passed in with this overload. ; The previous_* arrays can also be used to return second derivative and step size so that these can be passed forward again as well at the call site, if necessary. ; Definition at line 231 of file IFunction.h. ◆ FdF(). template<class T > . virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::FdF ; (; const T * ; x, . T & ; f, . T * ; df . ); const. inlinevirtual . Optimized method to evaluate at the same time the function value and derivative at a point x. ; Often both value and derivatives are needed and it is often more efficient to compute them at the same time. Derived class should implement this method if performances play an important role and if it is faster to evaluate value and derivative at the same time ; Definition at line 202 of file IFunction.h. ◆ Gradient(). template<class T > . virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::Gradient ; (; const T * ; x, . T * ; grad . ); const. inlinevirtual . Evaluate all the vector of function derivatives (gradient) at a point x. ; Derived classes must re-implement it if more efficient than evaluating one at a time ; Definition at line 177 of file IFunction.h. ◆ GradientWithPrevResult(). template<class T > . virtual void ROOT::Math::IGradientFunctionMultiDimTempl< T >::GradientWithPrevResult ; (; const T * ; x, . T * ; grad, . T * ; previous_grad, . T * ; previous_g2, . T * ; previous_gstep . ); const. inlinevirtual . In some cases, the gradient algorithm will use information from the previous step, these can be passed in with this overload. ; The previous_* arrays can also be used to return second derivative and step size so that these can be passed forward again as well at t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IGradientFunctionMultiDimTempl.html:6512,perform,performances,6512,doc/master/classROOT_1_1Math_1_1IGradientFunctionMultiDimTempl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IGradientFunctionMultiDimTempl.html,1,['perform'],['performances']
Performance,"rtual UShort_t GetPidOffset () const =0;  ; ReAllocCharFun_t GetReAllocFunc () const;  Return the reallocation method currently used. ;  ; virtual UInt_t GetTRefExecId ()=0;  ; virtual Int_t GetVersionOwner () const =0;  ; virtual void IncrementLevel (TVirtualStreamerInfo *info)=0;  ; virtual void InitMap ()=0;  ; TClass * IsA () const override;  ; Bool_t IsReading () const;  ; Bool_t IsWriting () const;  ; Int_t Length () const;  ; virtual void MapObject (const TObject *obj, UInt_t offset=1)=0;  ; virtual void MapObject (const void *obj, const TClass *cl, UInt_t offset=1)=0;  ; virtual TVirtualArray * PeekDataCache () const;  Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual TVirtualArray * PopDataCache ();  Pop and Return the 'current' data cache area from the list of area to be used for temporarily store 'missing' data members. ;  ; virtual void PushDataCache (TVirtualArray *);  Push a new data cache area onto the list of area to be used for temporarily store 'missing' data members. ;  ; virtual Int_t ReadArray (Bool_t *&b)=0;  ; virtual Int_t ReadArray (Char_t *&c)=0;  ; virtual Int_t ReadArray (Double_t *&d)=0;  ; virtual Int_t ReadArray (Float_t *&f)=0;  ; virtual Int_t ReadArray (Int_t *&i)=0;  ; virtual Int_t ReadArray (Long64_t *&l)=0;  ; virtual Int_t ReadArray (Long_t *&l)=0;  ; virtual Int_t ReadArray (Short_t *&h)=0;  ; virtual Int_t ReadArray (UChar_t *&c)=0;  ; virtual Int_t ReadArray (UInt_t *&i)=0;  ; virtual Int_t ReadArray (ULong64_t *&l)=0;  ; virtual Int_t ReadArray (ULong_t *&l)=0;  ; virtual Int_t ReadArray (UShort_t *&h)=0;  ; virtual Int_t ReadArrayDouble32 (Double_t *&d, TStreamerElement *ele=nullptr)=0;  ; virtual Int_t ReadArrayFloat16 (Float_t *&f, TStreamerElement *ele=nullptr)=0;  ; virtual void ReadBool (Bool_t &b)=0;  ; virtual Int_t ReadBuf (void *buf, Int_t max)=0;  ; virtual void ReadChar (Char_t &c)=0;  ; virtual void ReadCharP (Char_t *c)=0;  ; virtua",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBuffer.html:4620,cache,cache,4620,doc/master/classTBuffer.html,https://root.cern,https://root.cern/doc/master/classTBuffer.html,1,['cache'],['cache']
Performance,"rtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TEvePlot3DGL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEvePlot3DGL.html:1871,cache,cached,1871,root/html602/TEvePlot3DGL.html,https://root.cern,https://root.cern/root/html602/TEvePlot3DGL.html,4,['cache'],['cached']
Performance,"rtual voidResetCache(); virtual voidTFile::ResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidTNetFile::Seek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tTFile::SetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidTFile::SetCacheRead(TFileCacheRead* cache, TObject* tree = 0, TFile::ECacheAction action = kDisconnect); virtual voidTFile::SetCacheWrite(TFileCacheWrite* cache); virtual voidTFile::SetCompressionAlgorithm(Int_t algorithm = 0); virtual voidTFile::SetCompressionLevel(Int_t level = 1); virtual voidTFile::SetCompressionSettings(Int_t settings = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidTFile::SetEND(Long64_t last); static voidTFile::SetFileBytesRead(Long64_t bytes = 0); static voidTFile::SetFileBytesWritten(Long64_t bytes = 0); static voidTFile::SetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidTFile::SetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tTFile::SetOnlyStaged(Bool_t onlystaged); static UInt_tTFile::SetOpenTimeout(UInt_t timeout); virtual voidTFile::SetOption(Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXNetFile.html:12934,cache,cache,12934,root/html534/TXNetFile.html,https://root.cern,https://root.cern/root/html534/TXNetFile.html,6,['cache'],['cache']
Performance,"rtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:15404,cache,cache,15404,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,2,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); Roo1DMomentMorphFunction(); Roo1DMomentMorphFunction(const Roo1DMomentMorphFunction& other, const char* name = 0); Roo1DMomentMorphFunction(const char* name, const char* title, RooAbsReal& _m, const RooArgList& varList, const TVectorD& mrefpoints, const Roo1DMomentMorphFunction::Setting& setting = Linear); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo1DMomentMorphFunction.html:22730,cache,cache,22730,root/html602/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html602/Roo1DMomentMorphFunction.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); Roo2DMomentMorphFunction(); Roo2DMomentMorphFunction(const Roo2DMomentMorphFunction& other, const char* name = 0); Roo2DMomentMorphFunction(const char* name, const char* title, RooAbsReal& _m1, RooAbsReal& _m2, const TMatrixD& mrefpoints, const Roo2DMomentMorphFunction::Setting& setting = Linear, const Bool_t& verbose = false); Roo2DMomentMorphFunction(const char* name, const char* title, RooAbsReal& _m1, RooAbsReal& _m2, const Int_t& nrows, const Double_t* dm1arr, const Double_t* dm2arr, const Double_t* dvalarr, const Roo2DMomentMorphFunction::Setting& setting = Linear, const Bool_t& verbose = false); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterato",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DMomentMorphFunction.html:22730,cache,cache,22730,root/html602/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html602/Roo2DMomentMorphFunction.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsCachedReal(); RooAbsCachedReal(const RooAbsCachedReal& other, const char* name = 0); RooAbsCachedReal(const char* name, const char* title, Int_t ipOrder = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedReal.html:23591,cache,cache,23591,root/html602/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsMoment(); RooAbsMoment(const RooAbsMoment& other, const char* name = 0); RooAbsMoment(const char* name, const char* title, RooAbsReal& func, RooRealVar& x, Int_t order = 1, Bool_t takeRoot = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsMoment.html:22915,cache,cache,22915,root/html602/RooAbsMoment.html,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsSelfCachedReal(); RooAbsSelfCachedReal(const RooAbsSelfCachedReal& other, const char* name = 0); RooAbsSelfCachedReal(const char* name, const char* title, Int_t ipOrder = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsSelfCachedReal.html:23586,cache,cache,23586,root/html602/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsSelfCachedReal.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAddition(); RooAddition(const RooAddition& other, const char* name = 0); RooAddition(const char* name, const char* title, const RooArgList& sumSet, Bool_t takeOwnerShip = kFALSE); RooAddition(const char* name, const char* title, const RooArgList& sumSet1, const RooArgList& sumSet2, Bool_t takeOwnerShip = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAddition.html:22891,cache,cache,22891,root/html602/RooAddition.html,https://root.cern,https://root.cern/root/html602/RooAddition.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction1Binding<double,double>(); RooCFunction1Binding<double,double>(const RooCFunction1Binding<double,double>& other, const char* name = 0); RooCFunction1Binding<double,double>(const char* name, const char* title, double(*)(double) _func, RooAbsReal& _x); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackH",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1Binding_double_double_.html:23301,cache,cache,23301,root/html602/RooCFunction1Binding_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1Binding_double_double_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction1Binding<double,int>(); RooCFunction1Binding<double,int>(const RooCFunction1Binding<double,int>& other, const char* name = 0); RooCFunction1Binding<double,int>(const char* name, const char* title, double(*)(int) _func, RooAbsReal& _x); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction1Binding_double_int_.html:23283,cache,cache,23283,root/html602/RooCFunction1Binding_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction1Binding_double_int_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction2Binding<double,double,double>(); RooCFunction2Binding<double,double,double>(const RooCFunction2Binding<double,double,double>& other, const char* name = 0); RooCFunction2Binding<double,double,double>(const char* name, const char* title, double(*)(double,double) _func, RooAbsReal& _x, RooAbsReal& _y); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_double_double_.html:23343,cache,cache,23343,root/html602/RooCFunction2Binding_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_double_double_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction2Binding<double,double,int>(); RooCFunction2Binding<double,double,int>(const RooCFunction2Binding<double,double,int>& other, const char* name = 0); RooCFunction2Binding<double,double,int>(const char* name, const char* title, double(*)(double,int) _func, RooAbsReal& _x, RooAbsReal& _y); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_double_int_.html:23325,cache,cache,23325,root/html602/RooCFunction2Binding_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_double_int_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction2Binding<double,int,double>(); RooCFunction2Binding<double,int,double>(const RooCFunction2Binding<double,int,double>& other, const char* name = 0); RooCFunction2Binding<double,int,double>(const char* name, const char* title, double(*)(int,double) _func, RooAbsReal& _x, RooAbsReal& _y); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_int_double_.html:23325,cache,cache,23325,root/html602/RooCFunction2Binding_double_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_int_double_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction2Binding<double,int,int>(); RooCFunction2Binding<double,int,int>(const RooCFunction2Binding<double,int,int>& other, const char* name = 0); RooCFunction2Binding<double,int,int>(const char* name, const char* title, double(*)(int,int) _func, RooAbsReal& _x, RooAbsReal& _y); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_int_int_.html:23307,cache,cache,23307,root/html602/RooCFunction2Binding_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_int_int_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction2Binding<double,unsigned int,double>(); RooCFunction2Binding<double,unsigned int,double>(const RooCFunction2Binding<double,unsigned int,double>& other, const char* name = 0); RooCFunction2Binding<double,unsigned int,double>(const char* name, const char* title, double(*)(unsigned int,double) _func, RooAbsReal& _x, RooAbsReal& _y); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_unsigned_int_double_.html:23379,cache,cache,23379,root/html602/RooCFunction2Binding_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_unsigned_int_double_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction3Binding<double,double,double,bool>(); RooCFunction3Binding<double,double,double,bool>(const RooCFunction3Binding<double,double,double,bool>& other, const char* name = 0); RooCFunction3Binding<double,double,double,bool>(const char* name, const char* title, double(*)(double,double,bool) _func, RooAbsReal& _x, RooAbsReal& _y, RooAbsReal& _z); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UI",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_double_double_bool_.html:23373,cache,cache,23373,root/html602/RooCFunction3Binding_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_double_double_bool_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction3Binding<double,double,double,double>(); RooCFunction3Binding<double,double,double,double>(const RooCFunction3Binding<double,double,double,double>& other, const char* name = 0); RooCFunction3Binding<double,double,double,double>(const char* name, const char* title, double(*)(double,double,double) _func, RooAbsReal& _x, RooAbsReal& _y, RooAbsReal& _z); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_double_double_double_.html:23385,cache,cache,23385,root/html602/RooCFunction3Binding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_double_double_double_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction3Binding<double,double,int,int>(); RooCFunction3Binding<double,double,int,int>(const RooCFunction3Binding<double,double,int,int>& other, const char* name = 0); RooCFunction3Binding<double,double,int,int>(const char* name, const char* title, double(*)(double,int,int) _func, RooAbsReal& _x, RooAbsReal& _y, RooAbsReal& _z); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_double_int_int_.html:23349,cache,cache,23349,root/html602/RooCFunction3Binding_double_double_int_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_double_int_int_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction3Binding<double,unsigned int,double,double>(); RooCFunction3Binding<double,unsigned int,double,double>(const RooCFunction3Binding<double,unsigned int,double,double>& other, const char* name = 0); RooCFunction3Binding<double,unsigned int,double,double>(const char* name, const char* title, double(*)(unsigned int,double,double) _func, RooAbsReal& _x, RooAbsReal& _y, RooAbsReal& _z); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html:23421,cache,cache,23421,root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_double_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction3Binding<double,unsigned int,double,unsigned int>(); RooCFunction3Binding<double,unsigned int,double,unsigned int>(const RooCFunction3Binding<double,unsigned int,double,unsigned int>& other, const char* name = 0); RooCFunction3Binding<double,unsigned int,double,unsigned int>(const char* name, const char* title, double(*)(unsigned int,double,unsigned int) _func, RooAbsReal& _x, RooAbsReal& _y, RooAbsReal& _z); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html:23457,cache,cache,23457,root/html602/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_double_unsigned_int_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction3Binding<double,unsigned int,unsigned int,double>(); RooCFunction3Binding<double,unsigned int,unsigned int,double>(const RooCFunction3Binding<double,unsigned int,unsigned int,double>& other, const char* name = 0); RooCFunction3Binding<double,unsigned int,unsigned int,double>(const char* name, const char* title, double(*)(unsigned int,unsigned int,double) _func, RooAbsReal& _x, RooAbsReal& _y, RooAbsReal& _z); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html:23457,cache,cache,23457,root/html602/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction3Binding_double_unsigned_int_unsigned_int_double_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction4Binding<double,double,double,double,bool>(); RooCFunction4Binding<double,double,double,double,bool>(const RooCFunction4Binding<double,double,double,double,bool>& other, const char* name = 0); RooCFunction4Binding<double,double,double,double,bool>(const char* name, const char* title, double(*)(double,double,double,bool) _func, RooAbsReal& _x, RooAbsReal& _y, RooAbsReal& _z, RooAbsReal& _w); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_bool_.html:23415,cache,cache,23415,root/html602/RooCFunction4Binding_double_double_double_double_bool_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_bool_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction4Binding<double,double,double,double,double>(); RooCFunction4Binding<double,double,double,double,double>(const RooCFunction4Binding<double,double,double,double,double>& other, const char* name = 0); RooCFunction4Binding<double,double,double,double,double>(const char* name, const char* title, double(*)(double,double,double,double) _func, RooAbsReal& _x, RooAbsReal& _y, RooAbsReal& _z, RooAbsReal& _w); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_double_.html:23427,cache,cache,23427,root/html602/RooCFunction4Binding_double_double_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_double_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCFunction4Binding<double,double,double,double,int>(); RooCFunction4Binding<double,double,double,double,int>(const RooCFunction4Binding<double,double,double,double,int>& other, const char* name = 0); RooCFunction4Binding<double,double,double,double,int>(const char* name, const char* title, double(*)(double,double,double,int) _func, RooAbsReal& _x, RooAbsReal& _y, RooAbsReal& _z, RooAbsReal& _w); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name,",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_int_.html:23409,cache,cache,23409,root/html602/RooCFunction4Binding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_int_.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooCachedReal(); RooCachedReal(const RooCachedReal& other, const char* name = 0); RooCachedReal(const char* name, const char* title, RooAbsReal& _func); RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:22951,cache,cache,22951,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooChangeTracker(); RooChangeTracker(const RooChangeTracker& other, const char* name = 0); RooChangeTracker(const char* name, const char* title, const RooArgSet& trackSet, Bool_t checkValues = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChangeTracker.html:23318,cache,cache,23318,root/html602/RooChangeTracker.html,https://root.cern,https://root.cern/root/html602/RooChangeTracker.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooConstVar(); RooConstVar(const RooConstVar& other, const char* name = 0); RooConstVar(const char* name, const char* title, Double_t value); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConstVar.html:22688,cache,cache,22688,root/html602/RooConstVar.html,https://root.cern,https://root.cern/root/html602/RooConstVar.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooConstraintSum(); RooConstraintSum(const RooConstraintSum& other, const char* name = 0); RooConstraintSum(const char* name, const char* title, const RooArgSet& constraintSet, const RooArgSet& paramSet); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConstraintSum.html:22991,cache,cache,22991,root/html602/RooConstraintSum.html,https://root.cern,https://root.cern/root/html602/RooConstraintSum.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooConvCoefVar(); RooConvCoefVar(const RooConvCoefVar& other, const char* name = 0); RooConvCoefVar(const char* name, const char* title, const RooAbsAnaConvPdf& input, Int_t coefIdx, const RooArgSet* varList = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConvCoefVar.html:22919,cache,cache,22919,root/html602/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html602/RooConvCoefVar.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooExtendedBinding(); RooExtendedBinding(const RooExtendedBinding& other, const char* name = 0); RooExtendedBinding(const char* name, const char* title, RooAbsPdf& _pdf); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsRea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendedBinding.html:22698,cache,cache,22698,root/html602/RooExtendedBinding.html,https://root.cern,https://root.cern/root/html602/RooExtendedBinding.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooFirstMoment(); RooFirstMoment(const RooFirstMoment& other, const char* name = 0); RooFirstMoment(const char* name, const char* title, RooAbsReal& func, RooRealVar& x); RooFirstMoment(const char* name, const char* title, RooAbsReal& func, RooRealVar& x, const RooArgSet& nset, Bool_t intNSet = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFirstMoment.html:22874,cache,cache,22874,root/html602/RooFirstMoment.html,https://root.cern,https://root.cern/root/html602/RooFirstMoment.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooFracRemainder(); RooFracRemainder(const RooFracRemainder& other, const char* name = 0); RooFracRemainder(const char* name, const char* title, const RooArgSet& sumSet); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsRea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFracRemainder.html:22924,cache,cache,22924,root/html602/RooFracRemainder.html,https://root.cern,https://root.cern/root/html602/RooFracRemainder.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooFunctor1DBinding(); RooFunctor1DBinding(const RooFunctor1DBinding& other, const char* name = 0); RooFunctor1DBinding(const char* name, const char* title, const ROOT::Math::IBaseFunctionOneDim& ftor, RooAbsReal& var); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctor1DBinding.html:23205,cache,cache,23205,root/html602/RooFunctor1DBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctor1DBinding.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooFunctorBinding(); RooFunctorBinding(const RooFunctorBinding& other, const char* name = 0); RooFunctorBinding(const char* name, const char* title, const ROOT::Math::IBaseFunctionMultiDim& ftor, const RooArgList& vars); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctorBinding.html:23193,cache,cache,23193,root/html602/RooFunctorBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctorBinding.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooGenProdProj(); RooGenProdProj(const RooGenProdProj& other, const char* name = 0); RooGenProdProj(const char* name, const char* title, const RooArgSet& _prodSet, const RooArgSet& _intSet, const RooArgSet& _normSet, const char* isetRangeName, const char* normRangeName = 0, Bool_t doFactorize = kTRUE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set);",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooGenProdProj.html:23070,cache,cache,23070,root/html602/RooGenProdProj.html,https://root.cern,https://root.cern/root/html602/RooGenProdProj.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooHistFunc(); RooHistFunc(const RooHistFunc& other, const char* name = 0); RooHistFunc(const char* name, const char* title, const RooArgSet& vars, const RooDataHist& dhist, Int_t intOrder = 0); RooHistFunc(const char* name, const char* title, const RooArgList& funcObs, const RooArgList& histObs, const RooDataHist& dhist, Int_t intOrder = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistFunc.html:22808,cache,cache,22808,root/html602/RooHistFunc.html,https://root.cern,https://root.cern/root/html602/RooHistFunc.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooLegendre(); RooLegendre(const RooLegendre& other, const char* name = 0); RooLegendre(const char* name, const char* title, RooAbsReal& ctheta, int l, int m = 0); RooLegendre(const char* name, const char* title, RooAbsReal& ctheta, int l1, int m1, int l2, int m2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTra",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLegendre.html:22604,cache,cache,22604,root/html602/RooLegendre.html,https://root.cern,https://root.cern/root/html602/RooLegendre.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooMoment(); RooMoment(const RooMoment& other, const char* name = 0); RooMoment(const char* name, const char* title, RooAbsReal& func, RooRealVar& x, Int_t order = 1, Bool_t central = kFALSE, Bool_t takeRoot = kFALSE); RooMoment(const char* name, const char* title, RooAbsReal& func, RooRealVar& x, const RooArgSet& nset, Int_t order = 1, Bool_t central = kFALSE, Bool_t takeRoot = kFALSE, Bool_t intNSet = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMoment.html:22839,cache,cache,22839,root/html602/RooMoment.html,https://root.cern,https://root.cern/root/html602/RooMoment.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooMultiBinomial(); RooMultiBinomial(const RooMultiBinomial& other, const char* name = 0); RooMultiBinomial(const char* name, const char* title, const RooArgList& effFuncList, const RooArgList& catList, Bool_t ignoreNonVisible); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiBinomial.html:23291,cache,cache,23291,root/html602/RooMultiBinomial.html,https://root.cern,https://root.cern/root/html602/RooMultiBinomial.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooNumCdf(const RooNumCdf& other, const char* name = 0); RooNumCdf(const char* name, const char* title, RooAbsPdf& _pdf, RooRealVar& _x, const char* binningName = ""cache""); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumCdf.html:23225,cache,cache,23225,root/html602/RooNumCdf.html,https://root.cern,https://root.cern/root/html602/RooNumCdf.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooNumRunningInt(const RooNumRunningInt& other, const char* name = 0); RooNumRunningInt(const char* name, const char* title, RooAbsReal& _func, RooRealVar& _x, const char* binningName = ""cache""); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumRunningInt.html:23431,cache,cache,23431,root/html602/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html602/RooNumRunningInt.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooParamHistFunc(); RooParamHistFunc(const RooParamHistFunc& other, const char* name = 0); RooParamHistFunc(const char* name, const char* title, RooDataHist& dh, Bool_t paramRelative = kTRUE); RooParamHistFunc(const char* name, const char* title, const RooAbsArg& x, RooDataHist& dh, Bool_t paramRelative = kTRUE); RooParamHistFunc(const char* name, const char* title, RooDataHist& dh, const RooParamHistFunc& paramSource, Bool_t paramRelative = kTRUE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParamHistFunc.html:22770,cache,cache,22770,root/html602/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html602/RooParamHistFunc.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooPolyVar(); RooPolyVar(const RooPolyVar& other, const char* name = 0); RooPolyVar(const char* name, const char* title, RooAbsReal& x); RooPolyVar(const char* name, const char* title, RooAbsReal& _x, const RooArgList& _coefList, Int_t lowestOrder = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPolyVar.html:22846,cache,cache,22846,root/html602/RooPolyVar.html,https://root.cern,https://root.cern/root/html602/RooPolyVar.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooProduct(); RooProduct(const RooProduct& other, const char* name = 0); RooProduct(const char* name, const char* title, const RooArgList& _prodSet); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t =",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProduct.html:22704,cache,cache,22704,root/html602/RooProduct.html,https://root.cern,https://root.cern/root/html602/RooProduct.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooPullVar(); RooPullVar(const RooPullVar& other, const char* name = 0); RooPullVar(const char* name, const char* title, RooRealVar& measurement, RooAbsReal& truth); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPullVar.html:22986,cache,cache,22986,root/html602/RooPullVar.html,https://root.cern,https://root.cern/root/html602/RooPullVar.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooRangeBoolean(); RooRangeBoolean(const RooRangeBoolean& other, const char* name = 0); RooRangeBoolean(const char* name, const char* title, RooAbsRealLValue& x, const char* rangeName); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRangeBoolean.html:22699,cache,cache,22699,root/html602/RooRangeBoolean.html,https://root.cern,https://root.cern/root/html602/RooRangeBoolean.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooRealMPFE(const RooRealMPFE& other, const char* name = 0); RooRealMPFE(const char* name, const char* title, RooAbsReal& arg, Bool_t calcInline = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealMPFE.html:23584,cache,cache,23584,root/html602/RooRealMPFE.html,https://root.cern,https://root.cern/root/html602/RooRealMPFE.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooRecursiveFraction(); RooRecursiveFraction(const RooRecursiveFraction& other, const char* name = 0); RooRecursiveFraction(const char* name, const char* title, const RooArgList& fracSet); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRecursiveFraction.html:22950,cache,cache,22950,root/html602/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html602/RooRecursiveFraction.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooSecondMoment(); RooSecondMoment(const RooSecondMoment& other, const char* name = 0); RooSecondMoment(const char* name, const char* title, RooAbsReal& func, RooRealVar& x, Bool_t central = kFALSE, Bool_t takeRoot = kFALSE); RooSecondMoment(const char* name, const char* title, RooAbsReal& func, RooRealVar& x, const RooArgSet& nset, Bool_t central = kFALSE, Bool_t takeRoot = kFALSE, Bool_t intNSet = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Te",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSecondMoment.html:22881,cache,cache,22881,root/html602/RooSecondMoment.html,https://root.cern,https://root.cern/root/html602/RooSecondMoment.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooSpHarmonic(); RooSpHarmonic(const RooSpHarmonic& other, const char* name = 0); RooSpHarmonic(const char* name, const char* title, RooAbsReal& ctheta, RooAbsReal& phi, int l, int m); RooSpHarmonic(const char* name, const char* title, RooAbsReal& ctheta, RooAbsReal& phi, int l1, int m1, int l2, int m2); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooSpHarmonic.html:23771,cache,cache,23771,root/html602/RooSpHarmonic.html,https://root.cern,https://root.cern/root/html602/RooSpHarmonic.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooStepFunction(); RooStepFunction(const RooStepFunction& other, const char* name = 0); RooStepFunction(const char* name, const char* title, RooAbsReal& x, const RooArgList& coefList, const RooArgList& limits, Bool_t interpolate = kFALSE); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); stati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStepFunction.html:23181,cache,cache,23181,root/html602/RooStepFunction.html,https://root.cern,https://root.cern/root/html602/RooStepFunction.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooTFnBinding(); RooTFnBinding(const RooTFnBinding& other, const char* name = 0); RooTFnBinding(const char* name, const char* title, TF1* func, const RooArgList& list); RooTFnBinding(const char* name, const char* title, TF1* func, const RooArgList& list, const RooArgList& plist); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTFnBinding.html:22653,cache,cache,22653,root/html602/RooTFnBinding.html,https://root.cern,https://root.cern/root/html602/RooTFnBinding.html,4,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/PiecewiseInterpolation.html:21717,cache,cache,21717,root/html528/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html528/PiecewiseInterpolation.html,40,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddition.html:21470,cache,cache,21470,root/html526/RooAddition.html,https://root.cern,https://root.cern/root/html526/RooAddition.html,35,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooHistFunc.html:21428,cache,cache,21428,root/html528/RooHistFunc.html,https://root.cern,https://root.cern/root/html528/RooHistFunc.html,1,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::set",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooHistFunc.html:21334,cache,cache,21334,root/html526/RooHistFunc.html,https://root.cern,https://root.cern/root/html526/RooHistFunc.html,1,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedReal.html:21639,cache,cache,21639,root/html526/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedReal.html,6,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:21246,cache,cache,21246,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,2,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedReal.html:21764,cache,cache,21764,root/html528/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:21670,cache,cache,21670,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/Roo1DMomentMorphFunction.html:21762,cache,cache,21762,root/html532/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html532/Roo1DMomentMorphFunction.html,53,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidsetAllInterpCodes(int code); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooStats__HistFactory__FlexibleInterpVar.html:22189,cache,cache,22189,root/html532/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html532/RooStats__HistFactory__FlexibleInterpVar.html,2,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ParamHistFunc.html:22391,cache,cache,22391,root/html532/ParamHistFunc.html,https://root.cern,https://root.cern/root/html532/ParamHistFunc.html,9,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAddition.html:22273,cache,cache,22273,root/html532/RooAddition.html,https://root.cern,https://root.cern/root/html532/RooAddition.html,1,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooHistFunc.html:22183,cache,cache,22183,root/html532/RooHistFunc.html,https://root.cern,https://root.cern/root/html532/RooHistFunc.html,2,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo1DMomentMorphFunction.html:23048,cache,cache,23048,root/html534/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html534/Roo1DMomentMorphFunction.html,94,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static void",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddition.html:23245,cache,cache,23245,root/html534/RooAddition.html,https://root.cern,https://root.cern/root/html534/RooAddition.html,2,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:23189,cache,cache,23189,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,2,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetConstant(bool constant); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:23480,cache,cache,23480,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,6,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:22892,cache,cache,22892,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,2,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidsetActual(Int_t ibin, Double_t newVal); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooParamHistFunc.html:23250,cache,cache,23250,root/html534/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html534/RooParamHistFunc.html,2,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidsetAllInterpCodes(int code); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); Bool_tsetBinIntegrator(RooArgSet& allVars); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")ME",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/PiecewiseInterpolation.html:22166,cache,cache,22166,root/html532/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html532/PiecewiseInterpolation.html,1,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidsetAllInterpCodes(int code); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); Bool_tsetBinIntegrator(RooArgSet& allVars); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/PiecewiseInterpolation.html:23161,cache,cache,23161,root/html534/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html534/PiecewiseInterpolation.html,6,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidsetAllInterpCodes(int code); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStats__HistFactory__FlexibleInterpVar.html:23710,cache,cache,23710,root/html534/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html534/RooStats__HistFactory__FlexibleInterpVar.html,6,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsRea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/PiecewiseInterpolation.html:21773,cache,cache,21773,root/html530/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html530/PiecewiseInterpolation.html,39,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tsetData(RooAbsData& data, Bool_t cloneData = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAddition.html:21919,cache,cache,21919,root/html530/RooAddition.html,https://root.cern,https://root.cern/root/html530/RooAddition.html,1,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOn",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooHistFunc.html:21821,cache,cache,21821,root/html530/RooHistFunc.html,https://root.cern,https://root.cern/root/html530/RooHistFunc.html,1,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidsetAllInterpCodes(int code); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStats__HistFactory__FlexibleInterpVar.html:22106,cache,cache,22106,root/html530/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html530/RooStats__HistFactory__FlexibleInterpVar.html,1,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDraw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsSelfCachedReal.html:22209,cache,cache,22209,root/html532/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsSelfCachedReal.html,5,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCachedReal.html:21816,cache,cache,21816,root/html532/RooCachedReal.html,https://root.cern,https://root.cern/root/html532/RooCachedReal.html,1,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsSelfCachedReal.html:23604,cache,cache,23604,root/html534/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsSelfCachedReal.html,6,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCacheSource(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:23233,cache,cache,23233,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,2,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsSelfCachedReal.html:22126,cache,cache,22126,root/html530/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html530/RooAbsSelfCachedReal.html,3,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tRooAbsCachedReal::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCdfBoundaries(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCachedReal.html:21733,cache,cache,21733,root/html530/RooCachedReal.html,https://root.cern,https://root.cern/root/html530/RooCachedReal.html,1,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(vo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedReal.html:22599,cache,cache,22599,root/html532/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Optio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCachedReal.html:23617,cache,cache,23617,root/html534/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html534/RooAbsCachedReal.html,2,['cache'],['cache']
Performance,"rtual voidRooAbsArg::printTitle(ostream& os) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsReal::printValue(ostream& os) const; virtual Int_tTObject::Read(const char* name); virtual Bool_tRooAbsReal::readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDto",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedReal.html:22157,cache,cache,22157,root/html530/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,"rtual voidRooAbsReal::attachToTree(TTree& t, Int_t bufSize = 32000); virtual const char*RooNumRunningInt::binningName() const; TStringRooAbsCachedReal::cacheNameSuffix(const RooArgSet& nset) const; RooFitResult*RooAbsReal::chi2FitDriver(RooAbsReal& fcn, RooLinkedList& cmdList); TStringRooAbsArg::cleanBranchName() const; voidRooAbsCachedReal::clearCacheObject(RooAbsCachedReal::FuncCacheElem& cache) const; virtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); virtual RooAbsCachedReal::FuncCacheElem*RooNumRunningInt::createCache(const RooArgSet* nset) const; RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; voidRooAbsCachedReal::disableCache(Bool_t flag); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tRooNumRunningInt::evaluate() const; virtual voidfillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); RooAbsCachedReal::FuncCacheElem*RooAbsCachedReal::getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual const char*RooNumRunningInt::inputBaseName() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumCdf.html:26120,cache,cacheFunc,26120,root/html526/RooNumCdf.html,https://root.cern,https://root.cern/root/html526/RooNumCdf.html,3,['cache'],['cacheFunc']
Performance,"rtual voidRooAbsReal::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDirty = kTRUE); RooAbsReal*RooAbsReal::createIntObj(const RooArgSet& iset, const RooArgSet* nset, const RooNumIntConfig* cfg, const char* rangeName) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Double_tevaluate() const; virtual voidRooAbsReal::fillTreeBranch(TTree& t); voidRooAbsReal::findInnerMostIntegration(const RooArgSet& allObs, RooArgSet& innerObs, const char* rangeName) const; static Bool_tRooAbsArg::flipAClean(); virtual RooAbsGenContext*RooAbsPdf::genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; RooDataSet*RooAbsPdf::generate(RooAbsGenContext& context, const RooArgSet& whatVars, const RooDataSet* prototype, Int_t nEvents, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE) const; RooMomentMorph::CacheElem*getCache(const RooArgSet* nset) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); intidxmax(const double& m) const; intidxmin(const double& m) const; Int_tij(const Int_t& i, const Int_t& j) const; static Bool_tRooAbsArg::inhibitDirty(); voidinitialize(); TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVar",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooMomentMorph.html:32127,Cache,CacheElem,32127,root/html532/RooMomentMorph.html,https://root.cern,https://root.cern/root/html532/RooMomentMorph.html,1,['Cache'],['CacheElem']
Performance,"rtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidloadValues(const Double_t[] xvector, Bool_t clipInvalid = kFALSE) const. Data Members; protected:. Bool_t_clipInvalidIf true, invalid x values are clipped into their valid range; UInt_tRooAbsFunc::_dimensionNumber of observables; const RooAbsReal*_funcPointer to input function; const RooAbsReal*_modelPointer to input resolution model; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nsetNormalization set to be used for function evaluations; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**_varsArray of pointers to variables; Bool_t_xvecValidIf true _xvec defines a valid point. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConvIntegrandBinding(const RooAbsReal& func, const RooAbsReal& model, RooAbsReal& x, RooAbsReal& xprime, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE); Constructor where func and model. 'func' = func(xprime); 'model' = model(xprime). and. ~RooConvIntegrandBinding(); Destructor. void loadValues(const Double_t[] xvector, Bool_t clipInvalid = kFALSE) const; Load external input values. Double_t operator()(const Double_t[] xvector) const; Evaluate self at given parameter values. Double_t getMinLimit(UInt_t dimension) const; Retrieve lower limit of i-th observable. Double_t getMaxLimit(UInt_t dimension) const; Retrieve upper limit of i-th observable. RooConvIntegrandBinding(const RooAbsReal& func, const RooAbsReal& model, RooAbsReal& x, RooAbsReal& xprime, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE). void setNormalizationSet(const RooArgSet* nset); Use the supplied nset as normalization set for calls to func and model. » Last changed: Tue Jun 30 14:32:20 2015 » Last generated: 2015-06-30 14:32; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConvIntegrandBinding.html:2783,load,loadValues,2783,root/html602/RooConvIntegrandBinding.html,https://root.cern,https://root.cern/root/html602/RooConvIntegrandBinding.html,3,"['Load', 'load']","['Load', 'loadValues']"
Performance,"rtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetCallProfiling(Bool_t flag, Int_t nbinX = 40, Int_t nbinCall = 40, Int_t nCallHigh = 1000); voidsetCallWarning(Int_t threshold = 2000); voidsetConvolutionWindow(RooAbsReal& centerParam, RooAbsReal& widthParam, Double_t widthScaleFactor = 1); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsPdf::setTraceCounter(Int_t value, Bool_t allNodes = kFALSE); voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniq",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:29259,cache,cache,29259,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,1,['cache'],['cache']
Performance,"rtual voidwriteToStream(ostream& os, Bool_t compact) const. protected:. virtual voidRooAbsString::attachToTree(TTree& t, Int_t bufSize = 32000); TStringRooAbsArg::cleanBranchName() const; virtual voidRooAbsString::copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual TStringRooAbsString::evaluate() const; virtual voidRooAbsString::fillTreeBranch(TTree& t); static Bool_tRooAbsArg::flipAClean(); virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); static Bool_tRooAbsArg::inhibitDirty(); virtual Bool_tRooAbsString::isValid() const; virtual Bool_tRooAbsString::isValidString(const char*, Bool_t printError = kFALSE) const; voidTObject::MakeZombie(); Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsString::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsString::syncCache(const RooArgSet* nset = 0); const char*RooAbsString::traceEval() const; virtual Bool_tRooAbsString::traceEvalHook(const char* value) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActiv",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooStringVar.html:15686,optimiz,optimizeDirtyHook,15686,root/html526/RooStringVar.html,https://root.cern,https://root.cern/root/html526/RooStringVar.html,3,['optimiz'],['optimizeDirtyHook']
Performance,"rtualPadEditor. Abstract base class used by ROOT graphics editor. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualPadEditor(); virtual voidBuild(); static TClass*Class(); virtual voidDeleteEditors(); virtual voidDrawLine(Double_t, Double_t, Double_t, Double_t); virtual voidDrawLineNDC(Double_t, Double_t, Double_t, Double_t); virtual voidDrawText(Double_t, Double_t, const char*); virtual voidDrawTextNDC(Double_t, Double_t, const char*); virtual voidFillAttributes(Int_t, Int_t); virtual TCanvas*GetCanvas() const; static const char*GetEditorName(); static TVirtualPadEditor*GetPadEditor(Bool_t load = kTRUE); virtual voidHide(); static voidHideEditor(); virtual TClass*IsA() const; virtual Bool_tIsGlobal() const; virtual voidLineAttributes(Int_t, Int_t, Int_t); static TVirtualPadEditor*LoadEditor(); virtual voidMarkerAttributes(Int_t, Int_t, Float_t); TVirtualPadEditor&operator=(const TVirtualPadEditor&); virtual voidSetGlobal(Bool_t); static voidSetPadEditorName(const char* name); virtual voidShow(); static voidShowEditor(); virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); static voidTerminate(); virtual voidTextAttributes(Int_t, Float_t, Int_t, Int_t, Float_t); TVirtualPadEditor(); TVirtualPadEditor(const TVirtualPadEditor&); static voidUpdateFillAttributes(Int_t col, Int_t sty); static voidUpdateLineAttributes(Int_t col, Int_t sty, Int_t width); static voidUpdateMarkerAttributes(Int_t col, Int_t sty, Float_t msiz); static voidUpdateTextAttributes(Int_t align, Float_t angle, Int_t col, Int_t font, Float_t tsize). Data Members; protected:. static TStringfgEditorNamename of the default pad editor ""Ged""; static TVirtualPadEditor*fgPadEditorsingleton editor dialog. Class Charts. Inheritance Chart:. TVirtualPadEditor. ←. TGedEditor; ←. TEveGedEdi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualPadEditor.html:1056,load,load,1056,root/html602/TVirtualPadEditor.html,https://root.cern,https://root.cern/root/html602/TVirtualPadEditor.html,6,"['Load', 'load']","['LoadEditor', 'load']"
Performance,"rtual~RooAbsString(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname = 0) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:1666,Cache,CacheModeRooAbsArg,1666,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"rtual~RooMappedCategory(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMappedCategory.html:1357,Cache,CacheModeRooAbsArg,1357,root/html602/RooMappedCategory.html,https://root.cern,https://root.cern/root/html602/RooMappedCategory.html,2,['Cache'],['CacheModeRooAbsArg']
Performance,"rtual~RooStringVar(); voidTObject::AbstractMethod(const char* method) const; Bool_tRooAbsArg::addOwnedComponents(const RooArgSet& comps); voidRooAbsArg::addParameters(RooArgSet& params, const RooArgSet* nset = 0, Bool_t stripDisconnected = kTRUE) const; voidRooAbsArg::addServer(RooAbsArg& server, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); voidRooAbsArg::addServerList(RooAbsCollection& serverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual voidTObject::AppendPad(Option_t* option = """"); voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); virtual voidTNamed::Copy(TObject& named) const; static UInt_tRooAbsArg::crc32(const char* ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStringVar.html:1561,Cache,CacheModeRooAbsArg,1561,root/html534/RooStringVar.html,https://root.cern,https://root.cern/root/html534/RooStringVar.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"rty state changes; static Int_t_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooAbsPdf(); Default constructor. RooAbsPdf(const char* name, const char* title = 0); Constructor with name and title only. RooAbsPdf(const char* name, const char* title, Double_t minVal, Double_t maxVal); Constructor with name, title, and plot range. RooAbsPdf(const RooAbsPdf& other, const char* name = 0); Copy constructor. ~RooAbsPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Return current value, normalizated by integrating over; the observables in 'nset'. If 'nset' is 0, the unnormalized value.; is returned. All elements of 'nset' must be lvalues. Unnormalized values are not cached; Doing so would be complicated as _norm->getVal() could; spoil the cache and interfere with returning the cached; return value. Since unnormalized calls are typically; done in integration calls, there is no performance hit. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* set = 0) const; Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optional",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsPdf.html:48679,perform,performance,48679,root/html602/RooAbsPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsPdf.html,4,['perform'],['performance']
Performance,"rty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; voidSummary() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo2DMomentMorphFunction.html:26718,cache,cache,26718,root/html534/Roo2DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html534/Roo2DMomentMorphFunction.html,2,['cache'],['cache']
Performance,"rty(BaseClassInfo_t *bcinfo) const finalDefinition TCling.cxx:8529; TCling::CallFunc_SetFuncvoid CallFunc_SetFunc(CallFunc_t *func, ClassInfo_t *info, const char *method, const char *params, Longptr_t *Offset) const finalDefinition TCling.cxx:8038; TCling::GetUsingNamespacesstd::vector< std::string > GetUsingNamespaces(ClassInfo_t *cl) const finalGet the scopes representing using declarations of namespace.Definition TCling.cxx:4478; TCling::ClassInfo_FileNameconst char * ClassInfo_FileName(ClassInfo_t *info) const finalDefinition TCling.cxx:8416; TCling::FuncTempInfo_Titlevoid FuncTempInfo_Title(FuncTempInfo_t *, TString &name) const finalReturn the comments associates with this function template.Definition TCling.cxx:8970; TCling::ClassInfo_TmpltNameconst char * ClassInfo_TmpltName(ClassInfo_t *info) const finalDefinition TCling.cxx:8450; TCling::SaveContextvoid SaveContext() finalSave the current Cling state.Definition TCling.cxx:3859; TCling::LoadPCMImplvoid LoadPCMImpl(TFile &pcmFile)Tries to load a PCM from TFile; returns true on success.Definition TCling.cxx:1696; TCling::IsAutoLoadNamespaceCandidateBool_t IsAutoLoadNamespaceCandidate(const clang::NamespaceDecl *nsDecl)Definition TCling.cxx:6627; TCling::ResetGlobalsvoid ResetGlobals() finalReset in Cling the list of global variables to the state saved by the last call to TCling::SaveGlobal...Definition TCling.cxx:3740; TCling::CodeCompletevoid CodeComplete(const std::string &, size_t &, std::vector< std::string > &) finalThe call to Cling's tab complition.Definition TCling.cxx:7670; TCling::ResetGlobalVarvoid ResetGlobalVar(void *obj) finalReset the Cling 'user' global objects/variables state to the state saved by the last call to TCling::...Definition TCling.cxx:3754; TCling::MapCppNameconst char * MapCppName(const char *) const finalInterface to cling function.Definition TCling.cxx:7523; TCling::CalcLongptr_t Calc(const char *line, EErrorCode *error=nullptr) finalDirectly execute an executable statement (e.g",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:452844,load,load,452844,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,2,['load'],['load']
Performance,"rtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.d.f being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedPdf.html:46470,cache,cached,46470,root/html602/RooCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooCachedPdf.html,4,['cache'],['cached']
Performance,"rtype is used, the first seen as priority. For example with:; #pragma link C++ ioctortype UserClass1;; #pragma link C++ ioctortype UserClass2;; We look for the first existing public constructor in the following order:; MyClass(UserClass1*);; MyClass(UserClass2*);; MyClass(TRootIOCtor*);; MyClass(); // Or a constructor with all its arguments defaulted.; 15.4 rootcling: The Cling Dictionary Generator; A way in which dictionaries can be generated is via the rootcling utility. This tool generates takes as input a set of headers and generates in output the dictionary C++ code and a pcm file. This latter file is fundamental for the correct functioning of the dictionary at runtime. It should be located in the directory where the shared library is installed in which the compiled dictionary resides.; NOTA BENE: the dictionaries that will be used within the same project must have unique names. In other words, compiled object files relative to dictionary source files cannot reside in the same library or in two libraries loaded by the same application if the original source files have the same name. This loose limitation is imposed by the registration mechanism ROOT has in place to keep track of dynamically loaded libraries.; In the following example, we walk through the steps necessary to generate a dictionary, I/O, and inspect member functions. Let’s start with a TEvent class, which contains a collection of TTracks.; The TEvent.h header is:; #ifndef __TEvent__; #define __TEvent__; #include ""TObject.h""; #include ""TCollection.h"". class TTrack;. class TEvent : public TObject {; private:; Int_t fId; // event sequential id; Float_t fTotalMom; // total momentum; TCollection *fTracks; // collection of tracks; public:; TEvent() { fId = 0; fTotalMom = 0; fTracks = nullptr; }; TEvent(Int_t id);; ~TEvent();; void AddTrack(TTrack *t);; Int_t GetId() const { return fId; }; Int_t GetNoTracks() const;; void Print(Option_t *opt="""");; Float_t TotalMomentum();. ClassDef(TEvent,1); //Simple eve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:817754,load,loaded,817754,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loaded']
Performance,"ructor ; (; Bool_t ; testio = kFALSE); const. Return true if we have access to a constructor usable for I/O. ; This is typically the default constructor but can also be a constructor specifically marked for I/O (for example a constructor taking a TRootIOCtor* as an argument). In other words, if this routine returns true, TClass::New is guarantee to succeed. To know if the class described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7393 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrapping procedure initiated during the loading of a library. ; Definition at line 3906 of file TClass.cxx. ◆ HasDictionarySelection(). Bool_t TClass::HasDictionarySelection ; (; const char * ; clname). static . Check whether a class has a dictionary or ROOT can load one. ; This is equivalent to ask HasDictionary() or whether a library is known where it can be loaded from, or whether a Dictionary function is available because the class's dictionary library was already loaded. ; Definition at line 3917 of file TClass.cxx. ◆ HasInterpreterInfo(). Bool_t TClass::HasInterpreterInfo ; (; ); const. inline . Definition at line 410 of file TClass.h. ◆ HasInterpreterInfoInMemory(). Bool_t TClass::HasInterpreterInfoInMemory ; (; ); const. inline . Definition at line 409 of file TClass.h. ◆ HasLocalHashMember(). Bool_t TClass::HasLocalHashMember ; (; ); const. Returns true if this class has an definition and/or overload of the member function Hash. ; For example to test if the class overload TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:95054,load,loading,95054,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['loading']
Performance,"ructor ; (; Bool_t ; testio = kFALSE); const. Return true if we have access to a constructor usable for I/O. ; This is typically the default constructor but can also be a constructor specifically marked for I/O (for example a constructor taking a TRootIOCtor* as an argument). In other words, if this routine returns true, TClass::New is guarantee to succeed. To know if the class described by this TClass has a default constructor (public or not), use cl->GetProperty() & kClassHasDefaultCtor; kClassHasDefaultCtor@ kClassHasDefaultCtorDefinition TDictionary.h:140; To know if the class described by this TClass has a public default constructor use: gInterpreter->ClassInfo_HasDefaultConstructor(aClass->GetClassInfo());; gInterpreter#define gInterpreterDefinition TInterpreter.h:573. Definition at line 7460 of file TClass.cxx. ◆ HasDictionary(). Bool_t TClass::HasDictionary ; (; ); const. Check whether a class has a dictionary or not. ; This is equivalent to ask if a class is coming from a bootstrapping procedure initiated during the loading of a library. ; Definition at line 3973 of file TClass.cxx. ◆ HasDictionarySelection(). Bool_t TClass::HasDictionarySelection ; (; const char * ; clname). static . Check whether a class has a dictionary or ROOT can load one. ; This is equivalent to ask HasDictionary() or whether a library is known where it can be loaded from, or whether a Dictionary function is available because the class's dictionary library was already loaded. ; Definition at line 3984 of file TClass.cxx. ◆ HasInterpreterInfo(). Bool_t TClass::HasInterpreterInfo ; (; ); const. inline . Definition at line 410 of file TClass.h. ◆ HasInterpreterInfoInMemory(). Bool_t TClass::HasInterpreterInfoInMemory ; (; ); const. inline . Definition at line 409 of file TClass.h. ◆ HasLocalHashMember(). Bool_t TClass::HasLocalHashMember ; (; ); const. Returns true if this class has an definition and/or overload of the member function Hash. ; For example to test if the class overload TObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:95055,load,loading,95055,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['loading']
Performance,"ructor ;  ;  ~SVWorkingSet ();  destructor ;  ; Bool_t ExamineExample (SVEvent *);  ; Bool_t ExamineExampleReg (SVEvent *);  ; Float_t GetBpar ();  ; std::vector< TMVA::SVEvent * > * GetSupportVectors ();  ; Bool_t IsDiffSignificant (Float_t, Float_t, Float_t);  ; void SetIPythonInteractive (bool *ExitFromTraining, UInt_t *fIPyCurrentIter_);  ; Bool_t TakeStep (SVEvent *, SVEvent *);  ; Bool_t TakeStepReg (SVEvent *, SVEvent *);  ; Bool_t Terminated ();  ; void Train (UInt_t nIter=1000);  train the SVM ;  ; void TrainReg ();  . Private Member Functions; void SetIndex (TMVA::SVEvent *);  . Private Attributes; Float_t fB_low;  documentation ;  ; Float_t fB_up;  documentation ;  ; Bool_t fdoRegression;  TODO temporary, find nicer solution. ;  ; bool * fExitFromTraining = nullptr;  ; std::vector< TMVA::SVEvent * > * fInputData;  input events ;  ; UInt_t * fIPyCurrentIter = nullptr;  ; SVKernelFunction * fKFunction;  kernel function ;  ; SVKernelMatrix * fKMatrix;  kernel matrix ;  ; MsgLogger * fLogger;  ! message logger ;  ; std::vector< TMVA::SVEvent * > * fSupVec;  output events - support vectors ;  ; SVEvent * fTEventLow;  last optimized event ;  ; SVEvent * fTEventUp;  last optimized event ;  ; Float_t fTolerance;  documentation ;  . #include <TMVA/SVWorkingSet.h>; Constructor & Destructor Documentation. ◆ SVWorkingSet() [1/2]. TMVA::SVWorkingSet::SVWorkingSet ; (; ). constructor ; Definition at line 50 of file SVWorkingSet.cxx. ◆ SVWorkingSet() [2/2]. TMVA::SVWorkingSet::SVWorkingSet ; (; std::vector< TMVA::SVEvent * > * ; inputVectors, . SVKernelFunction * ; kernelFunction, . Float_t ; tol, . Bool_t ; doreg . ). constructor ; Definition at line 68 of file SVWorkingSet.cxx. ◆ ~SVWorkingSet(). TMVA::SVWorkingSet::~SVWorkingSet ; (; ). destructor ; Definition at line 120 of file SVWorkingSet.cxx. Member Function Documentation. ◆ ExamineExample(). Bool_t TMVA::SVWorkingSet::ExamineExample ; (; TMVA::SVEvent * ; jevt). Definition at line 128 of file SVWorkingSet.cxx. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1SVWorkingSet.html:1679,optimiz,optimized,1679,doc/master/classTMVA_1_1SVWorkingSet.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1SVWorkingSet.html,2,['optimiz'],['optimized']
Performance,"ructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; virtual RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const =0;  ; virtual RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const =0;  ; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; virtual PdfCacheElem * createCache (const RooArgSet *nset) const;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; virtual void fillCacheObject (PdfCacheElem &cache) const =0;  ; PdfCacheElem * getCache (const RooArgSet *nset, bool recalculate=true) const;  Retrieve cache object associated with given choice of observables. ;  ; virtual TString histNameSuffix () const;  ; virtual const char * inputBaseName () const =0;  ; virtual const char * payloadUniqueSuffix () const;  ; virtual RooAbsArg & pdfObservable (RooAbsArg &histObservable) const;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCachedPdf.html:62879,cache,cacheNameSuffix,62879,doc/master/classRooAbsCachedPdf.html,https://root.cern,https://root.cern/doc/master/classRooAbsCachedPdf.html,3,['cache'],"['cache', 'cacheNameSuffix']"
Performance,"ructors then this is a generic one protected. ; Parameters. namethe name algorithm. ; dataloaderTMVA::DataLoader object with the data. ; fileoptional file to save the results. ; optionsextra options for the algorithm. . Definition at line 40 of file Envelope.cxx. ◆ ~Envelope(). Envelope::~Envelope ; (; ). Default destructor. ; Definition at line 62 of file Envelope.cxx. Member Function Documentation. ◆ BookMethod() [1/2]. void TMVA::Envelope::BookMethod ; (; TString ; methodName, . TString ; methodTitle, . TString ; options = """" . ). virtual . Method to book the machine learning method to perform the algorithm. ; Parameters. methodNameString with the name of the mva method ; methodTitleString with the method title. ; optionsString with the options for the method. . Definition at line 163 of file Envelope.cxx. ◆ BookMethod() [2/2]. void TMVA::Envelope::BookMethod ; (; Types::EMVA ; method, . TString ; methodTitle, . TString ; options = """" . ). virtual . Method to book the machine learning method to perform the algorithm. ; Parameters. methodenum TMVA::Types::EMVA with the type of the mva method ; methodTitleString with the method title. ; optionsString with the options for the method. . Definition at line 152 of file Envelope.cxx. ◆ Class(). static TClass * TMVA::Envelope::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TMVA::Envelope::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TMVA::Envelope::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 123 of file Envelope.h. ◆ DeclFileName(). static const char * TMVA::Envelope::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 123 of file Envelope.h. ◆ Evaluate(). virtual void TMVA::Envelope::Evaluate ; (; ). pure virtual . Virtual method to be implemented with your algorithm. ; Implemented in TMVA::Experimental:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1Envelope.html:18388,perform,perform,18388,doc/master/classTMVA_1_1Envelope.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1Envelope.html,1,['perform'],['perform']
Performance,"ructure).; On the other hand, any volume is a small world by itself - what we need to do is to take it out and to ignore all the rest since it is a self-contained object. In fact, the modeller can act like this, considering a given volume as temporary MARS, but we will describe this feature later on. Let us focus on the biggest pack - it is mandatory to define one. Consider the simplest geometry that is made of a single box. Here is an example on how to build it:. Example 1: Creating the World; We first need to load the geometry library. This is not needed if one does ""make map"" in root folder.; root[] gSystem->Load(""libGeom"");; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TSystem::Loadvirtual int Load(const char *module, const char *entry="""", Bool_t system=kFALSE)Load a shared library.Definition TSystem.cxx:1857; Second, we have to create an instance of the geometry manager class. This takes care of all the modeller components, performing several tasks to insure geometry validity and containing the user interface for building and interacting with the geometry. After its creation, the geometry manager class can be accessed with the global gGeoManager:; root[] new TGeoManager(""world"", ""the simplest geometry"");; TGeoManagerThe manager class for any TGeo geometry.Definition TGeoManager.h:44; We want to create a single volume in our geometry, but since any volume needs to have an associated medium, we will create a dummy one. You can safely ignore the following lines for the time being, since materials and media will be explained in detail later on.; root[] TGeoMaterial *mat = new TGeoMaterial(""Vacuum"",0,0,0);; root[] TGeoMedium *med = new TGeoMedium(""Vacuum"",1,mat);; TGeoMaterialBase class describing materials.Definition TGeoMaterial.h:34; TGeoMediumMedia are used to store properties related to tracking and which are useful only when using geometry ...Definition TGeoMedium.h:23; We can finally make our volume having a box shape. Note that the world volume",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:4418,perform,performing,4418,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,1,['perform'],['performing']
Performance,"ructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; TIterator*_catIter! Iterator over set of input categories; RooSetProxy_catSetSet of input category; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSuperCategory.html:22333,cache,cache,22333,root/html534/RooSuperCategory.html,https://root.cern,https://root.cern/root/html534/RooSuperCategory.html,7,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"rue and drive volume is defined/determined; Average and dispersion of the weight distribution will is found along; each edge and the best edge (minimum dispersion, best maximum weight); is memorized for future use.; The optimal division point for eventual future cell division is; determined/recorded. Recorded are also minimum and maximum weight etc.; The volume estimate in all (inactive) parent cells is updated.; Note that links to parents and initial volume = 1/2 parent has to be; already defined prior to calling this routine. void Varedu(Double_t* , Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; In determines the best edge candidate and the position of the cell division plane; in case of the variance reduction for future cell division,; using results of the MC exploration run stored in fHistEdg. void Carver(Int_t& , Double_t& , Double_t& ); Internal subrogram used by Initialize.; Determines the best edge-candidate and the position of the division plane; for the future cell division, in the case of the optimization of the maximum weight.; It exploits results of the cell MC exploration run stored in fHistEdg. void MakeAlpha(); Internal subrogram used by Initialize.; Provides random vector Alpha 0< Alpha(i) < 1. void Grow(); Internal subrogram used by Initialize.; It grow new cells by the binary division process. Long_t PeekMax(); Internal subprogram used by Initialize.; It finds cell with maximal driver integral for the purpose of the division. Int_t Divide(TFoamCell* ); Internal subrogram used by Initialize.; It divides cell iCell into two daughter cells.; The iCell is retained and tagged as inactive, daughter cells are appended; at the end of the buffer.; New vertex is added to list of vertices.; List of active cells is updated, iCell removed, two daughters added; and their properties set with help of MC sampling (TFoam_Explore); Returns Code RC=-1 of buffer limit is reached, fLastCe=fnBuf. void MakeActiveList(); Internal subrogram used b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFoam.html:17763,optimiz,optimization,17763,root/html528/TFoam.html,https://root.cern,https://root.cern/root/html528/TFoam.html,6,['optimiz'],['optimization']
Performance,"rue is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; ofstream*fLogFile! log file with SQL statements; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; Int_tfModifyCounter! indicates how many changes was done with database tables; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; const char**fOtherTypes! pointer on list of other SQL types like TEXT or blob; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tfQuerisCounter! how many query was applied; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); TSQLServer*fSQL! interface to SQL database ; TList*fSQLClassInfos! list of SQL class infos; Int_tfSQLIOversion! version of SQL I/O which is stored in configurations; Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Int_tfS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TSQLFile.html:30122,cache,cache,30122,root/html530/TSQLFile.html,https://root.cern,https://root.cern/root/html530/TSQLFile.html,5,['cache'],['cache']
Performance,"rue is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; ofstream*fLogFile! log file with SQL statements; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; Int_tfModifyCounter! indicates how many changes was done with database tables; TObject*TDirectory::fMotherpointer to mother of the directory; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; const char**fOtherTypes! pointer on list of other SQL types like TEXT or blob; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; Int_tfQuerisCounter! how many query was applied; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); TSQLServer*fSQL! interface to SQL database; TList*fSQLClassInfos! list of SQL class infos; Int_tfSQLIOversion! version of SQL I/O which is stored in configurations; Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Int_tfSt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLFile.html:31965,cache,cache,31965,root/html602/TSQLFile.html,https://root.cern,https://root.cern/root/html602/TSQLFile.html,4,['cache'],['cache']
Performance,"rue)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:308; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:173; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1509; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:174; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1484; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1320; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1355; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:143; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RWebWindow_8hxx_source.html:36490,perform,performed,36490,doc/v632/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/v632/RWebWindow_8hxx_source.html,1,['perform'],['performed']
Performance,"rue)configures that only native (own-created) connections are allowedDefinition RWebWindow.hxx:311; ROOT::RWebWindow::fProtocolPrefixstd::string fProtocolPrefix! prefix for created files namesDefinition RWebWindow.hxx:176; ROOT::RWebWindow::GetSendQueueLengthint GetSendQueueLength(unsigned connid) constReturns send queue length for specified connection.Definition RWebWindow.cxx:1551; ROOT::RWebWindow::RemoveConnectionstd::shared_ptr< WebConn > RemoveConnection(unsigned wsid)Remove connection with given websocket id.Definition RWebWindow.cxx:279; ROOT::RWebWindow::CreateWSHandlerstd::shared_ptr< RWebWindowWSHandler > CreateWSHandler(std::shared_ptr< RWebWindowsManager > mgr, unsigned id, double tmout)Assigns manager reference, window id and creates websocket handler, used for communication with the c...Definition RWebWindow.cxx:152; ROOT::RWebWindow::fProtocolstd::string fProtocol! protocolDefinition RWebWindow.hxx:177; ROOT::RWebWindow::CanSendbool CanSend(unsigned connid, bool direct=true) constReturns true if sending via specified connection can be performed.Definition RWebWindow.cxx:1526; ROOT::RWebWindow::GetUserArgsstd::string GetUserArgs() constReturns configured user arguments for web window See SetUserArgs method for more details.Definition RWebWindow.cxx:1362; ROOT::RWebWindow::RecordDatavoid RecordData(const std::string &fname=""protocol.json"", const std::string &fprefix="""")Configures recording of communication data in protocol file Provided filename will be used to store J...Definition RWebWindow.cxx:1397; ROOT::RWebWindow::fUseProcessEventsbool fUseProcessEvents! all window functionality will run through process eventsDefinition RWebWindow.hxx:146; ROOT::RWebWindow::GetDisplayConnectionunsigned GetDisplayConnection() constReturns first connection id where window is displayed It could be that connection(s) not yet fully es...Definition RWebWindow.cxx:244; ROOT::RWebWindow::fMaxQueueLengthunsigned fMaxQueueLength! maximal number of queue entriesDefinition RW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RWebWindow_8hxx_source.html:36879,perform,performed,36879,doc/master/RWebWindow_8hxx_source.html,https://root.cern,https://root.cern/doc/master/RWebWindow_8hxx_source.html,1,['perform'],['performed']
Performance,"runeStrength(Float_t alpha = -1.). Data Members; private:. Float_tfAlpha! regularization parameter in CC pruning; Bool_tfDebug! debug flag; Int_tfOptimalK! index of the optimal tree in the pruned tree sequence; Bool_tfOwnQIndex! flag indicates if fQualityIndex is owned by this; vector<TMVA::DecisionTreeNode*>fPruneSequence! map of weakest links (i.e., branches to prune) -> pruning index; vector<Float_t>fPruneStrengthList! map of alpha -> pruning index; TMVA::SeparationBase*fQualityIndex! the quality index used to calculate R(t), R(T) = sum[t in ~T]{ R(t) }; vector<Float_t>fQualityIndexList! map of R(T) -> pruning index; TMVA::DecisionTree*fTree! (pruned) decision tree; const TMVA::DataSet*fValidationDataSet! the event sample to select the optimally-pruned tree; const TMVA::CCPruner::EventList*fValidationSample! the event sample to select the optimally-pruned tree. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex ); constructor. CCPruner( DecisionTree* t_max, const DataSet* validationSample, SeparationBase* qualityIndex ); constructor. ~CCPruner(). void Optimize(); determine the pruning sequence. std::vector<DecisionTreeNode*> GetOptimalPruneSequence() const; return the prune strength (=alpha) corresponding to the prune sequence. void SetPruneStrength(Float_t alpha = -1.). CCPruner( DecisionTree* t_max, const EventList* validationSample, SeparationBase* qualityIndex = NULL ). Float_t GetOptimalQualityIndex() const; return the quality index from the validation sample for the optimal subtree T'. Float_t GetOptimalPruneStrength() const; return the prune strength (=alpha) corresponding to the prune sequence. » Last changed: Tue Jun 30 15:15:17 2015 » Last generated: 2015-06-30 15:15; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__CCPruner.html:2080,Optimiz,Optimize,2080,root/html602/TMVA__CCPruner.html,https://root.cern,https://root.cern/root/html602/TMVA__CCPruner.html,1,['Optimiz'],['Optimize']
Performance,"rupt should be propagated; intfILevHighest received interrupt; TMutex*fIMtxTo protect interrupt queue; Int_tfLogLevelLog level to be transmitted to servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; intfSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t PickUpReady(); Manage asynchronous message. TXSockBuf * PopUpSpare(Int_t sz). void PushBackSpare(). void PostMsg(Int_t type, const char* msg = 0); Post a message into the queue for asynchronous processing. Int_t GetLowSocket() const; Auxilliary. { return (fConn ? fConn->GetLowSocket() : -1); }. void SetLocation(const char* loc = """"). void InitEnvs(). TXSocket(const char* url, Char_t mode = 'M', Int_t psid = -1, Char_t ver = -1, const char* logbuf = 0, Int_t loglevel = -1, TXHandler* handler = 0). TXSocket& operator=(const TXSocket& xs). virtual ~TXSocket(). void Close(Option_t* opt = """"). Bool_t Create(Bool_t attach = kFALSE). void DisconnectSession(Int_t id, Option_t* opt = """"). void DoError(int level, const char* location, const char* fmt, va_list va) const. Int_t GetClientID() const; { return -1; }. Int_t GetClientIDSize() const; { return 1; }. Int_t GetLogConnID() const; { return (fConn ? fConn->GetLogConnID() : -1); }. Int_t GetOpenError() const; { return (fConn ? fConn->GetOpenError() : -1); }. Int_t GetServType() const; { return (fConn ? fConn->GetServType() : -1); }. Int_t GetSessionID() const; { return (fConn ? fConn->GetSess",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TXSocket.html:12320,queue,queue,12320,root/html528/TXSocket.html,https://root.cern,https://root.cern/root/html528/TXSocket.html,4,['queue'],['queue']
Performance,"rupt should be propagated; intfILevHighest received interrupt; TMutex*fIMtxTo protect interrupt queue; Int_tfLogLevelLog level to be transmitted to servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; intfSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Int_t PickUpReady(); Manage asynchronous message. TXSockBuf * PopUpSpare(Int_t sz). void PushBackSpare(). void PostMsg(Int_t type, const char* msg = 0); Post a message into the queue for asynchronous processing. Int_t GetLowSocket() const; Auxilliary. { return (fConn ? fConn->GetLowSocket() : -1); }. void SetLocation(const char* loc = """"). void InitEnvs(). TXSocket(const char* url, Char_t mode = 'M', Int_t psid = -1, Char_t ver = -1, const char* logbuf = 0, Int_t loglevel = -1, TXHandler* handler = 0). virtual ~TXSocket(). void Close(Option_t* opt = """"). Bool_t Create(Bool_t attach = kFALSE). void DisconnectSession(Int_t id, Option_t* opt = """"). void DoError(int level, const char* location, const char* fmt, va_list va) const. Int_t GetClientID() const; { return -1; }. Int_t GetClientIDSize() const; { return 1; }. Int_t GetLogConnID() const; { return (fConn ? fConn->GetLogConnID() : -1); }. Int_t GetOpenError() const; { return (fConn ? fConn->GetOpenError() : -1); }. Int_t GetServType() const; { return (fConn ? fConn->GetServType() : -1); }. Int_t GetSessionID() const; { return (fConn ? fConn->GetSessionID() : -1); }. Int_t GetXrdProofdVersi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TXSocket.html:12769,queue,queue,12769,root/html534/TXSocket.html,https://root.cern,https://root.cern/root/html534/TXSocket.html,2,['queue'],['queue']
Performance,"rvable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_weightSqApply weights squared?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNLLVar(const char *name, const char* title, RooAbsPdf& pdf, RooAbsData& indata,		 const RooCmdArg& arg1, const RooCmdArg& arg2,const RooCmdArg& arg3,		 const RooCmdArg& arg4, const RooCmdArg& arg5,const RooCmdArg& arg6,		 const RooCmdArg& arg7, const RooCmdArg& arg8,const RooCmdArg& arg9); Construct likelihood from given p.d.f and (binned or unbinned dataset). Extended() -- Include extended term in calculation; NumCPU() -- Activate parall",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNLLVar.html:35744,cache,cache,35744,root/html526/RooNLLVar.html,https://root.cern,https://root.cern/root/html526/RooNLLVar.html,1,['cache'],['cache']
Performance,"rvable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; TListRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Int_tRooAbsTestStatistic::_simCountTotal number of component p.d.f.s in RooSimultaneous (if any); RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; Bool_tRooAbsTestStatistic::_splitRangeSplit rangeName in RooSimultaneous index labels if true; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; Bool_tRooAbsTestStatistic::_verboseVerbose messaging if true; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; Bool_t_weightSqApply weights squared?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooNLLVar(const char* name, const char* title, RooAbsPdf& pdf, RooAbsData& data, const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none(), const RooCmdArg& arg9 = RooCmdArg::none(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNLLVar.html:36250,cache,cache,36250,root/html528/RooNLLVar.html,https://root.cern,https://root.cern/root/html528/RooNLLVar.html,1,['cache'],['cache']
Performance,"rvableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0); voidRooAbsArg::printDirty(Bool_t depth = kTRUE) c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategory.html:10276,optimiz,optimizeCacheMode,10276,root/html526/RooAbsCategory.html,https://root.cern,https://root.cern/root/html526/RooAbsCategory.html,1,['optimiz'],['optimizeCacheMode']
Performance,"rvableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_toperator!=(Int_t index); Bool_toperator!=(const char* label); Bool_toperator!=(const RooAbsArg& other); TNamed&TNamed::operator=(const TNamed& rhs); Bool_toperator==(Int_t index) const; Bool_toperator==(const char* label) const; virtual Bool_toperator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", const char* namePat = 0, Int_t nLevel = 999); voidRooAbsArg::printDirty(Boo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCategory.html:10391,optimiz,optimizeCacheMode,10391,root/html528/RooAbsCategory.html,https://root.cern,https://root.cern/root/html528/RooAbsCategory.html,1,['optimiz'],['optimizeCacheMode']
Performance,"rvableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); virtual RooAbsArg&operator=(const RooAbsReal& other); virtual RooAbsArg&operator=(Double_t newValue); virtual RooAbsArg&operator=(Int_t ival); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsRealLValue.html:21561,optimiz,optimizeCacheMode,21561,root/html530/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html530/RooAbsRealLValue.html,2,['optimiz'],['optimizeCacheMode']
Performance,"rvableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction4Binding<double,double,double,double,int>&operator=(const RooCFunction4Binding<double,double,double,double,int>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_int_.html:19874,optimiz,optimizeCacheMode,19874,root/html602/RooCFunction4Binding_double_double_double_double_int_.html,https://root.cern,https://root.cern/root/html602/RooCFunction4Binding_double_double_double_double_int_.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rvableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFunctorBinding&operator=(const RooFunctorBinding&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctorBinding.html:19730,optimiz,optimizeCacheMode,19730,root/html602/RooFunctorBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctorBinding.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rvableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNumConvolution&operator=(const RooNumConvolution&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooAbsReal&pdf() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumConvolution.html:21518,optimiz,optimizeCacheMode,21518,root/html602/RooNumConvolution.html,https://root.cern,https://root.cern/root/html602/RooNumConvolution.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rvableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUnblindUniform&operator=(const RooUnblindUniform&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindUniform.html:19266,optimiz,optimizeCacheMode,19266,root/html602/RooUnblindUniform.html,https://root.cern,https://root.cern/root/html602/RooUnblindUniform.html,4,['optimiz'],['optimizeCacheMode']
Performance,"rvables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit const RooAbsArg &testArg const { return observableOverlaps(dset,testArg);  ; const RooAbsArg &testArg const { return observableOverlaps(depList, testArg);  ;  Static Protected Member Functions inherited from RooAbsReal; static void globalSelectComp (bool flag);  Global switch controlling the activation of the selectComp() functionality. ;  ;  Static Protected Member Functions inherited from RooAbsArg; static void ioStreamerPass2Finalize ();  Method called by workspace container to finalize schema evolution issues that cannot be handled in a single ioStreamer pass. ;  ;  Static Protected Attributes inherited from RooAbsPdf; static TString _normRangeOverride;  ; static Int_t _verboseEval = 0;  ;  Static Protected Attributes inherited from RooAbsReal; static bool _globalSelectComp = false;  ; static bool _hideOffset = true;  Offset hiding flag. ;  ;  Static Protected Attributes inherited from RooAbsArg; static bool _inhibitDirty;  ; static bool _verboseDirty;  cache of the list of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooAddModel.h>. Inheritance diagram for RooAddModel:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ pRooArgList. typedef RooArgList* RooAddModel::pRooArgList. protected . Definition at line 106 of file RooAddModel.h. Constructor & Destructor Documentation. ◆ RooAddModel() [1/3]. RooAddModel::RooAddModel ; (; ). Definition at line 63 of file RooAddModel.cxx. ◆ RooAddModel() [2/3]. RooAddModel::RooAddModel ; (; const char * ; name, . const char * ; title, . const RooArgList & ; inPdfList, . const RooArgList & ; inCoefList, . bool ; ownPdfList = false . ). Generic constructor from list of PDFs and list of coefficients. ; Each pdf list element (i) is paired with coefficient list element (i). The number of coefficie",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:78542,cache,cache,78542,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['cache'],['cache']
Performance,"rved by this object. . ReturnsTrue if values are served. ; Definition at line 116 of file RooAbsArg.h. ◆ dependsOnValue() [2/2]. bool RooAbsArg::dependsOnValue ; (; const RooAbsCollection & ; serverList, . const RooAbsArg * ; ignoreArg = nullptr . ); const. inline . Check whether this object depends on values from an element in the serverList. ; Parameters. serverListTest if one of the elements in this list serves values to this. ; ignoreArgIgnore values served by this object. . ReturnsTrue if values are served. ; Definition at line 108 of file RooAbsArg.h. ◆ expensiveObjectCache(). RooExpensiveObjectCache & RooAbsArg::expensiveObjectCache ; (; ); const. Definition at line 2324 of file RooAbsArg.cxx. ◆ fillTreeBranch(). virtual void RooAbsArg::fillTreeBranch ; (; TTree & ; t). protectedpure virtual . Implemented in RooAbsCategory, RooAbsReal, RooRealVar, and RooStringVar. ◆ findConstantNodes() [1/2]. bool RooAbsArg::findConstantNodes ; (; const RooArgSet & ; observables, . RooArgSet & ; cacheList . ). Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ; Definition at line 1859 of file RooAbsArg.cxx. ◆ findConstantNodes() [2/2]. bool RooAbsArg::findConstantNodes ; (; const RooArgSet & ; observables, . RooArgSet & ; cacheList, . RooLinkedList & ; processedNodes . ). Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ; Definition at line 1877 of file RooAbsArg.cxx. ◆ findNewServer(). RooAbsArg * RooAbsArg::findNewServer ; (; const RooAbsCollection & ; newSet, . bool ; nameChange . ); const. Find the new server in the specified set that matches the old server. ; Parameters. [in]newSetSearch this set by name for a new server. ; [in]nameChangeIf true, search for an item with the bool attribute ""ORIGNAME:<oldName>"" set. Use <object>.setAttribute(""ORIGNAME:<oldName>"") to set this a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:59488,cache,cacheList,59488,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['cacheList']
Performance,"rver using the ML ApMon package (libapmoncpp.so/UDP; packets). The MonaLisa ApMon library for C++ can be downloaded at; http://monalisa.cacr.caltech.edu/monalisa__Download__ApMon.html,; current version:; http://monalisa.cacr.caltech.edu/download/apmon/ApMon_c-2.2.0.tar.gz. The ROOT implementation is primary optimized for process/job; monitoring, although all other generic MonaLisa ApMon functionality; can be exploited through the ApMon class directly via; dynamic_cast<TMonaLisaWriter*>(gMonitoringWriter)->GetApMon(). Additions/modifications by Fabrizio Furano 10/04/2008; - The implementation of TFile throughput and info sending was; just sending 'regular' samples about the activity of the single TFile; instance that happened to trigger an activity in the right moment.; - Now TMonaLisaWriter keeps internally track of every activity; and regularly sends summaries valid for all the files which had; activity in the last time interval.; - Additionally, it's now finalized the infrastructure able to measure; and keep track of the file Open latency. A packet is sent for each; successful Open, sending the measures of the latencies for the; various phases of the open. Currently exploited fully by TAlienFile; and TXNetFile. Easy to report from other TFiles too.; - Now, the hook for the Close() func triggers sending of a packet; containing various information about the performance related to that; file only.; - Added support also for performance monitoring when writing. Function Members (Methods); public:. TMonaLisaWriter(const char* monserver, const char* montag, const char* monid = 0, const char* monsubid = 0, const char* option = """"); virtual~TMonaLisaWriter(); voidTObject::AbstractMethod(const char* method) const; virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newnam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMonaLisaWriter.html:1542,latency,latency,1542,root/html530/TMonaLisaWriter.html,https://root.cern,https://root.cern/root/html530/TMonaLisaWriter.html,3,['latency'],['latency']
Performance,rver; TChain A chain of TTrees; TChainElement A chain element; TChainIndex A Tree Index with majorname and minorname.; TChainIndex::TChainIndexEntry ; TChair A base class to provide a user custom interface to TTable class objects; TCint Interface to CINT C/C++ interpreter; TClass Dictionary containing class information; TClassDocInfo info cache for class documentation; TClassDocOutput generates documentation web pages for a class; TClassEdit ; TClassGenerator interface for TClass generators; TClassMenuItem One element of the class context menu; TClassRef ; TClassStreamer ; TClassTable Table of known classes; TClassTree Manager class to draw classes inheritance tree and relations; TClonesArray An array of clone objects; TCollection Collection abstract base class; TCollectionClassStreamer ; TCollectionMemberStreamer ; TCollectionMethodBrowsable Helper object to browse a collection's methods; TCollectionPropertyBrowsable Helper object to add browsable collection properties; TCollectionProxyFactory ; TCollectionStreamer ; TColor Color defined by RGB or HLS; TColorWheel The ROOT Color Wheel; TColumnView Helper to represent one TTable column; TComplex Complex Class; TCondition Condition variable class; TConditionImp Condition variable implementation ABC; TCondor Interface to the Condor System; TCondorSlave Describes a claimed slave; TConfidenceLevel output for TLimit functions; TContextMenu Context sensitive popup menu; TContextMenuImp Context sensitive popup menu implementation; TControlBar Control bar; TControlBarButton The Control bar button; TControlBarImp GUI independent controlbar abc; TCrown A crown or segment of crown; TCurlyArc A curly arc; TCurlyArcEditor GUI for editing arrow attributes; TCurlyLine A curly polyline; TCurlyLineEditor GUI for editing arrow attributes; TCut A specialized string object used for TTree selections; TCutG A Graphical cut.; TDCacheFile A ROOT file that reads/writes via a dCache server; TDCacheSystem Directory handler for DCache; TDNDData,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/ClassIndex.html:53880,cache,cache,53880,root/html530/ClassIndex.html,https://root.cern,https://root.cern/root/html530/ClassIndex.html,2,['cache'],['cache']
Performance,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooExtendPdf.html:2617,cache,cacheUniqueSuffix,2617,root/html532/RooExtendPdf.html,https://root.cern,https://root.cern/root/html532/RooExtendPdf.html,2,['cache'],['cacheUniqueSuffix']
Performance,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Double_tcoefAnalyticalIntegral(Int_t coef, Int_t code, const char* rangeName = 0) const; virtual ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsAnaConvPdf.html:3564,cache,cacheUniqueSuffix,3564,root/html528/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsAnaConvPdf.html,2,['cache'],['cacheUniqueSuffix']
Performance,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedPdf.html:2664,cache,cacheUniqueSuffix,2664,root/html528/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedPdf.html,2,['cache'],['cacheUniqueSuffix']
Performance,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooEffProd.html:2265,cache,cacheUniqueSuffix,2265,root/html528/RooEffProd.html,https://root.cern,https://root.cern/root/html528/RooEffProd.html,8,['cache'],['cacheUniqueSuffix']
Performance,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; const RooArgList&coefList() const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOpt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddPdf.html:3305,cache,cacheUniqueSuffix,3305,root/html528/RooAddPdf.html,https://root.cern,https://root.cern/root/html528/RooAddPdf.html,4,['cache'],['cacheUniqueSuffix']
Performance,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tcheckObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::Const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:3751,cache,cacheUniqueSuffix,3751,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,2,['cache'],['cacheUniqueSuffix']
Performance,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tcanBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidclearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*RooAbsArg::clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAbsArg::ConstOpCode opco",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsPdf.html:5866,cache,cacheUniqueSuffix,5866,root/html528/RooAbsPdf.html,https://root.cern,https://root.cern/root/html528/RooAbsPdf.html,2,['cache'],['cacheUniqueSuffix']
Performance,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedReal.html:2678,cache,cacheUniqueSuffix,2678,root/html528/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedReal.html,1,['cache'],['cacheUniqueSuffix']
Performance,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tanalyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/PiecewiseInterpolation.html:2116,cache,cacheUniqueSuffix,2116,root/html530/PiecewiseInterpolation.html,https://root.cern,https://root.cern/root/html530/PiecewiseInterpolation.html,2,['cache'],['cacheUniqueSuffix']
Performance,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooConvCoefVar.html:2207,cache,cacheUniqueSuffix,2207,root/html528/RooConvCoefVar.html,https://root.cern,https://root.cern/root/html528/RooConvCoefVar.html,4,['cache'],['cacheUniqueSuffix']
Performance,"rverList, Bool_t valueProp = kTRUE, Bool_t shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tanalyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAddition.html:2325,cache,cacheUniqueSuffix,2325,root/html528/RooAddition.html,https://root.cern,https://root.cern/root/html528/RooAddition.html,16,['cache'],['cacheUniqueSuffix']
Performance,"ry = 0); virtual voidUseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidAddClone(TTree*); virtual TBranch*BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tCheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tGetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*GetLeafImpl(const char* branchname, const char* leafname); charGetNewlineValue(istream& inputStream); TTreeCache*GetReadCache(TFile* file, Bool_t create = kFALSE); voidImportClusterRanges(TTree* fromtree); virtual voidKeepCircular(); voidTObject::MakeZombie(); voidMoveReadCache(TFile* src, TDirectory* dir); Int_tSetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); Int_tSetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TTree&operator=(const TTree& tt); TTree(const TTree& tt). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TTree::(anonymous)kCircular; static TTree::ESetBr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTree.html:30944,cache,cacheSize,30944,root/html604/TTree.html,https://root.cern,https://root.cern/root/html604/TTree.html,2,['cache'],['cacheSize']
Performance,"ry = 0); virtual voidUseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidAddClone(TTree*); virtual TBranch*BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tCheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tGetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*GetLeafImpl(const char* branchname, const char* leafname); charGetNewlineValue(istream& inputStream); TTreeCache*GetReadCache(TFile* file, Bool_t create = kFALSE); voidImportClusterRanges(TTree* fromtree); virtual voidKeepCircular(); voidTObject::MakeZombie(); voidMoveReadCache(TFile* src, TDirectory* dir); Int_tSetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidSetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TTree&operator=(const TTree& tt); TTree(const TTree& tt). Data Members; public:. static TObject::(anonymous)TObject::kBitMask; static TObject::EStatusBitsTObject::kCanDelete; static TObject::EStatusBitsTObject::kCannotPick; static TTree::(anonymous)kCircular; static TTree::ESetBr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTree.html:30959,cache,cacheSize,30959,root/html602/TTree.html,https://root.cern,https://root.cern/root/html602/TTree.html,2,['cache'],['cacheSize']
Performance,"ry = 0); virtual voidUseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tWrite(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. voidAddClone(TTree*); virtual TBranch*BranchImp(const char* branchname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImp(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, const char* classname, TClass* ptrClass, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BranchImpRef(const char* branchname, TClass* ptrClass, EDataType datatype, void* addobj, Int_t bufsize, Int_t splitlevel); virtual TBranch*BronchExec(const char* name, const char* classname, void* addobj, Bool_t isptrptr, Int_t bufsize, Int_t splitlevel); virtual Int_tCheckBranchAddressType(TBranch* branch, TClass* ptrClass, EDataType datatype, Bool_t ptr); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; Long64_tGetCacheAutoSize(Bool_t withDefault = kFALSE) const; virtual TLeaf*GetLeafImpl(const char* branchname, const char* leafname); charGetNewlineValue(istream& inputStream); TTreeCache*GetReadCache(TFile* file, Bool_t create = kFALSE); voidImportClusterRanges(TTree* fromtree); virtual voidKeepCircular(); voidTObject::MakeZombie(); voidMoveReadCache(TFile* src, TDirectory* dir); Int_tSetBranchAddressImp(TBranch* branch, void* addr, TBranch** ptr); voidSetCacheSizeAux(Bool_t autocache = kTRUE, Long64_t cacheSize = 0). private:. TTree(const TTree& tt); TTree&operator=(const TTree& tt). Data Members; public:. enum ELockStatusBits { kFindBranch; kFindLeaf; kGetAlias; kGetBranch; kGetEntry; kGetEntryWithIndex; kGetFriend; kGetFriendAlias; kGetLeaf; kLoadTree; kPrint; kRemoveFriend; kSetBranchStatus; };; enu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTree.html:30779,cache,cacheSize,30779,root/html534/TTree.html,https://root.cern,https://root.cern/root/html534/TTree.html,2,['cache'],['cacheSize']
Performance,"ry and then overlay the new TTree information onto this TTree object (so that this TTree object is now the appropriate to use for further merging).; Returns the total number of entries in the merged tree. ; Reimplemented in TChain.; Definition at line 6927 of file TTree.cxx. ◆ MergeTrees(). TTree * TTree::MergeTrees ; (; TList * ; li, . Option_t * ; options = """" . ). static . Static function merging the trees in the TList into a new tree. ; Trees in the list can be memory or disk-resident trees. The new tree is created in the current directory (memory if gROOT). ; Definition at line 6851 of file TTree.cxx. ◆ MoveReadCache(). void TTree::MoveReadCache ; (; TFile * ; src, . TDirectory * ; dir . ). protected . Move a cache from a file to the current file in dir. ; if src is null no operation is done, if dir is null or there is no current file the cache is deleted. ; Definition at line 6983 of file TTree.cxx. ◆ Notify(). bool TTree::Notify ; (; ). overridevirtual . Function called when loading a new class library. ; Reimplemented from TObject.; Definition at line 7033 of file TTree.cxx. ◆ operator=(). TTree & TTree::operator= ; (; const TTree & ; tt). delete . ◆ OptimizeBaskets(). void TTree::OptimizeBaskets ; (; ULong64_t ; maxMemory = 10000000, . Float_t ; minComp = 1.1, . Option_t * ; option = """" . ). virtual . This function may be called after having filled some entries in a Tree. ; Using the information in the existing branch buffers, it will reassign new branch buffer sizes to optimize time and memory.; The function computes the best values for branch buffer sizes such that the total buffer sizes is less than maxMemory and nearby entries written at the same time. In case the branch compression factor for the data written so far is less than compMin, the compression is disabled.; if option =""d"" an analysis report is printed. ; Definition at line 7057 of file TTree.cxx. ◆ Principal(). TPrincipal * TTree::Principal ; (; const char * ; varexp = """", . const char * ; se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:182889,load,loading,182889,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['load'],['loading']
Performance,"ry structure do the following instead: TFile* file = TFile::Open(""newfile.root"", ""RECREATE"");; file->mkdir(""mydir"")->cd();; ch.Merge(file, 0);; If 'option' contains the word 'fast' the merge will be done without unzipping or unstreaming the baskets (i.e., a direct copy of the raw bytes on disk).; When 'fast' is specified, 'option' can also contains a sorting order for the baskets in the output file.; There is currently 3 supported sorting order: SortBasketsByOffset (the default); SortBasketsByBranch; SortBasketsByEntry; When using SortBasketsByOffset the baskets are written in the output file in the same order as in the original file (i.e. the basket are sorted on their offset in the original file; Usually this also means that the baskets are sorted on the index/number of the last entry they contain); When using SortBasketsByBranch all the baskets of each individual branches are stored contiguously. This tends to optimize reading speed when reading a small number (1->5) of branches, since all their baskets will be clustered together instead of being spread across the file. However it might decrease the performance when reading more branches (or the full entry).; When using SortBasketsByEntry the baskets with the lowest starting entry are written first. (i.e. the baskets are sorted on the index/number of the first entry they contain). This means that on the file the baskets will be in the order in which they will be needed when reading the whole tree sequentially. IMPORTANT Note 1: AUTOMATIC FILE OVERFLOW; When merging many files, it may happen that the resulting file reaches a size > TTree::fgMaxTreeSize (default = 100 GBytes). In this case the current file is automatically closed and a new file started. If the name of the merged file was ""merged.root"", the subsequent files will be named ""merged_1.root"", ""merged_2.root"", etc. fgMaxTreeSize may be modified via the static function TTree::SetMaxTreeSize. When in fast mode, the check and switch is only done in between ea",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:86429,optimiz,optimize,86429,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['optimiz'],['optimize']
Performance,"ry* theBaseDir = 0); TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodLDMethodLD(const TMVA::MethodLD&); TMVA::MethodLDMethodLD(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = 0); TMVA::MethodLDMethodLD(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""LD"", TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::MethodLD&operator=(const TMVA::MethodLD&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; virtual voidProcessOptions(); voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& i); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformation",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodLD.html:9583,Optimiz,OptimizeTuningParameters,9583,root/html602/TMVA__MethodLD.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodLD.html,2,['Optimiz'],['OptimizeTuningParameters']
Performance,"ry*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tTClass::GetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*TClass::GetFunctionTemplate(const char* name); UInt_tTClass::GetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tTClass::GetImplFileLine() const; const char*TClass::GetImplFileName() const; UInt_tTClass::GetInstanceCount() const; TVirtualIsAProxy*TClass::GetIsAProxy() const; TVirtualStreamerInfo*TClass::GetLastReadInfo() const; TList*TClass::GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*TClass::GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*TClass::GetListOfBases(); TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TClass::GetListOfDataMembers(Bool_t load = kTRUE); TList*TClass::GetListOfEnums(Bool_t load = kTRUE); TList*TClass::GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*TClass::GetListOfMethodOverloads(const char* name) const; TList*TClass::GetListOfMethods(Bool_t load = kTRUE); TList*TClass::GetListOfRealData() const; TList*TQObject::GetListOfSignals() const; voidTClass::GetMenuItems(TList* listitems); TList*TClass::GetMenuList() const; ROOT::MergeFunc_tTClass::GetMerge() const; TMethod*TClass::GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetMethodAllAny(const char* method); TMethod*TClass::GetMethodAny(const char* method); TMethod*TClass::GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidTClass::GetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tTClass::GetNdata(); ROOT::NewFunc_tTClass::GetNew() const; ROOT::NewArrFunc_tTClass::GetNewArray() cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:10047,load,load,10047,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,4,['load'],['load']
Performance,"ry::Remove(TObject*); virtual Int_tReOpen(Option_t* mode); voidTObject::ResetBit(UInt_t f); virtual voidResetErrno() const; virtual voidTDirectoryFile::rmdir(const char* name); virtual voidTDirectoryFile::Save(); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual Int_tTDirectoryFile::SaveObjectAs(const TObject* obj, const char* filename = """", Option_t* option = """") const; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual voidTDirectoryFile::SaveSelf(Bool_t force = kFALSE); virtual voidSeek(Long64_t offset, TFile::ERelativeTo pos = kBeg); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidTDirectoryFile::SetBufferSize(Int_t bufsize); static Bool_tSetCacheFileDir(const char* cacheDir, Bool_t operateDisconnected = kTRUE, Bool_t forceCacheread = kFALSE); virtual voidSetCacheRead(TFileCacheRead* cache); virtual voidSetCacheWrite(TFileCacheWrite* cache); virtual voidSetCompressionLevel(Int_t level = 1); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidSetEND(Long64_t last); static voidSetFileBytesRead(Long64_t bytes = 0); static voidSetFileBytesWritten(Long64_t bytes = 0); static voidSetFileReadCalls(Int_t readcalls = 0); virtual voidTDirectoryFile::SetModified(); virtual voidTDirectory::SetMother(TObject* mother); virtual voidTDirectory::SetName(const char* newname); virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); virtual voidSetOffset(Long64_t offset, TFile::ERelativeTo pos = kBeg); static Bool_tSetOnlyStaged(Bool_t onlystaged); static UInt_tSetOpenTimeout(UInt_t timeout); virtual voidSetOption(Option_t* option = "">""); static voidSetReadaheadSize(Int_t bufsize = 256000); virtual voidSetReadCalls(Int_t readcalls = 0); static voidSetReadStreamerInfo(Bool_t readinfo = kTRUE); virtual voidTDir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:12886,cache,cache,12886,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['cache'],['cache']
Performance,"ryList->TestBit(kCanDelete)){; 2920 TEntryList *tmp = fEntryList;; 2921 fEntryList = nullptr; // Avoid problem with RecursiveRemove.; 2922 delete tmp;; 2923 } else {; 2924 fEntryList = nullptr;; 2925 }; 2926 }; 2927 return;; 2928 }; 2929 ; 2930 char enlistname[100];; 2931 snprintf(enlistname,100, ""%s_%s"", evlist->GetName(), ""entrylist"");; 2932 TEntryList *enlist = new TEntryList(enlistname, evlist->GetTitle());; 2933 enlist->SetDirectory(nullptr);; 2934 ; 2935 Int_t nsel = evlist->GetN();; 2936 Long64_t globalentry, localentry;; 2937 const char *treename;; 2938 const char *filename;; 2939 if (fTreeOffset[fNtrees-1]==TTree::kMaxEntries){; 2940 //Load all the tree headers if the tree offsets are not known; 2941 //It is assumed here, that loading the last tree will load all; 2942 //previous ones; 2943 printf(""loading trees\n"");; 2944 (const_cast<TChain*>(this))->LoadTree(evlist->GetEntry(evlist->GetN()-1));; 2945 }; 2946 for (Int_t i=0; i<nsel; i++){; 2947 globalentry = evlist->GetEntry(i);; 2948 //add some protection from globalentry<0 here; 2949 Int_t treenum = 0;; 2950 while (globalentry>=fTreeOffset[treenum]); 2951 treenum++;; 2952 treenum--;; 2953 localentry = globalentry - fTreeOffset[treenum];; 2954 // printf(""globalentry=%lld, treeoffset=%lld, localentry=%lld\n"", globalentry, fTreeOffset[treenum], localentry);; 2955 treename = ((TNamed*)fFiles->At(treenum))->GetName();; 2956 filename = ((TNamed*)fFiles->At(treenum))->GetTitle();; 2957 //printf(""entering for tree %s %s\n"", treename, filename);; 2958 enlist->SetTree(treename, filename);; 2959 enlist->Enter(localentry);; 2960 }; 2961 enlist->SetBit(kCanDelete, true);; 2962 enlist->SetReapplyCut(evlist->GetReapplyCut());; 2963 SetEntryList(enlist);; 2964}; 2965 ; 2966////////////////////////////////////////////////////////////////////////////////; 2967/// Change the name of this TChain.; 2968 ; 2969void TChain::SetName(const char* name); 2970{; 2971 if (fGlobalRegistration) {; 2972 // Should this be extended to incl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:106691,load,loading,106691,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,3,['load'],"['load', 'loading']"
Performance,"s "" << (nr?nr:""<null>"") << endl ;; 534 RooAbsReal* normInt;; 535 {; 536 // Normalization is always over all pdf components. Overriding the global; 537 // component selection temporarily makes all RooRealIntegrals created during; 538 // that time always include all components.; 539 GlobalSelectComponentRAII selCompRAII(true);; 540 normInt = std::unique_ptr<RooAbsReal>{createIntegral(depList,*getIntegratorConfig(),nr)}.release();; 541 }; 542 static_cast<RooRealIntegral*>(normInt)->setAllowComponentSelection(false);; 543 normInt->getVal() ;; 544// cout << ""resulting normInt = "" << normInt->GetName() << endl ;; 545 ; 546 const char* cacheParamsStr = getStringAttribute(""CACHEPARAMINT"") ;; 547 if (cacheParamsStr && strlen(cacheParamsStr)) {; 548 ; 549 std::unique_ptr<RooArgSet> intParams{normInt->getVariables()} ;; 550 ; 551 RooArgSet cacheParams = RooHelpers::selectFromArgSet(*intParams, cacheParamsStr);; 552 ; 553 if (!cacheParams.empty()) {; 554 cxcoutD(Caching) << ""RooAbsReal::createIntObj("" << GetName() << "") INFO: constructing "" << cacheParams.size(); 555 << ""-dim value cache for integral over "" << depList << "" as a function of "" << cacheParams << "" in range "" << (nr?nr:""<default>"") << endl ;; 556 string name = Form(""%s_CACHE_[%s]"",normInt->GetName(),cacheParams.contentsString().c_str()) ;; 557 RooCachedReal* cachedIntegral = new RooCachedReal(name.c_str(),name.c_str(),*normInt,cacheParams) ;; 558 cachedIntegral->setInterpolationOrder(2) ;; 559 cachedIntegral->addOwnedComponents(*normInt) ;; 560 cachedIntegral->setCacheSource(true) ;; 561 if (normInt->operMode()==ADirty) {; 562 cachedIntegral->setOperMode(ADirty) ;; 563 }; 564 normInt= cachedIntegral ;; 565 }; 566 ; 567 }; 568 _norm = normInt ;; 569 }; 570 ; 571 // Register new normalization with manager (takes ownership); 572 cache = new CacheElem(*_norm) ;; 573 _normMgr.setObj(nset,cache) ;; 574 ; 575// cout << ""making new object "" << _norm->GetName() << endl ;; 576 ; 577 return true ;; 578}; 579 ; 580 ; 581 ; 582/",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:21464,cache,cacheParams,21464,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cacheParams']
Performance,"s % 100;; 2313 fCompress = 100 * algorithm + level;; 2314 }; 2315}; 2316 ; 2317////////////////////////////////////////////////////////////////////////////////; 2318/// See comments for function SetCompressionSettings; 2319 ; 2320void TFile::SetCompressionLevel(Int_t level); 2321{; 2322 if (level < 0) level = 0;; 2323 if (level > 99) level = 99;; 2324 if (fCompress < 0) {; 2325 // if the algorithm is not defined yet use 0 as a default; 2326 fCompress = level;; 2327 } else {; 2328 int algorithm = fCompress / 100;; 2329 if (algorithm >= ROOT::RCompressionSetting::EAlgorithm::kUndefined) algorithm = 0;; 2330 fCompress = 100 * algorithm + level;; 2331 }; 2332}; 2333 ; 2334////////////////////////////////////////////////////////////////////////////////; 2335/// Used to specify the compression level and algorithm.; 2336///; 2337/// See the TFile constructor for the details.; 2338 ; 2339void TFile::SetCompressionSettings(Int_t settings); 2340{; 2341 fCompress = settings;; 2342}; 2343 ; 2344////////////////////////////////////////////////////////////////////////////////; 2345/// Set a pointer to the read cache.; 2346///; 2347/// <b>This relinquishes ownership</b> of the previous cache, so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:82696,cache,cache,82696,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"s () const;  Returns maximal visible number of nodes, ignored when non-positive. ;  ; TVirtualMutex * GetMutex () const;  Return currently used mutex. ;  ; int GetNSegments () const;  Return of segments for cylindrical shapes, if 0 - default value will be used. ;  ; int GetNumNodes () const;  Number of unique nodes in the geometry. ;  ; std::string GetSearch () const;  ; std::string GetSearchJson () const;  ; bool GetTopVisible () const;  Returns draw options, used for JSROOT TGeoPainter. ;  ; int GetVisLevel () const;  Returns maximal visible level. ;  ; bool HasDrawData () const;  Check if there is draw data available. ;  ; bool IsBuild () const;  ; int IsBuildShapes () const;  Returns true if binary 3D model build already by C++ server (default) ;  ; bool IsPreferredOffline () const;  Is offline operations preferred. ;  ; bool IsPrincipalEndNode (int nodeid);  return true when node used in main geometry drawing and does not have childs for such nodes one could provide optimize toggling of visibility flags ;  ; void IssueSignal (const void *handler, const std::string &kind);  Issue signal, which distributed on all handlers - excluding source handler. ;  ; std::vector< int > MakeIdsByStack (const std::vector< int > &stack);  Produce list of node ids for given stack If found nodes preselected - use their ids. ;  ; std::unique_ptr< RGeomNodeInfo > MakeNodeInfo (const std::vector< int > &stack);  Change visibility for specified element Returns true if changes was performed. ;  ; std::vector< std::string > MakePathByStack (const std::vector< int > &stack);  Returns path string for provided stack. ;  ; std::vector< int > MakeStackByIds (const std::vector< int > &ids);  Creates stack for given array of ids, first element always should be 0. ;  ; std::vector< int > MakeStackByPath (const std::vector< std::string > &path);  Produce stack based on string path Used to highlight geo volumes by browser hover event. ;  ; std::string ProcessBrowserRequest (const std::string &req=",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html:3134,optimiz,optimize,3134,doc/v632/classROOT_1_1RGeomDescription.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RGeomDescription.html,1,['optimiz'],['optimize']
Performance,"s ();  Do labels. ;  ; void Init ();  Default initialization. ;  ; TClass * IsA () const override;  ; void PaintGLAxis (const Double_t p1[3], const Double_t p2[3], Double_t wmin, Double_t wmax, Int_t ndiv, Option_t *opt="""");  Paint GL Axis. ;  ; void PaintGLAxisBody ();  Paint horizontal axis body at position (0,0,0) ;  ; void PaintGLAxisLabels ();  Paint axis labels on the main tick marks. ;  ; void PaintGLAxisTickMarks ();  Paint axis tick marks. ;  ; void SetGridLength (Double_t grid);  ; void SetLabelsAngles (Double_t a1, Double_t a2, Double_t a3);  Set labels' angles. ;  ; void SetLabelsOffset (Double_t offset);  ; void SetLabelsSize (Double_t size);  ; void SetTickMarksLength (Double_t length);  ; void SetTickMarksOrientation (Int_t tmo);  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TicksPositions (Option_t *opt="""");  Compute ticks positions. ;  ; void TicksPositionsNoOpt ();  Compute ticks positions. Linear and not optimized. ;  ; void TicksPositionsOpt ();  Compute ticks positions. Linear and optimized. ;  ;  Public Member Functions inherited from TAttLine;  TAttLine ();  AttLine default constructor. ;  ;  TAttLine (Color_t lcolor, Style_t lstyle, Width_t lwidth);  AttLine normal constructor. ;  ; virtual ~TAttLine ();  AttLine destructor. ;  ; void Copy (TAttLine &attline) const;  Copy this line attributes to a new TAttLine. ;  ; Int_t DistancetoLine (Int_t px, Int_t py, Double_t xp1, Double_t yp1, Double_t xp2, Double_t yp2);  Compute distance from point px,py to a line. ;  ; virtual Color_t GetLineColor () const;  Return the line color. ;  ; virtual Style_t GetLineStyle () const;  Return the line style. ;  ; virtual Width_t GetLineWidth () const;  Return the line width. ;  ; virtual void Modify ();  Change current line attributes if necessary. ;  ; virtual void ResetAttLine (Option_t *option="""");  Reset this line attributes to default values. ;  ; virtual void SaveLineAttributes (std::ostr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLAxis.html:1572,optimiz,optimized,1572,doc/master/classTGLAxis.html,https://root.cern,https://root.cern/doc/master/classTGLAxis.html,1,['optimiz'],['optimized']
Performance,"s (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_lowestOrder; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooPolynomial.html:42026,cache,cache,42026,root/html602/RooPolynomial.html,https://root.cern,https://root.cern/root/html602/RooPolynomial.html,10,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"s *baseclass = base->GetClassPointer();; 2729 if (!baseclass) return -1;; 2730 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2731 if (subOffset == -2) return -2;; 2732 if (subOffset != -1) return offset+subOffset;; 2733 offset += baseclass->Size();; 2734 } else if (element->IsA() == TStreamerSTL::Class()) {; 2735 TStreamerSTL *base = (TStreamerSTL*)element;; 2736 TClass *baseclass = base->GetClassPointer();; 2737 if (!baseclass) return -1;; 2738 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2739 if (subOffset == -2) return -2;; 2740 if (subOffset != -1) return offset+subOffset;; 2741 offset += baseclass->Size();; 2742 ; 2743 } else {; 2744 Error(""GetBaseClassOffsetRecurse"",""Unexpected element type for base class: %s\n"",element->IsA()->GetName());; 2745 }; 2746 }; 2747 }; 2748 return -1;; 2749 }; 2750 }; 2751 ; 2752 TClass *c;; 2753 Int_t off;; 2754 TBaseClass *inh;; 2755 TObjLink *lnk = nullptr;; 2756 if (fBase.load() == nullptr); 2757 lnk = GetListOfBases()->FirstLink();; 2758 else; 2759 lnk = fBase.load()->FirstLink();; 2760 ; 2761 // otherwise look at inheritance tree; 2762 while (lnk) {; 2763 inh = (TBaseClass *)lnk->GetObject();; 2764 //use option load=kFALSE to avoid a warning like:; 2765 //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; 2766 //We can not afford to not have the class if it exist, so we; 2767 //use kTRUE.; 2768 c = inh->GetClassPointer(kTRUE); // kFALSE);; 2769 if (c) {; 2770 if (cl == c) {; 2771 if ((inh->Property() & kIsVirtualBase) != 0); 2772 return -2;; 2773 return inh->GetDelta();; 2774 }; 2775 off = c->GetBaseClassOffsetRecurse(cl);; 2776 if (off == -2) return -2;; 2777 if (off != -1) {; 2778 return off + inh->GetDelta();; 2779 }; 2780 }; 2781 lnk = lnk->Next();; 2782 }; 2783 return -1;; 2784}; 2785 ; 2786////////////////////////////////////////////////////////////////////////////////; 2787/// - Return data member offset to the base class ""cl"".; 2788/// - Returns -1 in case ""cl"" i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:103259,load,load,103259,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"s *baseclass = base->GetClassPointer();; 2796 if (!baseclass) return -1;; 2797 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2798 if (subOffset == -2) return -2;; 2799 if (subOffset != -1) return offset+subOffset;; 2800 offset += baseclass->Size();; 2801 } else if (element->IsA() == TStreamerSTL::Class()) {; 2802 TStreamerSTL *base = (TStreamerSTL*)element;; 2803 TClass *baseclass = base->GetClassPointer();; 2804 if (!baseclass) return -1;; 2805 Int_t subOffset = baseclass->GetBaseClassOffsetRecurse(cl);; 2806 if (subOffset == -2) return -2;; 2807 if (subOffset != -1) return offset+subOffset;; 2808 offset += baseclass->Size();; 2809 ; 2810 } else {; 2811 Error(""GetBaseClassOffsetRecurse"",""Unexpected element type for base class: %s\n"",element->IsA()->GetName());; 2812 }; 2813 }; 2814 }; 2815 return -1;; 2816 }; 2817 }; 2818 ; 2819 TClass *c;; 2820 Int_t off;; 2821 TBaseClass *inh;; 2822 TObjLink *lnk = nullptr;; 2823 if (fBase.load() == nullptr); 2824 lnk = GetListOfBases()->FirstLink();; 2825 else; 2826 lnk = fBase.load()->FirstLink();; 2827 ; 2828 // otherwise look at inheritance tree; 2829 while (lnk) {; 2830 inh = (TBaseClass *)lnk->GetObject();; 2831 //use option load=kFALSE to avoid a warning like:; 2832 //""Warning in <TClass::TClass>: no dictionary for class TRefCnt is available""; 2833 //We can not afford to not have the class if it exist, so we; 2834 //use kTRUE.; 2835 c = inh->GetClassPointer(kTRUE); // kFALSE);; 2836 if (c) {; 2837 if (cl == c) {; 2838 if ((inh->Property() & kIsVirtualBase) != 0); 2839 return -2;; 2840 return inh->GetDelta();; 2841 }; 2842 off = c->GetBaseClassOffsetRecurse(cl);; 2843 if (off == -2) return -2;; 2844 if (off != -1) {; 2845 return off + inh->GetDelta();; 2846 }; 2847 }; 2848 lnk = lnk->Next();; 2849 }; 2850 return -1;; 2851}; 2852 ; 2853////////////////////////////////////////////////////////////////////////////////; 2854/// - Return data member offset to the base class ""cl"".; 2855/// - Returns -1 in case ""cl"" i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:106010,load,load,106010,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"s * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7204 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7066 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7036 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4772 of file TClass.cxx. ◆ ForceReload(). void TClass::ForceReload ; (; TClass * ; oldcl). we found at least one equivalent. ; let's force a reload ; Definition at line 1336 of file TClass.cxx. ◆ GetActualClass(). TClass * TClass::GetActualClass ; (; const void * ; object); const. Return a pointer to the real class of the object. ; This is equivalent to object->IsA() when the class has a ClassDef. It is REQUIRED that object is coming from a proper pointer to the class represented by 'this'. Example: Special case: class MyClass : public AnotherClass, public TObject; TObjectMother of all ROOT objects.Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:68428,load,loaded,68428,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['loaded']
Performance,"s * ; onfile_cl, . UInt_t ; checksum . ); const. Return a Conversion StreamerInfo from the class represented by cl for the layout represented by 'checksum' to this class, if any. ; Definition at line 7271 of file TClass.cxx. ◆ FindStreamerInfo() [1/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; TObjArray * ; arr, . UInt_t ; checksum . ); const. protected . Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7133 of file TClass.cxx. ◆ FindStreamerInfo() [2/2]. TVirtualStreamerInfo * TClass::FindStreamerInfo ; (; UInt_t ; checksum, . Bool_t ; isTransient = kFALSE . ); const. Find the TVirtualStreamerInfo in the StreamerInfos corresponding to checksum. ; Definition at line 7103 of file TClass.cxx. ◆ FindStreamerInfoAbstractEmulated(). TVirtualStreamerInfo * TClass::FindStreamerInfoAbstractEmulated ; (; UInt_t ; checksum); const. For the case where the requestor class is emulated and this class is abstract, returns a pointer to the TVirtualStreamerInfo object for version with an emulated representation whether or not the class is loaded. ; If the object does not exist, it is created; Warning: If we create a new streamer info, whether or not the build optimizes is controlled externally to us by a global variable! Don't call us unless you have set that variable properly with TStreamer::Optimize()! ; Definition at line 4839 of file TClass.cxx. ◆ ForceReload(). void TClass::ForceReload ; (; TClass * ; oldcl). we found at least one equivalent. ; let's force a reload ; Definition at line 1403 of file TClass.cxx. ◆ GetActualClass(). TClass * TClass::GetActualClass ; (; const void * ; object); const. Return a pointer to the real class of the object. ; This is equivalent to object->IsA() when the class has a ClassDef. It is REQUIRED that object is coming from a proper pointer to the class represented by 'this'. Example: Special case: class MyClass : public AnotherClass, public TObject; TObjectMother of all ROOT objects.Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:68429,load,loaded,68429,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['loaded']
Performance,"s * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TNamed; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  . Public Attributes; RWebWindow & fWindow;  ! window reference ;  . Protected Member Functions; std::string GetCodeVersion () override;  Method generate extra suffix for all kinds of loaded code. ;  ; Bool_t ProcessBatchHolder (std::shared_ptr< THttpCallArg > &arg) override;  Method used to accept or reject root_batch_holder.js request. ;  ; void VerifyDefaultPageContent (std::shared_ptr< THttpCallArg > &arg) override;  Method called when default page content is prepared for use By default no-cache header is provided. ;  ;  Protected Member Functions inherited from THttpWSHandler;  THttpWSHandler (const char *name, const char *title, Bool_t syncmode=kTRUE);  normal constructor ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1RWebWindowWSHandler.html:12699,load,loaded,12699,doc/v632/classROOT_1_1RWebWindowWSHandler.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1RWebWindowWSHandler.html,2,['load'],['loaded']
Performance,"s 0 on failure. TObjArray* GetListOfLeaves(); -- Return a pointer to the list of leaves of the current tree. Warning: May set the current tree!. Double_t GetMaximum(const char* columname); -- Return maximum of column with name columname. Double_t GetMinimum(const char* columname); -- Return minimum of column with name columname. Int_t GetNbranches(); -- Return the number of branches of the current tree. Warning: May set the current tree!. Long64_t GetReadEntry() const; -- See TTree::GetReadEntry(). Double_t GetWeight() const; -- Return the chain weight. By default the weight is the weight of the current tree.; However, if the weight has been set in TChain::SetWeight(); with the option ""global"", then that weight will be returned. Warning: May set the current tree!. void InvalidateCurrentTree(); Set the TTree to be reloaded as soon as possible. In particular this; is needed when adding a Friend. Int_t LoadBaskets(Long64_t maxmemory); -- Dummy function.; It could be implemented and load all baskets of all trees in the chain.; For the time being use TChain::Merge and TTree::LoadBasket; on the resulting tree. Long64_t LoadTree(Long64_t entry); -- Find the tree which contains entry, and set it as the current tree. Returns the entry number in that tree. The input argument entry is the entry serial number in the whole chain. In case of error, LoadTree returns a negative number:; -1: The chain is empty.; -2: The requested entry number of less than zero or too large for the chain.; or too large for the large TTree.; -3: The file corresponding to the entry could not be correctly open; -4: The TChainElement corresponding to the entry is missing or; the TTree is missing from the file. Note: This is the only routine which sets the value of fTree to; a non-zero pointer. void Lookup(Bool_t force = kFALSE); Check / locate the files in the chain.; By default only the files not yet looked up are checked.; Use force = kTRUE to check / re-check every file. void Loop(Option_t* option = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TChain.html:41791,load,load,41791,root/html534/TChain.html,https://root.cern,https://root.cern/root/html534/TChain.html,6,['load'],['load']
Performance,"s ; (; const char * ; bname, . bool ; status = true, . UInt_t * ; found = nullptr . ). overridevirtual . Set branch status to Process or DoNotProcess. ; Parameters. [in]bnameis the name of a branch. if bname=""*"", apply to all branches. ; [in]status= 1 branch will be processed, = 0 branch will not be processed ; [out]found. See IMPORTANT REMARKS in TTree::SetBranchStatus and TChain::SetBranchAddress; If found is not 0, the number of branch(es) found matching the regular expression is returned in *found AND the error message 'unknown branch' is suppressed. ; Reimplemented from TTree.; Definition at line 2639 of file TChain.cxx. ◆ SetCacheSize(). Int_t TChain::SetCacheSize ; (; Long64_t ; cacheSize = -1). overridevirtual . Set maximum size of the file cache . . if cachesize = 0 the existing cache (if any) is deleted.; if cachesize = -1 (default) it is set to the AutoFlush value when writing the Tree (default is 30 MBytes). The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; Returns:; 0 size set, cache was created if possible; -1 on error . Reimplemented from TTree.; Definition at line 2467 of file TChain.cxx. ◆ SetDirectory(). void TChain::SetDirectory ; (; TDirectory * ; dir). overridevirtual . Remove reference to this chain from current directory and add reference to new directory dir. ; dir can be 0 in which case the chain does not belong to any directory. ; Reimplemented from TTree.; Definition at line 2666 of file TChain.cxx. ◆ SetEntryList(). void TChain::SetEntryList ; (; TEntryList * ; elist, . Option_t * ; opt = """" . ). overridevirtual . Set the input entry list (processing the entries of the chain will then be limited to the entries in the list). ; Parameters. [in]elistThe entry list to be assigned to this chain. ; [in]optAn option string. Possible values are:; """" (default): both the file names of the chain elements and the file names of the TEntryList sublists are expanded to full path name.; ""ne"": the file names are taken as they are and not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTChain.html:97543,cache,cacheSize,97543,doc/master/classTChain.html,https://root.cern,https://root.cern/doc/master/classTChain.html,2,['cache'],"['cache', 'cacheSize']"
Performance,"s ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooGenProdProj(); Default constructor. RooGenProdProj(const char* name, const char* title, const RooArgSet& _prodSet, const RooArgSet& _intSet, const RooArgSet& _normSet, const char* isetRangeName); Constructor for a normalization projection of the product of p.d.f.s _prodSet; integrated over _intSet in range isetRangeName while normalized over _normSet. RooGenProdProj(const RooGenProdProj& other, const char* name = 0); Copy constructor. ~RooGenProdProj(); Destructor. RooAbsReal* makeIntegral(const char* name, const RooArgSet& compSet, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName); Utility function to create integral over observables intSet in range isetRangeName over product of p.d.fs in compSet.; The integration is factorized into components as much as possible and done analytically as far as possible.; All component object needed to represent product integral are added as owned members to saveSet.; The return value is a RooAbsReal object representing the requested integral. Double_t evaluate() const; Calculate and return value of normalization projection. void operModeHook(); Intercept cache mode operation changes and propagate them to the components. TObject* clone(const char* newname) const; { return new RooGenProdProj(*this, newname); }. » Last changed: Mon Dec 7 13:47:54 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenProdProj.html:34258,cache,cache,34258,root/html526/RooGenProdProj.html,https://root.cern,https://root.cern/root/html526/RooGenProdProj.html,1,['cache'],['cache']
Performance,"s = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 )); , kMustCleanup = (1ULL << ( 3 )); , kIsReferenced = (1ULL << ( 4 )); , kHasUUID = (1ULL << ( 5 )); , ;   kCannotPick = (1ULL << ( 6 )); , kNoContextMenu = (1ULL << ( 8 )); , kInvalidObject = (1ULL << ( 13 )). };  ;  Public Types inherited from RooPrintable; enum  ContentsOption { ;   kName =1; , kClassName =2; , kValue =4; , kArgs =8; , ;   kExtras =16; , kAddress =32; , kTitle =64; , kCollectionHeader =128. };  ; enum  StyleOption { ;   kInline =1; , kSingleLine =2; , kStandard =3; , kVerbose =4; , ;   kTreeStructure =5. };  ;  Protected Types inherited from TObject; enum  { kOnlyPrepStep = (1ULL << ( 3 )); };  ;  Protected Attributes inherited from RooAbsGenContext; UInt_t _expectedEvents;  Number of expected events from extended p.d.f. ;  ; RooAbsPdf::ExtendMode _extendMode;  Extended mode capabilities of p.d.f. ;  ; RooDataSet * _genData = nullptr;  ! Data being generated ;  ; bool _isValid;  Is context in valid state? ;  ; Int_t _nextProtoIndex;  Next prototype event to load according to LUT. ;  ; TString _normRange;  Normalization range of pdf. ;  ; std::vector< Int_t > _protoOrder;  LUT with traversal order of prototype data. ;  ; const RooDataSet * _prototype;  Pointer to prototype dataset. ;  ; RooArgSet _protoVars;  Prototype observables. ;  ; RooArgSet _theEvent;  Pointer to observable event being generated. ;  ; bool _verbose;  Verbose messaging? ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooEffGenContext.h>. Inheritance diagram for RooEffGenContext:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooEffGenContext(). RooEffGenContext::RooEffGenContext ; (; const RooAbsPdf & ; model, . const RooAbsPdf & ; pdf, . const RooAbsReal & ; eff, . const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooEffGenContext.html:16648,load,load,16648,doc/master/classRooEffGenContext.html,https://root.cern,https://root.cern/doc/master/classRooEffGenContext.html,1,['load'],['load']
Performance,"s Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProduct(); Default constructor. ~RooProduct(); Destructor. RooProduct(const char* name, const char* title, const RooArgSet& _prodSet); Construct function representing the product of functions in prodSet. RooProduct(const RooProduct& other, const char* name = 0); Copy constructor. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force internal handling of integration of given observable if any; of the product terms depend on it. Int_t getPartIntList(const RooArgSet* iset, const char* rangeName = 0) const; Return list of (partial) integrals whose product defines the integral of this; RooProduct over the observables in iset in range isetRange. If no such list; exists, create it now and store it in the cache for future use. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Declare that we handle all integrations internally. Double_t analyticalIntegral(Int_t code, const char* rangeName = 0) const; Calculate integral internally from appropriate partial integral cache. Double_t calculate(const RooArgList& partIntList) const; Calculate and return product of partial terms in partIntList. const char* makeFPName(const char* pfx, const RooArgSet& terms) const; Construct automatic name for internal product terms. Double_t evaluate() const; Evaluate product of input functions. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooProduct to more intuitively reflect the contents of the; product operator construction. TObject* clone(const char* newname) const; { return new RooProduct(*this, newname); }. ProdMap* groupProductTerms(const RooArgSet& ) const. » Last changed: Mon Dec 7 13:48:44 2009 » Last generated: 2009-12-07 13:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProduct.html:33703,cache,cache,33703,root/html526/RooProduct.html,https://root.cern,https://root.cern/root/html526/RooProduct.html,1,['cache'],['cache']
Performance,"s RooSimWSTool::ObjBuildConfig. Class RooSimWSTool is a tool operating on RooWorkspace objects that; can clone p.d.f.s into a series of variations that are joined together; into a RooSimultanous p.d.f. The simplest use case to to take a workspace p.d.f as prototype and; 'split' a parameter of that p.d.f into two specialized parameters; depending on a category in the dataset. For example, given a Gaussian; p.d.f G(x,m,s) we want to construct a G_a(x,m_a,s) and a G_b(x,m_b,s); with different mean parameters to be fit to a dataset with observables; (x,c) where c is a category with states 'a' and 'b'. Using RooSimWSTool one can create a simultaneous p.d.f from G_a and G_b; from G with the following command. RooSimWSTool wst(wspace) ;; wst.build(""G_sim"",""G"",SplitParam(""m"",""c"")) ;. From this simple example one can go to builds of arbitrary complexity; by specifying multiple SplitParam arguments on multiple parameters; involving multiple splitting categories. Splits can also be performed; in the product multiple categories, e.g. SplitParam(""m"",""c,d"")) ;. splits parameter m in the product of states of c and d. Another possibility; is the 'constrained' split which clones the parameter for all but one state; and insert a formula specialization in a chosen state that evaluates; to 1 - sum_i(a_i) where a_i are all other specializations. For example,; given a category c with state ""A"",""B"",""C"",""D"" the specification. SplitParamConstrained(""m"",""c"",""D""). will result in parameters m_A,m_B,m_C and a formula expression m_D; that evaluates to (1-(m_A+m_B+m_C)). Constrained split can also be; specified in product of categories. In that case the name of the; remainder state follows the syntax ""{State1;State2}"" where State1 and; State2 are the state names of the two spitting categories. The examples so far deal with a single prototype p.d.f. It is also; possible to build with multiple prototype p.d.fs by specifying a; mapping between the prototype to use and the names of states of; a 'maste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSimWSTool__ObjBuildConfig.html:1291,perform,performed,1291,root/html526/RooSimWSTool__ObjBuildConfig.html,https://root.cern,https://root.cern/root/html526/RooSimWSTool__ObjBuildConfig.html,5,['perform'],['performed']
Performance,"s TClassStreamer. TClassStreamer is used to stream an object of a specific class. The address passed to operator() will be the address of the start; of the object. Function Members (Methods); public:. TClassStreamer(ClassStreamerFunc_t pointer); TClassStreamer(const TClassStreamer& rhs); virtual~TClassStreamer(); virtual TClassStreamer*Generate() const; virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* objp); TClassStreamer&operator=(const TClassStreamer&); virtual voidSetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* objp, const TClass* onfileClass). protected:. TClassStreamer(). Data Members; protected:. TClassReffOnFileClass. private:. ClassStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassStreamer(); {}. TClassStreamer(ClassStreamerFunc_t pointer); {}. TClassStreamer(const TClassStreamer& rhs); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. TClassStreamer * Generate() const; Virtual copy constructor. virtual ~TClassStreamer(); {}. void operator()(TBuffer& b, void* objp); The address passed to operator() will be the address of the start of the; object. void Stream(TBuffer& b, void* objp, const TClass* onfileClass); The address passed to operator() will be the address of the start of the; object. Overload this routine, if your derived class can optimize; the handling of the onfileClass (rather than storing and restoring from the; fOnFileClass member. » Author: Victor Perev and Philippe Canal 08/05/02 » Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *; » Last changed: root/base:$Id: TClassStreamer.h 36096 2010-10-05 21:27:26Z pcanal $ » Last generated: 2010-10-06 06:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClassStreamer.html:1744,optimiz,optimize,1744,root/html528/TClassStreamer.html,https://root.cern,https://root.cern/root/html528/TClassStreamer.html,1,['optimiz'],['optimize']
Performance,"s TClassStreamer. TClassStreamer is used to stream an object of a specific class. The address passed to operator() will be the address of the start; of the object. Function Members (Methods); public:. TClassStreamer(ClassStreamerFunc_t pointer); TClassStreamer(const TClassStreamer& rhs); virtual~TClassStreamer(); virtual TClassStreamer*Generate() const; virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* objp); TClassStreamer&operator=(const TClassStreamer&); virtual voidSetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* objp, const TClass* onfileClass). protected:. TClassStreamer(). Data Members; protected:. TClassReffOnFileClass. private:. ClassStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassStreamer(); {}. TClassStreamer(ClassStreamerFunc_t pointer); {}. TClassStreamer(const TClassStreamer& rhs); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. TClassStreamer * Generate() const; Virtual copy constructor. virtual ~TClassStreamer(); {}. void operator()(TBuffer& b, void* objp); The address passed to operator() will be the address of the start of the; object. void Stream(TBuffer& b, void* objp, const TClass* onfileClass); The address passed to operator() will be the address of the start of the; object. Overload this routine, if your derived class can optimize; the handling of the onfileClass (rather than storing and restoring from the; fOnFileClass member. » Author: Victor Perev and Philippe Canal 08/05/02 » Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *; » Last changed: root/base:$Id: TClassStreamer.h 36096 2010-10-05 21:27:26Z pcanal $ » Last generated: 2011-07-04 15:25; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TClassStreamer.html:1746,optimiz,optimize,1746,root/html530/TClassStreamer.html,https://root.cern,https://root.cern/root/html530/TClassStreamer.html,1,['optimiz'],['optimize']
Performance,"s TClassStreamer. TClassStreamer is used to stream an object of a specific class. The address passed to operator() will be the address of the start; of the object. Function Members (Methods); public:. TClassStreamer(ClassStreamerFunc_t pointer); TClassStreamer(const TClassStreamer& rhs); virtual~TClassStreamer(); virtual TClassStreamer*Generate() const; virtual const TClass*GetOnFileClass() const; virtual voidoperator()(TBuffer& b, void* objp); TClassStreamer&operator=(const TClassStreamer&); virtual voidSetOnFileClass(const TClass* cl); virtual voidStream(TBuffer& b, void* objp, const TClass* onfileClass). protected:. TClassStreamer(). Data Members; protected:. TClassReffOnFileClass. private:. ClassStreamerFunc_tfStreamer. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TClassStreamer(); {}. TClassStreamer(ClassStreamerFunc_t pointer); {}. TClassStreamer(const TClassStreamer& rhs); {}. void SetOnFileClass(const TClass* cl); { fOnFileClass = const_cast<TClass*>(cl); }. const TClass* GetOnFileClass() const; { return fOnFileClass; }. TClassStreamer * Generate() const; Virtual copy constructor. virtual ~TClassStreamer(); {}. void operator()(TBuffer& b, void* objp); The address passed to operator() will be the address of the start of the; object. void Stream(TBuffer& b, void* objp, const TClass* onfileClass); The address passed to operator() will be the address of the start of the; object. Overload this routine, if your derived class can optimize; the handling of the onfileClass (rather than storing and restoring from the; fOnFileClass member. » Author: Victor Perev and Philippe Canal 08/05/02 » Copyright (C) 1995-2003, Rene Brun, Fons Rademakers and al. *; » Last changed: root/base:$Id: TClassStreamer.h 36096 2010-10-05 21:27:26Z pcanal $ » Last generated: 2011-11-03 20:10; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClassStreamer.html:1746,optimiz,optimize,1746,root/html532/TClassStreamer.html,https://root.cern,https://root.cern/root/html532/TClassStreamer.html,2,['optimiz'],['optimize']
Performance,"s TFile's cache. ; Reimplemented in TSQLFile, TXMLFile, TDavixFile, TDCacheFile, TNetFile, TWebFile, and TNetXNGFile.; Definition at line 1720 of file TFile.cxx. ◆ ReadBufferAsync(). Bool_t TFile::ReadBufferAsync ; (; Long64_t ; offs, . Int_t ; len . ). virtual . Reimplemented in TDavixFile.; Definition at line 5208 of file TFile.cxx. ◆ ReadBuffers(). Bool_t TFile::ReadBuffers ; (; char * ; buf, . Long64_t * ; pos, . Int_t * ; len, . Int_t ; nbuf . ). virtual . Read the nbuf blocks described in arrays pos and len. ; The value pos[i] is the seek position of block i of length len[i]. Note that for nbuf=1, this call is equivalent to TFile::ReafBuffer. This function is overloaded by TNetFile, TWebFile, etc. Returns kTRUE in case of failure. ; Reimplemented in TDavixFile, TDCacheFile, TNetFile, TS3WebFile, TWebFile, and TNetXNGFile.; Definition at line 1821 of file TFile.cxx. ◆ ReadBufferViaCache(). Int_t TFile::ReadBufferViaCache ; (; char * ; buf, . Int_t ; len . ). protected . Read buffer via cache. ; Returns 0 if the requested block is not in the cache, 1 in case read via cache was successful, 2 in case read via cache failed. ; Definition at line 1889 of file TFile.cxx. ◆ ReadFree(). void TFile::ReadFree ; (; ). virtual . Read the FREE linked list. ; Every file has a linked list (fFree) of free segments. This linked list has been written on the file via WriteFree as a single data record. ; Reimplemented in TSQLFile, and TXMLFile.; Definition at line 1925 of file TFile.cxx. ◆ ReadProcessID(). TProcessID * TFile::ReadProcessID ; (; UShort_t ; pidf). virtual . The TProcessID with number pidf is read from this file. ; If the object is not already entered in the gROOT list, it is added. ; Definition at line 1951 of file TFile.cxx. ◆ ReadStreamerInfo(). void TFile::ReadStreamerInfo ; (; ). virtual . Read the list of StreamerInfo from this file. ; The key with name holding the list of TStreamerInfo objects is read. The corresponding TClass objects are updated. Note that this",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFile.html:87414,cache,cache,87414,doc/master/classTFile.html,https://root.cern,https://root.cern/doc/master/classTFile.html,1,['cache'],['cache']
Performance,"s TFile;; 64class TGraph;; 65class TH1F;; 66class TMultiGraph;; 67class TTree;; 68namespace TMVA {; 69 ; 70 class IMethod;; 71 class MethodBase;; 72 class DataInputHandler;; 73 class DataSetInfo;; 74 class DataSetManager;; 75 class DataLoader;; 76 class ROCCurve;; 77 class VariableTransformBase;; 78 ; 79 ; 80 class Factory : public Configurable {; 81 friend class CrossValidation;; 82 public:; 83 ; 84 typedef std::vector<IMethod*> MVector;; 85 std::map<TString,MVector*> fMethodsMap;//all methods for every dataset with the same name; 86 ; 87 // no default constructor; 88 Factory( TString theJobName, TFile* theTargetFile, TString theOption = """" );; 89 ; 90 // constructor to work without file; 91 Factory( TString theJobName, TString theOption = """" );; 92 ; 93 // default destructor; 94 virtual ~Factory();; 95 ; 96 // use TName::GetName and define correct name in constructor; 97 //virtual const char* GetName() const { return ""Factory""; }; 98 ; 99 ; 100 MethodBase* BookMethod( DataLoader *loader, TString theMethodName, TString methodTitle, TString theOption = """" );; 101 MethodBase* BookMethod( DataLoader *loader, Types::EMVA theMethod, TString methodTitle, TString theOption = """" );; 102 MethodBase* BookMethod( DataLoader *, TMVA::Types::EMVA /*theMethod*/,; 103 TString /*methodTitle*/,; 104 TString /*methodOption*/,; 105 TMVA::Types::EMVA /*theComposite*/,; 106 TString /*compositeOption = """"*/ ) { return nullptr; }; 107 ; 108 // optimize all booked methods (well, if desired by the method); 109 std::map<TString,Double_t> OptimizeAllMethods (TString fomType=""ROCIntegral"", TString fitType=""FitGA"");; 110 void OptimizeAllMethodsForClassification(TString fomType=""ROCIntegral"", TString fitType=""FitGA"") { OptimizeAllMethods(fomType,fitType); }; 111 void OptimizeAllMethodsForRegression (TString fomType=""ROCIntegral"", TString fitType=""FitGA"") { OptimizeAllMethods(fomType,fitType); }; 112 ; 113 // training for all booked methods; 114 void TrainAllMethods ();; 115 void TrainAllMethodsF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html:3615,load,loader,3615,doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2inc_2TMVA_2Factory_8h_source.html,1,['load'],['loader']
Performance,"s TVirtualViewer3D.; Definition at line 329 of file TGLScenePad.cxx. ◆ AddObject() [2/2]. Int_t TGLScenePad::AddObject ; (; UInt_t ; physicalID, . const TBuffer3D & ; buffer, . Bool_t * ; addChildren = nullptr . ). overridevirtual . Add an object to the scene, using an external physical ID TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx for description of viewer architecture. ; Implements TVirtualViewer3D.; Definition at line 342 of file TGLScenePad.cxx. ◆ AttemptDirectRenderer(). TGLLogicalShape * TGLScenePad::AttemptDirectRenderer ; (; TObject * ; id). protected . Try to construct an appropriate logical-shape sub-class based on id'class, following convention that SomeClassGL is a suitable renderer for class SomeClass. ; Definition at line 778 of file TGLScenePad.cxx. ◆ BeginScene(). void TGLScenePad::BeginScene ; (; ). overridevirtual . Start building of the scene. ; Old contents is dropped, unless smart-refresh is in active. Then the object supporting it are kept in a cache and possibly reused.; TVirtualViewer3D interface overload - see base/src/TVirtualViewer3D.cxx for description of viewer architecture. ; Implements TVirtualViewer3D.; Definition at line 259 of file TGLScenePad.cxx. ◆ BuildComposite(). RootCsg::TBaseMesh * TGLScenePad::BuildComposite ; (; ). protected . Build and return composite shape mesh. ; Definition at line 749 of file TGLScenePad.cxx. ◆ BuildingScene(). Bool_t TGLScenePad::BuildingScene ; (; ); const. inlineoverridevirtual . Implements TVirtualViewer3D.; Definition at line 89 of file TGLScenePad.h. ◆ CanLoopOnPrimitives(). Bool_t TGLScenePad::CanLoopOnPrimitives ; (; ); const. inlineoverridevirtual . Reimplemented from TVirtualViewer3D.; Definition at line 78 of file TGLScenePad.h. ◆ Class(). static TClass * TGLScenePad::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TGLScenePad::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constex",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLScenePad.html:27388,cache,cache,27388,doc/master/classTGLScenePad.html,https://root.cern,https://root.cern/doc/master/classTGLScenePad.html,1,['cache'],['cache']
Performance,"s a ""/"", the function assumes a folder name.; In this case, it creates automatically branches following the folder hierarchy.; splitlevel may be used in this case to control the split level. ~TTree(); Destructor. TBuffer* GetTransientBuffer(Int_t size); Returns the transient buffer currently used by this TTree for reading/writing baskets. void AddBranchToCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddBranchToCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(const char* bname, Bool_t subbranches = kFALSE); Add branch with name bname to the Tree cache.; If bname=""*"" all branches are added to the cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void DropBranchFromCache(TBranch* branch, Bool_t subbranches = kFALSE); Add branch b to the Tree cache.; if subbranches is true all the branches of the subbranches are; also put to the cache. void AddClone(TTree* ); Add a cloned tree to our list of trees to be notified whenever we change; our branch addresses or when we are deleted. TFriendElement* AddFriend(const char* treename, const char* filename = """"); Add a TFriendElement to the list of friends. This function:; -opens a file if filename is specified; -reads a Tree with name treename from the file (current directory); -adds the Tree to the list of friends; see other AddFriend functions. A TFriendElement TF describes a TTree object TF in a file.; When a TFriendElement TF is added to the the list of friends of an; existing TTree T, any variable from TF can be referenced in a query; to T. A tree keeps a list of friends. In the context of a tree (or a chain),; friendship means unrestricted ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:35599,cache,cache,35599,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,2,['cache'],['cache']
Performance,"s a callable that takes N arguments of type T, passes them down to function func as an initializer list {t1, t2, t3,..., tN} and returns whatever f({t1, t2, t3, ..., tN}) returns.; Note that for this to work with RDataFrame the type of all columns that the callable is applied to must be exactly T. Example usage together with RDataFrame (""varX"" columns must all be float variables): bool myVecFunc(std::vector<float> args);; df.Filter(PassAsVec<3, float>(myVecFunc), {""var1"", ""var2"", ""var3""});. Definition at line 103 of file RDFHelpers.hxx. ◆ RunGraphs(). unsigned int ROOT::RDF::RunGraphs ; (; std::vector< RResultHandle > ; handles). Trigger the event loop of multiple RDataFrames concurrently. ; Parameters. [in]handlesA vector of RResultHandles . ReturnsThe number of distinct computation graphs that have been processed; This function triggers the event loop of all computation graphs which relate to the given RResultHandles. The advantage compared to running the event loop implicitly by accessing the RResultPtr is that the event loops will run concurrently. Therefore, the overall computation of all results is generally more efficient. It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ROOT::RDataFrame df1(""tree1"", ""file1.root"");; auto r1 = df1.Histo1D(""var1"");; ; ROOT::RDataFrame df2(""tree2"", ""file2.root"");; auto r2 = df2.Sum(""var2"");; ; // RResultPtr -> RResultHandle conversion is automatic; ROOT::RDF::RunGraphs({r1, r2});; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Definition at line 66 of file RDFHelpers.cxx. ◆ SaveGraph() [1/2]. template<typename NodeType > . std::string ROOT::RDF::SaveGraph ; (; No",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:13890,concurren,concurrently,13890,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,2,['concurren'],['concurrently']
Performance,"s a failure.; 1001 ; 1002Int_t TChain::GetEntry(Long64_t entry, Int_t getall); 1003{; 1004 Long64_t treeReadEntry = LoadTree(entry);; 1005 if (treeReadEntry < 0) {; 1006 return 0;; 1007 }; 1008 if (!fTree) {; 1009 return 0;; 1010 }; 1011 return fTree->GetEntry(treeReadEntry, getall);; 1012}; 1013 ; 1014////////////////////////////////////////////////////////////////////////////////; 1015/// Return entry number corresponding to entry.; 1016///; 1017/// if no TEntryList set returns entry; 1018/// else returns entry \#entry from this entry list and; 1019/// also computes the global entry number (loads all tree headers); 1020 ; 1021Long64_t TChain::GetEntryNumber(Long64_t entry) const; 1022{; 1023 ; 1024 if (fEntryList){; 1025 Int_t treenum = 0;; 1026 Long64_t localentry = fEntryList->GetEntryAndTree(entry, treenum);; 1027 //find the global entry number; 1028 //same const_cast as in the GetEntries() function; 1029 if (localentry<0) return -1;; 1030 if (treenum != fTreeNumber){; 1031 if (fTreeOffset[treenum]==TTree::kMaxEntries){; 1032 for (Int_t i=0; i<=treenum; i++){; 1033 if (fTreeOffset[i]==TTree::kMaxEntries); 1034 (const_cast<TChain*>(this))->LoadTree(fTreeOffset[i-1]);; 1035 }; 1036 }; 1037 //(const_cast<TChain*>(this))->LoadTree(fTreeOffset[treenum]);; 1038 }; 1039 Long64_t globalentry = fTreeOffset[treenum] + localentry;; 1040 return globalentry;; 1041 }; 1042 return entry;; 1043}; 1044 ; 1045////////////////////////////////////////////////////////////////////////////////; 1046/// Return entry corresponding to major and minor number.; 1047///; 1048/// The function returns the total number of bytes read.; 1049/// If the Tree has friend trees, the corresponding entry with; 1050/// the index values (major,minor) is read. Note that the master Tree; 1051/// and its friend may have different entry serial numbers corresponding; 1052/// to (major,minor).; 1053 ; 1054Int_t TChain::GetEntryWithIndex(Int_t major, Int_t minor); 1055{; 1056 Long64_t serial = GetEntryNumberWi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:38227,load,loads,38227,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loads']
Performance,"s also an implementation of the linear fitter (class TLinearFitter), for solving linear least square fits.; Minuit2: new object-oriented implementation of MINUIT, with the same minimization algorithms (such as Migrad or Simplex). In addition it provides a new implementation of the Fumili algorithm, a specialized method for finding the minimum of a standard least square or likelihood functions.; Fumili: library providing the implementation of the original Fumili fitting algorithm (class TFumili). Linear algebra. Two libraries are contained in ROOT for describing linear algebra matrices and vector classes:; Matrix: general matrix package providing matrix classes (TMatrixD and TMatrixF) and vector classes (TVectorD and TVectorF) and the complete environment to perform linear algebra calculations, like equation solving and eigenvalue decompositions.; SMatrix: package optimized for high performances matrix and vector computations of small and fixed size. It is based on expression templates to achieve an high level optimization. Physics Vectors: Classes for describing vectors in 2, 3 and 4 dimensions (relativistic vectors) and their rotation and transformation algorithms. Two package exist in ROOT:; Physics: library with the TVector3 and TLorentzVector classes.; GenVector: new library providing generic class templates for modeling the vectors. See the GenVector page. UNURAN: Package with universal algorithms for generating non-uniform pseudo-random numbers, from a large classes of continuous or discrete distributions in one or multi-dimensions.; Foam Multi-dimensional general purpose Monte Carlo event generator (and integrator). It generates randomly points (vectors) according to an arbitrary probability distribution in n dimensions.; FFTW Library with implementation of the fast Fourier transform (FFT) using the FFTW package. It requires a previous installation of FFTW.; MLP Library with the neural network class, TMultiLayerPerceptron based on the NN algorithm from the mlp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Math.html:2941,optimiz,optimization,2941,doc/master/group__Math.html,https://root.cern,https://root.cern/doc/master/group__Math.html,2,['optimiz'],['optimization']
Performance,"s and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility.; WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum. They are both used to handle backward compatibility and should both return the same values. TStreamerInfo uses the information in TStreamerElement while TClass uses the information from TClass::GetListOfBases and TClass::GetListOfDataMembers. ; Definition at line 6544 of file TClass.cxx. ◆ GetCheckSum() [3/3]. UInt_t TClass::GetCheckSum ; (; ECheckSum ; code = kCurrentCheckSum); const. Call GetCheckSum with validity check. ; Definition at line 6505 of file TClass.cxx. ◆ GetClass() [1/6]. template<typename T > . TClass * TClass::GetClass ; (; Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Definition at line 655 of file TClass.h. ◆ GetClass() [2/6]. TClass * TClass::GetClass ; (; ClassInfo_t * ; info, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified ClassInfo. ; If load is true an attempt is made to obtain the class by loading the appropriate shared library (directed by the rootmap file). If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members) Returns 0 in case class is not found. ; Definition at line 3351 of file TClass.cxx. ◆ GetClass() [3/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load, . Bool_t ; silent, . size_t ; hint_pair_offset, . size_t ; hint_pair_size . ). static . Definition at line 2973 of file TClass.cxx. ◆ GetClass() [4/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified class name. ; If load is true, an attempt is made to obtain the class by loading the appropriate shared ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:72975,load,load,72975,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance,"s and base classes, not including the ranges and array size found in comments.; kWithTypeDef: use the sugared type name in the calculation. This is needed for backward compatibility.; WARNING: this function must be kept in sync with TStreamerInfo::GetCheckSum. They are both used to handle backward compatibility and should both return the same values. TStreamerInfo uses the information in TStreamerElement while TClass uses the information from TClass::GetListOfBases and TClass::GetListOfDataMembers. ; Definition at line 6611 of file TClass.cxx. ◆ GetCheckSum() [3/3]. UInt_t TClass::GetCheckSum ; (; ECheckSum ; code = kCurrentCheckSum); const. Call GetCheckSum with validity check. ; Definition at line 6572 of file TClass.cxx. ◆ GetClass() [1/6]. template<typename T > . TClass * TClass::GetClass ; (; Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Definition at line 655 of file TClass.h. ◆ GetClass() [2/6]. TClass * TClass::GetClass ; (; ClassInfo_t * ; info, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified ClassInfo. ; If load is true an attempt is made to obtain the class by loading the appropriate shared library (directed by the rootmap file). If silent is 'true', do not warn about missing dictionary for the class. (typically used for class that are used only for transient members) Returns 0 in case class is not found. ; Definition at line 3418 of file TClass.cxx. ◆ GetClass() [3/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load, . Bool_t ; silent, . size_t ; hint_pair_offset, . size_t ; hint_pair_size . ). static . Definition at line 3040 of file TClass.cxx. ◆ GetClass() [4/6]. TClass * TClass::GetClass ; (; const char * ; name, . Bool_t ; load = kTRUE, . Bool_t ; silent = kFALSE . ). static . Static method returning pointer to TClass of the specified class name. ; If load is true, an attempt is made to obtain the class by loading the appropriate shared ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:72976,load,load,72976,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance,"s are not deleted. ; Reimplemented from TProof.; Definition at line 2104 of file TProofLite.cxx. ◆ RequestStagingDataSet(). Bool_t TProofLite::RequestStagingDataSet ; (; const char * ; dataset). overridevirtual . Allows users to request staging of a particular dataset. ; Requests are saved in a special dataset repository and must be honored by the endpoint. This is the special PROOF-Lite re-implementation of the TProof function and includes code originally implemented in TProofServ. ; Reimplemented from TProof.; Definition at line 2131 of file TProofLite.cxx. ◆ ResolveKeywords(). void TProofLite::ResolveKeywords ; (; TString & ; s, . const char * ; ord, . const char * ; logfile . ). private . Resolve some keywords in 's' <logfilewrk>, <user>, <rootsys>, <cpupin> ; Definition at line 801 of file TProofLite.cxx. ◆ SendInputDataFile(). void TProofLite::SendInputDataFile ; (; ). overrideprivatevirtual . Make sure that the input data objects are available to the workers in a dedicated file in the cache; the objects are taken from the dedicated list and / or the specified file. ; If the fInputData is empty the specified file is sent over. If there is no specified file, a file named ""inputdata.root"" is created locally with the content of fInputData and sent over to the master. If both fInputData and the specified file are not empty, a copy of the file is made locally and augmented with the content of fInputData. ; Reimplemented from TProof.; Definition at line 2310 of file TProofLite.cxx. ◆ SetDataSetTreeName(). Int_t TProofLite::SetDataSetTreeName ; (; const char * ; dataset, . const char * ; treename . ). overridevirtual . Set/Change the name of the default tree. ; The tree name may contain subdir specification in the form ""subdir/name"". Returns 0 on success, -1 otherwise. ; Reimplemented from TProof.; Definition at line 2002 of file TProofLite.cxx. ◆ SetProofServEnv(). Int_t TProofLite::SetProofServEnv ; (; const char * ; ord). private . Create environment files for wor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:64820,cache,cache,64820,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['cache'],['cache']
Performance,"s are provided to change the default values. It is possible to print the list of default control parameters using the ROOT::Math::IntegratorMultiDimOptions::Print function. Example:; ROOT::Math::IntegratorMultiDimOptions opt;; opt.Print();; Integrator Type : ADAPTIVE; Absolute tolerance : 1e-09; Relative tolerance : 1e-09; Workspace size : 100000; (max) function calls : 100000; Depending on the algorithm, some of the control parameters might have no effect.; 13.8.3.3 ROOT::Math::AdaptiveIntegratorMultiDim; This class implements an adaptive quadrature integration method for multi dimensional functions. It is described in this paper Genz, A.A. Malik, An adaptive algorithm for numerical integration over an N-dimensional rectangular region, J. Comput. Appl. Math. 6 (1980) 295-302. It is part of the MathCore library. The user can control the relative and absolute tolerance and the maximum allowed number of function evaluation.; 13.8.3.4 ROOT::Math::GSLMCIntegrator; It is a class for performing numerical integration of a multidimensional function. It uses the numerical integration algorithms of GSL, which reimplements the algorithms used in the QUADPACK, a numerical integration package written in Fortran. Plain MC, MISER and VEGAS integration algorithms are supported for integration over finite (hypercubic) ranges. For a detail description of the GSL methods visit the GSL users guide. Specific configuration options (documented in the GSL user guide) for the ROOT::Math::GSLMCIntegration can be set directly in the class, or when using it via the ROOT::Math::IntegratorMultiDim interface, can be defined using the ROOT::Math::IntegratorMultiDimOptions.; 13.9 Function Derivation; There are in ROOT only two classes to perform numerical derivation. One of them is in the MathCore library while the other is in the MathMore wrapping an integration function from the GSL library. * RichardsonDerivator: Implements the Richardson method for numerical integration. It can calculate up to t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:712606,perform,performing,712606,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['performing']
Performance,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(Double32_t& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(Double32_t& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html:10003,perform,performing,10003,root/html534/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SMatrix_Double32_t_3_3_-p1MatRepStd_Double32_t_3_3___.html,16,['perform'],['performing']
Performance,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(double& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(double& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html:9670,perform,performing,9670,root/html534/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SMatrix_double_2_2_-p1MatRepStd_double_2_2___.html,122,['perform'],['performing']
Performance,"s based on direct inversion using the Cramer rule for; matrices upto 5x5. Afterwards the same default algorithm of Invert() is used.; Note that this method is faster but can suffer from much larger numerical accuracy; when the condition of the matrix is large. SMatrix<T,D1,D2,R> InverseFast(int& ifail) const. Invert a square Matrix and returns a new matrix. In case the inversion fails; the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertFast for the inversion algorithm. bool InvertChol(). Invertion of a symmetric positive defined Matrix using Choleski decomposition.; ( this method changes the current matrix).; Return true if inversion is successfull.; The method used is based on Choleski decomposition; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; For solving a linear system, it is possible to use also the function; ROOT::Math::SolveChol(matrix, vector) which will be faster than performing the inversion. SMatrix<T,D1,D2,R> InverseChol(int& ifail) const. Invert of a symmetric positive defined Matrix using Choleski decomposition.; A compile error is given if the matrix is not of type symmetric and a run-time failure if the; matrix is not positive defined.; In case the inversion fails the current matrix is returned.; \param ifail . ifail will be set to 0 when inversion is successfull.; See ROOT::Math::SMatrix::InvertChol for the inversion algorithm. bool Det(float& det). determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will destroy the contents of the Matrix!. bool Det2(float& det) const. determinant of square Matrix via Dfact.; Return true when the calculation is successfull.; \param det will contain the calculated determinant value; \b Note: this will preserve the content of the Matrix!. SVector",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html:9565,perform,performing,9565,root/html534/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__SMatrix_float_2_2_-p1MatRepStd_float_2_2___.html,90,['perform'],['performing']
Performance,"s been filled with weights different than one, a weighted likelihood method can be used and the errors retrieved from the fit are corrected following a procedure described in paragraph 8.5.2 of the book, F. James, Statistical Methods in Experimental Physics, 2nd Edition.; 5.5.4 Fit Statistics; You can change the statistics box to display the fit parameters with the TStyle::SetOptFit(mode) method. This parameter has four digits: mode = pcev (default = 0111). p = 1 print probability; c = 1 print Chi-square/number of degrees of freedom; e = 1 print errors (if e=1, v must be 1); v = 1 print name/values of parameters. For example, to print the fit probability, parameter names/values, and errors, use:; gStyle->SetOptFit(1011);; 5.6 The Fit Panel. The Fit Panel. To display the Fit Panel right click on a histogram to pop up the context menu, and then select the menu entry Fit Panel.; The new Fit Panel GUI is available in ROOT v5.14. Its goal is to replace the old Fit Panel and to provide more user friendly way for performing, exploring and comparing fits.; By design, this user interface is planned to contain two tabs: “General” and “Minimization”. Currently, the “General” tab provides user interface elements for setting the fit function, fit method and different fit, draw, print options. The “Minimization tab” provides the option to set the Minimizer to use in the fit and its specific options.; The new fit panel is a modeless dialog, i.e. when opened, it does not prevent users from interacting with other windows. Its first prototype is a singleton application. When the Fit Panel is activated, users can select an object for fitting in the usual way, i.e. by left-mouse click on it. If the selected object is suitable for fitting, the fit panel is connected with this object and users can perform fits by setting different parameters and options.; 5.6.1 Function Choice and Settings; ‘Predefined’ combo box - contains a list of predefined functions in ROOT. You have a choice of seve",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:182323,perform,performing,182323,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['performing']
Performance,"s browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Enumeration Documentation. ◆ BufStrat. enum RooFFTConvPdf::BufStrat. EnumeratorExtend ; Mirror ; Flat . Definition at line 47 of file RooFFTConvPdf.h. Constructor & Destructor Documentation. ◆ RooFFTConvPdf() [1/4]. RooFFTConvPdf::RooFFTConvPdf ; (; ). inline . Definition at line 28 of file RooFFTConvPdf.h. ◆ RooFFTConvPdf() [2/4]. RooFFTConvPdf::RooFFTConvPdf ; (; const char * ; name, . const char * ; title, . RooRealVar & ; convVar, . RooAbsPdf & ; pdf1, . RooAbsPdf & ; pdf2, . Int_t ; ipOrder = 2 . ). Constructor for numerical (FFT) convolution of PDFs. ; Parameters. [in]nameName of this PDF ; [in]titleTitle for plotting this PDF ; [in]convVarObservable to convolve the PDFs in . AttentionUse a high number of bins (>= 1000) for good accuracy. ; Parameters. [in]pdf1First PDF to be convolved ; [in]pdf2Second PDF to be convolved ; [in]ipOrderOrder for interpolation between bins (since FFT is discrete) The binning used for the FFT sampling is controlled by the binning named ""cache"" in the convolution observable convVar. If such a binning is not set, the same number of bins as for convVar will be used. . Definition at line 223 of file RooFFTConvPdf.cxx. ◆ RooFFTConvPdf() [3/4]. RooFFTConvPdf::RooFFTConvPdf ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; pdfConvVar, . RooRealVar & ; convVar, . RooAbsPdf & ; pdf1, . RooAbsPdf & ; pdf2, . Int_t ; ipOrder = 2 . ). Constructor for numerical (FFT) convolution of PDFs. ; Parameters. [in]nameName of this PDF ; [in]titleTitle for plotting this PDF ; [in]convVarObservable to convolve the PDFs in . AttentionUse a high number of bins (>= 1000) for good accuracy. ; Parameters. [in]pdf1First PDF to be convolved ; [in]pdf2Second PDF to be convolved ; [in]ipOrderOrder for interpolation between bins (since FFT is discrete) The binning used for the FFT sampling is controlled by the binning named ""cache"" in the convolutio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:85240,cache,cache,85240,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,"s class imposes special end-point conditions on the interpolated histogram that represents the output so that the value at the lower bound is guaranteed to converge to exactly zero and that the value at the upper bound is guaranteed to converge to exactly one, at all interpolation orders. ; Definition at line 17 of file RooNumCdf.h. Public Member Functions;  RooNumCdf (const char *name, const char *title, RooAbsPdf &_pdf, RooRealVar &_x, const char *binningName=""cache"");  Construct a cumulative distribution function from given input p.d.f over observable x. ;  ;  RooNumCdf (const RooNumCdf &other, const char *name=nullptr);  ; TObject * clone (const char *newname) const override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooNumRunningInt;  RooNumRunningInt (const char *name, const char *title, RooAbsReal &_func, RooRealVar &_x, const char *binningName=""cache"");  Construct running integral of function '_func' over x_print from the lower bound on _x to the present value of _x using a numeric sampling technique. ;  ;  RooNumRunningInt (const RooNumRunningInt &other, const char *name=nullptr);  Copy constructor. ;  ;  ~RooNumRunningInt () override;  Destructor. ;  ; TObject * clone (const char *newname) const override;  ; TClass * IsA () const override;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooAbsCachedReal;  RooAbsCachedReal ();  ;  RooAbsCachedReal (const char *name, const char *title, Int_t ipOrder=0);  Constructor. ;  ;  RooAbsCachedReal (const RooAbsCachedReal &other, const char *name=nullptr);  Copy constructor. ;  ; double analyticalIntegralWN (Int_t code, const RooArgSet *normSet, const char *rangeName=nullptr) const override;  Forward call to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumCdf.html:1515,cache,cache,1515,doc/master/classRooNumCdf.html,https://root.cern,https://root.cern/doc/master/classRooNumCdf.html,1,['cache'],['cache']
Performance,s code and instance factory ; RooCmdArg Generic named argument container; RooCmdConfig Configurable parse of RooCmdArg objects; RooComplex a non-persistent bare-bones complex class; RooCompositeDataStore Composite Data Storage class; RooConstVar Constant RooAbsReal value object; RooConstraintSum sum of -log of set of RooAbsPdf representing parameter constraints; RooConvCoefVar Auxiliary class representing the coefficient of a RooAbsAnaConvPdf as a RooAbsReal; RooConvGenContext Context for generating a dataset from a PDF; RooConvIntegrandBinding RooAbsFunc representation of convolution integrands; RooCurve 1-dimensional smooth curve for use in RooPlots; RooCustomizer Editing tool for RooAbsArg composite object expressions; RooDLLSignificanceMCSModule MCStudy module to calculate Delta(-logL) significance w.r.t given null hypothesis; RooDataHist Binned data set; RooDataHistSliceIter Iterator over a one-dimensional slice of a RooDataHist; RooDataProjBinding RealFunc/Dataset binding for data projection of a real function; RooDataSet Unbinned data set; RooDataWeightedAverage Optimized calculator of data weighted average of a RooAbsReal; RooDecay General decay function p.d.f ; RooDerivative Representation of derivative of any RooAbsReal; RooDirItem Base class for RooFit objects that are listed TDirectories; RooDouble Container class for Double_t; RooDstD0BG D*-D0 mass difference background PDF; RooEffGenContext Context for generating a dataset from a PDF; RooEffProd Product operator p.d.f of (PDF x efficiency) implementing optimized generator context; RooEfficiency Generic PDF defined by string expression and list of variables; RooEllipse 2-dimensional contour; RooErrorVar RooAbsRealLValue representation of an error of a RooRealVar; RooExpensiveObjectCache Singleton class that serves as session repository for expensive objects; RooExpensiveObjectCache::ExpensiveObject Cache element containing expensive object and parameter values for which object is valid; RooExponential Ex,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ClassIndex.html:34644,Optimiz,Optimized,34644,root/html534/ClassIndex.html,https://root.cern,https://root.cern/root/html534/ClassIndex.html,1,['Optimiz'],['Optimized']
Performance,"s create a new instance of class T to represent the ""Sum"" object. This method is not thread safe: correct or acceptable behaviours depend on the nature of T and of the merging function. ; Definition at line 312 of file TThreadedObject.hxx. Member Data Documentation. ◆ fDirectories. template<class T > . std::deque<TDirectory*> ROOT::TThreadedObject< T >::fDirectories. private . A TDirectory per slot. ; Definition at line 332 of file TThreadedObject.hxx. ◆ fgMaxSlots. template<class T > . constexpr const TNumSlots ROOT::TThreadedObject< T >::fgMaxSlots {64}. staticconstexpr . The initial number of empty processing slots that a TThreadedObject is constructed with by default. ; Deprecated: TThreadedObject grows as more slots are required. ; Definition at line 155 of file TThreadedObject.hxx. ◆ fIsMerged. template<class T > . bool ROOT::TThreadedObject< T >::fIsMerged. private . Remember if the objects have been merged already. ; Definition at line 335 of file TThreadedObject.hxx. ◆ fModel. template<class T > . std::unique_ptr<T> ROOT::TThreadedObject< T >::fModel. private . Use to store a ""model"" of the object. ; Definition at line 327 of file TThreadedObject.hxx. ◆ fObjPointers. template<class T > . std::deque<std::shared_ptr<T> > ROOT::TThreadedObject< T >::fObjPointers. private . An object pointer per slot. ; Definition at line 329 of file TThreadedObject.hxx. ◆ fSpinMutex. template<class T > . ROOT::TSpinMutex ROOT::TThreadedObject< T >::fSpinMutex. mutableprivate . Protects concurrent access to fThrIDSlotMap, fObjPointers. ; Definition at line 334 of file TThreadedObject.hxx. ◆ fThrIDSlotMap. template<class T > . std::map<std::thread::id, unsigned> ROOT::TThreadedObject< T >::fThrIDSlotMap. private . A mapping between the thread IDs and the slots. ; Definition at line 333 of file TThreadedObject.hxx. core/thread/inc/ROOT/TThreadedObject.hxx. ROOTTThreadedObject. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:45:00 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1TThreadedObject.html:10679,concurren,concurrent,10679,doc/master/classROOT_1_1TThreadedObject.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1TThreadedObject.html,1,['concurren'],['concurrent']
Performance,"s custom dashed lines on the lower plot, specified by a vector of floats. ;  ;  ratioplot4.py;   Example that shows custom dashed lines on the lower plot, specified by a vector of floats. ;  ;  ratioplot5.C;   Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ;  ;  ratioplot5.py;   Example that shows how you can set the colors of the confidence interval bands by using the method TRatioPlot::SetConfidenceIntervalColors. ;  ;  ratioplot6.C;   Example showing a fit residual plot, where the separation margin has been set to 0. ;  ;  ratioplot6.py;   Example showing a fit residual plot, where the separation margin has been set to 0. ;  ;  ratioplotOld.C;  Example displaying two histograms and their ratio. ;  ;  rebin.C;   Rebin a variable bin-width histogram. ;  ;  reverseaxis.C;   Example showing an histogram with reverse axis. ;  ;  sparsehist.C;  Evaluate the performance of THnSparse vs TH1/2/3/nF for different numbers of dimensions and bins per dimension. ;  ;  statsEditing.C;   Edit statistics box. ;  ;  testSmooth.C;   Histogram smoothing. ;  ;  th2polyBoxes.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly). ;  ;  th2polyEurope.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it. ;  ;  th2polyHoneycomb.C;   This tutorial illustrates how to create an histogram with hexagonal bins (TH2Poly). ;  ;  th2polyUSA.C;   This tutorial illustrates how to create an histogram with polygonal bins (TH2Poly), fill it and draw it using the col option. ;  ;  thstack2palettecolor.C;   Palette coloring for 2D histograms' stack is activated thanks to the option PFC (Palette Fill Color). ;  ;  thstackcolorscheme.C;   This example demonstrates how to use the accessible color schemes with THStack. ;  ;  thstackpalettecolor.C;   Palette coloring for histograms' stack is activated thanks to the options PFC (Pa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html:5037,perform,performance,5037,doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,https://root.cern,https://root.cern/doc/master/dir_cb5b3ace9d7fddaf972edd3edd27e2ab.html,1,['perform'],['performance']
Performance,"s deleted.; 8675/// - if cachesize = -1 (default) it is set to the AutoFlush value when writing; 8676/// the Tree (default is 30 MBytes).; 8677///; 8678/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8679///; 8680/// Returns:; 8681/// - 0 size set, cache was created if possible; 8682/// - -1 on error; 8683 ; 8684Int_t TTree::SetCacheSize(Long64_t cacheSize); 8685{; 8686 // remember that the user has requested an explicit cache setup; 8687 fCacheUserSet = true;; 8688 ; 8689 return SetCacheSizeAux(false, cacheSize);; 8690}; 8691 ; 8692////////////////////////////////////////////////////////////////////////////////; 8693/// Set the size of the file cache and create it if possible.; 8694///; 8695/// If autocache is true:; 8696/// this may be an autocreated cache, possibly enlarging an existing; 8697/// autocreated cache. The size is calculated. The value passed in cacheSize:; 8698/// - cacheSize = 0 make cache if default cache creation is enabled; 8699/// - cacheSize = -1 make a default sized cache in any case; 8700///; 8701/// If autocache is false:; 8702/// this is a user requested cache. cacheSize is used to size the cache.; 8703/// This cache should never be automatically adjusted.; 8704///; 8705/// The cacheSize might be clamped, see TFileCacheRead::SetBufferSize; 8706///; 8707/// Returns:; 8708/// - 0 size set, or existing autosized cache almost large enough.; 8709/// (cache was created if possible); 8710/// - -1 on error; 8711 ; 8712Int_t TTree::SetCacheSizeAux(bool autocache /* = true */, Long64_t cacheSize /* = 0 */ ); 8713{; 8714 if (autocache) {; 8715 // used as a once only control for automatic cache setup; 8716 fCacheDoAutoInit = false;; 8717 }; 8718 ; 8719 if (!autocache) {; 8720 // negative size means the user requests the default; 8721 if (cacheSize < 0) {; 8722 cacheSize = GetCacheAutoSize(true);; 8723 }; 8724 } else {; 8725 if (cacheSize == 0) {; 8726 cacheSize = GetCacheAutoSize();; 8727 } else if (cacheSize < 0) {; 8728 cacheSiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:338768,cache,cacheSize,338768,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,7,['cache'],"['cache', 'cacheSize']"
Performance,s division optimization check box; TGNumberEntry*fXTickLengthX axis tick length number entry; TGColorSelect*fXTitleColorX axis title color selection widget; TGFontTypeComboBox*fXTitleFontX axis title font combo box; TGNumberEntry*fXTitleOffsetX axis title offset number entry; TGNumberEntry*fXTitleSizeX axis title size number entry; TGCheckButton*fXTitleSizeInPixelsX axis title size check box; TGColorSelect*fYAxisColorY axis color selection widget; TGColorSelect*fYLabelColorY axis label color selection widget; TGFontTypeComboBox*fYLabelFontY axis label font combo box; TGNumberEntry*fYLabelOffsetY axis label offset number entry; TGNumberEntry*fYLabelSizeY axis label size number entry; TGCheckButton*fYLabelSizeInPixelsY axis label size check box; TGNumberEntry*fYNdivMainY axis primary division number entry; TGNumberEntry*fYNdivSubY axis secondary division number entry; TGNumberEntry*fYNdivSubSubY axis tertiary division number entry; TGCheckButton*fYNdivisionsOptimizeY axis division optimization check box; TGNumberEntry*fYTickLengthY axis tick length number entry; TGColorSelect*fYTitleColorY axis title color selection widget; TGFontTypeComboBox*fYTitleFontY axis title font combo box; TGNumberEntry*fYTitleOffsetY axis title offset number entry; TGNumberEntry*fYTitleSizeY axis title size number entry; TGCheckButton*fYTitleSizeInPixelsY axis title size check box; TGColorSelect*fZAxisColorZ axis color selection widget; TGColorSelect*fZLabelColorZ axis label color selection widget; TGFontTypeComboBox*fZLabelFontZ axis label font combo box; TGNumberEntry*fZLabelOffsetZ axis label offset number entry; TGNumberEntry*fZLabelSizeZ axis label size number entry; TGCheckButton*fZLabelSizeInPixelsZ axis label size check box; TGNumberEntry*fZNdivMainZ axis primary division number entry; TGNumberEntry*fZNdivSubZ axis secondary division number entry; TGNumberEntry*fZNdivSubSubZ axis tertiary division number entry; TGCheckButton*fZNdivisionsOptimizeZ axis division optimization check box; ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TStyleManager.html:46924,optimiz,optimization,46924,root/html528/TStyleManager.html,https://root.cern,https://root.cern/root/html528/TStyleManager.html,10,['optimiz'],['optimization']
Performance,"s done on the first Tree, the list of branches; in the cache is kept for the following files. -Special case of a TEventlist; if the Tree or TChain has a TEventlist, only the buffers; referenced by the list are put in the cache. The learning period is started or restarted when:; - TTree automatically creates a cache. This feature can be; controlled with an env. variable or the TTreeCache.Size option.; - TTree::SetCacheSize is called with a non-zero size and a cache; did not previously exist; - TTreeCache::StartLearningPhase is called.; - TTree[Cache]::SetEntryRange is called; * and the learning is not yet finished; * and has not been set to manual; * and the new minimun entry is different. The learning period is stopped (and prefetching is actually started) when:; - TTree[Cache]::StopLearningPhase is called.; - An entry outside the 'learning' range is requested; The 'learning range is from fEntryMin (default to 0) to; fEntryMin + fgLearnEntries (default to 100).; - A 'cached' TChain switches over to a new file. WHY DO WE NEED the TreeCache when doing data analysis?. When writing a TTree, the branch buffers are kept in memory.; A typical branch buffersize (before compression) is typically 32 KBytes.; After compression, the zipped buffer may be just a few Kbytes.; The branch buffers cannot be much larger in case of Trees with several; hundred or thousand branches.; When writing, this does not generate a performance problem because branch; buffers are always written sequentially and the OS is in general clever enough; to flush the data to the output file when a few MBytes of data have to be written.; When reading at the contrary, one may hit a performance problem when reading; across a network (LAN or WAN) and the network latency is high.; For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each; with no cache will imply 10s penalty where a local read of the 10 MBytes would; take about 1 second.; The TreeCache will try to prefetch all the buffers f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:2139,cache,cached,2139,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['cache'],['cached']
Performance,"s drawn using semi-transparent colored boxes. See $ROOTSYS/tutorials/gl/glvox1.C. . TH3 as boxes (spheres); The supported options are:. Option Description . ""GLBOX"" TH3 as a set of boxes, size of box is proportional to bin content. . ""GLBOX1"" The same as ""glbox"", but spheres are drawn instead of boxes. . TH3 as iso-surface(s); The supported option is:. Option Description . ""GLISO"" TH3 is drawn using iso-surfaces. . TF3 (implicit function); The supported option is:. Option Description . ""GL"" Draw a TF3. . Parametric surfaces; $ROOTSYS/tutorials/gl/glparametric.C shows how to create parametric equations and visualize the surface.; Interaction with the plots; All the interactions are implemented via standard methods DistancetoPrimitive() and ExecuteEvent(). That's why all the interactions with the OpenGL plots are possible only when the mouse cursor is in the plot's area (the plot's area is the part of a the pad occupied by gl-produced picture). If the mouse cursor is not above gl-picture, the standard pad interaction is performed.; Selectable parts; Different parts of the plot can be selected:. xoz, yoz, xoy back planes: When such a plane selected, it's highlighted in green if the dynamic slicing by this plane is supported, and it's highlighted in red, if the dynamic slicing is not supported.; The plot itself: On surfaces, the selected surface is outlined in red. (TF3 and ISO are not outlined). On lego plots, the selected bin is highlighted. The bin number and content are displayed in pad's status bar. In box plots, the box or sphere is highlighted and the bin info is displayed in pad's status bar. Rotation and zooming. Rotation: When the plot is selected, it can be rotated by pressing and holding the left mouse button and move the cursor.; Zoom/Unzoom: Mouse wheel or 'j', 'J', 'k', 'K' keys. Panning; The selected plot can be moved in a pad's area by pressing and holding the left mouse button and the shift key.; Box cut; Surface, iso, box, TF3 and parametric painters ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:125971,perform,performed,125971,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['perform'],['performed']
Performance,"s drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject *prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Resize(Option_t* option = """"); Recompute canvas parameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this canvas in C++ macro file with GUI. void SaveSource(const char* filename = """", Option_t* option = """"); Save primitives in this canvas as a C++ macro file.; This function loops on all the canvas primitives and for each primitive; calls the object SavePrimitive function.; When outputing floating point numbers, the default precision is 7 digits.; The precision can be changed (via system.rootrc) by changing the value; of the environment variable ""Canvas.SavePrecision"". void SetBatch(Bool_t batch = kTRUE); Toggle batch mode. However, if the canvas is created without a window; then batch mode always stays set. void SetCanvasSize(UInt_t ww, UInt_t wh); Set Width and Height of canvas to ww and wh respectively; If ww and/or wh are greater than the current canvas window; a scroll bar is automatically generated.; Use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TCanvas.html:41376,response time,response time,41376,root/html526/TCanvas.html,https://root.cern,https://root.cern/root/html526/TCanvas.html,1,['response time'],['response time']
Performance,"s drawn when moving them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void Paint(Option_t* option = """"); Paint canvas. TPad * Pick(Int_t px, Int_t py, TObject* prevSelObj); Prepare for pick, call TPad::Pick() and when selected object; is different from previous then emit Picked() signal. void Picked(TPad* selpad, TObject* selected, Int_t event); Emit Picked() signal. void Selected(TVirtualPad* pad, TObject* obj, Int_t event); Emit Selected() signal. void ProcessedEvent(Int_t event, Int_t x, Int_t y, TObject* selected); Emit ProcessedEvent() signal. void Resize(Option_t* option = """"); Recompute canvas parameters following a X11 Resize. void ResizeOpaque(Int_t set = 1); Set option to resize objects/pads in a canvas. if set = 1 (default) graphics objects are resized in opaque mode; = 0 only the outline of objects is drawn when resizing them; The option opaque produces the best effect. It requires however a; a reasonably fast workstation or response time. void RunAutoExec(); Execute the list of TExecs in the current pad. void SavePrimitive(ostream& out, Option_t* option = """"); Save primitives in this canvas in C++ macro file with GUI. void SaveSource(const char* filename = """", Option_t* option = """"); Save primitives in this canvas as a C++ macro file.; This function loops on all the canvas primitives and for each primitive; calls the object SavePrimitive function.; When outputing floating point numbers, the default precision is 7 digits.; The precision can be changed (via system.rootrc) by changing the value; of the environment variable ""Canvas.SavePrecision"". void SetBatch(Bool_t batch = kTRUE); Toggle batch mode. However, if the canvas is created without a window; then batch mode always stays set. void SetCanvasSize(UInt_t ww, UInt_t wh); Set Width and Height of canvas to ww and wh respectively; If ww and/or wh are greater than the current canvas window; a scroll bar is automatically generated.; Use",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TCanvas.html:41370,response time,response time,41370,root/html528/TCanvas.html,https://root.cern,https://root.cern/root/html528/TCanvas.html,10,['response time'],['response time']
Performance,"s example; and the following example is that the event pointer; is zero when the branch is created. An example of a branch with an object allocated and; owned by the caller:. TFile* f = new TFile(""myfile.root"", ""recreate"");; TTree* t = new TTree(""t"", ""A test tree.""); Event* event = new Event();; TBranchElement* br = t->Branch(""event."", &event);; for (Int_t i = 0; i < 10; ++i) {; ... Fill event with meaningful data in some way.; t->Fill();; }; t->Write();; delete event;; event = 0;; delete f;; f = 0;. If AutoDelete is on (see TBranch::SetAutoDelete),; the top level objet will be deleted and recreate; each time an entry is read, whether or not the; TTree owns the object. void SetBasketSize(Int_t buffsize); -- Reset the basket size for all sub-branches of this branch element. void SetBranchCount(TBranchElement* bre); -- Set the branch counter for this branch. void SetObject(void* objadd); Set object this branch is pointing to. void SetTargetClassName(const char* name); Set the name of the class of the in-memory object into which the data will; loaded. void SetupAddresses(); -- If the branch address is not set, we set all addresses starting with; the top level parent branch. This is required to be done in order for; GetOffset to be correct and for GetEntry to run. void Streamer(TBuffer& b); -- Stream an object of class TBranchElement. Int_t Unroll(const char* name, TClass* cltop, TClass* cl, char* ptr, Int_t basketsize, Int_t splitlevel, Int_t btype); -- Split class cl into sub-branches of this branch. Create a sub-branch of this branch for each non-empty,; non-abstract base class of cl (unless we are a sub-branch; of a TClonesArray or an STL container, in which case we; do *not* create a sub-branch), and for each non-split data; member of cl. Note: We do *not* create sub-branches for base classes of cl; if we are a sub-branch of a TClonesArray or an STL container. Note: We do *not* create sub-branches for data members which; have a class type and which we are splitting.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TBranchElement.html:26889,load,loaded,26889,root/html526/TBranchElement.html,https://root.cern,https://root.cern/root/html526/TBranchElement.html,1,['load'],['loaded']
Performance,"s exceeded when running for lower error; status = 2 : maximum number of function calls exceeded when running for upper error; status = 3 : new minimum found when running for lower error; status = 4 : new minimum found when running for upper error; status = 5 : any other failure. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0). scan a parameter i around the minimum. A minimization must have been done before,; return false if it is not the case. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. bool Hesse(). perform a full calculation of the Hessian matrix for error calculation; If a valid minimum exists the calculation is done on the minimum point otherwise is performed; in the current set values of parameters; Status code of minimizer is updated according to the following convention (in case Hesse failed); status += 100*hesseStatus where hesse status is:; status = 1 : hesse failed; status = 2 : matrix inversion failed; status = 3 : matrix is not pos defined. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const;; protected function for accessing the internal Minuit2 object. Needed for derived classes. { return fMinimizer; }. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void SetMinimizerType(ROOT::Minuit2::EMinimizerType type). const ROOT::Minuit2::FCNBase * GetFCN() const; { return fMinuitFCN; }. bool ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& min); examine the minimum result. » Author: L. Moneta Wed Oct 18 11:48:00 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/minuit2:$Id$ » Last generated: 2009-12-08 17:03; This",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html:10293,perform,perform,10293,root/html526/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html526/ROOT__Minuit2__Minuit2Minimizer.html,2,['perform'],"['perform', 'performed']"
Performance,"s exceeded when running for lower error; status = 2 : maximum number of function calls exceeded when running for upper error; status = 3 : new minimum found when running for lower error; status = 4 : new minimum found when running for upper error; status = 5 : any other failure. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0). scan a parameter i around the minimum. A minimization must have been done before,; return false if it is not the case. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. bool Hesse(). perform a full calculation of the Hessian matrix for error calculation; If a valid minimum exists the calculation is done on the minimum point otherwise is performed; in the current set values of parameters; Status code of minimizer is updated according to the following convention (in case Hesse failed); status += 100*hesseStatus where hesse status is:; status = 1 : hesse failed; status = 2 : matrix inversion failed; status = 3 : matrix is not pos defined. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const;; print result of minimization. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; protected function for accessing the internal Minuit2 object. Needed for derived classes. { return fMinimizer; }. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void SetMinimizerType(ROOT::Minuit2::EMinimizerType type). const ROOT::Minuit2::FCNBase * GetFCN() const; { return fMinuitFCN; }. bool ExamineMinimum(const ROOT::Minuit2::FunctionMinimum& min); examine the minimum result. » Author: L. Moneta Wed Oct 18 11:48:00 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__Minuit2__Minuit2Minimizer.html:10309,perform,perform,10309,root/html528/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html528/ROOT__Minuit2__Minuit2Minimizer.html,8,['perform'],"['perform', 'performed']"
Performance,"s exceeded when running for lower error; status = 2 : maximum number of function calls exceeded when running for upper error; status = 3 : new minimum found when running for lower error; status = 4 : new minimum found when running for upper error; status = 5 : any other failure. bool Scan(unsigned int i, unsigned int& nstep, double* x, double* y, double xmin = 0, double xmax = 0). scan a parameter i around the minimum. A minimization must have been done before,; return false if it is not the case. bool Contour(unsigned int i, unsigned int j, unsigned int& npoints, double* xi, double* xj). find the contour points (xi,xj) of the function for parameter i and j around the minimum; The contour will be find for value of the function = Min + ErrorUp();. bool Hesse(). perform a full calculation of the Hessian matrix for error calculation; If a valid minimum exists the calculation is done on the minimum point otherwise is performed; in the current set values of parameters; Status code of minimizer is updated according to the following convention (in case Hesse failed); status += 100*hesseStatus where hesse status is:; status = 1 : hesse failed; status = 2 : matrix inversion failed; status = 3 : matrix is not pos defined. void PrintResults(); return reference to the objective function; virtual const ROOT::Math::IGenFunction & Function() const;; print result of minimization. void SetTraceObject(ROOT::Minuit2::MnTraceObject& obj); set an object to trace operation for each iteration; The object muust implement operator() (unsigned int, MinimumState & state). void SetStorageLevel(int level); set storage level = 1 : store all iteration states (default); = 0 : store only first and last state to save memory. const ROOT::Minuit2::ModularFunctionMinimizer * GetMinimizer() const; protected function for accessing the internal Minuit2 object. Needed for derived classes. { return fMinimizer; }. void SetMinimizer(ROOT::Minuit2::ModularFunctionMinimizer* m); { fMinimizer = m; }. void SetMini",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Minuit2__Minuit2Minimizer.html:13010,perform,perform,13010,root/html534/ROOT__Minuit2__Minuit2Minimizer.html,https://root.cern,https://root.cern/root/html534/ROOT__Minuit2__Minuit2Minimizer.html,12,['perform'],"['perform', 'performed']"
Performance,"s feature is activated (on by default), the sampling array for the FFT calculation is extended in both directions, and padded with the lowest/highest bin. Example: original: -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5; add buffer zones: U U -5 -4 -3 -2 -1 0 +1 +2 +3 +4 +5 O O; rotate: 0 +1 +2 +3 +4 +5 O O U U -5 -4 -3 -2 -1; zonesDefinition zones.py:1; The buffer bins are stripped away when the FFT output values are transferred back to the p.d.f cache. The default buffer size is 10% of the observable domain size, and can be changed with the setBufferFraction() member function.; The RooFFTConvPdf uses caching inherited from a RooAbsCachedPdf. If it is evaluated for a particular value of x, the FFT and convolution is calculated for all bins in the observable space for the given choice of parameters, which are also stored in the cache. Subsequent evaluations for different values of the convolution observable and identical parameters will be retrieved from the cache. If one or more of the parameters change, the cache will be updated, i.e., a new FFT runs.; The sampling density of the FFT is controlled by the binning of the the convolution observable, which can be changed using RooRealVar::setBins(N). For good results, N should be large (>=1000). Additional interpolation between the bins may improve the result if coarse binnings are chosen. These can be activated in the constructor or by calling setInterpolationOrder(). For N >> 1000, interpolation will not substantially improve the accuracy.; Additionial information on caching can be displayed by monitoring the message stream with topic ""Caching"" at the INFO level, i.e. by calling RooMsgService::instance().addStream(RooMsgService::INFO,Topic(""Caching"")) to see these message on stdout.; Multi-dimensional convolutions are not supported at the moment. Installing an external version of FFTW on Linux and compiling ROOT to use it; You have two options:; Recommended: ROOT can automatically install FFTW for itself, see builtin_fftw3 at http",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:2939,cache,cache,2939,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cache']
Performance,"s flase, then the libraries are actually stored in; sub-directories of 'build_dir' including the full pathname of the; script. If the script is location at /full/path/name/macro.C; the library will be located at 'build_dir+/full/path/name/macro_C.so'; If 'isflat' is true, then no subdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell command, including; the use of ';' to separate several instructions. However, shell specific; construct should be avoided. In particular this description can contain; environment variables, like $ROOTSYS (or %ROOTSYS% on windows). Five special variables will be expanded before executio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:44861,optimiz,optimized,44861,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,10,['optimiz'],['optimized']
Performance,"s for Multidimensional gradient functions. More...;  ; class  GradFunctor1D;  GradFunctor1D class for one-dimensional gradient functions. More...;  ; class  GSL1DMinimizerWrapper;  wrapper class for gsl_min_fminimizer structure More...;  ; class  GSLChebSeries;  wrapper class for C struct gsl_cheb_series More...;  ; class  GSLDerivator;  Class for computing numerical derivative of a function based on the GSL numerical algorithm This class is implemented using the numerical derivatives algorithms provided by GSL (see GSL Online Manual ). More...;  ; class  GSLError;  class to change GSL Error handler to use ROOT one. More...;  ; class  GSLFunctionAdapter;  Class for adapting any C++ functor class to C function pointers used by GSL. More...;  ; class  GSLFunctionDerivWrapper;  class to wrap a gsl_function_fdf (with derivatives) More...;  ; class  GSLFunctionWrapper;  Wrapper class to the gsl_function C structure. More...;  ; class  GSLIntegrationWorkspace;  ; class  GSLIntegrator;  Class for performing numerical integration of a function in one dimension. More...;  ; class  GSLInterpolator;  Interpolation class based on GSL interpolation functions. More...;  ; class  GSLMCIntegrationWorkspace;  ; class  GSLMCIntegrator;  ; class  GSLMinimizer;  GSLMinimizer class. More...;  ; class  GSLMinimizer1D;  Minimizer for arbitrary one dimensional functions. More...;  ; class  GSLMiserIntegrationWorkspace;  Workspace for MISER. More...;  ; struct  GSLMonteFunctionAdapter;  ; class  GSLMonteFunctionWrapper;  wrapper to a multi-dim function withtout derivatives for Monte Carlo multi-dimensional integration algorithm More...;  ; class  GSLMultiFit;  GSLMultiFit, internal class for implementing GSL non linear least square GSL fitting. More...;  ; class  GSLMultiFitFunctionAdapter;  Class for adapting a C++ functor class to C function pointers used by GSL MultiFit Algorithm The templated C++ function class must implement: More...;  ; class  GSLMultiFitFunctionWrapper;  wrapper to a ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1Math.html:9620,perform,performing,9620,doc/master/namespaceROOT_1_1Math.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1Math.html,2,['perform'],['performing']
Performance,"s for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TMutex*fAMtxTo protect async msg queue; list<TXSockBuf*>fAQuelist of asynchronous messages; TSemaphorefASemControl access to conn async msg queue; Bool_tfAWaitkTRUE if waiting at the async msg queue; TSemaphorefAsynProcControl actions while processing async messages; TXSockBuf*fBufCurcurrent read buffer; TStringfBufferContainer for exchanging information; Int_tfByteCurcurrent position in the first buffer; Int_tfByteLeftbytes left in the first buffer; XrdProofConn*fConninstance of the underlying connection module; Bool_tfDontTimeoutIf true wait forever for incoming messages; TXHandler*fHandlerHandler of asynchronous events (input, error); TStringfHostRemote host; Bool_tfIForwardWhether the interrupt should be propagated; kXR_int32fILevHighest received interrupt; TMutex*fIMtxTo protect interrupt queue; Int_tfLogLevelLog level to be transmitted to servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; kXR_int32fSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TSocket. XrdClientAbsUnsolMsgHandler. ←; TXSocket. ←. TXUnixSocket. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protecte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TXSocket.html:11769,queue,queue,11769,root/html602/TXSocket.html,https://root.cern,https://root.cern/root/html602/TXSocket.html,8,['queue'],['queue']
Performance,"s for special authentication options; static ULong64_tTSocket::fgBytesRecvtotal bytes received by all socket objects; static ULong64_tTSocket::fgBytesSenttotal bytes sent by all socket objects; static Int_tTSocket::fgClientProtocolclient ""protocol"" version. private:. TMutex*fAMtxTo protect async msg queue; list<TXSockBuf*>fAQuelist of asynchronous messages; TSemaphorefASemControl access to conn async msg queue; Bool_tfAWaitkTRUE if waiting at the async msg queue; TSemaphorefAsynProcControl actions while processing async messages; TXSockBuf*fBufCurcurrent read buffer; TStringfBufferContainer for exchanging information; Int_tfByteCurcurrent position in the first buffer; Int_tfByteLeftbytes left in the first buffer; XrdProofConn*fConninstance of the underlying connection module; Bool_tfDontTimeoutIf true wait forever for incoming messages; TXHandler*fHandlerHandler of asynchronous events (input, error); TStringfHostRemote host; Bool_tfIForwardWhether the interrupt should be propagated; kXR_int32fILevHighest received interrupt; TMutex*fIMtxTo protect interrupt queue; Int_tfLogLevelLog level to be transmitted to servers; charfMode'e' (def) or 'i' (internal - proofsrv); Int_tfPid; Int_tfPortRemote port; Bool_tfRDInterruptTo interrupt waiting for messages; TObject*fReferenceGeneric object reference of this socket; kXR_int32fSendOptOptions for sending messages; Short_tfSessionIDproofsrv: remote ID of connected session; TStringfUserUsername used for login; Int_tfXrdProofdVersion; static Bool_tfgInitDoneAvoid initializing more than once; static TStringfgLocLocation string; static TXSockPipefgPipePipe for input monitoring; static TMutexfgSMtxTo protect spare list; static list<TXSockBuf*>fgSQuelist of spare buffers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void DoError(int level, const char* location, const char* fmt, va_list va) const; Interface to ErrorHandler (protected). TXSocket(const char* url, Char_t mode = 'M', Int_t psi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TXSocket.html:11745,queue,queue,11745,root/html604/TXSocket.html,https://root.cern,https://root.cern/root/html604/TXSocket.html,8,['queue'],['queue']
Performance,"s from CINT (more expensive).; The proto string must be of the form: ""int, char*, float"". TObject * GetGeometry(const char* name) const; Return pointer to Geometry with name. TCollection * GetListOfEnums(Bool_t load = kFALSE). TCollection * GetListOfFunctionTemplates(). TCollection * GetListOfGlobals(Bool_t load = kFALSE); Return list containing the TGlobals currently defined.; Since globals are created and deleted during execution of the; program, we need to update the list of globals every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfGlobalFunctions(Bool_t load = kFALSE); Return list containing the TFunctions currently defined.; Since functions are created and deleted during execution of the; program, we need to update the list of functions every time we; execute this method. However, when calling this function in; a (tight) loop where no interpreter symbols will be created; you can set load=kFALSE (default). TCollection * GetListOfTypes(Bool_t load = kFALSE); Return a dynamic list giving access to all TDataTypes (typedefs); currently defined. The list is populated on demand. Calling; gROOT->GetListOfTypes()->FindObject(nameoftype);; will return the TDataType corresponding to 'nameoftype'. If the; TDataType is not already in the list itself and the type does exist,; a new TDataType will be created and added to the list. Calling; gROOT->GetListOfTypes()->ls(); // or Print(); list only the typedefs that have been previously accessed throught the; list (plus the builtins types). void Idle(UInt_t idleTimeInSec, const char* command = 0); Execute command when system has been idle for idleTimeInSec seconds. Int_t IgnoreInclude(const char* fname, const char* expandedfname); Return 1 if the name of the given include file corresponds to a class that; is known to ROOT, e.g. ""TLorentzVector.h"" versus TLorentzVector. void InitSystem();",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TROOT.html:28986,load,load,28986,root/html602/TROOT.html,https://root.cern,https://root.cern/root/html602/TROOT.html,4,['load'],['load']
Performance,"s from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_t_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCachedReal.html:33441,cache,cache,33441,root/html530/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html530/RooAbsCachedReal.html,2,['cache'],['cache']
Performance,"s from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; RooListProxy_list; TIterator*_listIter! do not persist; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooRecursiveFraction.html:32189,cache,cache,32189,root/html530/RooRecursiveFraction.html,https://root.cern,https://root.cern/root/html530/RooRecursiveFraction.html,2,['cache'],['cache']
Performance,"s fully qualified and has all typedef desugared except for the 'special' typedef which include Double32_t, Float16_t, [U]Long64_t and std::string. It also has std:: removed [This is subject to change]. ; Definition at line 164 of file TFunction.cxx. ◆ GetSignature(). const char * TFunction::GetSignature ; (; ). Return signature of function. ; Definition at line 122 of file TFunction.cxx. ◆ InterfaceMethod(). void * TFunction::InterfaceMethod ; (; ); const. Return pointer to the interface method. ; Using this pointer we can find which TFunction belongs to a CINT MethodInfo object. Both need to have the same InterfaceMethod pointer. ; Definition at line 221 of file TFunction.cxx. ◆ IsA(). TClass * TFunction::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TDictionary.; Reimplemented in TMethod.; Definition at line 68 of file TFunction.h. ◆ IsValid(). Bool_t TFunction::IsValid ; (; ). virtual . Return true if this function object is pointing to a currently loaded function. ; If a function is unloaded after the TFunction is created, the TFunction will be set to be invalid. ; Reimplemented in TMethod.; Definition at line 232 of file TFunction.cxx. ◆ ls(). void TFunction::ls ; (; Option_t * ; option = """"); const. overridevirtual . List TFunction name and title. ; Reimplemented from TObject.; Definition at line 273 of file TFunction.cxx. ◆ operator=(). TFunction & TFunction::operator= ; (; const TFunction & ; rhs). Assignment operator. ; Definition at line 66 of file TFunction.cxx. ◆ Print(). void TFunction::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print TFunction name and title. ; Reimplemented from TObject.; Definition at line 283 of file TFunction.cxx. ◆ Property(). Long_t TFunction::Property ; (; ); const. overridevirtual . Get property description word. For meaning of bits see EProperty. ; Implements TDictionary.; Definition at line 193 of file TFunction.cxx. ◆ Streamer(). void TFunction::St",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFunction.html:19566,load,loaded,19566,doc/master/classTFunction.html,https://root.cern,https://root.cern/doc/master/classTFunction.html,1,['load'],['loaded']
Performance,"s function of the frames variable. ;  ; virtual RooPlot * plotOn (RooPlot *frame, PlotOpt o) const;  Create and fill a histogram of the frame's variable and append it to the frame. ;  ; virtual void resetCache ();  Internal method – Remove cached function values. ;  ; virtual void setArgStatus (const RooArgSet &set, bool active);  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  ;  Protected Member Functions inherited from RooDirItem; void appendToDir (TObject *obj, bool forceMemoryResident=false);  Append object to directory. ;  ; void removeFromDir (TObject *obj);  Remove object from directory it was added to. ;  . Protected Attributes; RooArgSet _varsNoWgt;  Vars without weight variable. ;  ; RooRealVar * _wgtVar = nullptr;  Pointer to weight variable (if set) ;  ;  Protected Attributes inherited from RooAbsData; RooArgSet _cachedVars;  ! External variables cached with this data set ;  ; std::unique_ptr< RooAbsDataStore > _dstore;  Data storage implementation. ;  ; std::unique_ptr< RooArgSet > _globalObservables;  Snapshot of global observables. ;  ; const TNamed * _namePtr = nullptr;  ! De-duplicated name pointer. This will be equal for all objects with the same name. ;  ; std::map< std::string, RooAbsData * > _ownedComponents;  Owned external components. ;  ; RooArgSet _vars;  Dimensions of this data set. ;  ; StorageType storageType;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  ;  Protected Attributes inherited from RooDirItem; TDirectory * _dir {nullptr};  ! Associated directory ;  . Private Member Functions; void loadValuesFromSlices (RooCategory &indexCat, std::map< std::string, RooAbsData * > const &slices, const char *rangeName, RooFormulaVar const *cutVar, const char *cutSpec);  . Private Attributes; bool _doWeightErrorCheck {true};  ! When adding events wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataSet.html:33783,cache,cached,33783,doc/master/classRooDataSet.html,https://root.cern,https://root.cern/doc/master/classRooDataSet.html,1,['cache'],['cached']
Performance,"s has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.94999999999999996, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.94999999999999996, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors() const; flag to chek if errors are normalized. { return fNormalized; }. void Print(ostream& os, bool covmat = false) const; print the result and optionaly covariance matrix and correlations. void PrintCovMatrix(ostream& os) const; print error matrix and correlations. bool IsParameterBound(unsigned int ipar) const; query if a parameter is bound. bool IsParame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Fit__FitResult.html:10145,perform,performed,10145,root/html602/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html602/ROOT__Fit__FitResult.html,2,['perform'],['performed']
Performance,"s has not run for parameter i return the parabolic error. double GlobalCC(unsigned int i) const; parameter global correlation coefficient. double CovMatrix(unsigned int i, unsigned int j) const; retrieve covariance matrix element. double Correlation(unsigned int i, unsigned int j) const; retrieve correlation elements. void GetConfidenceIntervals(unsigned int n, unsigned int stride1, unsigned int stride2, const double* x, double* ci, double cl = 0.94999999999999996, bool norm = true) const. get confidence intervals for an array of n points x.; stride1 indicates the stride in the coordinate space while stride2 the stride in dimension space.; For 1-dim points : stride1=1, stride2=1; for multi-dim points arranged as (x0,x1,...,xN,y0,....yN) stride1=1 stride2=n; for multi-dim points arraged as (x0,y0,..,x1,y1,...,xN,yN,..) stride1=ndim, stride2=1. the confidence interval are returned in the array ci; cl is the desired confidedence interval value; norm is a flag to control if the intervals need to be normalized to the chi2/ndf value; By default the intervals are corrected using the chi2/ndf value of the fit if a chi2 fit is performed. void GetConfidenceIntervals(const ROOT::Fit::BinData& data, double* ci, double cl = 0.94999999999999996, bool norm = true) const. evaluate confidence interval for the point specified in the passed data sets; the confidence interval are returned in the array ci; cl is the desired confidence interval value.; This method is mantained for backward compatibility and will be deprecated. std::vector<double> GetConfidenceIntervals(double cl = 0.94999999999999996, bool norm = true) const. evaluate confidence interval for the data set used in the last fit; the confidence interval are returned as a vector of data points. int Index(const string& name) const; get index for parameter name (return -1 if not found). void NormalizeErrors(); normalize errors using chi2/ndf for chi2 fits. bool NormalizedErrors() const; flag to chek if errors are normalized. { ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/ROOT__Fit__FitResult.html:10744,perform,performed,10744,root/html604/ROOT__Fit__FitResult.html,https://root.cern,https://root.cern/root/html604/ROOT__Fit__FitResult.html,2,['perform'],['performed']
Performance,s in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously ; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks that were prefetched; Int_tTFileCacheRead::fNbNumber of long buffers; Int_tfNbranches! Number of branches in the cache; Int_tTFileCacheRead::fNseekNumber of blocks to be prefetched; Int_tTFileCacheRead::fNtotTotal size of prefetched blocks; Bool_tfOneTime! used in the learning phase ; TTree*fOwner! pointer to the owner Tree/chain; Long64_t*TFileCacheRead::fPos[fNb] start of long buffers; TFilePrefetch*TFileCacheRead::fPrefetch!Object that does the asynchronous reading in another thread; Long64_tTFileCacheRead::fPrefetchedBlocksNumber of blocks prefetched.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:17209,cache,cache,17209,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,9,['cache'],['cache']
Performance,"s into a single integration code valid for RooAddPdf. ; Reimplemented from RooAbsReal.; Definition at line 631 of file RooAddPdf.cxx. ◆ getCoefNormalization(). const RooArgSet & RooAddPdf::getCoefNormalization ; (; ); const. Definition at line 335 of file RooAddPdf.cxx. ◆ getCoefRange(). const char * RooAddPdf::getCoefRange ; (; ); const. inline . Definition at line 83 of file RooAddPdf.h. ◆ getNormAndCache(). std::pair< const RooArgSet *, AddCacheElem * > RooAddPdf::getNormAndCache ; (; const RooArgSet * ; nset); const. private . Look up projection cache and per-PDF norm sets. ; If a PDF doesn't have a special norm set, use the defaultNorm. If defaultNorm == nullptr, use the member _normSet. ; Definition at line 458 of file RooAddPdf.cxx. ◆ getProjCache(). AddCacheElem * RooAddPdf::getProjCache ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset = nullptr . ); const. protected . Manager of cache with coefficient projections and transformations. ; Retrieve cache element for the computation of the PDF normalisation.; Parameters. [in]nsetCurrent normalisation set (integration over these variables yields 1). ; [in]isetIntegration set. Variables to be integrated over (if integrations are performed). If a cache element does not exist, create and fill it on the fly. The cache also contains; Supplemental normalization terms (in case not all added p.d.f.s have the same observables); Projection integrals to calculate transformed fraction coefficients when a frozen reference frame is provided; Projection integrals for similar transformations when a frozen reference range is provided. . Definition at line 406 of file RooAddPdf.cxx. ◆ getValV(). double RooAddPdf::getValV ; (; const RooArgSet * ; set = nullptr); const. overrideprotectedvirtual . Calculate and return the current value. ; Reimplemented from RooAbsPdf.; Definition at line 515 of file RooAddPdf.cxx. ◆ IsA(). TClass * RooAddPdf::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:89579,cache,cache,89579,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['cache'],['cache']
Performance,"s into the I/O buffer. ; Used only by TLeafC, just dummy implementation here ; Implements TBuffer.; Definition at line 2307 of file TBufferXML.cxx. ◆ WriteFloat(). void TBufferXML::WriteFloat ; (; Float_t ; f). finalvirtual . Writes Float_t value to buffer. ; Implements TBuffer.; Definition at line 2737 of file TBufferXML.cxx. ◆ WriteInt(). void TBufferXML::WriteInt ; (; Int_t ; i). finalvirtual . Writes Int_t value to buffer. ; Implements TBuffer.; Definition at line 2683 of file TBufferXML.cxx. ◆ WriteLong(). void TBufferXML::WriteLong ; (; Long_t ; l). finalvirtual . Writes Long_t value to buffer. ; Implements TBuffer.; Definition at line 2701 of file TBufferXML.cxx. ◆ WriteLong64(). void TBufferXML::WriteLong64 ; (; Long64_t ; l). finalvirtual . Writes Long64_t value to buffer. ; Implements TBuffer.; Definition at line 2719 of file TBufferXML.cxx. ◆ WriteObjectClass(). void TBufferXML::WriteObjectClass ; (; const void * ; actualObjStart, . const TClass * ; actualClass, . Bool_t ; cacheReuse . ). finalprotectedvirtual . Write object to buffer. Only used from TBuffer. ; Implements TBufferIO.; Definition at line 1516 of file TBufferXML.cxx. ◆ WriteShort(). void TBufferXML::WriteShort ; (; Short_t ; s). finalvirtual . Writes Short_t value to buffer. ; Implements TBuffer.; Definition at line 2665 of file TBufferXML.cxx. ◆ WriteStdString() [1/3]. void TBufferXML::WriteStdString ; (; const std::string * ; s). finalvirtual . Writes a std::string. ; Implements TBuffer.; Definition at line 2789 of file TBufferXML.cxx. ◆ WriteStdString() [2/3]. virtual void TBuffer::WriteStdString ; (; const std::string * ; s). virtual . Implements TBuffer. ◆ WriteStdString() [3/3]. virtual void TBuffer::WriteStdString ; (; std::string & ; s). inlinevirtual . Reimplemented from TBuffer.; Definition at line 312 of file TBuffer.h. ◆ WriteTString(). void TBufferXML::WriteTString ; (; const TString & ; s). finalvirtual . Writes a TString. ; Implements TBuffer.; Definition at line 2764 of file ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferXML.html:92853,cache,cacheReuse,92853,doc/master/classTBufferXML.html,https://root.cern,https://root.cern/doc/master/classTBufferXML.html,1,['cache'],['cacheReuse']
Performance,"s is a static function).Definition TClassTable.cxx:398; TClassTClass instances represent classes, structs and namespaces in the ROOT type system.Definition TClass.h:81; TClass::GetDataMemberTDataMember * GetDataMember(const char *datamember) constReturn pointer to datamember object with name ""datamember"".Definition TClass.cxx:3506; TClass::GetStateEState GetState() constDefinition TClass.h:488; TClass::GetCollectionTypeROOT::ESTLType GetCollectionType() constReturn the 'type' of the STL the TClass is representing.Definition TClass.cxx:2953; TClass::fStateEState fStatecached of the streaming method to useDefinition TClass.h:277; TClass::fBasestd::atomic< TList * > fBaseDefinition TClass.h:201; TClass::AddClassToDeclIdMapstatic void AddClassToDeclIdMap(TDictionary::DeclId_t id, TClass *cl)static: Add a TClass* to the map of classes.Definition TClass.cxx:576; TClass::fClassVersionVersion_t fClassVersionDefinition TClass.h:221; TClass::GetListOfFunctionTemplatesTList * GetListOfFunctionTemplates(Bool_t load=kTRUE)Return TListOfFunctionTemplates for a class.Definition TClass.cxx:3865; TClass::DynamicCastvoid * DynamicCast(const TClass *base, void *obj, Bool_t up=kTRUE)Cast obj of this class type up to baseclass cl if up is true.Definition TClass.cxx:4982; TClass::RemoveClassDeclIdstatic void RemoveClassDeclId(TDictionary::DeclId_t id)Definition TClass.cxx:603; TClass::CallShowMembersBool_t CallShowMembers(const void *obj, TMemberInspector &insp, Bool_t isTransient=kFALSE) constCall ShowMembers() on the obj of this class type, passing insp and parent.Definition TClass.cxx:2272; TClass::fEnumsstd::atomic< TListOfEnums * > fEnumsDefinition TClass.h:205; TClass::HasNoInfoOrEmuOrFwdDeclaredDeclstatic Bool_t HasNoInfoOrEmuOrFwdDeclaredDecl(const char *)Definition TClass.cxx:3465; TClass::PostLoadCheckvirtual void PostLoadCheck()Do the initialization that can only be done after the CINT dictionary has been fully populated and ca...Definition TClass.cxx:6026; TClass::LoadClassst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:399256,load,load,399256,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['load']
Performance,"s libqt >= 4.8. qtgsi; *; GSI's Qt integration, requires libqt >= 4.8. roofit; *; Build the libRooFit advanced fitting package. root7; OFF; ROOT 7 support (read more). roottest; OFF; Include roottest in the test suit, if roottest exists in root or if it is a sibling directory. ruby; OFF; Ruby ROOT bindings, requires ruby >= 1.8. r; OFF; R ROOT bindings, requires R, Rcpp and RInside. rfio; ON; RFIO support, requires libshift from CASTOR >= 1.5.2. rpath; OFF; Set run-time library load path on executables and shared libraries (at installation area). runtime_cxxmodules; OFF; Enable runtime c++ modules. sapdb; ON; MaxDB/SapDB support, requires libsqlod and libsqlrte. shadowpw; ON; Shadow password support. shared; ON; Use shared 3rd party libraries if possible. soversion; OFF; Set version number in sonames (recommended). sqlite; ON; SQLite support, requires libsqlite3. srp; ON; SRP support, requires SRP source tree. ssl; ON; SSL encryption support, requires openssl. tbb; OFF; TBB multi-threading support, requires TBB. table; *; Build libTable contrib library. tcmalloc; OFF; Using the tcmalloc allocator. testing; OFF; Enable test suit of ROOT with CTest. thread; ON; Using thread library (cannot be disabled). tmva; ON; Build TMVA multi variate analysis library. unuran; *; UNURAN - package for generating non-uniform random numbers. vc; *; Vc adds a few new types for portable and intuitive SIMD programming. vdt; ON; VDT adds a set of fast and vectorisable mathematical functions. winrtdebug; OFF; Link against the Windows debug runtime library. xft; ON; Xft support (X11 antialiased fonts). xml; ON; XML parser interface. xrootd; ON; Build xrootd file server and its client (if supported). x11; *; X11 support. The default value for these options are platform dependent. CMake Generators; CMake can generate, in addition to standard makefiles, specific proejcts for various integrated development environments (IDEs) such as Xcode, Eclipse, Visual Studio, etc.. The available generators ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:12434,multi-thread,multi-threading,12434,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['multi-thread'],['multi-threading']
Performance,"s made from the cells along the X axis; ranging from ixmin to ixmax and iymin to iymax included.; By default, bins 1 to nx and 1 to ny are included; By setting ixmin=1 and/or ixmax=NbinsX the underflow and/or overflow in X will be excluded; By setting iymin=1 and/or iymax=NbinsY the underflow and/or overflow in Y will be excluded. if option ""e"" is specified, the errors are computed.; if option ""d"" is specified, the projection is drawn in the current pad.; if option ""o"" original axis range of the target axes will be; kept, but only bins inside the selected range will be filled. NOTE that if a TH1D named ""name"" exists in the current directory or pad and having; a compatible axis, the histogram is reset and filled again with the projected contents of the TH3.; In the case of axis incompatibility, an error is reported and a NULL pointer is returned. implemented using Project3D. TH1D * DoProject1D(const char* name, const char* title, TAxis* projX, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal methdod performing the projection to 1D histogram; called from TH3::Project3D. TH2D * DoProject2D(const char* name, const char* title, TAxis* projX, TAxis* projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) const; internal method performing the projection to a 2D histogram; called from TH3::Project3D. TH1 * Project3D(Option_t* option = ""x"") const; Project a 3-d histogram into 1 or 2-d histograms depending on the; option parameter; option may contain a combination of the characters x,y,z,e; option = ""x"" return the x projection into a TH1D histogram; option = ""y"" return the y projection into a TH1D histogram; option = ""z"" return the z projection into a TH1D histogram; option = ""xy"" return the x versus y projection into a TH2D histogram; option = ""yx"" return the y versus x projection into a TH2D histogram; option = ""xz"" return the x versus z projection into a TH2D histogram; option = ""zx"" return the z versus x projection into a TH2D ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TH3.html:41683,perform,performing,41683,root/html528/TH3.html,https://root.cern,https://root.cern/root/html528/TH3.html,4,['perform'],['performing']
Performance,"s method can be called before Initialize(), because the RResultPtr is constructed before the event loop is started.; void Initialize(): this method is called once before starting the event-loop. Useful for setup operations. It must reset the state of the helper to the expected state at the beginning of the event loop: the same helper, or copies of it, might be used for multiple event loops (e.g. in the presence of systematic variations).; void InitTask(TTreeReader *, unsigned int slot): each working thread shall call this method during the event loop, before processing a batch of entries. The pointer passed as argument, if not null, will point to the TTreeReader that RDataFrame has set up to read the task's batch of entries. It is passed to the helper to allow certain advanced optimizations it should not usually serve any purpose for the Helper. This method is often no-op for simple helpers.; void Exec(unsigned int slot, ColumnTypes...columnValues): each working thread shall call this method during the event-loop, possibly concurrently. No two threads will ever call Exec with the same 'slot' value: this parameter is there to facilitate writing thread-safe helpers. The other arguments will be the values of the requested columns for the particular entry being processed.; void Finalize(): this method is called at the end of the event loop. Commonly used to finalize the contents of the result.; std::string GetActionName(): it returns a string identifier for this type of action that RDataFrame will use in diagnostics, SaveGraph(), etc. Optional methods; If these methods are implemented they enable extra functionality as per the description below. Result_t &PartialUpdate(unsigned int slot): if present, it must return the value of the partial result of this action for the given 'slot'. Different threads might call this method concurrently, but will do so with different 'slot' numbers. RDataFrame leverages this method to implement RResultPtr::OnPartialResult().; ROOT::RDF::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:39661,concurren,concurrently,39661,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['concurren'],['concurrently']
Performance,"s named ""name"". ; Definition at line 1672 of file TROOT.cxx. ◆ GetListOfFunctions(). TCollection * TROOT::GetListOfFunctions ; (; ); const. inline . Definition at line 242 of file TROOT.h. ◆ GetListOfFunctionTemplates(). TCollection * TROOT::GetListOfFunctionTemplates ; (; ). Definition at line 1771 of file TROOT.cxx. ◆ GetListOfGeometries(). TSeqCollection * TROOT::GetListOfGeometries ; (; ); const. inline . Definition at line 244 of file TROOT.h. ◆ GetListOfGlobalFunctions(). TCollection * TROOT::GetListOfGlobalFunctions ; (; Bool_t ; load = kFALSE). Return list containing the TFunctions currently defined. ; Since functions are created and deleted during execution of the program, we need to update the list of functions every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1826 of file TROOT.cxx. ◆ GetListOfGlobals(). TCollection * TROOT::GetListOfGlobals ; (; Bool_t ; load = kFALSE). Return list containing the TGlobals currently defined. ; Since globals are created and deleted during execution of the program, we need to update the list of globals every time we execute this method. However, when calling this function in a (tight) loop where no interpreter symbols will be created you can set load=kFALSE (default). ; Definition at line 1788 of file TROOT.cxx. ◆ GetListOfMappedFiles(). TSeqCollection * TROOT::GetListOfMappedFiles ; (; ); const. inline . Definition at line 238 of file TROOT.h. ◆ GetListOfMessageHandlers(). TSeqCollection * TROOT::GetListOfMessageHandlers ; (; ); const. inline . Definition at line 250 of file TROOT.h. ◆ GetListOfProofs(). TSeqCollection * TROOT::GetListOfProofs ; (; ); const. inline . Definition at line 253 of file TROOT.h. ◆ GetListOfSecContexts(). TSeqCollection * TROOT::GetListOfSecContexts ; (; ); const. inline . Definition at line 252 of file TROOT.h. ◆ GetListOfSockets(). TSeqCollection * TROOT::G",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:57195,load,load,57195,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['load'],['load']
Performance,"s not ""*"", only nodes with names matching the pattern will be printed. TString cleanBranchName() const; Construct a mangled name from the actual name that; is free of any math symbols that might be interpreted by TTree. UInt_t crc32(const char* data); Calculate crc32 checksum on given string. UInt_t crc32(const char* data, ULong_t sz, UInt_t crc = 0); update CRC32 with new data. UInt_t fnv1a32(const char* data); calculate 32 bit FNV1A hash of string. UInt_t fnv1a32(const char* data, ULong_t sz, UInt_t hash = fnv1a32start); update 32 bit FNV1A hash. ULong64_t fnv1a64(const char* data); calculate 64 bit FNV1A hash of string. ULong64_t fnv1a64(const char* data, ULong_t sz, ULong64_t hash = fnv1a64start); update 64 bit FNV1A hash. void printCompactTreeHook(ostream& os, const char* ind = """"); Hook function interface for object to insert additional information; when printed in the context of a tree structure. This default; implementation prints nothing. void registerCache(RooAbsCache& cache); Register RooAbsCache with this object. This function is called; by RooAbsCache constructors for objects that are a datamember; of this RooAbsArg. By registering itself the RooAbsArg is aware; of all its cache data members and will forward server change; and cache mode change calls to the cache objects, which in turn; can forward them their contents. void unRegisterCache(RooAbsCache& cache); Unregister a RooAbsCache. Called from the RooAbsCache destructor. Int_t numCaches() const; Return number of registered caches. RooAbsCache* getCache(Int_t index) const; Return registered cache object by index. RooArgSet* getVariables(Bool_t stripDisconnected = kTRUE) const; Return RooArgSet with all variables (tree leaf nodes of expresssion tree). RooLinkedList getCloningAncestors() const; Return ancestors in cloning chain of this RooAbsArg. NOTE: Returned pointers; are not guaranteed to be 'live', so do not dereference without proper caution. void graphVizTree(const char* fileName, const char* del",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsArg.html:34840,cache,cache,34840,root/html534/RooAbsArg.html,https://root.cern,https://root.cern/root/html534/RooAbsArg.html,6,['cache'],['cache']
Performance,"s not determined. In order to find out this new state, one has to propagate the point with a distance slightly bigger that the computed step value (which is accurate within numerical precision). A method that performs this task finding the next location is TGeoManager::Step(), described in "" Making a Step "", but users may implement more precise methods to insure post-step boundary crossing.; 18.11 Geometry Graphical User Interface; The geombuilder package allows you to create and edit geometries. The package provides a library of all GUI classes related to geometry. Each editable geometry class TGeoXXX have a correspondent editor TGeoXXXEditor that provides a graphics user interface allowing to edit some (or all) parameters of a geometry object. The editable objects are geometry manager, volumes, nodes, shapes, media, materials and matrices. The interfaces provide also access to specific functionality of geometry objects. The editing mechanism is based on ROOT GED (Graphics Editors) functionality and the library is loaded using the plug-in mechanism.; 18.11.1 Editing a Geometry; There are two different use cases having different ways of invoking the geometry editors. The first one applies when starting with geometry from scratch and using the builder functionality to create new geometry objects. In this case, one should use the sequence:; root[] TGeoManager *geom = new TGeoManager(""MyGeom"",; ""Test builder"");; root[] geom->Edit(Option_t *option="""");; The lines above will create a new TGeoManager class, create an empty canvas and start the editor in the left-sided editor frame attached to the canvas. To open the editor in a separate frame one should provide a non-empty string as option to the Edit() method. The geometry manager editor. 18.11.2 The Geometry Manager Editor; ; The second use case applies when starting to edit an existing geometry. Supposing the geometry was loaded into memory, besides the first method that still applies one can also edit drawn geometry ob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1032529,load,loaded,1032529,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loaded']
Performance,"s not exist,; 0 otherwise). When the system flag is kTRUE, the library is consisdered; a permanent systen library that should not be unloaded during the; course of the session. char * DynamicPathName(const char* lib, Bool_t quiet = kFALSE); Need to return the equivalent of LD_LIBRARY_PATH. Func_t DynFindSymbol(const char* module, const char* entry); Find specific entry point in specified library. Specify ""*"" for lib; to search in all libraries. void Unload(const char* module); Unload a shared library. void ListSymbols(const char* module, const char* re = """"); List symbols in a shared library. void ListLibraries(const char* regexp = """"); List all loaded shared libraries. Regexp is a wildcard expression,; see TRegexp::MakeWildcard. TString & GetLastErrorString(); Return the thread local storage for the custom last error message. const TString & GetLastErrorString() const; Return the thread local storage for the custom last error message. const char * GetLinkedLibraries(); Get list of shared libraries loaded at the start of the executable.; Returns 0 in case list cannot be obtained or in case of error. const char * GetLibraries(const char* regexp = """", const char* option = """", Bool_t isRegexp = kTRUE); Return a space separated list of loaded shared libraries.; Regexp is a wildcard expression, see TRegexp::MakeWildcard.; This list is of a format suitable for a linker, i.e it may contain; -Lpathname and/or -lNameOfLib.; Option can be any of:; S: shared libraries loaded at the start of the executable, because; they were specified on the link line.; D: shared libraries dynamically loaded after the start of the program.; For MacOS only:; L: list the .dylib rather than the .so (this is intended for linking); This options is not the default. TInetAddress GetHostByName(const char* server); Get Internet Protocol (IP) address of host. TInetAddress GetPeerName(int sock); Get Internet Protocol (IP) address of remote host and port #. TInetAddress GetSockName(int sock); Get Internet ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TSystem.html:34703,load,loaded,34703,root/html534/TSystem.html,https://root.cern,https://root.cern/root/html534/TSystem.html,2,['load'],['loaded']
Performance,"s o n u n b i n n e d d a t a s e t s; // --------------------------------------------------------------; ; // RooDataSet is an unbinned dataset (a collection of points in N-dimensional space); RooDataSet d(""d"", ""d"", RooArgSet(x, y, c));; ; // Unlike RooAbsArgs (RooAbsPdf,RooFormulaVar,....) datasets are not attached to; // the variables they are constructed from. Instead they are attached to an internal; // clone of the supplied set of arguments; ; // Fill d with dummy values; Int_t i;; for (i = 0; i < 1000; i++) {; x = i / 50 - 10;; y = sqrt(1.0 * i);; c.setLabel((i % 2) ? ""Plus"" : ""Minus"");; ; // We must explicitly refer to x,y,c here to pass the values because; // d is not linked to them (as explained above); d.add(RooArgSet(x, y, c));; }; d.Print(""v"");; cout << endl;; ; // The get() function returns a pointer to the internal copy of the RooArgSet(x,y,c); // supplied in the constructor; const RooArgSet *row = d.get();; row->Print(""v"");; cout << endl;; ; // Get with an argument loads a specific data point in row and returns; // a pointer to row argset. get() always returns the same pointer, unless; // an invalid row number is specified. In that case a null ptr is returned; d.get(900)->Print(""v"");; cout << endl;; ; // R e d u c i n g , A p p e n d i n g a n d M e r g i n g; // -------------------------------------------------------------; ; // The reduce() function returns a new dataset which is a subset of the original; cout << endl << "">> d1 has only columns x,c"" << endl;; std::unique_ptr<RooAbsData> d1{d.reduce({x, c})};; d1->Print(""v"");; ; cout << endl << "">> d2 has only column y"" << endl;; std::unique_ptr<RooAbsData> d2{d.reduce({y})};; d2->Print(""v"");; ; cout << endl << "">> d3 has only the points with y>5.17"" << endl;; std::unique_ptr<RooAbsData> d3{d.reduce(""y>5.17"")};; d3->Print(""v"");; ; cout << endl << "">> d4 has only columns x,c for data points with y>5.17"" << endl;; std::unique_ptr<RooAbsData> d4{d.reduce({x, c}, ""y>5.17"")};; d4->Print(""v"");; ; // The m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8C.html:2035,load,loads,2035,doc/master/rf402__datahandling_8C.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8C.html,1,['load'],['loads']
Performance,"s object to the current directory. ;  ; virtual Int_t Write (const char *name=nullptr, Int_t option=0, Int_t bufsize=0) const;  Write this object to the current directory. ;  . Static Public Member Functions; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static EParUnzipMode GetParallelUnzip ();  Static function that returns the parallel option (to indicate an additional thread) ;  ; static bool IsParallelUnzip ();  Static function that tells wether the multithreading unzipping is activated. ;  ; static Int_t SetParallelUnzip (TTreeCacheUnzip::EParUnzipMode option=TTreeCacheUnzip::kEnable);  Static function that (de)activates multithreading unzipping. ;  ; static void SetUnzipRelBufferSize (Float_t relbufferSize);  static function: Sets the unzip relative buffer size ;  ;  Static Public Member Functions inherited from TTreeCache; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Int_t GetLearnEntries ();  Static function returning the number of entries used to train the cache see SetLearnEntries. ;  ; static void SetLearnEntries (Int_t n=10);  Static function to set the number of entries to be used in learning mode The default value for n is 10. ;  ;  Static Public Member Functions inherited from TFileCacheRead; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Static Public Member Functions inherited from TObject; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:17982,cache,cache,17982,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['cache'],['cache']
Performance,"s of 'var' prior to the moment calculation. If cutSpec and/or cutRange are specified the moment is calculated on the subset of the data which pass the C++ cut specification expression 'cutSpec' and/or are inside the range named 'cutRange' ; Definition at line 860 of file RooAbsData.cxx. ◆ namePtr(). const TNamed * RooAbsData::namePtr ; (; ); const. inline . De-duplicated pointer to this object's name. ; This can be used for fast name comparisons. like if (namePtr() == other.namePtr()). NoteTNamed::GetName() will return a pointer that's different for each object, but namePtr() always points to a unique instance. ; Definition at line 297 of file RooAbsData.h. ◆ numEntries(). Int_t RooAbsData::numEntries ; (; ); const. virtual . Return number of entries in dataset, i.e., count unweighted entries. ; Definition at line 323 of file RooAbsData.cxx. ◆ operator=(). RooAbsData & RooAbsData::operator= ; (; const RooAbsData & ; other). Definition at line 255 of file RooAbsData.cxx. ◆ optimizeReadingWithCaching(). void RooAbsData::optimizeReadingWithCaching ; (; RooAbsArg & ; arg, . const RooArgSet & ; cacheList, . const RooArgSet & ; keepObsList . ). protectedvirtual . Prepare dataset for use with cached constant terms listed in 'cacheList' of expression 'arg'. ; Deactivate tree branches for any dataset observable that is either not used at all, or is used exclusively by cached branch nodes. ; Definition at line 2262 of file RooAbsData.cxx. ◆ plotAsymOn(). RooPlot * RooAbsData::plotAsymOn ; (; RooPlot * ; frame, . const RooAbsCategoryLValue & ; asymCat, . PlotOpt ; o . ); const. protectedvirtual . Create and fill a histogram with the asymmetry N[+] - N[-] / ( N[+] + N[-] ), where N(+/-) is the number of data points with asymCat=+1 and asymCat=-1 as function of the frames variable. ; The asymmetry category 'asymCat' must have exactly 2 (or 3) states defined with index values +1,-1 (and 0); The plot range and the number of plot bins is determined by the parameters of the plot var",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:52600,optimiz,optimizeReadingWithCaching,52600,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['optimiz'],['optimizeReadingWithCaching']
Performance,"s of PDFs (or othe...Definition JSONIO.h:26; rf202_extendedmlfitDefinition rf202_extendedmlfit.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x7ffc9b6dfb50 RooAddPdf::model = 0.898615/1 [Auto,Clean] ; 0x7ffc9b6df238/V- RooChebychev::bkg = 0.79892 [Auto,Dirty] ; 0x7ffc9b6df768/V- RooRealVar::x = 5; 0x7ffc9b6dd3a8/V- RooRealVar::a0 = 0.441701 +/- 0.0731848; 0x7ffc9b6dd790/V- RooRealVar::a1 = 0.20108 +/- 0.1176; 0x7ffc9b6dee50/V- RooRealVar::nbkg = 504.206 +/- 39.3065; 0x7ffc9b6ddf60/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7ffc9b6dc128/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x7ffc9b6df768/V- RooRealVar::x = 5; 0x7ffc9b6de680/V- RooRealVar::mean = 5; 0x7ffc9b6dcbd8/V- RooRealVar::sigma1 = 0.5; 0x7ffc9b6ddb78/V- Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf202__extendedmlfit_8C.html:6990,optimiz,optimization,6990,doc/master/rf202__extendedmlfit_8C.html,https://root.cern,https://root.cern/doc/master/rf202__extendedmlfit_8C.html,2,['optimiz'],['optimization']
Performance,"s of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (Option_t *option="""") override;  Paint all objects in the file. ;  ; void Print (Option_t *option="""") const override;  Print all objects in the file. ;  ; virtual Bool_t ReadBufferAsync (Long64_t offs, Int_t len);  ; virtual void ReadFree ();  Read the FREE linked list. ;  ; virtual TProcessID * ReadProcessID (UShort_t pidf);  The TProcessID with number pidf is read from this file. ;  ; virtual void ReadStreamerInfo ();  Read the list of StreamerInfo from this file. ;  ; virtual Int_t Recover ();  Attempt to recover file if not correctly closed. ;  ; virtual void ResetErrno () const;  Method resetting the errno. ;  ; virtual void SetCacheRead (TFileCacheRead *cache, TObject *tree=nullptr, ECacheAction action=kDisconnect);  Set a pointer to the read cache. ;  ; virtual void SetCacheWrite (TFileCacheWrite *cache);  Set a pointer to the write cache. ;  ; virtual void SetCompressionAlgorithm (Int_t algorithm=ROOT::RCompressionSetting::EAlgorithm::kUseGlobal);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionLevel (Int_t level=ROOT::RCompressionSetting::ELevel::kUseMin);  See comments for function SetCompressionSettings. ;  ; virtual void SetCompressionSettings (Int_t settings=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault);  Used to specify the compression level and algorithm. ;  ; virtual void SetEND (Long64_t last);  ; virtual void SetOffset (Long64_t offset, ERelativeTo pos=kBeg);  Set position from where to start reading. ;  ; virtual void SetOption (Option_t *option="">"");  ; virtual void SetReadCalls (Int_t readcalls=0);  ; virtual void ShowStreamerInfo ();  Show the StreamerInfo of all classes written to this file. ;  ; Int_t Sizeof () const override;  Return the size in bytes of the file header. ;  ; void StreamerNVirtual (TBuffer &Cl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTNetXNGFile.html:6815,cache,cache,6815,doc/master/classTNetXNGFile.html,https://root.cern,https://root.cern/doc/master/classTNetXNGFile.html,6,['cache'],['cache']
Performance,"s of all files for an object with name. ;  ; const char * FindObjectClassName (const char *name) const;  Returns class name of a ROOT object including CINT globals. ;  ; const char * FindObjectPathName (const TObject *obj) const;  Return path name of obj somewhere in the //root/... path. ;  ; TObject * FindSpecialObject (const char *name, void *&where);  Returns address and folder of a ROOT object if it exists. ;  ; TClass * FindSTLClass (const char *name, Bool_t load, Bool_t silent=kFALSE) const;  return a TClass object corresponding to 'name' assuming it is an STL container. ;  ; void ForceStyle (Bool_t force=kTRUE);  ; Bool_t FromPopUp () const;  ; TApplication * GetApplication () const;  ; Int_t GetBuiltDate () const;  ; Int_t GetBuiltTime () const;  ; TClass * GetClass (const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE) const;  Return pointer to class with name. Obsolete, use TClass::GetClass directly. ;  ; TClass * GetClass (const std::type_info &typeinfo, Bool_t load=kTRUE, Bool_t silent=kFALSE) const;  Return pointer to class from its name. ;  ; TSeqCollection * GetClipboard () const;  ; TColor * GetColor (Int_t color) const;  Return address of color with index color. ;  ; const char * GetConfigFeatures () const;  ; const char * GetConfigOptions () const;  ; const char * GetCutClassName () const;  ; const char * GetDefCanvasName () const;  ; Bool_t GetEditHistograms () const;  ; Int_t GetEditorMode () const;  ; TFile * GetFile () const override;  ; TFile * GetFile (const char *name) const;  Return pointer to file with name. ;  ; Bool_t GetForceStyle () const;  ; TObject * GetFunction (const char *name) const;  Return pointer to function with name. ;  ; TFunctionTemplate * GetFunctionTemplate (const char *name);  ; TObject * GetGeometry (const char *name) const;  Return pointer to Geometry with name. ;  ; const char * GetGitBranch () const;  ; const char * GetGitCommit () const;  ; const char * GetGitDate ();  Return date/time make was run. ;  ; TGlob",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTROOT.html:5317,load,load,5317,doc/v632/classTROOT.html,https://root.cern,https://root.cern/doc/v632/classTROOT.html,2,['load'],['load']
Performance,s of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooNumConvolution*_conv! Actual convolution calculation; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_o,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:39257,cache,cache,39257,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,1,['cache'],['cache']
Performance,s of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooNumConvolution*_conv! Actual convolution calculation; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Bool_t_init! do not persist; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*Ro,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNumConvPdf.html:39639,cache,cache,39639,root/html528/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html528/RooNumConvPdf.html,4,['cache'],['cache']
Performance,"s of objects written so far; TStringfTablesType! type, used in CREATE TABLE statements; TStringTNamed::fTitleobject title; TUUIDTDirectory::fUUIDUnique identifier; Char_tTFile::fUnitsNumber of bytes for file pointers; TUrlTFile::fUrl!URL of file; Int_tfUseIndexes! use indexes for tables: 0 - off, 1 - only for basic tables, 2 + normal class tables, 3 - all tables; Bool_tfUseSuffixes! use suffixes in column names like fValue:Int_t or fObject:pointer; Int_tfUseTransactions! use transaction statements for writing data into the tables; TStringfUserName! user name, used to access objects from database; Int_tTFile::fVersionFile format version; Bool_tTDirectoryFile::fWritabletrue if directory is writable; Int_tTFile::fWrittenNumber of objects written so far; static Bool_tTDirectory::fgAddDirectory!flag to add histograms, graphs,etc to the directory; static TList*TFile::fgAsyncOpenRequestsList of handles for pending open requests; static atomic<Long64_t>TFile::fgBytesReadNumber of bytes read by all TFile objects; static atomic<Long64_t>TFile::fgBytesWriteNumber of bytes written by all TFile objects; static TStringTFile::fgCacheFileDirDirectory where to locally stage files; static Bool_tTFile::fgCacheFileDisconnectedIndicates, we trust in the files in the cache dir without stat on the cached file; static Bool_tTFile::fgCacheFileForceIndicates, to force all READ to CACHEREAD; static atomic<Long64_t>TFile::fgFileCounterCounter for all opened files; static Bool_tTFile::fgOnlyStagedBefore the file is opened, it is checked, that the file is staged, if not, the open fails; static UInt_tTFile::fgOpenTimeoutTimeout for open operations in ms - 0 corresponds to blocking i/o; static atomic<Int_t>TFile::fgReadCallsNumber of bytes read from all TFile objects; static Bool_tTFile::fgReadInfoif true (default) ReadStreamerInfo is called when opening a file; static Int_tTFile::fgReadaheadSizeReadahead buffer size; static TSQLFile::ELockingKindskLockBusy; static TSQLFile::ELockingKindskLockFree.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLFile.html:34408,cache,cache,34408,root/html602/TSQLFile.html,https://root.cern,https://root.cern/root/html602/TSQLFile.html,10,"['CACHE', 'cache']","['CACHEREAD', 'cache', 'cached']"
Performance,"s of the freed record on the file are overwritten by GAPSIZE; where GAPSIZE = -(Number of bytes occupied by the record). Option compress is used to specify the compression level:; compress = 0 objects written to this file will not be compressed.; compress = 1 minimal compression level but fast. compress = 9 maximal compression level but slow. Note that the compression level may be changed at any time.; The new compression level will only apply to newly written objects.; The function TFile::Map() shows the compression factor; for each object written to this file.; The function TFile::GetCompressionFactor returns the global; compression factor for this file. In case the file does not exist or is not a valid ROOT file,; it is made a Zombie. One can detect this situation with a code like:; TFile f(""file.root"");; if (f.IsZombie()) {; cout << ""Error opening file"" << endl;; exit(-1);; }. When opening the file, the system checks the validity of this directory.; If something wrong is detected, an automatic Recovery is performed. In; this case, the file is scanned sequentially reading all logical blocks; and attempting to rebuild a correct directory (see TFile::Recover).; One can disable the automatic recovery procedure when reading one; or more files by setting the environment variable ""TFile::Recover 0""; in the system.rootrc file. TFile(const TFile& ); TFile objects can not be copied. ~TFile(); File destructor. void Init(Bool_t create); Initialize a TFile object.; TFile implementations providing asynchronous open functionality need to; override this method to run the appropriate checks before calling this; standard initialization part. See TXNetFile::Init for an example. void Close(Option_t* option = """"); Close a file.; If option == ""R"", all TProcessIDs referenced by this file are deleted.; Calling TFile::Close(""R"") might be necessary in case one reads a long list; of files having TRef, writing some of the referenced objects or TRef; to a new file. If the TRef or referenced ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFile.html:26130,perform,performed,26130,root/html528/TFile.html,https://root.cern,https://root.cern/root/html528/TFile.html,1,['perform'],['performed']
Performance,"s of the; spectrum region. Usually peak finders fail to detect them.; resolution, decomposition of Double_tts and multiplets.; The algorithm should be able to recognize close positioned peaks.; ability to identify peaks with different sigma.; . Fig. 27 An example of one-dimensional synthetic spectrum with found peaks; denoted by markers.; ; References:. M.A. Mariscotti: A method for identification of peaks in the presence of; background and its application to spectrum analysis. NIM 50 (1967),; 309-320.; M. Morh�č, J. Kliman, V. Matou�ek, M. Veselsk�,; I. Turzo.:Identification of peaks in; multidimensional coincidence gamma-ray spectra. NIM, A443 (2000) 108-125.; Z.K. Silagadze, A new algorithm for automatic photopeak searches. NIM; A 376 (1996), 451.; . Examples of peak searching method:. The SearchHighRes function provides users with the possibility to vary the; input parameters and with the access to the output deconvolved data in the; destination spectrum. Based on the output data one can tune the parameters.; ; Example 15 - script SearchHR1.c:; . Fig. 28 One-dimensional spectrum with found peaks denoted by markers, 3; iterations steps in the deconvolution.; . Fig. 29 One-dimensional spectrum with found peaks denoted by markers, 8; iterations steps in the deconvolution.; ; Script:; ; // Example to illustrate high resolution peak searching function (class TSpectrum).; // To execute this example, do; // root > .x SearchHR1.C; #include ; void SearchHR1() {; Double_t fPositionX[100];; Double_t fPositionY[100];; Int_t fNPeaks = 0;; Int_t i,nfound,bin;; Double_t nbins = 1024,a;; Double_t xmin = 0;; Double_t xmax = nbins;; Double_t * source = new Double_t[nbins];; Double_t * dest = new Double_t[nbins];; TH1F *h = new TH1F(""h"",""High resolution peak searching, number of iterations = 3"",nbins,xmin,xmax);; TH1F *d = new TH1F(""d"","""",nbins,xmin,xmax);; TFile *f = new TFile(""spectra\\TSpectrum.root"");; h=(TH1F*) f->Get(""search2;1"");; for (i = 0; i < nbins; i++) source[i]=h->Ge",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSpectrum.html:54021,tune,tune,54021,root/html602/TSpectrum.html,https://root.cern,https://root.cern/root/html602/TSpectrum.html,4,['tune'],['tune']
Performance,"s only; 385 */; 386 DisplacementVector3D<CoordSystem, Tag>& SetRho (Scalar rr) { fCoordinates.SetRho(rr); return *this;}; 387 ; 388 /**; 389 Change Eta - CylindricalEta3D coordinates only; 390 */; 391 DisplacementVector3D<CoordSystem, Tag>& SetEta (Scalar etaval) { fCoordinates.SetEta(etaval); return *this;}; 392 ; 393 ; 394 // ------ Operations combining two vectors ------; 395 // -- need to have the specialized version in order to avoid; 396 ; 397 /**; 398 Return the scalar (dot) product of two displacement vectors.; 399 It is possible to perform the product for any type of vector coordinates,; 400 but they must have the same coordinate system tag; 401 */; 402 template< class OtherCoords >; 403 Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 404 return X()*v.X() + Y()*v.Y() + Z()*v.Z();; 405 }; 406 /**; 407 Return the scalar (dot) product of two vectors.; 408 It is possible to perform the product for any classes; 409 implementing x(), y() and z() member functions; 410 */; 411 template< class OtherVector >; 412 Scalar Dot( const OtherVector & v) const {; 413 return X()*v.x() + Y()*v.y() + Z()*v.z();; 414 }; 415 ; 416 /**; 417 Return vector (cross) product of two displacement vectors,; 418 as a vector in the coordinate system of this class.; 419 It is possible to perform the product for any type of vector coordinates,; 420 but they must have the same coordinate system tag; 421 */; 422 template <class OtherCoords>; 423 DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v) const {; 424 DisplacementVector3D result;; 425 result.SetXYZ ( Y()*v.Z() - v.Y()*Z(),; 426 Z()*v.X() - v.Z()*X(),; 427 X()*v.Y() - v.X()*Y() );; 428 return result;; 429 }; 430 /**; 431 Return vector (cross) product of two vectors,; 432 as a vector in the coordinate system of this class.; 433 It is possible to perform the product for any classes; 434 implementing X(), Y() and Z() member functions; 435 */; 436 template <class OtherVector>; 437 DisplacementVe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html:13028,perform,perform,13028,doc/master/GenVector_2DisplacementVector3D_8h_source.html,https://root.cern,https://root.cern/doc/master/GenVector_2DisplacementVector3D_8h_source.html,1,['perform'],['perform']
Performance,"s option 1, but you delete yourself the event.; for (Long64_t i=0;i<nentries;i++) {; delete event;; event = 0; // EXTREMELY IMPORTANT; T.GetEntry(i);; // the object event has been filled at this point; }. It is strongly recommended to use the default option 1. It has the; additional advantage that functions like TTree::Draw (internally calling; TTree::GetEntry) will be functional even when the classes in the file are; not available. TEntryList* GetEntryList(); Returns the entry list, set to this tree. Long64_t GetEntryNumber(Long64_t entry) const; Return entry number corresponding to entry. if no TEntryList set returns entry; else returns the entry number corresponding to the list index=entry. Long64_t GetEntryNumberWithBestIndex(Int_t major, Int_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediatly lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Int_t major, Int_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTree.html:95340,perform,performs,95340,root/html532/TTree.html,https://root.cern,https://root.cern/root/html532/TTree.html,2,['perform'],['performs']
Performance,"s option 1, but you delete yourself the event.; for (Long64_t i=0;i<nentries;i++) {; delete event;; event = 0; // EXTREMELY IMPORTANT; T.GetEntry(i);; // the object event has been filled at this point; }. It is strongly recommended to use the default option 1. It has the; additional advantage that functions like TTree::Draw (internally; calling TTree::GetEntry) will be functional even when the classes in the; file are not available. TEntryList* GetEntryList(); Returns the entry list, set to this tree. Long64_t GetEntryNumber(Long64_t entry) const; Return entry number corresponding to entry. if no TEntryList set returns entry; else returns the entry number corresponding to the list index=entry. Long64_t GetEntryNumberWithBestIndex(Int_t major, Int_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that maches val, it returns directly the; index in the table.; If an entry corresponding to major and minor is not found, the function; returns the index of the major,minor pair immediatly lower than the; requested value, ie it will return -1 if the pair is lower than; the first entry in the index. See also GetEntryNumberWithIndex. Long64_t GetEntryNumberWithIndex(Int_t major, Int_t minor = 0) const; Return entry number corresponding to major and minor number.; Note that this function returns only the entry number, not the data; To read the data corresponding to an entry number, use TTree::GetEntryWithIndex; the BuildIndex function has created a table of Long64_t* of sorted values; corresponding to val = major<<31 + minor;; The function performs binary search in this sorted table.; If it finds a pair that",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:91145,perform,performs,91145,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,2,['perform'],['performs']
Performance,"s pad. ; The most important graphics class in the ROOT system. ; A Pad is contained in a Canvas.; A Pad may contain other pads (unlimited pad hierarchy).; A pad is a linked list of primitives of any type (graphics objects, histograms, detectors, tracks, etc.).; Adding a new element into a pad is in general performed by the Draw member function of the object classes.; It is important to realize that the pad is a linked list of references to the original object. For example, in case of a histogram, the histogram.Draw() operation only stores a reference to the histogram object and not a graphical representation of this histogram. When the mouse is used to change (say the bin content), the bin content of the original histogram is changed.; The convention used in ROOT is that a Draw operation only adds a reference to the object. The effective drawing is performed when the canvas receives a signal to be painted. This signal is generally sent when typing carriage return in the command input or when a graphical operation has been performed on one of the pads of this canvas. When a Canvas/Pad is repainted, the member function Paint for all objects in the Pad linked list is invoked. When the mouse is moved on the Pad, The member function DistancetoPrimitive is called for all the elements in the pad. DistancetoPrimitive returns the distance in pixels to this object.; When the object is within the distance window, the member function ExecuteEvent is called for this object.; In ExecuteEvent, move, changes can be performed on the object.; For examples of DistancetoPrimitive and ExecuteEvent functions, see classes TLine::DistancetoPrimitive, TLine::ExecuteEvent; TBox::DistancetoPrimitive, TBox::ExecuteEvent; TH1::DistancetoPrimitive, TH1::ExecuteEvent; TBox::ExecuteEventvoid ExecuteEvent(Int_t event, Int_t px, Int_t py) overrideExecute action corresponding to one event.Definition TBox.cxx:232; TBox::DistancetoPrimitiveInt_t DistancetoPrimitive(Int_t px, Int_t py) overrideCompute di",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTPad.html:1469,perform,performed,1469,doc/master/classTPad.html,https://root.cern,https://root.cern/doc/master/classTPad.html,1,['perform'],['performed']
Performance,"s particularly useful when dealing with datasets of a moderate size (small enough to fit the RAM) over which several explorative loops need to be performed as fast as possible. In addition, caching can be useful when no file on disk needs to be created as a side effect of checkpointing part of the analysis.; All steps in the caching are lazy, i.e. the cached data frame is actually filled only when the event loop is triggered on it.; ; void df019_Cache(); {; // We create a data frame on top of the hsimple example.; auto hsimplePath = gROOT->GetTutorialDir();; hsimplePath += ""/hsimple.root"";; ROOT::RDataFrame df(""ntuple"", hsimplePath.Data());; ; // We apply a simple cut and define a new column.; auto df_cut = df.Filter([](float py) { return py > 0.f; }, {""py""}); .Define(""px_plus_py"", [](float px, float py) { return px + py; }, {""px"", ""py""});; ; // We cache the content of the dataset. Nothing has happened yet: the work to accomplish; // has been described. As for `Snapshot`, the types and columns can be written out explicitly; // or left for the jitting to handle (`df_cached` is intentionally unused - it shows how; // to create a *cached* dataframe specifying column types explicitly):; auto df_cached = df_cut.Cache<float, float>({""px_plus_py"", ""py""});; auto df_cached_implicit = df_cut.Cache();; auto h = df_cached_implicit.Histo1D<float>(""px_plus_py"");; ; // Now the event loop on the cached dataset is triggered. This event triggers the loop; // on the `df` data frame lazily.; h->DrawCopy();; }; h#define h(i)Definition RSha256.hxx:106; gROOT#define gROOTDefinition TROOT.h:406; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; df019_CacheDefinition df019_Cache.py:1; . DateJune 2018 ; AuthorDanilo Piparo (CERN) ; Definition in file df019_Cache.C. tutorialsdataframedf019_Cache.C. ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:27 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/df019__Cache_8C.html:1766,cache,cached,1766,doc/master/df019__Cache_8C.html,https://root.cern,https://root.cern/doc/master/df019__Cache_8C.html,2,['cache'],['cached']
Performance,"s read; TList*TEventIter::fPacketslist of packets processed packets; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile, const char* objname = 0); Load a tree from s TDSetElement. Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0); Get loop range. void PreProcessEvent(Long64_t ent); Actions to be done just before processing entry 'entry'.; Called by TProofPlayer. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-04 09:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TEventIterTree.html:8654,Load,Load,8654,root/html604/TEventIterTree.html,https://root.cern,https://root.cern/root/html604/TEventIterTree.html,2,['Load'],['Load']
Performance,"s read; TList*TEventIter::fPacketslist of packets processed packets; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; Bool_tfDontCacheFilesControl OS caching of read files (Mac Os X only); TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile, const char* objname = 0); Load a tree from s TDSetElement. Int_t GetNextPacket(Long64_t& first, Long64_t& num, TEntryList** enl = 0, TEventList** evl = 0); Get loop range. void PreProcessEvent(Long64_t ent); Actions to be done just before processing entry 'entry'.; Called by TProofPlayer. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rademakers. *; » Last changed: root/proofplayer:$Id$ » Last generated: 2015-06-30 14:48; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TEventIterTree.html:8654,Load,Load,8654,root/html602/TEventIterTree.html,https://root.cern,https://root.cern/root/html602/TEventIterTree.html,2,['Load'],['Load']
Performance,"s requires special care in sections protected by GetSharedDescriptorGuard() and GetExclDescriptorGuard() especially to avoid that the locks are acquired indirectly (e.g. by a call to GetNEntries()). As a general guideline, no other method of the page source should be called (directly or indirectly) in a guarded section. ; Definition at line 722 of file RPageStorage.hxx. ◆ GetType(). EPageStorageType ROOT::Experimental::Internal::RPageSource::GetType ; (; ). inlinefinalvirtual . Whether the concrete implementation is a sink or a source. ; Implements ROOT::Experimental::Internal::RPageStorage.; Definition at line 713 of file RPageStorage.hxx. ◆ LoadClusters(). virtual std::vector< std::unique_ptr< RCluster > > ROOT::Experimental::Internal::RPageSource::LoadClusters ; (; std::span< RCluster::RKey > ; clusterKeys). pure virtual . Populates all the pages of the given cluster ids and columns; it is possible that some columns do not contain any pages. ; The page source may load more columns than the minimal necessary set from columns. To indicate which columns have been loaded, LoadClusters()must mark them withSetColumnAvailable(). That includes the ones from thecolumnsthat don't have pages; otherwise subsequent requests for the cluster would assume an incomplete cluster and trigger loading again. LoadClusters()` is typically called from the I/O thread of a cluster pool, i.e. the method runs concurrently to other methods of the page source. ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ LoadPage() [1/2]. ROOT::Experimental::Internal::RPageRef ROOT::Experimental::Internal::RPageSource::LoadPage ; (; ColumnHandle_t ; columnHandle, . NTupleSize_t ; globalIndex . ). virtual . Allocates and fills a page that contains the index-th element. ; The default implementation searches the page and calls LoadPageImpl(). Returns a default-constructed RPage for suppressed ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:14234,load,load,14234,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['load'],['load']
Performance,"s so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCache.html:18824,cache,cache,18824,root/html528/TTreeCache.html,https://root.cern,https://root.cern/root/html528/TTreeCache.html,1,['cache'],['cache']
Performance,"s so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read fr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCache.html:20690,cache,cache,20690,root/html530/TTreeCache.html,https://root.cern,https://root.cern/root/html530/TTreeCache.html,1,['cache'],['cache']
Performance,"s so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the processing or we will; get uncomplete stats. Double_t GetEfficiencyRel() const; This will indicate a sort of relative efficiency... a ratio of the; reads found in the cache to the number of reads so far. Int_t GetLearnEntries(); static function returning the number of entries used to train the cache; see SetLearnEntries. TTree * GetOwner() const; return the owner of this cache. TTree * GetTree() const; return Tree in the cache. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Number of branches in the cache ...: 1093; Cache Efficiency ..................: 0.997372; Cache Efficiency Rel...............: 1.000000; Learn entries......................: 100; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being; cached is printed. Int_t ReadBufferNormal(char* buf, Long64_t pos, Int_t len). Int_t ReadBufferPrefetch(char* buf, Long64_t pos, Int_t len). Int_t ReadBuffer(char* buf, Long64_t pos, Int_t l",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TTreeCache.html:21532,cache,cache,21532,root/html532/TTreeCache.html,https://root.cern,https://root.cern/root/html532/TTreeCache.html,2,['cache'],['cache']
Performance,"s some cache content is lost, or if the buffer; is now larger, setup for a cache refill the next time there is a read; Returns 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void LearnPrefill(); Perform an initial prefetch, attempting to read as much of the learning; phase baskets for all branches at once. TTreeCache(const TTreeCache& ). TTreeCache",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeCache.html:26916,cache,cache,26916,root/html604/TTreeCache.html,https://root.cern,https://root.cern/root/html604/TTreeCache.html,2,['cache'],['cache']
Performance,"s successfully loaded.; 1969 ; 1970UInt_t TSystem::LoadAllLibraries(); 1971{; 1972 UInt_t nlibs = 0;; 1973 ; 1974 TEnv* mapfile = gInterpreter->GetMapfile();; 1975 if (!mapfile || !mapfile->GetTable()) return 0;; 1976 ; 1977 std::set<std::string> loadedlibs;; 1978 std::set<std::string> failedlibs;; 1979 ; 1980 TEnvRec* rec = nullptr;; 1981 TIter iEnvRec(mapfile->GetTable());; 1982 while ((rec = (TEnvRec*) iEnvRec())) {; 1983 TString libs = rec->GetValue();; 1984 TString lib;; 1985 Ssiz_t pos = 0;; 1986 while (libs.Tokenize(lib, pos)) {; 1987 // check that none of the libs failed to load; 1988 if (failedlibs.find(lib.Data()) != failedlibs.end()) {; 1989 // don't load it or any of its dependencies; 1990 libs = """";; 1991 break;; 1992 }; 1993 }; 1994 pos = 0;; 1995 while (libs.Tokenize(lib, pos)) {; 1996 // ignore libCore - it's already loaded; 1997 if (lib.BeginsWith(""libCore"")); 1998 continue;; 1999 ; 2000 if (loadedlibs.find(lib.Data()) == loadedlibs.end()) {; 2001 // just load the first library - TSystem will do the rest.; 2002 auto res = gSystem->Load(lib);; 2003 if (res >=0) {; 2004 if (res == 0) ++nlibs;; 2005 loadedlibs.insert(lib.Data());; 2006 } else {; 2007 failedlibs.insert(lib.Data());; 2008 }; 2009 }; 2010 }; 2011 }; 2012 return nlibs;; 2013}; 2014 ; 2015////////////////////////////////////////////////////////////////////////////////; 2016/// Find a dynamic library called lib using the system search paths.; 2017/// Appends known extensions if needed. Returned string must be deleted; 2018/// by the user!; 2019 ; 2020char *TSystem::DynamicPathName(const char *lib, Bool_t quiet /*=kFALSE*/); 2021{; 2022 TString sLib(lib);; 2023 if (FindDynamicLibrary(sLib, quiet)); 2024 return StrDup(sLib);; 2025 return nullptr;; 2026}; 2027 ; 2028////////////////////////////////////////////////////////////////////////////////; 2029/// Find a dynamic library using the system search paths. lib will be updated; 2030/// to contain the absolute filename if found. Returns lib if fo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSystem_8cxx_source.html:64653,load,load,64653,doc/master/TSystem_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSystem_8cxx_source.html,1,['load'],['load']
Performance,"s that a fifth of the; 146/// training data should be used. ""100""; 147/// indicates that 100 events should be used.; 148 ; 149void TMVA::MethodDNN::DeclareOptions(); 150{; 151 ; 152 DeclareOptionRef(fLayoutString=""SOFTSIGN|(N+100)*2,LINEAR"",; 153 ""Layout"",; 154 ""Layout of the network."");; 155 ; 156 DeclareOptionRef(fValidationSize = ""20%"", ""ValidationSize"",; 157 ""Part of the training data to use for ""; 158 ""validation. Specify as 0.2 or 20% to use a ""; 159 ""fifth of the data set as validation set. ""; 160 ""Specify as 100 to use exactly 100 events. ""; 161 ""(Default: 20%)"");; 162 ; 163 DeclareOptionRef(fErrorStrategy=""CROSSENTROPY"",; 164 ""ErrorStrategy"",; 165 ""Loss function: Mean squared error (regression)""; 166 "" or cross entropy (binary classification)."");; 167 AddPreDefVal(TString(""CROSSENTROPY""));; 168 AddPreDefVal(TString(""SUMOFSQUARES""));; 169 AddPreDefVal(TString(""MUTUALEXCLUSIVE""));; 170 ; 171 DeclareOptionRef(fWeightInitializationString=""XAVIER"",; 172 ""WeightInitialization"",; 173 ""Weight initialization strategy"");; 174 AddPreDefVal(TString(""XAVIER""));; 175 AddPreDefVal(TString(""XAVIERUNIFORM""));; 176 ; 177 DeclareOptionRef(fArchitectureString = ""CPU"", ""Architecture"", ""Which architecture to perform the training on."");; 178 AddPreDefVal(TString(""STANDARD""));; 179 AddPreDefVal(TString(""CPU""));; 180 AddPreDefVal(TString(""GPU""));; 181 AddPreDefVal(TString(""OPENCL""));; 182 ; 183 DeclareOptionRef(; 184 fTrainingStrategyString = ""LearningRate=1e-1,""; 185 ""Momentum=0.3,""; 186 ""Repetitions=3,""; 187 ""ConvergenceSteps=50,""; 188 ""BatchSize=30,""; 189 ""TestRepetitions=7,""; 190 ""WeightDecay=0.0,""; 191 ""Renormalize=L2,""; 192 ""DropConfig=0.0,""; 193 ""DropRepetitions=5|LearningRate=1e-4,""; 194 ""Momentum=0.3,""; 195 ""Repetitions=3,""; 196 ""ConvergenceSteps=50,""; 197 ""BatchSize=20,""; 198 ""TestRepetitions=7,""; 199 ""WeightDecay=0.001,""; 200 ""Renormalize=L2,""; 201 ""DropConfig=0.0+0.5+0.5,""; 202 ""DropRepetitions=5,""; 203 ""Multithreading=True"",; 204 ""TrainingStrategy"",; 205 ""Defines the tr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDNN_8cxx_source.html:6255,perform,perform,6255,doc/master/MethodDNN_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDNN_8cxx_source.html,1,['perform'],['perform']
Performance,s that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; static RooArgSet_emptySetSupports named argument constructor; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_t_extended; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Bool_t_first!; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*RooAbsOptTestStatistic::_funcClonePointer to internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*RooAbsOptTestStatistic::_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbs,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNLLVar.html:39386,cache,cache,39386,root/html602/RooNLLVar.html,https://root.cern,https://root.cern/root/html602/RooNLLVar.html,4,['cache'],['cache']
Performance,"s the closest distance to any boundary. Random points. A method to check the validity of a given geometry is shooting random points. This can be called with the method TGeoVolume::RandomPoints() and it draws a volume with the current visualization settings. Random points are generated in the bounding box of the drawn volume. The points are drawn with the color of their deepest container. Only points inside visible nodes are drawn. Random rays. A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node.; 18.7 The Drawing Package; The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter()loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes.; 18.7.1 Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1004609,load,loaded,1004609,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loaded']
Performance,"s the desired array elements as follows:; 479 ; 480~~~{.cpp}; 481// h is filled with all the elements of `good_pts`, for each event; 482auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); 483 .Histo1D(""good_pts"");; 484~~~; 485 ; 486And in Python:; 487 ; 488~~~{.py}; 489h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); 490~~~; 491 ; 492Learn more at ROOT::VecOps::RVec.; 493 ; 494\anchor transformations; 495## Transformations: manipulating data; 496\anchor Filters; 497### Filters; 498A filter is created through a call to `Filter(f, columnList)` or `Filter(filterString)`. In the first overload, `f` can; 499be a function, a lambda expression, a functor class, or any other callable object. It must return a `bool` signalling; 500whether the event has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; 501columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; 502when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; 503names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; 504certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; 505loop. See the paragraph about ""Just-in-time compilation"" below for more information.; 506 ; 507RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; 508in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; 509entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; 510each entry: after the first access it simply serves a cached result.; 511 ; 512\anchor named-filters-and-cutflow-reports; 513#### Named filters and cutflo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/RDataFrame_8cxx_source.html:30338,multi-thread,multi-threading,30338,doc/v632/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"s the desired array elements as follows:; 519 ; 520~~~{.cpp}; 521// h is filled with all the elements of `good_pts`, for each event; 522auto h = df.Define(""good_pts"", [](const ROOT::RVecF &pt) { return pt[pt > 0]; }); 523 .Histo1D(""good_pts"");; 524~~~; 525 ; 526And in Python:; 527 ; 528~~~{.py}; 529h = df.Define(""good_pts"", ""pt[pt > 0]"").Histo1D(""good_pts""); 530~~~; 531 ; 532Learn more at ROOT::VecOps::RVec.; 533 ; 534\anchor transformations; 535## Transformations: manipulating data; 536\anchor Filters; 537### Filters; 538A filter is created through a call to `Filter(f, columnList)` or `Filter(filterString)`. In the first overload, `f` can; 539be a function, a lambda expression, a functor class, or any other callable object. It must return a `bool` signalling; 540whether the event has passed the selection (`true`) or not (`false`). It should perform ""read-only"" operations on the; 541columns, and should not have side-effects (e.g. modification of an external or static variable) to ensure correctness; 542when implicit multi-threading is active. The second overload takes a string with a valid C++ expression in which column; 543names are used as variable names (e.g. `Filter(""x[0] + x[1] > 0"")`). This is a convenience feature that comes with a; 544certain runtime overhead: C++ code has to be generated on the fly from this expression before using it in the event; 545loop. See the paragraph about ""Just-in-time compilation"" below for more information.; 546 ; 547RDataFrame only evaluates filters when necessary: if multiple filters are chained one after another, they are executed; 548in order and the first one returning `false` causes the event to be discarded and triggers the processing of the next; 549entry. If multiple actions or transformations depend on the same filter, that filter is not executed multiple times for; 550each entry: after the first access it simply serves a cached result.; 551 ; 552\anchor named-filters-and-cutflow-reports; 553#### Named filters and cutflo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RDataFrame_8cxx_source.html:31978,multi-thread,multi-threading,31978,doc/master/RDataFrame_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RDataFrame_8cxx_source.html,1,['multi-thread'],['multi-threading']
Performance,"s the window size in pixels along X ; [in]whis the window size in pixels along Y . Definition at line 475 of file TCanvas.cxx. ◆ Constructor() [4/4]. void TCanvas::Constructor ; (; const char * ; name, . const char * ; title, . Int_t ; ww, . Int_t ; wh . ). Create a new canvas at a random position. ; Parameters. [in]namecanvas name ; [in]titlecanvas title ; [in]wwis the window size in pixels along X (if ww < 0 the menubar is not shown) ; [in]whis the window size in pixels along Y . Definition at line 386 of file TCanvas.cxx. ◆ CopyPixmaps(). void TCanvas::CopyPixmaps ; (; ). overrideprivatevirtual . Copy the canvas pixmap of the pad to the canvas. ; Implements TVirtualPad.; Definition at line 833 of file TCanvas.cxx. ◆ CreatePainter(). void TCanvas::CreatePainter ; (; ). private . Probably, TPadPainter must be placed in a separate ROOT module - ""padpainter"" (the same as ""histpainter""). ; But now, it's directly in a gpad dir, so, in case of default painter, no *.so should be loaded, no need in plugin managers. May change in future. ; Definition at line 2582 of file TCanvas.cxx. ◆ DeclFileName(). static const char * TCanvas::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 238 of file TCanvas.h. ◆ Delete(). void TCanvas::Delete ; (; Option_t * ; option = """"). inlineoverridevirtual . Delete this object. ; Typically called as a command via the interpreter. Normally use ""delete"" operator when object has been allocated on the heap. ; Reimplemented from TObject.; Definition at line 120 of file TCanvas.h. ◆ DeleteCanvasPainter(). void TCanvas::DeleteCanvasPainter ; (; ). assert on IsBatch() == false? ; Definition at line 2613 of file TCanvas.cxx. ◆ Destructor(). void TCanvas::Destructor ; (; ). Actual canvas destructor. ; Definition at line 692 of file TCanvas.cxx. ◆ DisconnectWidget(). void TCanvas::DisconnectWidget ; (; ). Used by friend class TCanvasImp. ; Definition at line 2545 of file TCanvas.cxx. ◆ Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTCanvas.html:69029,load,loaded,69029,doc/v632/classTCanvas.html,https://root.cern,https://root.cern/doc/v632/classTCanvas.html,1,['load'],['loaded']
Performance,"s the window size in pixels along X ; [in]whis the window size in pixels along Y . Definition at line 478 of file TCanvas.cxx. ◆ Constructor() [4/4]. void TCanvas::Constructor ; (; const char * ; name, . const char * ; title, . Int_t ; ww, . Int_t ; wh . ). Create a new canvas at a random position. ; Parameters. [in]namecanvas name ; [in]titlecanvas title ; [in]wwis the window size in pixels along X (if ww < 0 the menubar is not shown) ; [in]whis the window size in pixels along Y . Definition at line 389 of file TCanvas.cxx. ◆ CopyPixmaps(). void TCanvas::CopyPixmaps ; (; ). overrideprivatevirtual . Copy the canvas pixmap of the pad to the canvas. ; Implements TVirtualPad.; Definition at line 836 of file TCanvas.cxx. ◆ CreatePainter(). void TCanvas::CreatePainter ; (; ). private . Probably, TPadPainter must be placed in a separate ROOT module - ""padpainter"" (the same as ""histpainter""). ; But now, it's directly in a gpad dir, so, in case of default painter, no *.so should be loaded, no need in plugin managers. May change in future. ; Definition at line 2595 of file TCanvas.cxx. ◆ DeclFileName(). static const char * TCanvas::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 238 of file TCanvas.h. ◆ Delete(). void TCanvas::Delete ; (; Option_t * ; option = """"). inlineoverridevirtual . Delete this object. ; Typically called as a command via the interpreter. Normally use ""delete"" operator when object has been allocated on the heap. ; Reimplemented from TObject.; Definition at line 120 of file TCanvas.h. ◆ DeleteCanvasPainter(). void TCanvas::DeleteCanvasPainter ; (; ). assert on IsBatch() == false? ; Definition at line 2626 of file TCanvas.cxx. ◆ Destructor(). void TCanvas::Destructor ; (; ). Actual canvas destructor. ; Definition at line 695 of file TCanvas.cxx. ◆ DisconnectWidget(). void TCanvas::DisconnectWidget ; (; ). Used by friend class TCanvasImp. ; Definition at line 2558 of file TCanvas.cxx. ◆ Draw",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTCanvas.html:69405,load,loaded,69405,doc/master/classTCanvas.html,https://root.cern,https://root.cern/doc/master/classTCanvas.html,1,['load'],['loaded']
Performance,"s the; whole viewport. void MakeCurrent() const; Make GL context current. void SwapBuffers() const; Swap GL buffers. Bool_t RequestSelect(Int_t x, Int_t y); Post request for selection render pass viewer, picking objects; around the window point (x,y). Bool_t DoSelect(Int_t x, Int_t y); Perform GL selection, picking objects overlapping WINDOW; area described by 'rect'. Return kTRUE if selection should be; changed, kFALSE otherwise.; Select lock should already been taken in other thread in; TGLViewer::ReqSelect(). Bool_t RequestSecondarySelect(Int_t x, Int_t y); Request secondary select. Bool_t DoSecondarySelect(Int_t x, Int_t y); Secondary selection. void ApplySelection(); Process result from last selection (in fSelRec) and; extract a new current selection from it.; Here we only use physical shape. Bool_t RequestOverlaySelect(Int_t x, Int_t y); Post request for secondary selection rendering of selected object; around the window point (x,y). Bool_t DoOverlaySelect(Int_t x, Int_t y); Perform GL selection, picking overlay objects only.; Return TRUE if the selected overlay-element has changed. void AutoFade(Float_t fade, Float_t time = 1, Int_t steps = 10); Animate fading from curernt value to fade over given time (sec); and number of steps. void UseDarkColorSet(); Use the dark color-set. void UseLightColorSet(); Use the light color-set. void SwitchColorSet(); Swtich between dark and light colorsets. void UseDefaultColorSet(Bool_t x); Set usage of the default color set. Bool_t IsUsingDefaultColorSet() const; Check if the viewer is using the default color set.; If yes, some operations might be disabled. void SetClearColor(Color_t col); Set background method.; Deprecated method - set background color in the color-set. TGLColorSet& GetDefaultColorSet(); Returns reference to the default color-set.; Static function. void UseDefaultColorSetForNewViewers(Bool_t x); Sets static flag that determines if new viewers should use the; default color-set.; This is false at startup. Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLViewer.html:28773,Perform,Perform,28773,root/html532/TGLViewer.html,https://root.cern,https://root.cern/root/html532/TGLViewer.html,4,['Perform'],['Perform']
Performance,"s to be done. This machine independent version of the data is copied into a; basket (each branch has its own basket). When a basket is full; (32k worth of data by default), it is then optionally compressed; and written to disk (this operation is also called comitting or; 'flushing' the basket). The committed baskets are then; immediately removed from memory. The function returns the number of bytes committed to the; individual branches. If a write error occurs, the number of bytes returned is -1. If no data are written, because, e.g., the branch is disabled,; the number of bytes returned is 0. The baskets are flushed and the Tree header saved at regular intervals. At regular intervals, when the amount of data written so far is; greater than fAutoFlush (see SetAutoFlush) all the baskets are flushed to disk.; This makes future reading faster as it guarantees that baskets belonging to nearby; entries will be on the same disk region.; When the first call to flush the baskets happen, we also take this opportunity; to optimize the baskets buffers.; We also check if the amount of data written is greater than fAutoSave (see SetAutoSave).; In this case we also write the Tree header. This makes the Tree recoverable up to this point; in case the program writing the Tree crashes.; The decisions to FlushBaskets and Auto Save can be made based either on the number; of bytes written (fAutoFlush and fAutoSave negative) or on the number of entries; written (fAutoFlush and fAutoSave positive).; Note that the user can decide to call FlushBaskets and AutoSave in her event loop; base on the number of events written instead of the number of bytes written. Note that calling FlushBaskets too often increases the IO time.; Note that calling AutoSave too often increases the IO time and also the file size. TBranch* FindBranch(const char* name); Return the branch that correspond to the path 'branchname', which can; include the name of the tree or the ommited name of the parent branches.; In cas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTree.html:83554,optimiz,optimize,83554,root/html528/TTree.html,https://root.cern,https://root.cern/root/html528/TTree.html,4,['optimiz'],['optimize']
Performance,"s to compare the; 484/// performance of various configurations; 485 ; 486TMVA::MethodBase *; 487TMVA::Factory::BookMethod(TMVA::DataLoader *loader, Types::EMVA theMethod, TString methodTitle, TString theOption); 488{; 489 return BookMethod(loader, Types::Instance().GetMethodName(theMethod), methodTitle, theOption);; 490}; 491 ; 492////////////////////////////////////////////////////////////////////////////////; 493/// Adds an already constructed method to be managed by this factory.; 494///; 495/// \note Private.; 496/// \note Know what you are doing when using this method. The method that you; 497/// are loading could be trained already.; 498///; 499 ; 500TMVA::MethodBase *; 501TMVA::Factory::BookMethodWeightfile(DataLoader *loader, TMVA::Types::EMVA methodType, const TString &weightfile); 502{; 503 TString datasetname = loader->GetName();; 504 std::string methodTypeName = std::string(Types::Instance().GetMethodName(methodType).Data());; 505 DataSetInfo &dsi = loader->GetDataSetInfo();; 506 ; 507 IMethod *im = ClassifierFactory::Instance().Create(methodTypeName, dsi, weightfile);; 508 MethodBase *method = (dynamic_cast<MethodBase *>(im));; 509 ; 510 if (method == nullptr); 511 return nullptr;; 512 ; 513 if (method->GetMethodType() == Types::kCategory) {; 514 Log() << kERROR << ""Cannot handle category methods for now."" << Endl;; 515 }; 516 ; 517 TString fileDir;; 518 if (fModelPersistence) {; 519 // find prefix in fWeightFileDir;; 520 TString prefix = gConfig().GetIONames().fWeightFileDirPrefix;; 521 fileDir = prefix;; 522 if (!prefix.IsNull()); 523 if (fileDir[fileDir.Length() - 1] != '/'); 524 fileDir += ""/"";; 525 fileDir = loader->GetName();; 526 fileDir += ""/"" + gConfig().GetIONames().fWeightFileDir;; 527 }; 528 ; 529 if (fModelPersistence); 530 method->SetWeightFileDir(fileDir);; 531 method->SetModelPersistence(fModelPersistence);; 532 method->SetAnalysisType(fAnalysisType);; 533 method->SetupMethod();; 534 method->SetFile(fgTargetFile);; 535 method->SetSilentF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:20916,load,loader,20916,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,1,['load'],['loader']
Performance,"s to process. The default is 1000 events. Be aware that executing stress with 1000 eventswill create several files consuming about 100 MB of disk space; running stress with 30 events will consume about 20 MB. The disk space is released once stress is done.; There are two ways to run stress:; From the system prompt or from the ROOT prompt using the interpreter.; > cd $ROOTSYS/test; > stress // default 1000 events; > stress 30 // test with 30 events; Start ROOT with the batch mode option (-b) to suppress the graphic output.; > root -b; root[] .L stress.cxx; root[] stress(1000)// test with 1000 events; root[] stress(30)// test with 30 events; The output of stress includes a pass/fail conclusion for each test, the total number of bytes read and written, and the elapsed real and CPU time. It also calculates a performance index for your machine relative to a reference machine a DELL Inspiron 7500 (Pentium III 600 MHz) with 256 MB of memory and 18GB IDE disk in ROOTMARKS. Higher ROOTMARKS means better performance. The reference machine has 200 ROOTMARKS, so the sample run below with 53.7 ROOTMARKS is about four times slower than the reference machine.; Here is a sample run:; % root -b; root[] .x stress.cxx(30). Test 1 : Functions, Random Numbers, Histogram Fits............. OK; Test 2 : Check size & compression factor of a Root file........ OK; Test 3 : Purge, Reuse of gaps in TFile......................... OK; Test 4 : Test of 2-d histograms, functions, 2-d fits........... OK; Test 5 : Test graphics & PostScript ............................OK; Test 6 : Test subdirectories in a Root file.................... OK; Test 7 : TNtuple, selections, TCutG, TEventList.......... OK; Test 8 : Trees split and compression modes..................... OK; Test 9 : Analyze Event.root file of stress 8................... OK; Test 10 : Create 10 files starting from Event.root.............. OK; Test 11 : Test chains of Trees using the 10 files............... OK; Test 12 : Compare histograms of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1084302,perform,performance,1084302,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['perform'],['performance']
Performance,"s true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooRealIntegral.html:39186,Perform,Perform,39186,root/html534/RooRealIntegral.html,https://root.cern,https://root.cern/root/html534/RooRealIntegral.html,3,['Perform'],['Perform']
Performance,"s true if string contains one of the wildcard characters ""[]*?"".Definition TString.cxx:964; TString::Formatstatic TString Format(const char *fmt,...)Static method which formats a string using a printf style format descriptor and return a TString.Definition TString.cxx:2378; TString::Formvoid Form(const char *fmt,...)Formats a string using a printf style format descriptor.Definition TString.cxx:2356; TString::ContainsBool_t Contains(const char *pat, ECaseCompare cmp=kExact) constDefinition TString.h:632; TString::IndexSsiz_t Index(const char *pat, Ssiz_t i=0, ECaseCompare cmp=kExact) constDefinition TString.h:651; TSystem::AccessPathNamevirtual Bool_t AccessPathName(const char *path, EAccessMode mode=kFileExists)Returns FALSE if one can access a file using the specified access mode.Definition TSystem.cxx:1296; TSystem::BaseNamevirtual const char * BaseName(const char *pathname)Base name of a file name. Base name of /user/root is root.Definition TSystem.cxx:934; TTreeCacheA cache to speed-up the reading of ROOT datasets.Definition TTreeCache.h:32; TTreeCache::UpdateBranchesvirtual void UpdateBranches(TTree *tree)Update pointer to current Tree and recompute pointers to the branches in the cache.Definition TTreeCache.cxx:2211; TTreeCache::ResetCachevirtual void ResetCache()This will simply clear the cache.Definition TTreeCache.cxx:2040; TTree::TClusterIteratorHelper class to iterate over cluster of baskets.Definition TTree.h:270; TTree::TFriendLockHelper class to prevent infinite recursion in the usage of TTree Friends.Definition TTree.h:188; TTreeA TTree represents a columnar dataset.Definition TTree.h:79; TTree::AddFriendvirtual TFriendElement * AddFriend(const char *treename, const char *filename="""")Add a TFriendElement to the list of friends.Definition TTree.cxx:1332; TTree::FindBranchvirtual TBranch * FindBranch(const char *name)Return the branch that correspond to the path 'branchname', which can include the name of the tree or...Definition TTree.cxx:4841; TTree::",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:143329,cache,cache,143329,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['cache'],['cache']
Performance,"s used as weight. A separate firstval argument is needed so the compiler does not pick this overload instead of the non-templated Fill overloads ; Definition at line 167 of file THnBase.h. ◆ FillBin(). virtual void THnBase::FillBin ; (; Long64_t ; bin, . Double_t ; w . ). pure virtual . Implemented in THn, and THnSparse. ◆ FillBinBase(). void THnBase::FillBinBase ; (; Double_t ; w). inlineprotected . Increment the statistics due to filled weight ""w"",. ; Definition at line 89 of file THnBase.h. ◆ Fit(). TFitResultPtr THnBase::Fit ; (; TF1 * ; f, . Option_t * ; option = """", . Option_t * ; goption = """" . ). Fit a THnSparse with function f. ; since the data is sparse by default a likelihood fit is performed merging all the regions with empty bins for better performance efficiency; Since the THnSparse is not drawn no graphics options are passed Here is the list of possible options = ""I"" Use integral of function in bin instead of value at bin center; = ""X"" Use chi2 method (default is log-likelihood method); = ""U"" Use a User specified fitting algorithm (via SetFCN); = ""Q"" Quiet mode (minimum printing); = ""V"" Verbose mode (default is between Q and V); = ""E"" Perform better Errors estimation using Minos technique; = ""B"" Use this option when you want to fix one or more parameters; and the fitting function is like ""gaus"", ""expo"", ""poln"", ""landau"".; = ""M"" More. Improve fit results; = ""R"" Use the Range specified in the function range . Definition at line 505 of file THnBase.cxx. ◆ GetAxis(). TAxis * THnBase::GetAxis ; (; Int_t ; dim); const. inline . Definition at line 130 of file THnBase.h. ◆ GetBin() [1/6]. virtual Long64_t THnBase::GetBin ; (; const char * ; name[]); const. pure virtual . Implemented in THn, and THnSparse. ◆ GetBin() [2/6]. virtual Long64_t THnBase::GetBin ; (; const char * ; name[], . Bool_t ; = kTRUE . ). pure virtual . Implemented in THnSparse, and THn. ◆ GetBin() [3/6]. virtual Long64_t THnBase::GetBin ; (; const Double_t * ; x); const. pure virtual . Imple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHnBase.html:29074,perform,performed,29074,doc/master/classTHnBase.html,https://root.cern,https://root.cern/doc/master/classTHnBase.html,2,['perform'],"['performance', 'performed']"
Performance,"s useful to overload this function rather; 347/// than analyticalIntegralWN() as the additional normalization information; 348/// may be useful in determining a more efficient decomposition of the; 349/// requested integral.; 350 ; 351Int_t RooAbsReal::getAnalyticalIntegralWN(RooArgSet& allDeps, RooArgSet& analDeps,; 352 const RooArgSet* /*normSet*/, const char* rangeName) const; 353{; 354 return _forceNumInt ? 0 : getAnalyticalIntegral(allDeps,analDeps,rangeName) ;; 355}; 356 ; 357 ; 358 ; 359////////////////////////////////////////////////////////////////////////////////; 360/// Interface function getAnalyticalIntergral advertises the; 361/// analytical integrals that are supported. 'integSet'; 362/// is the set of dependents for which integration is requested. The; 363/// function should copy the subset of dependents it can analytically; 364/// integrate to anaIntSet and return a unique identification code for; 365/// this integration configuration. If no integration can be; 366/// performed, zero should be returned.; 367 ; 368Int_t RooAbsReal::getAnalyticalIntegral(RooArgSet& /*integSet*/, RooArgSet& /*anaIntSet*/, const char* /*rangeName*/) const; 369{; 370 return 0 ;; 371}; 372 ; 373 ; 374 ; 375////////////////////////////////////////////////////////////////////////////////; 376/// Implements the actual analytical integral(s) advertised by; 377/// getAnalyticalIntegral. This functions will only be called with; 378/// codes returned by getAnalyticalIntegral, except code zero.; 379 ; 380double RooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName) const; 381{; 382// cout << ""RooAbsReal::analyticalIntegralWN("" << GetName() << "") code = "" << code << "" normSet = "" << (normSet?*normSet:RooArgSet()) << std::endl ;; 383 if (code==0) return getVal(normSet) ;; 384 return analyticalIntegral(code,rangeName) ;; 385}; 386 ; 387 ; 388 ; 389////////////////////////////////////////////////////////////////////////////////; 390/// Implements",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsReal_8cxx_source.html:12660,perform,performed,12660,doc/master/RooAbsReal_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsReal_8cxx_source.html,1,['perform'],['performed']
Performance,"s value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<string,string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionOneDim*funcFunctor; RooRealProxyvarArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFunctor1DBinding(const char* name, const char* title, const ROOT::Math::IBaseFunctionOneDim& ftor, RooAbsReal& ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFunctor1DBinding.html:36501,cache,cache,36501,root/html602/RooFunctor1DBinding.html,https://root.cern,https://root.cern/root/html602/RooFunctor1DBinding.html,8,['cache'],['cache']
Performance,"s verbose then Dump().; If options contains 'streamerinfo', run ls on the list of streamerInfos; and the list of conversion streamerInfos. void MakeCustomMenuList(); Makes a customizable version of the popup menu list, i.e. makes a list; of TClassMenuItem objects of methods accessible by context menu.; The standard (and different) way consists in having just one element; in this list, corresponding to the whole standard list.; Once the customizable version is done, one can remove or add elements. void Move(void* arenaFrom, void* arenaTo) const; Register the fact that an object was moved from the memory location; 'arenaFrom' to the memory location 'arenaTo'. TList * GetMenuList() const; Return the list of menu items associated with the class. TListOfFunctions * GetMethodList(); Return (create an empty one if needed) the list of functions.; The major difference with GetListOfMethod is that this returns; the internal type of fMethod and thus can not be made public.; It also never 'loads' the content of the list. TMethod * GetMethodAny(const char* method); Return pointer to method without looking at parameters.; Does not look in (possible) base classes.; Has the side effect of loading all the TMethod object in the list; of the class. TMethod * GetMethodAllAny(const char* method); Return pointer to method without looking at parameters.; Does look in all base classes. TMethod * GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); Find the best method (if there is one) matching the parameters.; The params string must contain argument values, like ""3189, \""aap\"", 1.3"".; The function invokes GetClassMethod to search for a possible method; in the class itself or in its base classes. Returns 0 in case method; is not found. TMethod* FindClassOrBaseMethodWithId(TDictionary::DeclId_t faddr); Find a method with decl id in this class or its bases. TMethod * GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:42515,load,loads,42515,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['load'],['loads']
Performance,"s wanted. The instructions are coded in in the calling program (main.cpp), which allows looping, conditional execution, and all the other possibilities of , but not interactivity, since it must be compiled before execution.; 2.2 Design aspects of M in; What M is:. platform independent; written in an object-oriented way using standard; independent of any external package. The maintainability should be guaranteed with the choice of a modern computer language. Choosing object-oriented technology M should profit from an increased flexibility and functionality and make it also extendable (recursivness, new algorithms, new functionality).; What M does not:. histogramming; data handling; graphics. M is kept as a low-level package with optimal performance.; The main usages of M are. from a user’s program (such as int main()…); from a graphical data analysis tool such as HippoDraw@bib-HippoDraw. The most important goals of M in are. its numerical accuracy (equivalent to its Fortran version); its computational performance (equivalent to its Fortran version). For the design of the application programming interface (API) of M a two-way strategy was imposed:. a minimal required interface with minimum interaction with M objects and with appropriate usage of the standard library (STL): the user’s implementation of the FCNBase class, initial parameter values and uncertainties are provided by the to M user via std::vectors.; a rich interface which provides the user with more functionality such as interaction with parameters. The core of the minimization functionality and related tools (the kernel of M ) should be clearly separated from the user, who is interfacing via defined user interfaces (the API).; 2.3 Internal and external parameters; Each of the parameters to the \(\mbox{FCN}\) is defined by the user as belonging to one of the following types:. Freely variable: allowed to take on any value.; Variable with double sided limits: allowed to vary only between two limits specified b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/guides/minuit2/Minuit2.html:9793,perform,performance,9793,root/html534/guides/minuit2/Minuit2.html,https://root.cern,https://root.cern/root/html534/guides/minuit2/Minuit2.html,2,['perform'],['performance']
Performance,"s well as the list of branches used. ; Definition at line 697 of file TTreeCache.cxx. ◆ SetAutoCreated(). void TTreeCache::SetAutoCreated ; (; bool ; val). inline . Definition at line 164 of file TTreeCache.h. ◆ SetBufferSize(). Int_t TTreeCache::SetBufferSize ; (; Long64_t ; buffersize). overridevirtual . Change the underlying buffer size of the cache. ; If the change of size means some cache content is lost, or if the buffer is now larger, setup for a cache refill the next time there is a read Buffersize might be clamped, see TFileCacheRead::SetBufferSize Returns:; 0 if the buffer content is still available; 1 if some or all of the buffer content has been made unavailable; -1 on error . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 2073 of file TTreeCache.cxx. ◆ SetEntryRange(). void TTreeCache::SetEntryRange ; (; Long64_t ; emin, . Long64_t ; emax . ). virtual . Set the minimum and maximum entry number to be processed this information helps to optimize the number of baskets to read when prefetching the branch buffers. ; Reimplemented in TTreeCacheUnzip.; Definition at line 2106 of file TTreeCache.cxx. ◆ SetFile(). void TTreeCache::SetFile ; (; TFile * ; file, . TFile::ECacheAction ; action = TFile::kDisconnect . ). overridevirtual . Change the file that is being cached. ; Reimplemented from TFileCacheRead.; Definition at line 2128 of file TTreeCache.cxx. ◆ SetLearnEntries(). void TTreeCache::SetLearnEntries ; (; Int_t ; n = 10). static . Static function to set the number of entries to be used in learning mode The default value for n is 10. ; n must be >= 1 ; Definition at line 2145 of file TTreeCache.cxx. ◆ SetLearnPrefill(). void TTreeCache::SetLearnPrefill ; (; TTreeCache::EPrefillType ; type = kNoPrefill). virtual . Set whether the learning period is started with a prefilling of the cache and which type of prefilling is used. ; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCache.html:48936,optimiz,optimize,48936,doc/master/classTTreeCache.html,https://root.cern,https://root.cern/doc/master/classTTreeCache.html,1,['optimiz'],['optimize']
Performance,"s were looked up already; 122 std::set<size_t> fPayloads; // Set of payloads; 123 std::set<const char*> fParsedPayloadsAddresses; // Set of payloads which were parsed; 124 std::hash<std::string> fStringHashFunction; // A simple hashing function; 125 std::unordered_set<const clang::NamespaceDecl*> fNSFromRootmaps; // Collection of namespaces fwd declared in the rootmaps; 126 TObjArray* fRootmapFiles; // Loaded rootmap files.; 127 Bool_t fLockProcessLine; // True if ProcessLine should lock gInterpreterMutex.; 128 Bool_t fCxxModulesEnabled;// True if C++ modules was enabled; 129 ; 130 std::unique_ptr<cling::Interpreter> fInterpreter; // The interpreter.; 131 std::unique_ptr<cling::MetaProcessor> fMetaProcessor; // The metaprocessor.; 132 ; 133 std::vector<cling::Value> *fTemporaries; // Stack of temporaries; 134 ROOT::TMetaUtils::TNormalizedCtxt *fNormalizedCtxt; // Which typedef to avoid stripping.; 135 ROOT::TMetaUtils::TClingLookupHelper *fLookupHelper; // lookup helper used by TClassEdit; 136 ; 137 void* fPrevLoadedDynLibInfo; // Internal info to mark the last loaded libray.; 138 std::vector<void*> fRegisterModuleDyLibs; // Stack of libraries currently running RegisterModule; 139 TClingCallbacks* fClingCallbacks; // cling::Interpreter owns it.; 140 struct CharPtrCmp_t {; 141 bool operator()(const char* a, const char *b) const {; 142 return strcmp(a, b) < 0;; 143 }; 144 };; 145 std::set<TClass*> fModTClasses;; 146 std::vector<std::pair<TClass*,DictFuncPtr_t> > fClassesToUpdate;; 147 void* fAutoLoadCallBack;; 148 ULong64_t fTransactionCount; // Cling counter for commited or unloaded transactions which changed the AST.; 149 std::vector<const char*> fCurExecutingMacros;; 150 ; 151 typedef void* SpecialObjectLookupCtx_t;; 152 typedef std::unordered_map<std::string, TObject*> SpecialObjectMap_t;; 153 std::map<SpecialObjectLookupCtx_t, SpecialObjectMap_t> fSpecialObjectMaps;; 154 ; 155 struct MutexStateAndRecurseCount {; 156 /// State of gCoreMutex when the first interpret",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8h_source.html:5289,load,loaded,5289,doc/master/TCling_8h_source.html,https://root.cern,https://root.cern/doc/master/TCling_8h_source.html,1,['load'],['loaded']
Performance,"s when the same information can be retrieved using an index access operator of an array.) All similar accesses in derived classes should be replaced by the getters get_curWeight() or better get_wgt(i), which were also supported in ROOT <v6.24. More details on what happened:. Reduced side effects. This code produces undefined behaviour because the side effect of get(i), i.e., loading the new weight into _curWeight is not guaranteed to happen before weight() is called:. processEvent(dataHist.get(i), dataHist.weight()); // Dangerous! Order of evaluation is not guaranteed.; With the modernised interface, one would use:; processEvent(dataHist.get(i), dataHist.weight(i));; To modernise old code, one should replace patterns like h.get(i); h.func() by h.func(i);. One may #define R__SUGGEST_NEW_INTERFACE to switch on deprecation warnings for the functions in question. Similarly, the bin content can now be set using an index, making prior loading of a certain coordinate unnecessary:; for (int i=0 ; i<hist->numEntries() ; i++) {; - hist->get(i) ;; - hist->set(hist->weight() / sum);; + hist->set(i, hist->weight(i) / sum, 0.);; }. More const correctness. calcTreeIndex() doesn’t rely on side effects, any more. Instead of overwriting the internal coordinates with new values:. // In a RooDataHist subclass:; _vars = externalCoordinates;; auto index = calcTreeIndex();. // Or from the outside:; auto index = dataHist.getIndex(externalCoordinates); // Side effect: Active bin is now `index`.; coordinates are now passed into calcTreeIndex without side effects:; // In a subclass:; auto index = calcTreeIndex(externalCoordinates, fast=<true/false>); // No side effect. // From the outside:; auto index = dataHist.getIndex(externalCoordinates); // No side effect; This will allow for marking more functions const, or for lying less about const correctness. RooDataHist now supports fits with RooFit’s faster BatchMode().; Lower memory footprint. If weight errors are not needed, RooDataHist now allo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:23605,load,loading,23605,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['load'],['loading']
Performance,"s |; Protected Member Functions |; Protected Attributes |; Private Member Functions |; Friends |; List of all members ; TContextMenu Class ReferenceCore ROOT classes » Base ROOT classes. ; This class provides an interface to context sensitive popup menus. ; These menus pop up when the user hits the right mouse button, and are destroyed when the menu pops downs.; Context Menus are automatically generated by ROOT using the following convention: if the string // *MENU* is found in the comment field of a member function. This function will be added to the list of items in the menu.; The picture below shows a canvas with a pop-up menu. The picture below shows a canvas with a pop-up menu and a dialog box. Definition at line 44 of file TContextMenu.h. Public Member Functions;  TContextMenu (const char *name, const char *title=""Context sensitive popup menu"");  Create a context menu. ;  ; virtual ~TContextMenu ();  Destroy a context menu. ;  ; virtual void Action (TClassMenuItem *classmenuitem);  Action to be performed when this menu item is selected. ;  ; void Action (TMethod *method);  ; virtual void Action (TObject *object, TMethod *method);  Action to be performed when this menu item is selected. ;  ; virtual void Action (TObject *object, TToggle *toggle);  Action to be performed when this toggle menu item is selected. ;  ; void Action (TToggle *toggle);  ; virtual const char * CreateArgumentTitle (TMethodArg *argument);  Create string describing argument (for use in dialog box). ;  ; virtual const char * CreateDialogTitle (TObject *object, TFunction *method);  Create title for dialog box retrieving argument values. ;  ; virtual const char * CreatePopupTitle (TObject *object);  Create title for popup menu. ;  ; void Execute (const char *method, const char *params, Int_t *error=nullptr) override;  Execute method on this object with the given parameter string, e.g. ;  ; void Execute (const char *params);  ; void Execute (TMethod *method, TObjArray *params, Int_t *error=null",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTContextMenu.html:1214,perform,performed,1214,doc/master/classTContextMenu.html,https://root.cern,https://root.cern/doc/master/classTContextMenu.html,1,['perform'],['performed']
Performance,"s |; Static Public Member Functions |; List of all members ; TEveContextMenu Class ReferenceGraphics » 3D Graphics » Event Display. ; Specialization of TContext menu. ; Provide a window manager hint that ensures proper placement of popup on Cocoa. ; Definition at line 430 of file TEveWindow.h. Public Member Functions;  TEveContextMenu (const char *name, const char *title=""Eve context menu"");  Constructor. ;  ; TClass * IsA () const override;  ; void SetupAndPopup (TGWindow *button, TObject *obj);  Position the popup below given button and show context menu for object obj. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TContextMenu;  TContextMenu (const char *name, const char *title=""Context sensitive popup menu"");  Create a context menu. ;  ; virtual ~TContextMenu ();  Destroy a context menu. ;  ; virtual void Action (TClassMenuItem *classmenuitem);  Action to be performed when this menu item is selected. ;  ; void Action (TMethod *method);  ; virtual void Action (TObject *object, TMethod *method);  Action to be performed when this menu item is selected. ;  ; virtual void Action (TObject *object, TToggle *toggle);  Action to be performed when this toggle menu item is selected. ;  ; void Action (TToggle *toggle);  ; virtual const char * CreateArgumentTitle (TMethodArg *argument);  Create string describing argument (for use in dialog box). ;  ; virtual const char * CreateDialogTitle (TObject *object, TFunction *method);  Create title for dialog box retrieving argument values. ;  ; virtual const char * CreatePopupTitle (TObject *object);  Create title for popup menu. ;  ; void Execute (const char *method, const char *params, Int_t *error=nullptr) override;  Execute method on this object with the given parameter string, e.g. ;  ; void Execute (const char *params);  ; void Execute (TMethod *method, TObjArray *params, Int_t *error=null",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTEveContextMenu.html:1183,perform,performed,1183,doc/master/classTEveContextMenu.html,https://root.cern,https://root.cern/doc/master/classTEveContextMenu.html,1,['perform'],['performed']
Performance,"s"", theMethod->fDataSetInfo.GetName(), mname[0][i].Data());; 1924 // for (UInt_t icls = 0; icls < theMethod->fDataSetInfo.GetNClasses(); ++icls) {; 1925 // res += TString::Format(""%#1.3f "", (multiclass_testEff[i][icls]) * (multiclass_testPur[i][icls]));; 1926 // }; 1927 // Log() << kINFO << res << Endl;; 1928 // }; 1929 ; 1930 // Log() << kINFO << hLine << Endl;; 1931 // Log() << kINFO << Endl;; 1932 // }; 1933 ; 1934 // --- 1 vs Rest ROC AUC, signal efficiency @ given background efficiency; 1935 // --------------------------------------------------------------------; 1936 TString header1 = TString::Format(""%-15s%-15s%-15s%-15s%-15s%-15s"", ""Dataset"", ""MVA Method"", ""ROC AUC"", ""Sig eff@B=0.01"",; 1937 ""Sig eff@B=0.10"", ""Sig eff@B=0.30"");; 1938 TString header2 = TString::Format(""%-15s%-15s%-15s%-15s%-15s%-15s"", ""Name:"", ""/ Class:"", ""test (train)"", ""test (train)"",; 1939 ""test (train)"", ""test (train)"");; 1940 Log() << kINFO << Endl;; 1941 Log() << kINFO << ""1-vs-rest performance metrics per class"" << Endl;; 1942 Log() << kINFO << hLine << Endl;; 1943 Log() << kINFO << Endl;; 1944 Log() << kINFO << ""Considers the listed class as signal and the other classes"" << Endl;; 1945 Log() << kINFO << ""as background, reporting the resulting binary performance."" << Endl;; 1946 Log() << kINFO << ""A score of 0.820 (0.850) means 0.820 was acheived on the"" << Endl;; 1947 Log() << kINFO << ""test set and 0.850 on the training set."" << Endl;; 1948 ; 1949 Log() << kINFO << Endl;; 1950 Log() << kINFO << header1 << Endl;; 1951 Log() << kINFO << header2 << Endl;; 1952 for (Int_t k = 0; k < 2; k++) {; 1953 for (Int_t i = 0; i < nmeth_used[k]; i++) {; 1954 if (k == 1) {; 1955 mname[k][i].ReplaceAll(""Variable_"", """");; 1956 }; 1957 ; 1958 const TString datasetName = itrMap->first;; 1959 const TString mvaName = mname[k][i];; 1960 ; 1961 MethodBase *theMethod = dynamic_cast<MethodBase *>(GetMethod(datasetName, mvaName));; 1962 if (theMethod == 0) {; 1963 continue;; 1964 }; 1965 ; 1966 Log() << kINFO <<",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html:81215,perform,performance,81215,doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,https://root.cern,https://root.cern/doc/master/tmva_2tmva_2src_2Factory_8cxx_source.html,2,['perform'],['performance']
Performance,"s"",; 19865 config_options[DOCUMENT_ROOT].name);; 19866 }; 19867 free_context(ctx);; 19868 pthread_setspecific(sTlsKey, NULL);; 19869 return NULL;; 19870 }; 19871#endif; 19872 ; 19873 get_system_name(&ctx->systemName);; 19874 ; 19875#if defined(USE_LUA); 19876 /* If a Lua background script has been configured, start it. */; 19877 ctx->lua_bg_log_available = 0;; 19878 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19879 char ebuf[256];; 19880 struct vec opt_vec;; 19881 struct vec eq_vec;; 19882 const char *sparams;; 19883 ; 19884 memset(ebuf, 0, sizeof(ebuf));; 19885 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19886 ; 19887 /* Create a Lua state, load all standard libraries and the mg table */; 19888 lua_State *state = mg_lua_context_script_prepare(; 19889 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19890 if (!state) {; 19891 mg_cry_ctx_internal(ctx,; 19892 ""lua_background_script load error: %s"",; 19893 ebuf);; 19894 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19895 mg_snprintf(NULL,; 19896 NULL, /* No truncation check for error buffers */; 19897 error->text,; 19898 error->text_buffer_size,; 19899 ""Error in script %s: %s"",; 19900 config_options[LUA_BACKGROUND_SCRIPT].name,; 19901 ebuf);; 19902 }; 19903 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19904 ; 19905 free_context(ctx);; 19906 pthread_setspecific(sTlsKey, NULL);; 19907 return NULL;; 19908 }; 19909 ; 19910 /* Add a table with parameters into mg.params */; 19911 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19912 if (sparams && sparams[0]) {; 19913 lua_getglobal(state, ""mg"");; 19914 lua_pushstring(state, ""params"");; 19915 lua_newtable(state);; 19916 ; 19917 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19918 != NULL) {; 19919 reg_llstring(; 19920 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19921 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19922 break;; 19923 }; 19924 lua_rawset(state, -3);; 19925 lua_pop(state, 1);; 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:594393,load,load,594393,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['load'],['load']
Performance,"s"",; 19866 config_options[DOCUMENT_ROOT].name);; 19867 }; 19868 free_context(ctx);; 19869 pthread_setspecific(sTlsKey, NULL);; 19870 return NULL;; 19871 }; 19872#endif; 19873 ; 19874 get_system_name(&ctx->systemName);; 19875 ; 19876#if defined(USE_LUA); 19877 /* If a Lua background script has been configured, start it. */; 19878 ctx->lua_bg_log_available = 0;; 19879 if (ctx->dd.config[LUA_BACKGROUND_SCRIPT] != NULL) {; 19880 char ebuf[256];; 19881 struct vec opt_vec;; 19882 struct vec eq_vec;; 19883 const char *sparams;; 19884 ; 19885 memset(ebuf, 0, sizeof(ebuf));; 19886 pthread_mutex_lock(&ctx->lua_bg_mutex);; 19887 ; 19888 /* Create a Lua state, load all standard libraries and the mg table */; 19889 lua_State *state = mg_lua_context_script_prepare(; 19890 ctx->dd.config[LUA_BACKGROUND_SCRIPT], ctx, ebuf, sizeof(ebuf));; 19891 if (!state) {; 19892 mg_cry_ctx_internal(ctx,; 19893 ""lua_background_script load error: %s"",; 19894 ebuf);; 19895 if ((error != NULL) && (error->text_buffer_size > 0)) {; 19896 mg_snprintf(NULL,; 19897 NULL, /* No truncation check for error buffers */; 19898 error->text,; 19899 error->text_buffer_size,; 19900 ""Error in script %s: %s"",; 19901 config_options[LUA_BACKGROUND_SCRIPT].name,; 19902 ebuf);; 19903 }; 19904 pthread_mutex_unlock(&ctx->lua_bg_mutex);; 19905 ; 19906 free_context(ctx);; 19907 pthread_setspecific(sTlsKey, NULL);; 19908 return NULL;; 19909 }; 19910 ; 19911 /* Add a table with parameters into mg.params */; 19912 sparams = ctx->dd.config[LUA_BACKGROUND_SCRIPT_PARAMS];; 19913 if (sparams && sparams[0]) {; 19914 lua_getglobal(state, ""mg"");; 19915 lua_pushstring(state, ""params"");; 19916 lua_newtable(state);; 19917 ; 19918 while ((sparams = next_option(sparams, &opt_vec, &eq_vec)); 19919 != NULL) {; 19920 reg_llstring(; 19921 state, opt_vec.ptr, opt_vec.len, eq_vec.ptr, eq_vec.len);; 19922 if (mg_strncasecmp(sparams, opt_vec.ptr, opt_vec.len) == 0); 19923 break;; 19924 }; 19925 lua_rawset(state, -3);; 19926 lua_pop(state, 1);; 19",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:594426,load,load,594426,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['load'],['load']
Performance,"s()); 5187 return kTRUE;; 5188 ; 5189 int advice = POSIX_FADV_WILLNEED;; 5190 if (len == 0) {; 5191 // according POSIX spec if len is zero, all data following offset; 5192 // is specified. Nevertheless ROOT uses zero to probe readahead; 5193 // capabilities.; 5194 advice = POSIX_FADV_NORMAL;; 5195 }; 5196 Double_t start = 0;; 5197 if (gPerfStats) start = TTimeStamp();; 5198#if defined(R__SEEK64); 5199 Int_t result = posix_fadvise64(fD, offset, len, advice);; 5200#else; 5201 Int_t result = posix_fadvise(fD, offset, len, advice);; 5202#endif; 5203 if (gPerfStats) {; 5204 gPerfStats->FileReadEvent(this, len, start);; 5205 }; 5206 return (result != 0);; 5207}; 5208#else; 5209Bool_t TFile::ReadBufferAsync(Long64_t, Int_t); 5210{; 5211 // Not supported yet on non Linux systems.; 5212 ; 5213 return kTRUE;; 5214}; 5215#endif; 5216 ; 5217////////////////////////////////////////////////////////////////////////////////; 5218/// Max number of bytes to prefetch.; 5219///; 5220/// By default this is 75% of the; 5221/// read cache size. But specific TFile implementations may need to change it; 5222 ; 5223Int_t TFile::GetBytesToPrefetch() const; 5224{; 5225 TFileCacheRead *cr = nullptr;; 5226 if ((cr = GetCacheRead())) {; 5227 Int_t bytes = cr->GetBufferSize() / 4 * 3;; 5228 return ((bytes < 0) ? 0 : bytes);; 5229 }; 5230 return 0;; 5231}; Bytes.h; frombufvoid frombuf(char *&buf, Bool_t *x)Definition Bytes.h:278; tobufvoid tobuf(char *&buf, Bool_t x)Definition Bytes.h:55; Compression.h; RConcurrentHashColl.hxx; RConfig.hxx; SafeDelete#define SafeDelete(p)Definition RConfig.hxx:525; b#define b(i)Definition RSha256.hxx:100; f#define f(i)Definition RSha256.hxx:104; h#define h(i)Definition RSha256.hxx:106; updatestatic void update(gsl_integration_workspace *workspace, double a1, double b1, double area1, double error1, double a2, double b2, double area2, double error2)Definition RooAdaptiveGaussKronrodIntegrator1D.cxx:633; sizesize_t size(const MatrixT &matrix)retrieve the size of a squ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:189725,cache,cache,189725,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"s(). std::vector< std::string > RooLagrangianMorphFunc::getSamples ; (; ); const. return the vector of sample names, used to build the morph func ; Definition at line 2176 of file RooLagrangianMorphFunc.cxx. ◆ getSampleWeight(). RooAbsReal * RooLagrangianMorphFunc::getSampleWeight ; (; const char * ; name). retrieve the weight (prefactor) of a sample with the given name ; Definition at line 2184 of file RooLagrangianMorphFunc.cxx. ◆ getScale(). double RooLagrangianMorphFunc::getScale ; (; ). get energy scale of the EFT expansion ; Definition at line 1977 of file RooLagrangianMorphFunc.cxx. ◆ getSumElement(). RooProduct * RooLagrangianMorphFunc::getSumElement ; (; const char * ; name); const. return the RooProduct that is the element of the RooRealSumPdfi corresponding to the given sample name ; Definition at line 2150 of file RooLagrangianMorphFunc.cxx. ◆ hasCache(). bool RooLagrangianMorphFunc::hasCache ; (; ); const. private . return true if a cache object is present, false otherwise ; Definition at line 2347 of file RooLagrangianMorphFunc.cxx. ◆ hasParameter(). bool RooLagrangianMorphFunc::hasParameter ; (; const char * ; paramname); const. check if a parameter of the given name is contained in the list of known parameters ; Definition at line 2442 of file RooLagrangianMorphFunc.cxx. ◆ init(). void RooLagrangianMorphFunc::init ; (; ). private . initialise inputs required for the morphing function ; Definition at line 1910 of file RooLagrangianMorphFunc.cxx. ◆ insert(). void RooLagrangianMorphFunc::insert ; (; RooWorkspace * ; ws). ◆ IsA(). TClass * RooLagrangianMorphFunc::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsReal.; Definition at line 257 of file RooLagrangianMorphFunc.h. ◆ isBinnedDistribution(). bool RooLagrangianMorphFunc::isBinnedDistribution ; (; const RooArgSet & ; obs); const. overridevirtual . check if this PDF is a binned distribution in the given observable ; Reimplemented from RooA",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooLagrangianMorphFunc.html:84462,cache,cache,84462,doc/master/classRooLagrangianMorphFunc.html,https://root.cern,https://root.cern/doc/master/classRooLagrangianMorphFunc.html,1,['cache'],['cache']
Performance,"s().; 322///; 323/// WARNING when a selector is used with a TChain:; 324/// in the Process, ProcessCut, ProcessFill function, you must use; 325/// the pointer to the current Tree to call GetEntry(entry).; 326/// entry is always the local entry number in the current tree.; 327/// Assuming that fChain is the pointer to the TChain being processed,; 328/// use fChain->GetTree()->GetEntry(entry);; 329 ; 330void TSelector::ProcessFill(Long64_t /*entry*/); 331{; 332 ; 333}; 334 ; 335////////////////////////////////////////////////////////////////////////////////; 336/// The Process() function is called for each entry in the tree (or possibly; 337/// keyed object in the case of PROOF) to be processed. The entry argument; 338/// specifies which entry in the currently loaded tree is to be processed.; 339/// It can be passed to either t01::GetEntry() or TBranch::GetEntry(); 340/// to read either all or the required parts of the data. When processing; 341/// keyed objects with PROOF, the object is already loaded and is available; 342/// via the fObject pointer.; 343///; 344/// This function should contain the ""body"" of the analysis. It can contain; 345/// simple or elaborate selection criteria, run algorithms on the data; 346/// of the event and typically fill histograms.; 347///; 348/// The processing can be stopped by calling Abort().; 349///; 350/// Use fStatus to set the return value of TTree::Process().; 351///; 352/// The return value is currently not used.; 353///; 354/// WARNING when a selector is used with a TChain, you must use; 355/// the pointer to the current TTree to call GetEntry(entry).; 356/// The entry is always the local entry number in the current tree.; 357/// Assuming that fChain is the pointer to the TChain being processed,; 358/// use: `fChain->GetTree()->GetEntry(entry)`.; 359 ; 360bool TSelector::Process(Long64_t /*entry*/) {; 361 ; 362 return false;; 363}; kNPOSconstexpr Ssiz_t kNPOSDefinition RtypesCore.h:117; Long64_tlong long Long64_tDefinition Rtyp",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:13473,load,loaded,13473,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['load'],['loaded']
Performance,"s(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooStats::HistFactory::FlexibleInterpVar&operator=(const RooStats::HistFactory::FlexibleInterpVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html:20223,optimiz,optimizeCacheMode,20223,root/html602/RooStats__HistFactory__FlexibleInterpVar.html,https://root.cern,https://root.cern/root/html602/RooStats__HistFactory__FlexibleInterpVar.html,4,['optimiz'],['optimizeCacheMode']
Performance,"s(); static Int_tRooAbsReal::numEvalErrors(); Bool_tRooAbsArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsTestStatistic::offset() const; virtual Double_tRooAbsTestStatistic::offsetCarry() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooChi2Var&operator=(const RooChi2Var&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChi2Var.html:20159,optimiz,optimizeCacheMode,20159,root/html602/RooChi2Var.html,https://root.cern,https://root.cern/root/html602/RooChi2Var.html,4,['optimiz'],['optimizeCacheMode']
Performance,"s(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*TGLObject::GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, const Option_t* opt = 0); virtual Bool_tTGLObject::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TF2GL(); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLObject::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF2GL.html:2135,cache,cached,2135,root/html602/TF2GL.html,https://root.cern,https://root.cern/root/html602/TF2GL.html,4,['cache'],['cached']
Performance,"s();; axis->SetAxisColor(Color_t color = 1);; axis->SetLabelColor(Color_t color = 1);; axis->SetLabelFont(Style_t font = 62);; axis->SetLabelOffset(Float_t offset = 0.005);; axis->SetLabelSize(Float_t size = 0.04);; axis->SetNdivisions(Int_t n = 510, Bool_t optim = kTRUE);; axis->SetNoExponent(Bool_t noExponent = kTRUE);; axis->SetTickLength(Float_t length = 0.03);; axis->SetTitleOffset(Float_t offset = 1);; axis->SetTitleSize(Float_t size = 0.02);; The getters corresponding to the described setters are also available. The general options, not specific to axis, as for instance SetTitleTextColor() are valid and do have an effect on axis characteristics.; 9.5.3 Setting the Number of Divisions; Use TAxis::SetNdivisions(ndiv,optim) to set the number of divisions for an axis. The ndiv and optim are as follows:. ndiv = N1 + 100*N2 + 10000*N3; N1 = number of first divisions.; N2 = number of secondary divisions.; N3 = number of tertiary divisions.; optim = kTRUE (default), the divisions’ number will be optimized around the specified value.; optim = kFALSE, or n < 0, the axis will be forced to use exactly n divisions. For example:; ndiv = 0: no tick marks.; ndiv = 2: 2 divisions, one tick mark in the middle of the axis.; ndiv = 510: 10 primary divisions, 5 secondary divisions; ndiv = -10: exactly 10 primary divisions; 9.5.4 Zooming the Axis; You can use TAxis::SetRange or TAxis::SetRangeUser to zoom the axis.; TAxis::SetRange(Int_t binfirst,Int_t binlast); The SetRange method parameters are bin numbers. They are not axis. For example if a histogram plots the values from 0 to 500 and has 100 bins, SetRange(0,10) will cover the values 0 to 50. The parameters for SetRangeUser are user coordinates. If the start or end is in the middle of a bin the resulting range is approximation. It finds the low edge bin for the start and the high edge bin for the high.; TAxis::SetRangeUser(Axis_t ufirst,Axis_t ulast); Both methods, SetRange and SetRangeUser, are in the context menu of any axi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:337086,optimiz,optimized,337086,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['optimiz'],['optimized']
Performance,"s(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTProofServ::DeletePlayer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tTProofServ::Fork(); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; Int_tTProofServ::GetSessionStatus(); virtual voidTProofServ::HandleArchive(TMessage* mess, TString* slb = 0); virtual Int_tTProofServ::HandleCache(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleCheckFile(TMessage* mess, TString* slb = 0); virtual Int_tTProofServ::HandleDataSets(TMessage* mess, TString* slb = 0); virtual Int_tTProofServ::HandleLibIncPath(TMessage* mess); virtual voidTProofServ::HandleProcess(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleQueryList(TMessage* mess); virtual voidTProofServ::HandleRemove(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleRetrieve(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleSubmerger(TMessage* mess); virtual Int_tTProofServ::HandleWorkerLists(TMessage* mess); virtual voidTApplication::Help(const char* line); Bool_tTProofServ::IsIdle(); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); virtual voidTProofServ::MakePlayer(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual voidTProofServ::ProcessNext(TString* slb = 0); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh); Int_tTProofServ::SetupCommon(); Bool_tTProofServ::UnlinkDataDir(const char* path).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServLite.html:15541,Load,LoadGraphicsLibs,15541,root/html534/TProofServLite.html,https://root.cern,https://root.cern/root/html534/TProofServLite.html,2,['Load'],['LoadGraphicsLibs']
Performance,"s(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooMappedCategory&operator=(const RooMappedCategory&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMappedCategory.html:11166,optimiz,optimizeCacheMode,11166,root/html602/RooMappedCategory.html,https://root.cern,https://root.cern/root/html602/RooMappedCategory.html,4,['optimiz'],['optimizeCacheMode']
Performance,"s(false)->GetSize();. TVirtualStreamerInfo* GetStreamerInfo(Int_t version = 0) const; returns a pointer to the TVirtualStreamerInfo object for version; If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* GetStreamerInfoAbstractEmulated(Int_t version = 0) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Note: There are two special version numbers:. 0: Use the class version from the currently loaded class library.; -1: Assume no class library loaded (emulated class). Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. TVirtualStreamerInfo* FindStreamerInfoAbstractEmulated(UInt_t checksum) const; For the case where the requestor class is emulated and this class is abstract,; returns a pointer to the TVirtualStreamerInfo object for version with an emulated; representation whether or not the class is loaded. If the object does not exist, it is created. Warning: If we create a new streamer info, whether or not the build; optimizes is controlled externally to us by a global variable!; Don't call us unless you have set that variable properly; with TStreamer::Optimize()!. void IgnoreTObjectStreamer(Bool_t ignore = kTRUE); When the class kIgnoreTObjectStreamer bit is set, the automatically; generated Stre",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:46027,load,loaded,46027,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,4,['load'],['loaded']
Performance,"s(methodList);; 200 return 0;; 201}; 202 ; DataLoader.h; mainint main()Definition Prototype.cxx:12; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAMultiClassGui.h; TROOT.h; gROOT#define gROOTDefinition TROOT.h:406; TString.h; TSystem.h; gSystemR__EXTERN TSystem * gSystemDefinition TSystem.h:561; TTree.h; Tools.h; TFileA ROOT file is an on-disk file, usually with extension .root, that stores objects in a file-system-li...Definition TFile.h:53; TFile::Openstatic TFile * Open(const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0)Create / open a file.Definition TFile.cxx:4089; TFile::SetCacheFileDirstatic Bool_t SetCacheFileDir(std::string_view cacheDir, Bool_t operateDisconnected=kTRUE, Bool_t forceCacheread=kFALSE)Sets the directory where to locally stage/cache remote files.Definition TFile.cxx:4626; TFile::Closevoid Close(Option_t *option="""") overrideClose a file.Definition TFile.cxx:950; TMVA::DataLoaderDefinition DataLoader.h:50; TMVA::DataLoader::PrepareTrainingAndTestTreevoid PrepareTrainingAndTestTree(const TCut &cut, const TString &splitOpt)prepare the training and test trees -> same cuts for signal and backgroundDefinition DataLoader.cxx:632; TMVA::DataLoader::AddTreevoid AddTree(TTree *tree, const TString &className, Double_t weight=1.0, const TCut &cut="""", Types::ETreeType tt=Types::kMaxTreeType)Definition DataLoader.cxx:351; TMVA::DataLoader::AddVariablevoid AddVariable(const TString &expression, const TString &title, const TString &unit, char type='F', Double_t min=0, Double_t max=0)user inserts discriminating variable in data set infoDefinition DataLoader.cxx:485; TMVA::FactoryThis is the main MVA steering class.Definition Factory.h:80; T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C_source.html:8751,cache,cacheDir,8751,doc/master/TMVAMulticlass_8C_source.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C_source.html,2,['cache'],"['cache', 'cacheDir']"
Performance,"s) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); RooAbsCategoryLValue(); RooAbsCategoryLValue(const char* name, const char* title); RooAbsCategoryLValue(const RooAbsCategoryLValue& other, const char* name = 0); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidsetConstant(Bool_t v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:14641,cache,cache,14641,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,4,['cache'],['cache']
Performance,"s) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCategoryLValue.html:13448,cache,cache,13448,root/html526/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsCategoryLValue.html,2,['cache'],['cache']
Performance,"s) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCategoryLValue.html:13819,cache,cache,13819,root/html532/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsCategoryLValue.html,1,['cache'],['cache']
Performance,"s) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategoryLValue.html:14618,cache,cache,14618,root/html534/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html534/RooAbsCategoryLValue.html,2,['cache'],['cache']
Performance,"s) const; virtual voidRooAbsArg::printTree(ostream& os, TString indent = """") const; virtual voidRooAbsCategory::printValue(ostream& os) const; virtual voidrandomize(const char* rangeName = 0); virtual Int_tTObject::Read(const char* name); virtual Bool_treadFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Bool_tRooAbsArg::recursiveCheckDependents(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveCheckObservables(const RooArgSet* nset) const; Bool_tRooAbsArg::recursiveRedirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t recurseInNewSet = kTRUE); virtual voidTObject::RecursiveRemove(TObject* obj); Bool_tRooAbsArg::redirectServers(const RooAbsCollection& newServerList, Bool_t mustReplaceAll = kFALSE, Bool_t nameChange = kFALSE, Bool_t isRecursionStep = kFALSE); virtual Bool_tRooAbsArg::redirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidRooAbsArg::registerCache(RooAbsCache& cache); voidRooAbsArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); voidsetConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCach",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsCategoryLValue.html:13736,cache,cache,13736,root/html530/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html530/RooAbsCategoryLValue.html,1,['cache'],['cache']
Performance,"s)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.; 368 ; 369TObject *TList::Before(const TObject *obj) const; 370{; 371 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 372 R__COLLECTION_WRITE_GUARD();; 373 ; 374 TObjLink *t;; 375 ; 376 auto cached = fCache.lock();; 377 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 378 t = cached.get();; 379 ((TList*)this)->fCache = cached->fPrev; //cast const away, fCache should be mutable; 380 } else {; 381 Int_t idx;; 382 t = FindLink(obj, idx);; 383 if (t) ((TList*)this)->fCache = t->fPrev;; 384 }; 385 ; 386 if (t && t->Prev()); 387 return t->Prev()->GetObject();; 388 else; 389 return nullptr;; 390}; 391 ; 392////////////////////////////////////////////////////////////////////////////////; 393/// Remove all objects from the list. Does not delete the objects; 394/// unless the TList is the owner (set via SetOwner()) and option; 395/// ""nodelete"" is not set.; 396/// If option=""nodelete"" then don't delete any heap objects that were; 397/// marked with the kCanDelete bit, otherwise these objects will be; 398/// deleted (this option is used by THashTable::Clear()).; 399 ; 400void TList::Clear(Option_t *option); 401{; 402 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 403 R__COLLEC",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:10985,cache,cached,10985,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['cache'],['cached']
Performance,"s). Bool_t IsLeafString(Int_t code) const; return TRUE if the leaf or data member corresponding to code is a string. char * PrintValue(Int_t mode = 0) const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values. char * PrintValue(Int_t mode, Int_t instance, const char* decform = ""9.9"") const; Return value of variable as a string. mode = -2 : Print line with ***; mode = -1 : Print column names; mode = 0 : Print column values; decform contains the requested format (with the same convention as printf). void ResetLoading(); Tell the formula that we are going to request a new entry. void SetAxis(TAxis* axis = 0); Set the axis (in particular get the type). void Streamer(TBuffer& ); Stream an object of class TTreeFormula. Bool_t StringToNumber(Int_t code); Try to 'demote' a string into an array bytes. If this is not possible,; return false. void UpdateFormulaLeaves(); this function is called TTreePlayer::UpdateFormulaLeaves, itself; called by TChain::LoadTree when a new Tree is loaded.; Because Trees in a TChain may have a different list of leaves, one; must update the leaves numbers in the TTreeFormula used by the TreePlayer. void ResetDimensions(); Populate the TTreeFormulaManager with the dimension information. void LoadBranches(); Make sure that all the branches have been loaded properly. Bool_t LoadCurrentDim(). void Convert(UInt_t fromVersion); Convert the fOper of a TTTreeFormula version fromVersion to the current in memory version. Bool_t SwitchToFormLeafInfo(Int_t code); Convert the underlying lookup method from the direct technique; (dereferencing the address held by the branch) to the method using; TFormLeafInfo. This is in particular usefull in the case where we; need to append an additional TFormLeafInfo (for example to call a; method).; Return false if the switch was unsuccessfull (basically in the; case of an old style split tree). TTreeFormula(const char* name, const char* form",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeFormula.html:26243,load,loaded,26243,root/html534/TTreeFormula.html,https://root.cern,https://root.cern/root/html534/TTreeFormula.html,9,"['Load', 'load']","['LoadTree', 'loaded']"
Performance,"s).; If set to 0 (default) no scaling is applied. Bool_t SavePictureWidth(const TString& fileName, Int_t width, Bool_t pixel_object_scale = kTRUE); Save picture with given width (height scaled proportinally).; If pixel_object_scale is true (default), the corresponding; scaling gets calculated from the current window size. Bool_t SavePictureHeight(const TString& fileName, Int_t height, Bool_t pixel_object_scale = kTRUE); Save picture with given height (width scaled proportinally).; If pixel_object_scale is true (default), the corresponding; scaling gets calculated from the current window size. Bool_t SavePictureScale(const TString& fileName, Float_t scale, Bool_t pixel_object_scale = kTRUE); Save picture with given scale to current window size.; If pixel_object_scale is true (default), the same scaling is; used. void DrawGuides(); Draw reference marker and coordinate axes. void DrawDebugInfo(); If in debug mode draw camera aids and overall bounding box. void PreDraw(); Perform GL work which must be done before each draw. void PostDraw(); Perform GL work which must be done after each draw. void FadeView(Float_t alpha); Draw a rectangle (background color and given alpha) across the; whole viewport. void MakeCurrent() const; Make GL context current. void SwapBuffers() const; Swap GL buffers. Bool_t RequestSelect(Int_t x, Int_t y); Post request for selection render pass viewer, picking objects; around the window point (x,y). Bool_t DoSelect(Int_t x, Int_t y); Perform GL selection, picking objects overlapping WINDOW; area described by 'rect'. Return kTRUE if selection should be; changed, kFALSE otherwise.; Select lock should already been taken in other thread in; TGLViewer::ReqSelect(). Bool_t RequestSecondarySelect(Int_t x, Int_t y); Request secondary select. Bool_t DoSecondarySelect(Int_t x, Int_t y); Secondary selection. void ApplySelection(); Process result from last selection (in fSelRec) and; extract a new current selection from it.; Here we only use physical shape. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLViewer.html:27568,Perform,Perform,27568,root/html532/TGLViewer.html,https://root.cern,https://root.cern/root/html532/TGLViewer.html,4,['Perform'],['Perform']
Performance,"s); 3397 RegisterLoadedSharedLibrary(lib.c_str());; 3398#else; 3399 Error(""TCling::UpdateListOfLoadedSharedLibraries"",; 3400 ""Platform not supported!"");; 3401#endif; 3402}; 3403 ; 3404namespace {; 3405template <int N>; 3406static bool StartsWithStrLit(const char *haystack, const char (&needle)[N]) {; 3407 return !strncmp(haystack, needle, N - 1);; 3408}; 3409}; 3410 ; 3411////////////////////////////////////////////////////////////////////////////////; 3412/// Register a new shared library name with the interpreter; add it to; 3413/// fSharedLibs.; 3414 ; 3415void TCling::RegisterLoadedSharedLibrary(const char* filename); 3416{; 3417 // Ignore NULL filenames, aka ""the process"".; 3418 if (!filename) return;; 3419 ; 3420 // Tell the interpreter that this library is available; all libraries can be; 3421 // used to resolve symbols.; 3422 cling::DynamicLibraryManager* DLM = fInterpreter->getDynamicLibraryManager();; 3423 if (!DLM->isLibraryLoaded(filename)) {; 3424 DLM->loadLibrary(filename, true /*permanent*/, true /*resolved*/);; 3425 }; 3426 ; 3427#if defined(R__MACOSX); 3428 // Check that this is not a system library that does not exist on disk.; 3429 auto lenFilename = strlen(filename);; 3430 auto isInMacOSSystemDir = [](const char *fn) {; 3431 return StartsWithStrLit(fn, ""/usr/lib/"") || StartsWithStrLit(fn, ""/System/Library/"");; 3432 };; 3433 if (!strcmp(filename, ""cl_kernels"") // yepp, no directory; 3434 ; 3435 // These we should not link with (e.g. because they forward to .tbd):; 3436 || StartsWithStrLit(filename, ""/usr/lib/system/""); 3437 || StartsWithStrLit(filename, ""/usr/lib/libc++""); 3438 || StartsWithStrLit(filename, ""/System/Library/Frameworks/""); 3439 || StartsWithStrLit(filename, ""/System/Library/PrivateFrameworks/""); 3440 || StartsWithStrLit(filename, ""/System/Library/CoreServices/""); 3441 || StartsWithStrLit(filename, ""/usr/lib/libSystem""); 3442 || StartsWithStrLit(filename, ""/usr/lib/libstdc++""); 3443 || StartsWithStrLit(filename, ""/usr/lib/libicucore""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TCling_8cxx_source.html:132344,load,loadLibrary,132344,doc/master/TCling_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TCling_8cxx_source.html,1,['load'],['loadLibrary']
Performance,"s); RooDataHist::dh[c,x] = 300 bins (2964 weights); [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #8 because y cannot accommodate the value 11.1861; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds) Ignored 35 out-of-range events; RooDataSet::ds[x,y] = 65 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #7 because y cannot accommodate the value 13.3845; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #8 because z cannot accommodate the value 10; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #12 because y cannot accommodate the value 13.7009; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping event #14 because y cannot accommodate the value -10.6852; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds2) Skipping ...; [#0] WARNING:DataHandling -- RooTreeDataStore::loadValues(ds2) Ignored 36 out-of-range events; RooDataSet::ds2[x,z,y] = 26 entries; [#1] INFO:DataHandling -- RooAbsReal::attachToTree(i) TTree Int_t branch i will be converted to double precision.; RooDataSet::ds3[x,i] = 100 entries; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #2 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #5 because i cannot accommodate the value 0; [#1] INFO:DataHandling -- RooTreeDataStore::loadValues(ds4) Skipping event #8 because i cannot accommodate the value 0; [#1] INFO:DataHandling --",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf401__importttreethx_8py.html:4754,load,loadValues,4754,doc/master/rf401__importttreethx_8py.html,https://root.cern,https://root.cern/doc/master/rf401__importttreethx_8py.html,2,['load'],['loadValues']
Performance,"s);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TGLLogicalShape(); voidAddRef(TGLPhysicalShape* phys) const; virtual Bool_tAlwaysSecondarySelect() const; const TGLBoundingBox&BoundingBox() const; static TClass*Class(); voidDestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidDLCacheClear(); virtual voidDLCacheDrop(); virtual voidDLCachePurge(); virtual UInt_tDLOffset(Short_t) const; virtual voidDraw(TGLRnrCtx& rnrCtx) const; virtual voidDrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*GetExternal() const; const TGLPhysicalShape*GetFirstPhysical() const; static Bool_tGetIgnoreSizeForCameraInterest(); TGLScene*GetScene() const; TObject*ID() const; virtual Bool_tIgnoreSizeForOfInterest() const; voidInvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tRef() const; Bool_tSetDLCache(Bool_t cached); static voidSetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidStrongRef(Bool_t strong) const; voidSubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesSupportedLODAxes() const; virtual Bool_tSupportsSecondarySelect() const; TGLLogicalShape(); TGLLogicalShape(TObject* obj); TGLLogicalShape(const TBuffer3D& buffer); UInt_tUnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidUpdateBoundingBoxesOfPhysicals(). protected:. voidPurgeDLRange(UInt_t base, Int_t size) const. private:. TGLLogicalShape&operator=(const TGLLogicalShape&); TGLLogicalShape(cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLLogicalShape.html:3295,cache,cached,3295,root/html602/TGLLogicalShape.html,https://root.cern,https://root.cern/root/html602/TGLLogicalShape.html,4,['cache'],['cached']
Performance,"s)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TPluginManager.html:9970,Load,LoadHandlerMacros,9970,root/html602/TPluginManager.html,https://root.cern,https://root.cern/root/html602/TPluginManager.html,4,['Load'],"['Load', 'LoadHandlerMacros']"
Performance,"s)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; TList*TVirtualMonitoringWriter::fTmpOpenPhasesTo store open phases when there is not yet an object. private:. TSQLServer*fDBSQL database where to write; Long64_tfMaxBulkSizeMax packet size for insertions; TStringfTableSQL table name; Bool_tfVerboseVerbosity toggle. Class Charts. Inheritance Chart:. TObject. ←; TNamed. ←; TVirtualMonitoringWriter. ←; TSQLMonitoringWriter. Function documentation; TSQLMonitoringWriter(const char* serv, const char* user, const char* pass, const char* table); Constructor. ~TSQLMonitoringWriter(); Destructor. Bool_t SendParameters(TList* values, const char* ); Register query log using the information in the list which is in the form; TParameter(<par>,<value>) or TNamed(<name>,<string>). For bulk sending,; the first entry in the list is an TObjString defining the variable names; in the format; VARname1,VARname2,...; while the other entries are TObjStrings with the multiplets to be sent; VARvalue1,VARvalue2,... The string 'opt' allows the following additional control:; table=[<db>.]<table> allows to insert to a different table from the; one defined at construction (change is not; persistent); if <db> is not specified, the same; db defined at cinstruction is used.; bulk Do a bulk insert; More options can be given concurrently, comma-separated .; The specified table must already have been created in the DB. TSQLMonitoringWriter(const TSQLMonitoringWriter& ). TSQLMonitoringWriter& operator=(const TSQLMonitoringWriter& ). void Verbose(Bool_t onoff); { fVerbose = onoff; }. » Author: J.F. Grosse-Oetringhaus, G.Ganis » Copyright (C) 1995-2007, Rene Brun and Fons Rademakers. *; » Last changed: root/net:$Id$ » Last generated: 2015-06-30 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TSQLMonitoringWriter.html:8368,concurren,concurrently,8368,root/html602/TSQLMonitoringWriter.html,https://root.cern,https://root.cern/root/html602/TSQLMonitoringWriter.html,2,['concurren'],['concurrently']
Performance,"s* sender_class, const char* signal, TClass* receiver_class, const char* slot); static voidTApplication::Close(TApplication* app); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidDeletePlayer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFork(); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; Int_tGetSessionStatus(); virtual voidHandleArchive(TMessage* mess, TString* slb = 0); virtual Int_tHandleCache(TMessage* mess, TString* slb = 0); virtual voidHandleCheckFile(TMessage* mess, TString* slb = 0); virtual Int_tHandleDataSets(TMessage* mess, TString* slb = 0); virtual voidHandleFork(TMessage* mess); virtual voidHandleLibIncPath(TMessage* mess); virtual voidHandleProcess(TMessage* mess, TString* slb = 0); virtual voidHandleQueryList(TMessage* mess); virtual voidHandleRemove(TMessage* mess, TString* slb = 0); virtual voidHandleRetrieve(TMessage* mess, TString* slb = 0); virtual voidHandleSubmerger(TMessage* mess); virtual Int_tHandleWorkerLists(TMessage* mess); virtual voidTApplication::Help(const char* line); Bool_tIsIdle(); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); virtual voidMakePlayer(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual voidProcessNext(TString* slb = 0); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh); virtual Int_tSetup(); Int_tSetupCommon(); Bool_tUnlinkDataDir(const char* path).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofServ.html:13969,Load,LoadGraphicsLibs,13969,root/html532/TProofServ.html,https://root.cern,https://root.cern/root/html532/TProofServ.html,1,['Load'],['LoadGraphicsLibs']
Performance,"s*IsA() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTFormula::IsLinear() const; virtual Bool_tTFormula::IsNormalized() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTObject::IsZombie() const; virtual voidTNamed::ls(Option_t* option = """") const; voidTObject::MayNotUse(const char* method) const; static voidRooPrintable::nameFieldLength(Int_t newLen); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; Bool_tok(); voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); voidTFormula::Optimize(); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidPrint(Option_t* options = 0) const; virtual voidRooPrintable::printAddress(ostream& os) const; virtual voidprintArgs(ostream& os) const; virtual voidprintClassName(ostream& os) const; virtual voidRooPrintable::printExtras(ostream& os) const; virtual voidprintMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; virtual voidprintName(ostream& os) const; virtual voidRooPrintable::printStream(ostream& os, Int_t contents, RooPrintable::StyleOption style, TString indent = """") const; virtual voidprintTitle(ostream& os) const; virtual voidRooPrintable::printTree(ostream& os, TString indent = """") const; virtual voidprintValue(ostream& os) const; virtual voidTFormula::ProcessLinear(TString& replaceformula); virtual Int_tTObject::Read(const char* name); Bool_treCompile(const char* newFormula); virtual voidTObject::RecursiveRemove(TObject* obj); voidTObject::Rese",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFormula.html:5667,Optimiz,Optimize,5667,root/html602/RooFormula.html,https://root.cern,https://root.cern/root/html602/RooFormula.html,1,['Optimiz'],['Optimize']
Performance,"s, ""); print("">> the category 'c' will be projected in the filling process""); ; # The binning of real variables (like x,y) is done using their fit range; # 'get/setRange()' and number of specified fit bins 'get/setBins()'.; # Category dimensions of binned datasets get one bin per defined category; # state; x.setBins(10); y.setBins(10); dh = ROOT.RooDataHist(""dh"", ""binned version of d"", {x, y}, d); dh.Print(""v""); ; yframe = y.frame(Bins=10, Title=""Operations on binned datasets""); dh.plotOn(yframe) # plot projection of 2D binned data on y; ; # Examine the statistics of a binned dataset; print("">> number of bins in dh : "", dh.numEntries()); print("">> sum of weights in dh : "", dh.sum(False)); # accounts for bin volume; print("">> integral over histogram: "", dh.sum(True)); ; # Locate a bin from a set of coordinates and retrieve its properties; x.setVal(0.3); y.setVal(20.5); print("">> retrieving the properties of the bin enclosing coordinate (x,y) = (0.3,20.5) bin center:""); # load bin center coordinates in internal buffer; dh.get({x, y}).Print(""v""); print("" weight = "", dh.weight()) # return weight of last loaded coordinates; ; # Reduce the 2-dimensional binned dataset to a 1-dimensional binned dataset; #; # All reduce() methods are interfaced in RooAbsData. All reduction techniques; # demonstrated on unbinned datasets can be applied to binned datasets as; # well.; print("">> Creating 1-dimensional projection on y of dh for bins with x>0""); dh2 = dh.reduce({y}, ""x>0""); dh2.Print(""v""); ; # Add dh2 to yframe and redraw; dh2.plotOn(yframe, LineColor=""r"", MarkerColor=""r""); ; # Saving and loading from file; # -------------------------------------------------------; ; # Datasets can be persisted with ROOT I/O; print(""\n >> Persisting d via ROOT I/O""); f = ROOT.TFile(""rf402_datahandling.root"", ""RECREATE""); d.Write(); f.ls(); ; # To read back in future session:; # > ROOT.TFile f(""rf402_datahandling.root""); # > d = (ROOT.RooDataSet*) f.FindObject(""d""); ; c = ROOT.TCanvas(""rf402_datah",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf402__datahandling_8py.html:4185,load,load,4185,doc/master/rf402__datahandling_8py.html,https://root.cern,https://root.cern/doc/master/rf402__datahandling_8py.html,1,['load'],['load']
Performance,"s, Bool_t verbose, Bool_t randProtoOrder, Bool_t resampleProto, Bool_t skipInit = kFALSE, Bool_t extended = kFALSE) const; virtual voidRooAbsArg::getObservablesHook(const RooArgSet*, RooArgSet*) const; virtual voidRooAbsArg::getParametersHook(const RooArgSet*, RooArgSet*, Bool_t) const; RooAbsProxy*RooAbsArg::getProxy(Int_t index) const; static voidRooAbsReal::globalSelectComp(Bool_t flag); voidRooAbsArg::graphVizAddConnections(set<std::pair<RooAbsArg*,RooAbsArg*> >&); Bool_tRooAbsArg::inhibitDirty() const; voidinitialize() const; TStringRooAbsReal::integralNameSuffix(const RooArgSet& iset, const RooArgSet* nset = 0, const char* rangeName = 0, Bool_t omitEmpty = kFALSE) const; Bool_tRooAbsReal::isSelectedComp() const; virtual Bool_tRooAbsReal::isValid() const; virtual Bool_tRooAbsReal::isValidReal(Double_t value, Bool_t printError = kFALSE) const; voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidRooAbsArg::operModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsPdf::paramOn(RooPlot* frame, const RooArgSet& params, Bool_t showConstants = kFALSE, const char* label = """", Int_t sigDigits = 2, Option_t* options = ""NELU"", Double_t xmin = 0.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvPdf.html:38093,optimiz,optimizeDirtyHook,38093,root/html534/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html534/RooNumConvPdf.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"s, Int_t len); Read buffer at position pos if the request is in the list of; prefetched blocks read from fBuffer.; Otherwise try to fill the cache from the list of selected branches,; and recheck if pos is now in the list.; Returns; -1 in case of read failure,; 0 in case not in cache,; 1 in case read from cache.; This function overloads TFileCacheRead::ReadBuffer. void ResetCache(); This will simply clear the cache. void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Overload to make sure that the object specific. void SetLearnEntries(Int_t n = 10); Static function to set the number of entries to be used in learning mode; The default value for n is 10. n must be >= 1. void SetLearnPrefill(TTreeCache::EPrefillType type = kNoPrefill); Set whether the learning period is started with a prefilling of the; cache and which type of prefilling is used.; The two value currently supported are:; TTreeCache::kNoPrefill disable the prefilling; TTreeCache::kAllBranches fill the cache with baskets from all branches.; The default prefilling behavior can be controlled by setting; TTreeCache.Prefill or the environment variable ROOT_TTREECACHE_PREFILL. void StartLearningPhase(); The name should be enough to explain the method.; The only additional comments is that the cache is cleaned before; the new learning phase. void StopLearningPhase(); This is the counterpart of StartLearningPhase() and can be used to stop; the learning phase. It's useful when the user knows exactly what branches; they are going to use.; For the moment it's just a call to FillBuffer() since that method; will create the buffer lists from the specified branches. void UpdateBranches(TTree* tree); Update pointer to current Tree and recompute pointers to the branches in the cache. void Le",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:26054,cache,cache,26054,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,2,['cache'],['cache']
Performance,"s, UInt_t mode) override;  Open a file in 'MemFile'. ;  ; Int_t SysRead (Int_t fd, void *buf, Int_t len) override;  Read specified number of bytes from current offset into the buffer. ;  ; Int_t SysReadImpl (Int_t fd, void *buf, Long64_t len);  Read specified number of bytes from current offset into the buffer. ;  ; Long64_t SysSeek (Int_t fd, Long64_t offset, Int_t whence) override;  Seek to a specified position in the file. ;  ; Int_t SysStat (Int_t fd, Long_t *id, Long64_t *size, Long_t *flags, Long_t *modtime) override;  Perform a stat on the file; see TFile::SysStat(). ;  ; Int_t SysSync (Int_t fd) override;  Sync remaining data to disk. ;  ; Int_t SysWrite (Int_t fd, const void *buf, Int_t len) override;  Write a buffer into the file. ;  ; Int_t SysWriteImpl (Int_t fd, const void *buf, Long64_t len);  Write a buffer into the file. ;  ;  Protected Member Functions inherited from TFile; virtual Long64_t DirCreateEntry (TDirectory *);  ; virtual Int_t DirReadKeys (TDirectory *);  ; virtual void DirWriteHeader (TDirectory *);  ; virtual void DirWriteKeys (TDirectory *);  ; Bool_t FlushWriteCache ();  Flush the write cache if active. ;  ; virtual EAsyncOpenStatus GetAsyncOpenStatus ();  ; virtual InfoListRet GetStreamerInfoListImpl (bool lookupSICache);  See documentation of GetStreamerInfoList for more details. ;  ; virtual void Init (Bool_t create);  Initialize a TFile object. ;  ; Int_t MakeProjectParMake (const char *packname, const char *filename);  Create makefile at 'filemake' for PAR package 'pack'. ;  ; Int_t MakeProjectParProofInf (const char *packname, const char *proofinfdir);  Create BUILD.sh and SETUP.C under 'proofinf' for PAR package 'pack'. ;  ; Int_t ReadBufferViaCache (char *buf, Int_t len);  Read buffer via cache. ;  ; Int_t WriteBufferViaCache (const char *buf, Int_t len);  Write buffer via cache. ;  ;  Protected Member Functions inherited from TDirectoryFile; void BuildDirectoryFile (TFile *motherFile, TDirectory *motherDir);  Initialise direc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html:35504,cache,cache,35504,doc/v632/classROOT_1_1TBufferMergerFile.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html,5,['cache'],['cache']
Performance,"s, an extrusion behavior is dependent on the track parameters, which is a highly undesirable effect.; B) We will call ""overlaps"" only the regions in space contained by more than one node inside the same container. The owner of such regions cannot be determined based on hierarchical considerations; therefore they will be considered as belonging to the node from which the current track is coming from.; When coming from their container, the ownership is totally unpredictable. Again, the ownership of overlapping regions highly depends on the current track parameters.; We must say that even the overlaps of type A) and B) are allowed in case the corresponding nodes are created using TGeoVolume::AddNodeOverlap() method. Navigation is performed in such cases by giving priority to the non-overlapping nodes. The modeller has to perform an additional search through the overlapping candidates. These are detected automatically during the geometry closing procedure in order to optimize the algorithm, but we will stress that extensive usage of this feature leads to a drastic deterioration of performance. In the following we will focus on the non-declared overlaps of type A) and B) since this is the main source of errors during tracking. These are generally non-intended overlaps due to coding mistakes or bad geometry design. The checking package is loaded together with the painter classes and contains an automated overlap checker. Overlap checking; This can be activated both at volume level (checking for illegal overlaps only one level inside a given volume) and from the geometry manager level (checking full geometry):; myVolume->CheckOverlaps(precision, option);; gGeoManager->CheckOverlaps(precision);; myNode->CheckOverlaps(precision);; TGeoManager::CheckOverlapsvoid CheckOverlaps(Double_t ovlp=0.1, Option_t *option="""")Check all geometry for illegal overlaps within a limit OVLP.Definition TGeoManager.cxx:3869; Here precision represents the desired maximum accepted overlap value in",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:101086,optimiz,optimize,101086,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,2,"['optimiz', 'perform']","['optimize', 'performance']"
Performance,"s, const RooLinkedList& norms, const RooLinkedList& imps, const RooLinkedList& ints, const RooLinkedList& cross) const; Group product into terms that can be calculated independently. std::vector<RooAbsReal*> processProductTerm(const RooArgSet* nset, const RooArgSet* iset, const char* isetRangeName, const RooArgSet* term, const RooArgSet& termNSet, const RooArgSet& termISet, Bool_t& isOwned, Bool_t forceWrap = kFALSE) const; Calculate integrals of factorized product terms over observables iset while normalized; to observables in nset. const char* makeRGPPName(const char* pfx, const RooArgSet& term, const RooArgSet& iset, const RooArgSet& nset, const char* isetRangeName) const; Make an appropriate automatic name for a RooGenProdProj object in getPartIntList(). Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all observables for internal integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& numVars, const RooArgSet* normSet, const char* rangeName = 0) const; Determine which part (if any) of given integral can be performed analytically.; If any analytical integration is possible, return integration scenario code. RooProdPdf implements two strategies in implementing analytical integrals. First, PDF components whose entire set of dependents are requested to be integrated; can be dropped from the product, as they will integrate out to 1 by construction. Second, RooProdPdf queries each remaining component PDF for its analytical integration; capability of the requested set ('allVars'). It finds the largest common set of variables; that can be integrated by all remaining components. If such a set exists, it reconfirms that; each component is capable of analytically integrating the common set, and combines the components; individual integration codes into a single integration code valid for RooProdPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooProdPdf.html:51795,perform,performed,51795,root/html528/RooProdPdf.html,https://root.cern,https://root.cern/root/html528/RooProdPdf.html,10,['perform'],['performed']
Performance,"s, const char* wgtName); Utility function for constructors; Return RooArgSet that is copy of allVars minus variable matching wgtName if specified. RooRealVar* weightVar(const RooArgSet& allVars, const char* wgtName); Utility function for constructors; Return pointer to weight variable if it is defined. RooVectorDataStore(const RooVectorDataStore& other, const char* newname = 0); Regular copy ctor. RooVectorDataStore(const RooTreeDataStore& other, const RooArgSet& vars, const char* newname = 0). RooVectorDataStore(const RooVectorDataStore& other, const RooArgSet& vars, const char* newname = 0); Clone ctor, must connect internal storage to given new external set of vars. RooVectorDataStore(const char* name, const char* title, RooAbsDataStore& tds, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, Int_t nStart, Int_t nStop, Bool_t , const char* wgtVarName = 0). ~RooVectorDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Interface function to TTree::Fill. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. const RooArgSet* getNative(Int_t index) const; Load the n-th data point (n='index') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight(Int_t index) const; Return the weight of the n-th data point (n='index') in memory. Double_t weight() const; Return the weight of the n-th data point (n='index') in memory. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000); throw(std::string(""RooVectorD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooVectorDataStore.html:12649,load,loaded,12649,root/html532/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html532/RooVectorDataStore.html,8,['load'],['loaded']
Performance,"s, which automatizes the process of compilation and linking.; In /home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master.build/tutorials there are 3 demonstration programs:; foam_kanwa.C; is a simple example how to run FOAM in interactive mode. To run this macro issue the following simple command from the Linux shell:; root foam_kanwa.C; or from CLING:; root [0] .x foam_kanwa.C; Simulation will start and graphical canvas with plot of the distribution function appear. In this example we defined the distribution function simply as a global function function Camel2.; foam_demo.C; shows usage of FOAM in compiled mode, which is the preferred method. The integrand function is defined now as a Density method from class TFDISTR inheriting from abstract class TFoamIntegrand. User can modify interface to integrand function according to their needs but they should always remember to define Density method which provides the density distribution. Enter CLING interpreter and type:; root [0] gSystem->Load(""libFoam.so""); root [1] .x foam_demo.C+; to load FOAM library, compile and execute macro foam_demo.C. A shared object foam_demo_C.so is created in the current directory. At the end of exploration phase FOAM object including distribution function will be written to disk.; foam_demopers.C; demonstrates persistency of FOAM classes. To run this macro type:; root [0] .x foam_demopers.C; Program reads the FOAM object from disk, checks its consistency and prints geometry of cells. Next starts the the generation. It can be interpreted directly by CLING because compiled TFDISTR class is already available in foam_demo_C.so library. . Files; file  foam_demo.C;   Demonstrate the TFoam class. ;  ; file  foam_demopers.C;   This simple macro demonstrates persistency of FOAM object. ;  ; file  foam_kanwa.C;   This program can be execute from the command line as folows: ;  . ROOT master - Reference Guide Generated on Tue Nov 5 2024 09:41:34 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__tutorial__FOAM.html:1992,load,load,1992,doc/master/group__tutorial__FOAM.html,https://root.cern,https://root.cern/doc/master/group__tutorial__FOAM.html,1,['load'],['load']
Performance,"s. ; At the moment two engine kinds are supported:. civetweb or http (default); fastcgi. Examples: // creates civetweb web server with http port 8080; serv->CreateEngine(""http:8080"");; serv->CreateEngine(""civetweb:8080"");; serv->CreateEngine("":8080"");; // creates fastcgi server with port 9000; serv->CreateEngine(""fastcgi:9000"");; One could apply additional parameters, using URL syntax: serv->CreateEngine(""http:8080?thrds=10""); . Definition at line 419 of file THttpServer.cxx. ◆ CreateItem(). Bool_t THttpServer::CreateItem ; (; const char * ; fullname, . const char * ; title . ). Create item in sniffer. ; Definition at line 1455 of file THttpServer.cxx. ◆ CreateServerThread(). void THttpServer::CreateServerThread ; (; ). Creates special thread to process all requests, directed to http server. ; Should be used with care - only dedicated instance of TRootSniffer is allowed By default THttpServer allows to access global lists pointers gROOT or gFile. To be on the safe side, all kind of such access performed from the main thread. Therefore usage of specialized thread means that no any global pointers will be accessible by THttpServer ; Definition at line 515 of file THttpServer.cxx. ◆ DeclFileName(). static const char * THttpServer::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 198 of file THttpServer.h. ◆ ExecuteHttp(). Bool_t THttpServer::ExecuteHttp ; (; std::shared_ptr< THttpCallArg > ; arg). Execute HTTP request. ; Executes http request, specified in THttpCallArg structure.; Method can be called from any thread Actual execution will be done in main ROOT thread, where analysis code is running. ; Definition at line 642 of file THttpServer.cxx. ◆ ExecuteWS(). Bool_t THttpServer::ExecuteWS ; (; std::shared_ptr< THttpCallArg > & ; arg, . Bool_t ; external_thrd = kFALSE, . Bool_t ; wait_process = kFALSE . ). Execute WS request. ; Execute WS related operation. ; Definition at line 1299 of file THttpServer.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:23760,perform,performed,23760,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['perform'],['performed']
Performance,"s. ;  ; virtual Int_t BufferFill (Double_t x, Double_t y, Double_t z, Double_t w);  Accumulate arguments in buffer. ;  ; Int_t BufferFill (Double_t, Double_t) override;  accumulate arguments in buffer. ;  ; virtual Int_t BufferFill (Double_t, Double_t, Double_t);  ; void DoFillProfileProjection (TProfile2D *p2, const TAxis &a1, const TAxis &a2, const TAxis &a3, Int_t bin1, Int_t bin2, Int_t bin3, Int_t inBin, Bool_t useWeights) const;  internal function to fill the bins of the projected profile 2D histogram called from DoProjectProfile2D ;  ; virtual TH1D * DoProject1D (const char *name, const char *title, const TAxis *projAxis, const TAxis *axis1, const TAxis *axis2, bool computeErrors, bool originalRange, bool useUF, bool useOF) const;  internal methdod performing the projection to 1D histogram called from other TH3::DoProject1D ;  ; virtual TH1D * DoProject1D (const char *name, const char *title, int imin1, int imax1, int imin2, int imax2, const TAxis *projAxis, const TAxis *axis1, const TAxis *axis2, Option_t *option) const;  internal method performing the projection to 1D histogram called from TH3::Project3D ;  ; virtual TH2D * DoProject2D (const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool computeErrors, bool originalRange, bool useUF, bool useOF) const;  internal method performing the projection to a 2D histogram called from TH3::Project3D ;  ; virtual TProfile2D * DoProjectProfile2D (const char *name, const char *title, const TAxis *projX, const TAxis *projY, bool originalRange, bool useUF, bool useOF) const;  internal method to project to a 2D Profile called from TH3::Project3DProfile ;  ; Int_t Fill (const char *, const char *, Double_t);  ; Int_t Fill (const char *, Double_t) override;  Increment bin with namex with a weight w. ;  ; Int_t Fill (const char *, Double_t, Double_t);  ; Int_t Fill (Double_t) override;  Invalid Fill method. ;  ; Int_t Fill (Double_t, const char *, Double_t);  ; Int_t Fill (Double_t, Double_t) over",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGLTH3Composition.html:53591,perform,performing,53591,doc/master/classTGLTH3Composition.html,https://root.cern,https://root.cern/doc/master/classTGLTH3Composition.html,24,['perform'],['performing']
Performance,"s. A ray tracing method can be called TGeoVolume::RandomRays(). This shoots rays from a given point in the local reference frame with random directions. The intersections with displayed nodes appear as segments having the color of the touched node.; 18.7 The Drawing Package; The modeller provides a powerful drawing package, supporting several different options of visualization. A library separated from the main one provides all functionality being linked with the underlying ROOT visualization system. This library is dynamically loaded by the plug-in manager only when drawing features are requested. The geometrical structures that can be visualized are volumes and volume hierarchies.; The main component of the visualization system is volume primitive painting in a ROOT pad. Starting from this one, several specific options or subsystems are available, like: X3D viewing using hidden line and surface removal algorithms, OpenGL viewing* or ray tracing.; The method TGeoManager::GetGeomPainter()loads the painting library in memory.; This is generally not needed since it is called automatically by TGeoVolume::Draw() as well as by few other methods setting visualization attributes.; 18.7.1 Drawing Volumes and Hierarchies of Volumes; The first thing one would like to do after building some geometry is to visualize the volume tree. This provides the fastest validation check for most common coding or design mistakes. As soon as the geometry is successfully closed, one should draw it starting from the top-level volume:; //... code for geometry building; root[] gGeoManager->CloseGeometry();; root[] gGeoManager->GetMasterVolume()->Draw();; Doing this ensures that the original top-level volume of the geometry is drawn, even if another volume is currently the geometry root. OK, I suppose you already did that with your simple geometry and immediately noticed a new ROOT canvas popping-up and having some more or less strange picture inside. Here are few questions that might come:; Q: “T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1005078,load,loads,1005078,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loads']
Performance,"s. Bool_t isConstant() const; Returns true if 'Constant' attribute is set. Bool_t IsSortable() const; Object is sortable in ROOT container class. Bool_t operator==(const RooAbsArg& other). Bool_t inRange(const char* ) const; Range management. Bool_t hasRange(const char* ) const; Has this argument a defined range (dummy interface always returns flase). Bool_t isShapeDirty() const; Dirty state accessor. Bool_t isValueDirty() const; Returns true of value has been invalidated by server value change. OperMode operMode() const; { return _operMode==AClean ? (flipAClean() ? ADirty : AClean ) : _operMode ; }. const RooArgSet* ownedComponents() const; { return _ownedComponents ; }. void setProhibitServerRedirect(Bool_t flag); { _prohibitServerRedirect = flag ; }. void operModeHook(); friend class RooSimCloneTool ;. {}. void optimizeDirtyHook(const RooArgSet* ); {}. void getParametersHook(const RooArgSet* , RooArgSet* , Bool_t ) const; {}. void getObservablesHook(const RooArgSet* , RooArgSet* ) const; {}. void setValueDirty() const; Dirty state modifiers. { setValueDirty(0) ; }. void setShapeDirty() const; { setShapeDirty(0) ; }. void clearValueDirty() const. void clearShapeDirty() const. const char* cacheUniqueSuffix() const; { return 0 ; }. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); { return kFALSE ; }. void serverNameChangeHook(const RooAbsArg* , const RooAbsArg* ); { }. void setExpensiveObjectCache(RooExpensiveObjectCache& cache); { _eocache = &cache ; }. Bool_t importWorkspaceHook(RooWorkspace& ); { return kFALSE ; }. void syncCache(const RooArgSet* nset = 0). void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE). void setTreeBranchStatus(TTree& t, Bool_t active). void fillTreeBranch(TTree& t). » Last changed: Mon Jul 4 15:21:16 2011 » Last generated: 2011-07-04 15:21; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsArg.html:40949,cache,cacheUniqueSuffix,40949,root/html530/RooAbsArg.html,https://root.cern,https://root.cern/root/html530/RooAbsArg.html,3,['cache'],"['cache', 'cacheUniqueSuffix']"
Performance,"s. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLAxis.h 21794 2008-01-21 21:11:46Z matevz $ » Last generated: 2010-09-23 20:06; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLAxis.html:4712,optimiz,optimized,4712,root/html528/TGLAxis.html,https://root.cern,https://root.cern/root/html528/TGLAxis.html,2,['optimiz'],['optimized']
Performance,"s. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLAxis.h 21794 2008-01-21 21:11:46Z matevz $ » Last generated: 2011-07-04 15:29; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TGLAxis.html:4712,optimiz,optimized,4712,root/html530/TGLAxis.html,https://root.cern,https://root.cern/root/html530/TGLAxis.html,2,['optimiz'],['optimized']
Performance,"s. Function documentation; TGLAxis(); Constructor. void Init(); Default initialization. ~TGLAxis(); Destructor. void PaintGLAxis(const Double_t* p1, const Double_t* p2, Double_t wmin, Double_t wmax, Int_t ndiv, Option_t* opt = """"); Paint GL Axis. p1, p2 : Axis position in the 3D space.; wmin, wmax : Minimum and maximum values along the axis. wmin < wmax.; ndiv : Number of axis divisions. It is an integer in the form; ""ttsspp"" where ""tt"" is the number of tertiary divisions,; ""ss"" is the number of secondary divisions and ""pp"" the; number of primary divisions.; opt : Options.; ""N"" - By default the number of divisions is optimized to; get a nice labeling. When option ""N"" is given, the; number of divisions is not optimized. void PaintGLAxisBody(); Paint horizontal axis body at position (0,0,0). void PaintGLAxisTickMarks(); Paint axis tick marks. void PaintGLAxisLabels(); Paint axis labels on the main tick marks. void TicksPositions(Option_t* opt = """"); Compute ticks positions. void TicksPositionsNoOpt(); Compute ticks positions. Linear and not optimized. void TicksPositionsOpt(); Compute ticks positions. Linear and optimized. void DoLabels(); Do labels. void SetLabelsAngles(Double_t a1, Double_t a2, Double_t a3); Set labels' angles. TGLAxis(const TGLAxis& ). TGLAxis& operator=(const TGLAxis& ). void SetTickMarksLength(Double_t length); {fTickMarksLength = length;}. void SetTickMarksOrientation(Int_t tmo); {fTickMarksOrientation = tmo;}. void SetLabelsOffset(Double_t offset); {fLabelsOffset = offset;}. void SetLabelsSize(Double_t size); {fLabelsSize = size;}. void SetGridLength(Double_t grid); {fGridLength = grid;}. » Author: Olivier Couet 17/04/2007 » Copyright (C) 1995-2006, Rene Brun and Fons Rademakers. *; » Last changed: root/gl:$Id: TGLAxis.h 21794 2008-01-21 21:11:46Z matevz $ » Last generated: 2011-12-02 14:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLAxis.html:4712,optimiz,optimized,4712,root/html532/TGLAxis.html,https://root.cern,https://root.cern/root/html532/TGLAxis.html,4,['optimiz'],['optimized']
Performance,"s. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEntryListFromFile(); default c-tor. TEntryListFromFile(const char* filename, const char* listname, Int_t nfiles); File naming convention:; - by default, filename_elist.root is used, where filename is the; name of the chain element; - xxx$xxx.root - $ sign is replaced by the name of the chain element; The TObjArray of chain elements is set by the TEntryListFromFile::SetFileNames(); function.; If the list name is not specified, the first object of class TEntryList; in the file is taken.; nfiles is the total number of files to process. ~TEntryListFromFile(); d-tor. Long64_t GetEntry(Int_t index); returns entry #index; See also Next() for a faster alternative. Long64_t GetEntryAndTree(Int_t index, Int_t& treenum); return the entry corresponding to the index parameter and the; number of the tree, where this entry is. Long64_t GetEntries(); Returns the total number of entries in the list.; If some lists have not been loaded, loads them. Long64_t Next(); Returns the next entry in the list.; Faster than GetEntry(). Int_t LoadList(Int_t listnumber); Loads the list #listnumber; This is the only function that can modify fCurrent and fFile data members. void Print(Option_t* option = """") const; Print info about this list. TEntryListFromFile(). void Add(const TEntryList* ); {}. Int_t Contains(Long64_t , TTree* ); {return 0;}. Bool_t Enter(Long64_t , TTree* ); {return 0;}. TEntryList * GetCurrentList() const; { return fCurrent; }. TEntryList * GetEntryList(const char* , const char* , Option_t* ); {return 0;}. Long64_t GetEntriesFast() const; { return fN; }. Long64_t GetN() const; { return fN; }. const char * GetTreeName() const; { return fTreeName.Data(); }. const char * GetFileName() const; { return fFileName.Data(); }. Int_t GetTreeNumber() const; { return fTreeNumber; }. Int_t Merge(TCollection* ); { return 0; }. void OptimizeStorage(); {}. Bool_t Remove(Long64_t , TTree* ); { return 0; }. void SetT",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEntryListFromFile.html:10454,load,loaded,10454,root/html528/TEntryListFromFile.html,https://root.cern,https://root.cern/root/html528/TEntryListFromFile.html,4,['load'],"['loaded', 'loads']"
Performance,"s. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsCachedPdf(); Destructor. Double_t getValV(const RooArgSet* set = 0) const; Implementation of getVal() overriding default implementation; of RooAbsPdf. Return normalized value stored in cache p.d.f; rather than return value of evaluate() which is undefined; for RooAbsCachedPdf. RooAbsPdf* getCachePdf(const RooArgSet* nset = 0) const; Return pointer to RooHistPdf cache pdf for given choice of observables. RooDataHist* getCacheHist(const RooArgSet* nset = 0) const; Return pointer to RooDataHist cache histogram for given choice of observables. void clearCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Mark all bins of given cache as unitialized (value -1). TString cacheNameSuffix(const RooArgSet& nset) const; Construct string with unique suffix for cache objects based on; observable names that define cache configuration. void setInterpolationOrder(Int_t order); Change the interpolation order that is used in RooHistPdf cache; representation smoothing the RooDataHist shapes. Bool_t forceAnalyticalInt(const RooAbsArg& dep) const; Force RooRealIntegral to offer all our actual observable for internal; integration. Int_t getAnalyticalIntegralWN(RooArgSet& allVars, RooArgSet& analVars, const RooArgSet* normSet, const char* rangeName = 0) const; Advertises internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Implements internal (analytical) integration capabilities. Call; is forwarded to RooHistPdf cache p.d.f of cache that is used for; given choice of observables. Bool_t selfNormalized() const; Declare p.d.f self normalized. RooAbsPdf* getCachePdf(const RooArgSet& nset) const; Return RooHistPdf that represents cache histogram. RooDataHist* getCacheHist(const RooArgSet& nset) const; Return R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsCachedPdf.html:44509,cache,cache,44509,root/html532/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html532/RooAbsCachedPdf.html,3,['cache'],['cache']
Performance,"s. List of all members |; Public Member Functions |; Static Public Member Functions |; Protected Attributes |; Static Protected Attributes |; List of all members ; RooObjCacheManager Class ReferenceRooFit » RooFit Core. ; Implementation of a RooCacheManager<RooAbsCacheElement> that specializes in the storage of cache elements that contain RooAbsArg objects. ; Caches with RooAbsArg derived payload require special care as server redirects cache operation mode changes and constant term optimization calls may need to be forwarded to such cache payload. This cache manager takes care of all these operations by forwarding these calls to the RooAbsCacheElement interface functions, which have a sensible default implementation. ; Definition at line 29 of file RooObjCacheManager.h. Public Member Functions;  RooObjCacheManager (const RooObjCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooObjCacheManager (RooAbsArg *owner=nullptr, Int_t maxSize=2, bool clearCacheOnServerRedirect=true, bool allowOptimize=false);  Constructor of object cache manager for given owner. ;  ;  ~RooObjCacheManager () override;  Destructor. ;  ; void findConstantNodes (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  If clearOnRedirect is false, forward constant term optimization calls to cache elements. ;  ; void insertObjectHook (RooAbsCacheElement &) override;  Set owner link on all object inserted into cache. ;  ; TClass * IsA () const override;  ; void operModeHook () override;  Intercept changes to cache operation mode and forward to cache elements. ;  ; void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:1186,cache,cache,1186,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['cache'],['cache']
Performance,"s. ROOT; » TREE; » TREE; » TVirtualBranchBrowsable. class TVirtualBranchBrowsable: public TNamed. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. TVirtualBranchBrowsable",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualBranchBrowsable.html:1166,cache,cached,1166,root/html528/TVirtualBranchBrowsable.html,https://root.cern,https://root.cern/root/html528/TVirtualBranchBrowsable.html,12,['cache'],['cached']
Performance,"s. ROOT; » TREE; » TREE; » TVirtualBranchBrowsable. class TVirtualBranchBrowsable: public TNamed. TVirtualBranchBrowsable is a base class (not really abstract, but useless; by itself) for helper objects that extend TBranch's browsing support.; Each registered derived class's generator method is called, which fills; all created helper objects into a list which can then be browsed.; For details of what these browser helper objects can do, see e.g.; TMethodBrowsable, which allows methods to show up in the TBrowser. Only registered helper objects are created. By default, only; TMethodBrowsable, TNonSplitBrowsable, and TCollectionPropertyBrowsable; are registered (see RegisterDefaultGenerators). You can prevent any of; their objects to show up in the browser by unregistering the generator:; TMethodBrowsable::Unregister(); will stop creating browsable method helper objects from that call on.; Note that these helper objects are cached (in TBranch::fBrowsables);; already created (and thus cached) browsables will still appear in the; browser even after unregistering the corresponding generator. You can implement your own browsable objects and thier generator; see; e.g. the simple TCollectionPropertyBrowsable. Note that you will have; to register your generator just like any other, and that you should; implement the following methods for your own class, mainly for; consistency reasons:; static void Register() {; TVirtualBranchBrowsable::RegisterGenerator(GetBrowsables); }; static void Unregister() {; TVirtualBranchBrowsable::UnregisterGenerator(GetBrowsables); }; where GetBrowsables is a static member function of your class, that; creates the browsable helper objects, and has the signature; static Int_t GetBrowsables(TList& list, const TBranch* branch,; const TVirtualBranchBrowsable* parent=0);; It has to return the number of browsable helper objects for parent; (or, if NULL, for branch) which are added to the list. Function Members (Methods); public:. virtual~TVirtualBranchB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TVirtualBranchBrowsable.html:1190,cache,cached,1190,root/html602/TVirtualBranchBrowsable.html,https://root.cern,https://root.cern/root/html602/TVirtualBranchBrowsable.html,8,['cache'],['cached']
Performance,"s. size_t nEvents=0;; for (auto& i:{xData,meanData,sigmaData}); nEvents = std::max(nEvents,i.size());. Create the output batch by calling RunContext::makeBatch(). - auto output = _batchData.makeWritableBatchUnInit(begin, batchSize);; + auto output = evalData.makeBatch(this, nEvents);. DO NOT use RooSpan::isBatch() and RooSpan::empty() methods! Instead, distinguish between scalar (RooSpan of size 1) and vector (RooSpan of size>1) parameters as shown below. - const bool batchX = !xData.empty();; + const bool batchX = xData.size()>1;. Append RooBatchCompute:: to the classes that have been moved to the RooBatchCompute Library: RooSpan,BracketAdapterWithMask, BracketAdapter, RunContext. Alternatively, you can write. using namespace RooBatchCompute;. Replace _rf_fast_<function> with RooBatchCompute::fast_<function> and include RooVDTHeaders.h (if applicable). - output[i] = _rf_fast_exp(arg*arg * halfBySigmaSq);; + output[i] = RooBatchCompute::fast_exp(arg*arg * halfBySigmaSq);; Unbiased binned fits; When RooFit performs binned fits, it takes the probability density at the bin centre as a proxy for the probability in the bin. This can lead to a bias. To alleviate this, the new class RooBinSamplingPdf has been added to RooFit. Also see arxiv:2012.02746.; More accurate residual and pull distributions; When making residual or pull distributions with RooPlot::residHist or RooPlot::pullHist, the histogram is now compared with the curve’s average values within a given bin by default, ensuring that residual and pull distributions are valid for strongly curved distributions. The old default behaviour was to interpolate the curve at the bin centres, which can still be enabled by setting the useAverage parameter of RooPlot::residHist or RooPlot::pullHist to false.; Improved recovery from invalid parameters; When a function in RooFit is undefined (Poisson with negative mean, PDF with negative values, etc), RooFit can now pass information about the “badness” of the violation to the min",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v624/release-notes.html:20908,perform,performs,20908,doc/v624/release-notes.html,https://root.cern,https://root.cern/doc/v624/release-notes.html,1,['perform'],['performs']
Performance,"s. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. void operModeHook(). RooCachedReal(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that represent the cache histogram; will use special boundary conditions for use with cumulative distribution; functions: at the lower bound the function is forced to converge at zero and the upper; bound is the function is forced to converge at 1.0. Bool_t getCdfBoundaries() const; If true the c.d.f boundary mode is active. Bool_t cacheSource() const; { return _cacheSource ; }. void setCacheSource(Bool_t flag); { _cacheSource = flag ; }. const char* inputBaseName() const; Return base name for caches, i.e. the name of the cached function. Double_t evaluate() const; Dummy evaluate, it is never called. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Tue Jun 30 14:31:55 2015 » Last generated: 2015-06-30 14:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCachedReal.html:41399,cache,cache,41399,root/html602/RooCachedReal.html,https://root.cern,https://root.cern/root/html602/RooCachedReal.html,8,['cache'],"['cache', 'cacheSource', 'cached', 'caches']"
Performance,"s.; 3785 ; 3786TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3787{; 3788 // Fast path, no lock? Classes load at creation time.; 3789 if ((!load || IsClassStructOrUnion()) && fUsingData); 3790 return fUsingData;; 3791 ; 3792 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3793}; 3794 ; 3795////////////////////////////////////////////////////////////////////////////////; 3796/// Return TListOfFunctionTemplates for a class.; 3797 ; 3798TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3799{; 3800 R__LOCKGUARD(gInterpreterMutex);; 3801 ; 3802 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3803 if (load) fFuncTemplate->Load();; 3804 return fFuncTemplate;; 3805}; 3806 ; 3807////////////////////////////////////////////////////////////////////////////////; 3808/// Return list containing the TMethods of a class.; 3809/// If load is true, the list is populated with all the defined function; 3810/// and currently instantiated function template.; 3811 ; 3812TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3813{; 3814 R__LOCKGUARD(gInterpreterMutex);; 3815 ; 3816 if (!fMethod.load()) GetMethodList();; 3817 if (load) {; 3818 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3819 (*fMethod).Load();; 3820 }; 3821 return fMethod;; 3822}; 3823 ; 3824////////////////////////////////////////////////////////////////////////////////; 3825/// Return the collection of functions named ""name"".; 3826 ; 3827TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3828{; 3829 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3830}; 3831 ; 3832 ; 3833////////////////////////////////////////////////////////////////////////////////; 3834/// Returns a list of all public methods of this class and its base classes.; 3835/// Refers to a subset of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:144037,load,load,144037,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"s.; 3852 ; 3853TList *TClass::GetListOfUsingDataMembers(Bool_t load /* = kTRUE */); 3854{; 3855 // Fast path, no lock? Classes load at creation time.; 3856 if ((!load || IsClassStructOrUnion()) && fUsingData); 3857 return fUsingData;; 3858 ; 3859 return CreateListOfDataMembers(fUsingData, TDictionary::EMemberSelection::kOnlyUsingDecls, load);; 3860}; 3861 ; 3862////////////////////////////////////////////////////////////////////////////////; 3863/// Return TListOfFunctionTemplates for a class.; 3864 ; 3865TList *TClass::GetListOfFunctionTemplates(Bool_t load /* = kTRUE */); 3866{; 3867 R__LOCKGUARD(gInterpreterMutex);; 3868 ; 3869 if (!fFuncTemplate) fFuncTemplate = new TListOfFunctionTemplates(this);; 3870 if (load) fFuncTemplate->Load();; 3871 return fFuncTemplate;; 3872}; 3873 ; 3874////////////////////////////////////////////////////////////////////////////////; 3875/// Return list containing the TMethods of a class.; 3876/// If load is true, the list is populated with all the defined function; 3877/// and currently instantiated function template.; 3878 ; 3879TList *TClass::GetListOfMethods(Bool_t load /* = kTRUE */); 3880{; 3881 R__LOCKGUARD(gInterpreterMutex);; 3882 ; 3883 if (!fMethod.load()) GetMethodList();; 3884 if (load) {; 3885 if (gDebug>0) Info(""GetListOfMethods"",""Header Parsing - Asking for all the methods of class %s: this can involve parsing."",GetName());; 3886 (*fMethod).Load();; 3887 }; 3888 return fMethod;; 3889}; 3890 ; 3891////////////////////////////////////////////////////////////////////////////////; 3892/// Return the collection of functions named ""name"".; 3893 ; 3894TCollection *TClass::GetListOfMethodOverloads(const char* name) const; 3895{; 3896 return const_cast<TClass*>(this)->GetMethodList()->GetListForObject(name);; 3897}; 3898 ; 3899 ; 3900////////////////////////////////////////////////////////////////////////////////; 3901/// Returns a list of all public methods of this class and its base classes.; 3902/// Refers to a subset of the",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:146788,load,load,146788,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"s.cxx:5979; TClass::GetStreamerInfoTVirtualStreamerInfo * GetStreamerInfo(Int_t version=0, Bool_t isTransient=kFALSE) constreturns a pointer to the TVirtualStreamerInfo object for version If the object does not exist,...Definition TClass.cxx:4666; TClass::GetCollectionProxyTVirtualCollectionProxy * GetCollectionProxy() constReturn the proxy describing the collection (if any).Definition TClass.cxx:2964; TClass::GetClassSizeInt_t GetClassSize() constDefinition TClass.h:425; TClass::GetConversionStreamerInfoTVirtualStreamerInfo * GetConversionStreamerInfo(const char *onfile_classname, Int_t version) constReturn a Conversion StreamerInfo from the class 'classname' for version number 'version' to this clas...Definition TClass.cxx:7153; TClass::kInterpreted@ kInterpretedDefinition TClass.h:126; TClass::GetDeleteROOT::DelFunc_t GetDelete() constReturn the wrapper around delete ThiObject.Definition TClass.cxx:7530; TClass::GetClassstatic TClass * GetClass(const char *name, Bool_t load=kTRUE, Bool_t silent=kFALSE)Static method returning pointer to TClass of the specified class name.Definition TClass.cxx:3035; TCollection::kInitCapacity@ kInitCapacityDefinition TCollection.h:159; TCollection::GetSizevirtual Int_t GetSize() constReturn the capacity of the collection, i.e.Definition TCollection.h:184; TDataTypeBasic data type descriptor (datatype information is obtained from CINT).Definition TDataType.h:44; TDataType::GetTypeInt_t GetType() constDefinition TDataType.h:68; TDataType::SizeInt_t Size() constGet size of basic typedef'ed type.Definition TDataType.cxx:375; TEnum::GetEnumstatic TEnum * GetEnum(const std::type_info &ti, ESearchAction sa=kALoadAndInterpLookup)Definition TEnum.cxx:175; TEnum::kNone@ kNoneDefinition TEnum.h:48; TGenBitsetProxyDefinition TGenCollectionProxy.cxx:135; TGenBitsetProxy::TGenBitsetProxyTGenBitsetProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:138; TGenBitsetProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const ove",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:73580,load,load,73580,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"s.h. ◆ Lock(). void TWebCanvas::Lock ; (; ). inlineoverrideprotectedvirtual . Reimplemented from TCanvasImp.; Definition at line 129 of file TWebCanvas.h. ◆ NewCanvas(). TCanvasImp * TWebCanvas::NewCanvas ; (; TCanvas * ; c, . const char * ; name, . Int_t ; x, . Int_t ; y, . UInt_t ; width, . UInt_t ; height . ). static . Static method to create TWebCanvas instance Used by plugin manager. ; Definition at line 2869 of file TWebCanvas.cxx. ◆ PerformUpdate(). Bool_t TWebCanvas::PerformUpdate ; (; Bool_t ; async). overrideprotectedvirtual . if canvas or any subpad was modified, scan all primitives in the TCanvas and subpads and convert them into the structure which will be delivered to JSROOT client ; Reimplemented from TCanvasImp.; Definition at line 2319 of file TWebCanvas.cxx. ◆ ProcessCustomScripts(). std::string TWebCanvas::ProcessCustomScripts ; (; bool ; batch). staticprotected . For batch mode special handling of scripts are required Headless browser not able to load modules from the file system Therefore custom web-canvas modules and scripts has to be loaded in advance and processed. ; Definition at line 389 of file TWebCanvas.cxx. ◆ ProcessData(). Bool_t TWebCanvas::ProcessData ; (; unsigned ; connid, . const std::string & ; arg . ). protectedvirtual . Handle data from web browser Returns kFALSE if message was not processed. ; Definition at line 1790 of file TWebCanvas.cxx. ◆ ProcessExecs(). void TWebCanvas::ProcessExecs ; (; TPad * ; pad, . TExec * ; extra = nullptr . ). protected . Process TExec objects in the pad. ; Definition at line 1727 of file TWebCanvas.cxx. ◆ ProcessLinesForObject(). void TWebCanvas::ProcessLinesForObject ; (; TObject * ; obj, . const std::string & ; lines . ). protected . Execute one or several methods for selected object String can be separated by "";;"" to let execute several methods at once. ; Definition at line 1759 of file TWebCanvas.cxx. ◆ ProcessObjectOptions(). TPad * TWebCanvas::ProcessObjectOptions ; (; TWebObjectOptions & ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTWebCanvas.html:31523,load,load,31523,doc/master/classTWebCanvas.html,https://root.cern,https://root.cern/doc/master/classTWebCanvas.html,2,['load'],"['load', 'loaded']"
Performance,"s.h:113; ROOT::GetClassTClass * GetClass(T *)Definition TClass.h:663; ROOT::CreateClassTClass * CreateClass(const char *cname, Version_t id, const std::type_info &info, TVirtualIsAProxy *isa, const char *dfil, const char *ifil, Int_t dl, Int_t il)Global function called by a class' static Dictionary() method (see the ClassDef macro).Definition TClass.cxx:5869; ROOT::DelFunc_tvoid(* DelFunc_t)(void *)Definition Rtypes.h:111; ROOT::ESTLTypeESTLTypeDefinition ESTLType.h:28; ROOT::NewArrFunc_tvoid *(* NewArrFunc_t)(Long_t size, void *arena)Definition Rtypes.h:110; ROOT::EFunctionMatchModeEFunctionMatchModeDefinition TDictionary.h:161; ROOT::kConversionMatch@ kConversionMatchDefinition TDictionary.h:163; ROOT::ResetClassVersionvoid ResetClassVersion(TClass *, const char *, Short_t)Global function to update the version number.Definition TClassTable.cxx:951; ROOT::DelArrFunc_tvoid(* DelArrFunc_t)(void *)Definition Rtypes.h:112; ROOT::NewFunc_tvoid *(* NewFunc_t)(void *)Definition Rtypes.h:109; ROOT::MergeFunc_tLong64_t(* MergeFunc_t)(void *, TCollection *, TFileMergeInfo *)Definition Rtypes.h:115; whatstatic const char * whatDefinition stlLoader.cc:5; ROOT::Internal::TClassGetClassHelperDefinition TClass.h:630; ROOT::Internal::TClassGetClassHelper::GetClassstatic TClass * GetClass(Bool_t load, Bool_t silent)Definition TClass.h:631; TClass::ObjectPtrDefinition TClass.h:140; TClass::ObjectPtr::fPtrvoid * fPtrDefinition TClass.h:141; TClass::ObjectPtr::GetAllocatorTVirtualStreamerInfo * GetAllocator() constDefinition TClass.h:149; TClass::ObjectPtr::GetPtrvoid * GetPtr() constDefinition TClass.h:147; TClass::ObjectPtr::fAllocatorTVirtualStreamerInfo * fAllocatorDefinition TClass.h:143; TClass::ObjectPtr::ObjectPtrObjectPtr(void *ptr=nullptr, TVirtualStreamerInfo *allocator=nullptr)Definition TClass.h:145; Drawth1 Draw(); lTLine lDefinition textangle.C:4. coremetaincTClass.h. ROOT v6-32 - Reference Guide Generated on Fri Nov 1 2024 15:07:01 (GVA Time) using Doxygen 1.9.8   ; . ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8h_source.html:85886,load,load,85886,doc/v632/TClass_8h_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8h_source.html,1,['load'],['load']
Performance,"s.size();; 551 for (unsigned i = 0; i < N; ++i) {; 552 if (!fValues[i].fIsActive); 553 continue;; 554 ; 555 int nbytes;; 556 switch (fValues[i].fType) {; 557 case ETypes::kInteger: fValues[i].fInteger = sqlite3_column_int64(fDataSet->fQuery, i); break;; 558 case ETypes::kReal: fValues[i].fReal = sqlite3_column_double(fDataSet->fQuery, i); break;; 559 case ETypes::kText:; 560 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 561 if (nbytes == 0) {; 562 fValues[i].fText = """";; 563 } else {; 564 fValues[i].fText = reinterpret_cast<const char *>(sqlite3_column_text(fDataSet->fQuery, i));; 565 }; 566 break;; 567 case ETypes::kBlob:; 568 nbytes = sqlite3_column_bytes(fDataSet->fQuery, i);; 569 fValues[i].fBlob.resize(nbytes);; 570 if (nbytes > 0) {; 571 std::memcpy(fValues[i].fBlob.data(), sqlite3_column_blob(fDataSet->fQuery, i), nbytes);; 572 }; 573 break;; 574 case ETypes::kNull: break;; 575 default: throw std::runtime_error(""Unhandled column type"");; 576 }; 577 }; 578 return true;; 579}; 580 ; 581////////////////////////////////////////////////////////////////////////////////////////////////; 582/// Almost a no-op, many slots can in fact reduce the performance due to thread synchronization.; 583void RSqliteDS::SetNSlots(unsigned int nSlots); 584{; 585 if (nSlots > 1) {; 586 ::Warning(""SetNSlots"", ""Currently the SQlite data source faces performance degradation in multi-threaded mode. ""; 587 ""Consider turning off IMT."");; 588 }; 589 fNSlots = nSlots;; 590}; 591 ; 592////////////////////////////////////////////////////////////////////////////////////////////////; 593/// Helper function to throw an exception if there is a fatal sqlite error, e.g. an I/O error.; 594void RSqliteDS::SqliteError(int errcode); 595{; 596 std::string errmsg = ""SQlite error: "";; 597#if SQLITE_VERSION_NUMBER < 3007015; 598 errmsg += std::to_string(errcode);; 599#else; 600 errmsg += sqlite3_errstr(errcode);; 601#endif; 602 throw std::runtime_error(errmsg);; 603}; 604 ; 605} // namespace RDF; 606",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RSqliteDS_8cxx_source.html:24220,perform,performance,24220,doc/master/RSqliteDS_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RSqliteDS_8cxx_source.html,1,['perform'],['performance']
Performance,"s: TGeoHype class; Cones: TGeoCone class; Cone Segments: TGeoConeSeg class; Sphere: TGeoSphere class; Torus: TGeoTorus class; Paraboloid: TGeoParaboloid class; Polycone: TGeoPcon class; Polygon: TGeoPgon class; Polygonal extrusion: TGeoXtru class; Half Spaces: TGeoHalfSpace class; Composite Shapes: TGeoCompositeShape class. Navigation Methods Performed By Shapes; Shapes are named objects and register themselves to the manager class at creation time. This is responsible for their final deletion. Shapes can be created without name if their retrieval by name is no needed. Generally shapes are objects that are useful only at geometry creation stage. The pointer to a shape is in fact needed only when referring to a given volume and it is always accessible at that level. Several volumes may reference a single shape; therefore its deletion is not possible once volumes were defined based on it.; The navigation features related for instance to tracking particles are performed in the following way: Each shape implement its specific algorithms for all required tasks in its local reference system. Note that the manager class handles global queries related to geometry. However, shape-related queries might be sometimes useful:; Bool_t TGeoShape::Contains(Double_t *point[3]);; Bool_tbool Bool_tDefinition RtypesCore.h:63; Double_tdouble Double_tDefinition RtypesCore.h:59; TGeoShape::Containsvirtual Bool_t Contains(const Double_t *point) const =0; The method above returns kTRUE if the point *point is actually inside the shape. The point has to be defined in the local shape reference. For instance, for a box having DX,DY and DZhalf-lengths a point will be considered inside if:; -DX <= point[0] <= DX; -DY <= point[1] <= DY; -DZ <= point[2] <= DZ; Double_t TGeoShape::DistFromInside(Double_t *point[3],; Double_t *dir[3], Int_t iact,Double_t step,Double_t *safe);; Int_tint Int_tDefinition RtypesCore.h:45; TGeoShape::DistFromInsidevirtual Double_t DistFromInside(const Double_t *point, cons",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Shapes__classes.html:4470,perform,performed,4470,doc/master/group__Shapes__classes.html,https://root.cern,https://root.cern/doc/master/group__Shapes__classes.html,1,['perform'],['performed']
Performance,"s::GetDict(const type_info& info); static TDictionary*TDictionary::GetDictionary(const char* name); static TDictionary*TDictionary::GetDictionary(const type_info& typeinfo); ROOT::DirAutoAdd_tTClass::GetDirectoryAutoAdd() const; virtual Option_t*TObject::GetDrawOption() const; static Long_tTObject::GetDtorOnly(); TFunctionTemplate*TClass::GetFunctionTemplate(const char* name); UInt_tTClass::GetHeapInstanceCount() const; virtual const char*TObject::GetIconName() const; Short_tTClass::GetImplFileLine() const; const char*TClass::GetImplFileName() const; UInt_tTClass::GetInstanceCount() const; TVirtualIsAProxy*TClass::GetIsAProxy() const; TVirtualStreamerInfo*TClass::GetLastReadInfo() const; TList*TClass::GetListOfAllPublicDataMembers(Bool_t load = kTRUE); const TList*TClass::GetListOfAllPublicMethods(Bool_t load = kTRUE); TList*TClass::GetListOfBases(); TList*TQObject::GetListOfClassSignals() const; TList*TQObject::GetListOfConnections() const; TList*TClass::GetListOfDataMembers(Bool_t load = kTRUE); TList*TClass::GetListOfEnums(Bool_t load = kTRUE); TList*TClass::GetListOfFunctionTemplates(Bool_t load = kTRUE); TCollection*TClass::GetListOfMethodOverloads(const char* name) const; TList*TClass::GetListOfMethods(Bool_t load = kTRUE); TList*TClass::GetListOfRealData() const; TList*TQObject::GetListOfSignals() const; voidTClass::GetMenuItems(TList* listitems); TList*TClass::GetMenuList() const; ROOT::MergeFunc_tTClass::GetMerge() const; TMethod*TClass::GetMethod(const char* method, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetMethodAllAny(const char* method); TMethod*TClass::GetMethodAny(const char* method); TMethod*TClass::GetMethodWithPrototype(const char* method, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); voidTClass::GetMissingDictionaries(THashTable& result, bool recurse = false); virtual const char*TNamed::GetName() const; Int_tTClass::GetNdata(); ROOT::NewFunc_tTClass::GetNew() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:9996,load,load,9996,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,4,['load'],['load']
Performance,"s::TestStatSampler*RooStats::HypoTestCalculatorGeneric::fTestStatSampler. private:. RooAbsData*fAsimovDataasimov data set; RooArgSetfAsimovGlobObssnapshot of Asimov global observables; RooArgSetfBestFitParamssnapshot of all best fitted Parameter values; RooArgSetfBestFitPoisnapshot of best fitted POI values; doublefNLLAsimov; doublefNLLObs; boolfOneSidedfor one sided PL test statistic (upper limits); boolfOneSidedDiscoveryfor one sided PL test statistic (for discovery); intfUseQTildeflag to indicate if using qtilde or not (-1 (default based on RooRealVar)), 0 false, 1 (true); static intfgPrintLevelcontrol print level (0 minimal, 1 normal, 2 debug). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetPrintLevel(int level); set print level (static function); 0 minimal, 1 normal, 2 debug. AsymptoticCalculator(RooAbsData& data, const RooStats::ModelConfig& altModel, const RooStats::ModelConfig& nullModel, bool nominalAsimov = false); constructor for asymptotic calculator from Data set and ModelConfig; The constructor will perform a global fit of the model to the data; and build an Asimov data set.; It will then also fit the model to the Asimov data set to find the likelihood value; of the Asimov data set; nominalAsimov is an option for using Asimov data set obtained using nominal nuisance parameter values; By default the nuisance parameters are fitted to the data; NOTE: If a fit has been done before, one for speeding up could set all the initial prameters; to the fit value and in addition set the null snapshot to the best fit. Double_t EvaluateNLL(RooAbsPdf& pdf, RooAbsData& data, const RooArgSet* condObs, const RooArgSet* poiSet = 0). HypoTestResult* GetHypoTest() const; It performs an hypothesis tests using the likelihood function; and computes the p values for the null and the alternate using the asymptotic; formulae for the profile likelihood ratio.; See G. Cowan, K. Cranmer, E. Gross and O. Vitells.; Asymptotic formula",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html:5938,perform,perform,5938,root/html602/RooStats__AsymptoticCalculator.html,https://root.cern,https://root.cern/root/html602/RooStats__AsymptoticCalculator.html,2,['perform'],['perform']
Performance,"s::kDL, ""DL_CPU"", nnOptions);; }; if (Use[""DL_GPU""]) {; TString layoutString(""Layout=TANH|100,TANH|50,TANH|10,LINEAR"");; TString trainingStrategyString(""TrainingStrategy=Optimizer=ADAM,LearningRate=1e-3,""; ""TestRepetitions=1,ConvergenceSteps=10,BatchSize=100,MaxEpochs=20"");; TString nnOptions(""!H:V:ErrorStrategy=CROSSENTROPY:VarTransform=N:""; ""WeightInitialization=XAVIERUNIFORM:Architecture=GPU"");; nnOptions.Append("":"");; nnOptions.Append(layoutString);; nnOptions.Append("":"");; nnOptions.Append(trainingStrategyString);; factory->BookMethod(dataloader, TMVA::Types::kDL, ""DL_GPU"", nnOptions);; }; ; ; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Close();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAMulticlass is done!"" << std::endl;; ; delete factory;; delete dataloader;; ; // Launch the GUI for the root macros; if (!gROOT->IsBatch()) TMVAMultiClassGui( outfileName );; ; ; }; ; int main( int argc, char** argv ); {; // Select methods (don't look at this code - not of interest); TString methodList;; for (int i=1; i<argc; i++) {; TString regMethod(argv[i]);; if(regMethod==""-b"" || regMethod==""--batch"") continue;; if (!methodList.IsNull()) methodList += TString("","");; methodList += regMethod;; }; TMVAMulticlass(methodList);; return 0;; }; ; DataLoader.h; mainint main()Definition Prototype.cxx:12; UInt_tunsigned int UInt_tDefinition RtypesCore.h:46; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAMultiClassGui.h; TROOT.h; gROOT#define gROOTDefin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:37146,perform,performance,37146,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,"s:; ClassDef(<ClassName>,<VersionNumber>); The version number identifies this particular version of the class. When a class has version 0 it is not stored in a root file but its base class(es) is(are). The reason can be that this class has no data members worth saving or all real info is in the base classes. The version number is written to the file in the Streamer by the call TBuffer::WriteVersion. You, as the designer of the class, do not need to do any manual modification in the Streamer. ROOT schema evolution mechanism is automatic and handled by the StreamerInfo.; 11.5.6 Manual Data Model Evolution Capabilities; The automatic data model schema evolution implemented in ROOT makes it possible to read back the serialized data object in the situation when the definition of the classes those objects represent changed slightly (some of the data members were removed or some new ones added). It is also possible to manually specify the rules for more sophisticated data transformations done while reading to load the serialized objects into data structures that changed quite significantly.; ROOT provides two interface enabling users to specify the conversion rules. The first way is to define a rule in the dictionary file and the second way is to insert it to the TClass object using the C++ API.; There are two types of conversion rules. The first of them, the normal rules, are the ones that should be used in the most of the cases. They provide a buffered input data and an address of the in-memory target object and allow user to specify the conversion function mapping the data being read to the output format. The second type of the rules, the raw rules, also provide the pointer to the target object but the input is a raw TBuffer object containing the input data member declared as an input to the rule. This type of a rule is provided mainly to handle the file format changes that couldn’t have been handled otherwise and in general should not be used unless there is no other op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:498530,load,load,498530,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['load']
Performance,s; Color_tTAttLine::fLineColorline color; Style_tTAttLine::fLineStyleline style; Width_tTAttLine::fLineWidthline width; Int_tTTree::fMakeClass! not zero when processing code generated by MakeClass; Color_tTAttMarker::fMarkerColorMarker color index; Size_tTAttMarker::fMarkerSizeMarker size; Style_tTAttMarker::fMarkerStyleMarker style; Int_tTTree::fMaxClusterRange! Memory allocated for the cluster range.; Long64_tTTree::fMaxEntriesMaximum number of entries in case of circular buffers; Long64_tTTree::fMaxEntryLoopMaximum number of entries to process; Long64_tTTree::fMaxVirtualSizeMaximum total size of buffers kept in memory; Int_tTTree::fNClusterRangeNumber of Cluster range in addition to the one defined by 'AutoFlush'; TStringTNamed::fNameobject identifier; Int_tTTree::fNfill! Local for EntryLoop; TObject*TTree::fNotify! Object to be notified when loading a Tree; Int_tTTree::fPacketSize! Number of entries in one packet for parallel root; TVirtualPerfStats*TTree::fPerfStats! pointer to the current perf stats object; TVirtualTreePlayer*TTree::fPlayer! Pointer to current Tree player; Long64_tTTree::fReadEntry! Number of the entry being processed; Long64_tTTree::fSavedBytesNumber of autosaved bytes; Int_tTTree::fScanFieldNumber of runs before prompting in Scan; Int_tTTree::fTimerIntervalTimer interval in milliseconds; TStringTNamed::fTitleobject title; Long64_tTTree::fTotBytesTotal number of bytes in all branches before compression; Long64_tTTree::fTotalBuffers! Total number of bytes in branch buffers; TBuffer*TTree::fTransientBuffer! Pointer to the current transient buffer.; TVirtualIndex*TTree::fTreeIndexPointer to the tree Index (if any); Int_tfTypeRWN (0) or CWN (1); Int_tTTree::fUpdateUpdate frequency for EntryLoop; TList*TTree::fUserInfopointer to a list of user objects associated to this Tree; Double_tTTree::fWeightTree weight (see TTree::SetWeight); char*fXstorage area for RWN; Long64_tTTree::fZipBytesTotal number of bytes in all branches after compression; static,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THbookTree.html:25566,load,loading,25566,root/html534/THbookTree.html,https://root.cern,https://root.cern/root/html534/THbookTree.html,6,['load'],['loading']
Performance,"s; Includes; Libraries. Function documentation; RooObjCacheManager(RooAbsArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:4999,cache,cache,4999,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,6,['cache'],['cache']
Performance,"s; Libraries. Function documentation; TTreeCache(); Default Constructor. TTreeCache(TTree* tree, Int_t buffersize = 0); Constructor. ~TTreeCache(); destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subgbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); Add a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expressions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. void DropBranch(TBranch* b, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void DropBranch(const char* branch, Bool_t subbranches = kFALSE); Remove a branch to the list of branches to be stored in the cache; this is to be used by user (thats why we pass the name of the branch).; It works in exactly the same way as TTree::SetBranchStatus so you; probably want to look over ther for details about the use of bname; with regular expresions.; The branches are taken with respect to the Owner of this TTreeCache; (i.e. the original Tree); NB: if bname=""*"" all branches are put in the cache and the learning phase stopped. Bool_t FillBuffer(); Fill the cache buffer with the branches in the cache. Double_t GetEfficiency() const; Give the total efficiency of the cache... defined as the ratio; of blocks found in the cache vs. the number of blocks prefetched; ( it could be more than 1 if we read the same block from the cache more; than once ); Note: This should eb used at the end of the pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TTreeCache.html:22193,cache,cache,22193,root/html534/TTreeCache.html,https://root.cern,https://root.cern/root/html534/TTreeCache.html,2,['cache'],['cache']
Performance,"s; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport rectangle w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TGLCamera.html:7667,cache,cache,7667,root/html528/TGLCamera.html,https://root.cern,https://root.cern/root/html528/TGLCamera.html,4,['cache'],['cache']
Performance,"s; Libraries. Function documentation; ~TGLCamera(); Base camera destructor. void SetViewport(const TGLRect& viewport); Set viewport extents from passed 'viewport' rect. void UpdateCache() const; Update internally cached frustum values. TGLBoundingBox Frustum(Bool_t asBox = kTRUE) const; Return the the current camera frustum. If asBox == kFALSE return; a true frustum (truncated square based pyramid). If asBox == kTRUE; return a true box, using the far clipping plane intersection projected; back to the near plane. Camera must have valid frustum cache - call Apply() after last modifcation, before using. Note: TGLBoundingBox is not really valid when filled with truncated pyramid; - this is used as a visual debug aid only so ok. TGLVertex3 EyePoint() const; Return the camera eye point (vertex) in world space; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVector3 EyeDirection() const; Extract the camera eye direction (vector), running from EyePoint(); Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLVertex3 FrustumCenter() const; Find the center of the camera frustum from intersection of planes; This method will work even with parallel left/right & top/bottom and; infinite eye point of ortho cameras; Camera must have valid frustum cache - call Apply() after last modifcation, before using. Rgl::EOverlap FrustumOverlap(const TGLBoundingBox& box) const; Calcaulte overlap (kInside, kOutside, kPartial) of box with camera; frustum; Camera must have valid frustum cache - call Apply() after last modifcation, before using. Rgl::EOverlap ViewportOverlap(const TGLBoundingBox& box) const; Calculate overlap (kInside, kOutside, kPartial) of box projection onto viewport; (as rect) against the viewport rect.; Camera must have valid frustum cache - call Apply() after last modifcation, before using. TGLRect ViewportRect(const TGLBoundingBox& box, TGLBoundingBox::EFace face) const; Calculate viewport r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLCamera.html:12312,cache,cache,12312,root/html534/TGLCamera.html,https://root.cern,https://root.cern/root/html534/TGLCamera.html,2,['cache'],['cache']
Performance,s; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dgamma; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; RooRealProxy_f0; RooRealProxy_f1; RooRealProxy_f2; RooRealProxy_f3; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooBDecay.html:38169,cache,cache,38169,root/html526/RooBDecay.html,https://root.cern,https://root.cern/root/html526/RooBDecay.html,4,['cache'],['cache']
Performance,"s; after the closing of the file. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void SecondPrefetch(Long64_t , Int_t ). void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc). Int_t ReadBufferExtPrefetch(char* buf, Long64_t pos, Int_t len, Int_t& loc); prefetch the first block. Int_t ReadBufferExtNormal(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file, TFile::ECacheAction action = TFile::kDisconnect); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. void SecondSort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary.; Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFilePrefetch* GetPrefetchObj(). void WaitFinishPrefetc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TFileCacheRead.html:10541,cache,cache,10541,root/html534/TFileCacheRead.html,https://root.cern,https://root.cern/root/html534/TFileCacheRead.html,12,['cache'],['cache']
Performance,"s; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsData(); Destructor. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(RooCmdArg arg1, RooCmdArg arg2 = RooCmdArg(), RooCmdArg arg3 = RooCmdArg(), RooCmdArg arg4 = RooCmdArg(), RooCmdArg arg5 = RooCmdArg(), RooCmdArg arg6 = RooCmdArg(), RooCmdArg arg7 = RooCmdArg(), RooCmdArg arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormulaVar& expr) -- Only retain event surviving the given cu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsData.html:14299,cache,cached,14299,root/html526/RooAbsData.html,https://root.cern,https://root.cern/root/html526/RooAbsData.html,1,['cache'],['cached']
Performance,"s; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsData(); Destructor. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output dataset; Cut(const char* expression) -- Only retain event surviving the given cut expression; Cut(const RooFormu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsData.html:14341,cache,cached,14341,root/html528/RooAbsData.html,https://root.cern,https://root.cern/root/html528/RooAbsData.html,1,['cache'],['cached']
Performance,"s; public:. enum TBuffer::EMode { kRead; kWrite; };; enum TBuffer::[unnamed] { kIsOwner; kCannotHandleMemberWiseStreaming; kInitialSize; kMinimalSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfArraySepar! depending from compression level, "", "" or "",""; char*TBuffer::fBufCurCurrent position in buffer; char*TBuffer::fBufMaxEnd of buffer; Int_tTBuffer::fBufSizeSize of buffer; char*TBuffer::fBufferBuffer used to store objects; vector<TVirtualArray*>TBuffer::fCacheStackStack of pointers to the cache where to temporarily store the value of 'missing' data members; Int_tfCompact! 0 - no any compression, 1 - no spaces in the begin, 2 - no new lines, 3 - no spaces at all; Bool_tfExpectedChain! flag to resolve situation when several elements of same basic type stored as FastArray; unsigned intfJsonrCnt! counter for all objects and arrays; map<const void*,unsigned>fJsonrMap! map of recorded objects, used in JsonR to restore references; Bool_tTBuffer::fModeRead or write mode; TStringfNumericLocale! stored value of setlocale(LC_NUMERIC), which should be recovered at the end; TStringfOutBuffer! main output buffer for json code; TString*fOutput! current output buffer for json code; TObject*TBuffer::fParentPointer to parent object owning this buffer; ReAllocCharFun_tTBuffer::fReAllocFunc! Realloc function to be used when extending the buffer.; TStringfSemicolon! depending from compression level, "" : "" or "":""; TObjArrayfStack! stack of streamer infos; TStringfValue! buffer for current value; Int_tTBuffer::fVersionBuffer format version; static const char*fgFloatFmt! printf argument for floats and doubles, either ""%f"" or ""%e"" or ""%10f"" and so on. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBufferJSON(); Creat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBufferJSON.html:19097,cache,cache,19097,root/html534/TBufferJSON.html,https://root.cern,https://root.cern/root/html534/TBufferJSON.html,2,['cache'],['cache']
Performance,"s; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. private:. THashTable*fBasesLoaded! table of base classes already checked or loaded; TList*fHandlerslist of plugin handlers; Bool_tfReadingDirs! true if we are running LoadHandlersFromPluginDirs. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TPluginManager(); Clean up the plugin manager. void LoadHandlersFromEnv(TEnv* env); Load plugin handlers specified in config file, like:; Plugin.TFile: ^rfio: TRFIOFile RFIO ""TRFIOFile(...)""; Plugin.TSQLServer: ^mysql: TMySQLServer MySQL ""TMySQLServer(...)""; +Plugin.TSQLServer: ^pgsql: TPgSQLServer PgSQL ""TPgSQLServer(...)""; The + allows the extension of an already defined resource (see TEnv). void LoadHandlerMacros(const char* path); Load all plugin macros from the specified path/base directory. void LoadHandlersFromPluginDirs(const char* base = 0); Load plugin handlers specified via macros in a list of plugin; directories. The $ROOTSYS/etc/plugins is the default top plugin directory; specified in $ROOTSYS/etc/system.rootrc. The macros must have names; like <BaseClass>/PX0_<PluginClass>.C, e.g.:; TFile/P10_TRFIOFile.C, TSQLServer/P20_TMySQLServer.C, etc.; to allow easy sorting and grouping. If the BaseClass is in a namespace; the directory must have the name NameSpace@@BaseClass as : is a reserved; pathname character on some operating systems. Macros not beginning with; 'P' and ending with "".C"" are ignored. If base is specified only plugin; macros for that base class are loaded. The macros typically; should look like:; void P10_TDCacheFile(); {; gPluginMgr->AddHandler(""TFile"", ""^dcache"", ""TDCacheFile"",; ""DCache"", ""TDCacheFile(const char*,Option_t*,const char*,Int_t)"");; }; In general these macros should not cause side effect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TPluginManager.html:9490,Load,LoadHandlerMacros,9490,root/html532/TPluginManager.html,https://root.cern,https://root.cern/root/html532/TPluginManager.html,4,['Load'],"['Load', 'LoadHandlerMacros']"
Performance,"s; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Int_t_cacheAllNDim! Cache all integrals with given numeric dimension; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealIntegral::IntOperMode_intOperModeintegrati",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:31947,cache,cache,31947,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,2,['cache'],['cache']
Performance,"s; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Int_t_cacheAllNDim! Cache all integrals with given numeric dimension; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; Bool_t_cacheNumCache integral if numeric; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; RooSetProxy_facListSet of observables on which function does not depends, which are integrated nevertheless; TIterator*_facListIter! Iterator over factorizing observables; RooArgSet_facListOwnedOwned components in _facList; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooArgSet*_funcNormSetOptional normalization set passed to function; RooRealProxy_functionFunction being integration; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; RooNumIntConfig*_iconfig; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; RooSetProxy_intListSet of continuous observables over which is integrated numerically; RooRealInte",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealIntegral.html:30586,cache,cache,30586,root/html526/RooRealIntegral.html,https://root.cern,https://root.cern/root/html526/RooRealIntegral.html,3,['cache'],['cache']
Performance,"s; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Int_t_ipOrderInterpolation order for cache histograms; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedPdf.html:43449,cache,cache,43449,root/html602/RooAbsCachedPdf.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedPdf.html,4,['cache'],['cache']
Performance,"s; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_t_epsPrecision; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooFunctor*_ftor! Functor binding of RooAbsReal; RooRealProxy_funcInput function; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooDerivative.html:35050,cache,cache,35050,root/html602/RooDerivative.html,https://root.cern,https://root.cern/root/html602/RooDerivative.html,10,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"s; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. Bool_tTList::fAscending! sorting order (when calling Sort() or for TSortedList); TObjLink*TList::fCache! cache to speedup sequential calling of Before() and After() functions; TObjLink*TList::fFirst! pointer to first entry in linked list; TObjLink*TList::fLast! pointer to last entry in linked list; TStringTCollection::fNamename of the collection; Int_tTCollection::fSizenumber of elements in collection; Bool_tTSeqCollection::fSortedtrue if collection has been sorted; THashTable*THashList::fTableHashtable used for quick lookup of objects; static TCollection::(anonymous)TCollection::kIsOwner. private:. TClass*fClass! Context of this list. Not owned.; TExMap*fIds! Map from DeclId_t to TDataMember*; Bool_tfIsLoaded! Mark whether Load was executed.; ULong64_tfLastLoadMarker! Represent interpreter state when we last did a full load.; THashList*fUnloaded! Holder of TDataMember for unloaded DataMembers. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TListOfDataMembers(TClass* cl = 0); Constructor. ~TListOfDataMembers(); Destructor. void MapObject(TObject* obj); Add a pair<id, object> to the map of data members and their ids. void AddFirst(TObject* obj); Add object at the beginning of the list. void AddFirst(TObject* obj, Option_t* opt); Add object at the beginning of the list and also store option.; Storing an option is useful when one wants to change the behaviour; of an object a little without having to create a complete new; copy of the object. This feature is used, for example, by the Draw(); method. It allows the same object to be drawn in different ways. void AddLast(TObject* obj); Add object at the end of the list. void AddLast(TObject* obj, Option_t* opt); Add object at the end of the list and also store option.; Storing a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfDataMembers.html:11418,load,load,11418,root/html602/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html602/TListOfDataMembers.html,4,['load'],['load']
Performance,"s; that can be integrated by all remaining components. If such a set exists, it reconfirms that; each component is capable of analytically integrating the common set, and combines the components; individual integration codes into a single integration code valid for RooProdPdf. Double_t analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; Return analytical integral defined by given scenario code. Bool_t checkObservables(const RooArgSet* nset) const; Obsolete. RooAbsPdf::ExtendMode extendMode() const; If this product contains exactly one extendable p.d.f return the extension abilities of; that p.d.f, otherwise return CanNotBeExtended. Double_t expectedEvents(const RooArgSet* nset); Return the expected number of events associated with the extentable input p.d.f; in the product. If there is no extendable term, return zero and issue and error. RooAbsGenContext* genContext(const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t verbose = kFALSE) const; Return generator context optimized for generating events from product p.d.f.s. Int_t getGenerator(const RooArgSet& directVars, RooArgSet& generateVars, Bool_t staticInitOK = kTRUE) const; Query internal generation capabilities of component p.d.f.s and aggregate capabilities; into master configuration passed to the generator context. void initGenerator(Int_t code); Forward one-time initialization call to component generation initialization; methods. void generateEvent(Int_t code); Generate a single event with configuration specified by 'code'; Defer internal generation to components as encoded in the _genCode; registry for given generator code. Bool_t isDirectGenSafe(const RooAbsArg& arg) const; Forward determination of safety of internal generator code to; component p.d.f that would generate the given observable. RooArgSet* findPdfNSet(RooAbsPdf& pdf) const; Look up user specified normalization set for given input PDF component. RooArgSet* getConst",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProdPdf.html:51330,optimiz,optimized,51330,root/html526/RooProdPdf.html,https://root.cern,https://root.cern/root/html526/RooProdPdf.html,1,['optimiz'],['optimized']
Performance,"s; torch_spec = importlib.util.find_spec(""torch""); if torch_spec is not None and os.path.exists(pyTorchFileName):; #cmd = str(ROOT.TMVA.Python_Executable()) + "" "" + pyTorchFileName; #os.system(cmd); #import PyTorch_Generate_CNN_Model; ROOT.Info(""TMVA_CNN_Classification"", ""Booking PyTorch CNN model""); factory.BookMethod(; loader,; TMVA.Types.kPyTorch,; ""PyTorch"",; H=True,; V=False,; VarTransform=None,; FilenameModel=""PyTorchModelCNN.pt"",; FilenameTrainedModel=""PyTorchTrainedModelCNN.pt"",; NumEpochs=max_epochs,; BatchSize=100,; UserCode=str(pyTorchFileName); ); else:; ROOT.Warning(; ""TMVA_CNN_Classification"",; ""PyTorch is not installed or model building file is not existing - skip using PyTorch"",; ); ; if useKerasCNN:; ROOT.Info(""TMVA_CNN_Classification"", ""Building convolutional keras model""); # create python script which can be executed; # create 2 conv2d layer + maxpool + dense; import tensorflow; from tensorflow.keras.models import Sequential; from tensorflow.keras.optimizers import Adam; ; # from keras.initializers import TruncatedNormal; # from keras import initializations; from tensorflow.keras.layers import Input, Dense, Dropout, Flatten, Conv2D, MaxPooling2D, Reshape; ; # from keras.callbacks import ReduceLROnPlateau; model = Sequential(); model.add(Reshape((16, 16, 1), input_shape=(256,))); model.add(Conv2D(10, kernel_size=(3, 3), kernel_initializer=""TruncatedNormal"", activation=""relu"", padding=""same"")); model.add(Conv2D(10, kernel_size=(3, 3), kernel_initializer=""TruncatedNormal"", activation=""relu"", padding=""same"")); # stride for maxpool is equal to pool size; model.add(MaxPooling2D(pool_size=(2, 2))); model.add(Flatten()); model.add(Dense(64, activation=""tanh"")); # model.add(Dropout(0.2)); model.add(Dense(2, activation=""sigmoid"")); model.compile(loss=""binary_crossentropy"", optimizer=Adam(learning_rate=0.001), weighted_metrics=[""accuracy""]); model.save(""model_cnn.h5""); model.summary(); ; if not os.path.exists(""model_cnn.h5""):; raise FileNotFoundError(""Error c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html:14200,optimiz,optimizers,14200,doc/master/TMVA__CNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8py.html,1,['optimiz'],['optimizers']
Performance,"s=""bkg"", VisualizeError=(r, {fsig}, 2), FillColor=""m""); ; model.plotOn(frame4); model.plotOn(frame4, Components=""bkg"", LineStyle=""--""); frame4.SetMinimum(0); ; c = ROOT.TCanvas(""rf610_visualerror"", ""rf610_visualerror"", 800, 800); c.Divide(2, 2); c.cd(1); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); c.cd(2); ROOT.gPad.SetLeftMargin(0.15); frame2.GetYaxis().SetTitleOffset(1.6); frame2.Draw(); c.cd(3); ROOT.gPad.SetLeftMargin(0.15); frame3.GetYaxis().SetTitleOffset(1.6); frame3.Draw(); c.cd(4); ROOT.gPad.SetLeftMargin(0.15); frame4.GetYaxis().SetTitleOffset(1.6); frame4.Draw(); ; c.SaveAs(""rf610_visualerror.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_genData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsReal::plotOn(model) INFO: visualizing 1-sigma uncertainties in parameters (m,s,fsig,m2,s2) from fit result fitresult_model_genData using 315 samplings.; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf610__visualerror_8py.html:6298,optimiz,optimization,6298,doc/master/rf610__visualerror_8py.html,https://root.cern,https://root.cern/doc/master/rf610__visualerror_8py.html,2,['optimiz'],['optimization']
Performance,"sActive(); Static function that returns kTRUE in case we are a PROOF server. TProofServ * This(); Static function returning pointer to global object gProofServ.; Mainly for use via CINT, where the gProofServ symbol might be; deleted from the symbol table. Int_t OldAuthSetup(TString& wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TProofQueryResult * MakeQueryResult(Long64_t nentries, const char* opt, TList* inl, Long64_t first, TDSet* dset, const char* selec, TObject* elist); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. void HandleArchive(TMessage* mess, TString* slb = 0); Handle archive request. void HandleProcess(TMessage* mess, TString* slb = 0); Handle processing request. Int_t SendResults(TSocket* sock, TList* outlist = 0, TQueryResult* pq = 0); Sends all objects from the given list to the specified socket. void ProcessNext(TString* slb = 0); process the next query from the queue of submitted jobs.; to be called on the top master only. Int_t RegisterDataSets(TList* in, TList* out); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t ab",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofServ.html:25879,queue,queue,25879,root/html530/TProofServ.html,https://root.cern,https://root.cern/root/html530/TProofServ.html,3,['queue'],['queue']
Performance,"sActive(); Static function that returns kTRUE in case we are a PROOF server. TProofServ * This(); Static function returning pointer to global object gProofServ.; Mainly for use via CINT, where the gProofServ symbol might be; deleted from the symbol table. Int_t OldAuthSetup(TString& wconf); Setup authentication related stuff for old versions.; Provided for backward compatibility. TProofQueryResult * MakeQueryResult(Long64_t nentries, const char* opt, TList* inl, Long64_t first, TDSet* dset, const char* selec, TObject* elist); Create a TProofQueryResult instance for this query. void SetQueryRunning(TProofQueryResult* pq); Set query in running state. void HandleArchive(TMessage* mess, TString* slb = 0); Handle archive request. void HandleProcess(TMessage* mess, TString* slb = 0); Handle processing request. Int_t SendResults(TSocket* sock, TList* outlist = 0, TQueryResult* pq = 0); Sends all objects from the given list to the specified socket. void ProcessNext(TString* slb = 0); process the next query from the queue of submitted jobs.; to be called on the top master only. Int_t RegisterDataSets(TList* in, TList* out); Register TFileCollections in 'out' as datasets according to the rules in 'in'. void HandleQueryList(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. void HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. void HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProofServ.html:25606,queue,queue,25606,root/html528/TProofServ.html,https://root.cern,https://root.cern/root/html528/TProofServ.html,1,['queue'],['queue']
Performance,sAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; RooRealProxy_correctQ; RooRealProxy_delC; RooRealProxy_delS; RooRealProxy_delW; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_dm; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; Double_t_genB0Frac; Double_t_genRhoPlusFrac; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaConvPdf::_model! Original resolution model; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNonCPEigenDecay.html:39536,cache,cache,39536,root/html526/RooNonCPEigenDecay.html,https://root.cern,https://root.cern/root/html526/RooNonCPEigenDecay.html,5,['cache'],['cache']
Performance,"sArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:38190,optimiz,optimizeCacheMode,38190,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,6,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"sArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:47942,optimiz,optimizeCacheMode,47942,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,27,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"sArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; bool isShapeDir",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBMixDecay.html:47991,optimiz,optimizeCacheMode,47991,doc/master/classRooBMixDecay.html,https://root.cern,https://root.cern/doc/master/classRooBMixDecay.html,21,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"sArg as a server to us, ie, declare that we depend on it. ;  ; void addServerList (RooAbsCollection &serverList, bool valueProp=true, bool shapeProp=false);  Register a list of RooAbsArg as servers to us by calling addServer() for each arg in the list. ;  ; void replaceServer (RooAbsArg &oldServer, RooAbsArg &newServer, bool valueProp, bool shapeProp);  Replace 'oldServer' with 'newServer', specifying whether the new server has value or shape server properties. ;  ; void changeServer (RooAbsArg &server, bool valueProp, bool shapeProp);  Change dirty flag propagation mask for specified server. ;  ; void removeServer (RooAbsArg &server, bool force=false);  Unregister another RooAbsArg as a server to us, ie, declare that we no longer depend on its value and shape. ;  ; RooAbsArg * findNewServer (const RooAbsCollection &newSet, bool nameChange) const;  Find the new server in the specified set that matches the old server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual void constOptimizeTestStatistic (ConstOpCode opcode, bool doAlsoTrackingOpt=true);  Interface function signaling a request to perform constant term optimization. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void se",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBreitWigner.html:43305,optimiz,optimizeCacheMode,43305,doc/master/classRooBreitWigner.html,https://root.cern,https://root.cern/doc/master/classRooBreitWigner.html,405,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"sArg derived payload require special care as server redirects cache operation mode changes and constant term optimization calls may need to be forwarded to such cache payload. This cache manager takes care of all these operations by forwarding these calls to the RooAbsCacheElement interface functions, which have a sensible default implementation. ; Definition at line 29 of file RooObjCacheManager.h. Public Member Functions;  RooObjCacheManager (const RooObjCacheManager &other, RooAbsArg *owner=nullptr);  Copy constructor. ;  ;  RooObjCacheManager (RooAbsArg *owner=nullptr, Int_t maxSize=2, bool clearCacheOnServerRedirect=true, bool allowOptimize=false);  Constructor of object cache manager for given owner. ;  ;  ~RooObjCacheManager () override;  Destructor. ;  ; void findConstantNodes (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  If clearOnRedirect is false, forward constant term optimization calls to cache elements. ;  ; void insertObjectHook (RooAbsCacheElement &) override;  Set owner link on all object inserted into cache. ;  ; TClass * IsA () const override;  ; void operModeHook () override;  Intercept changes to cache operation mode and forward to cache elements. ;  ; void optimizeCacheMode (const RooArgSet &, RooArgSet &, RooLinkedList &) override;  Intercept calls to perform automatic optimization of cache mode operation. ;  ; void printCompactTreeHook (std::ostream &, const char *) override;  Add details on cache contents when printing in tree mode. ;  ; bool redirectServersHook (const RooAbsCollection &, bool, bool, bool) override;  Intercept server redirect calls. ;  ; void setClearOnRedirect (bool flag);  ; void sterilize () override;  Clear the cache payload but retain slot mapping w.r.t to normalization and integration sets. ;  ; void Streamer (TBuffer &) override;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from RooCacheManager< RooAbsCacheElement >;  RooCacheManager (const RooCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooObjCacheManager.html:1551,cache,cache,1551,doc/master/classRooObjCacheManager.html,https://root.cern,https://root.cern/doc/master/classRooObjCacheManager.html,1,['cache'],['cache']
Performance,"sArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tselfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidsetInterpolationOrder(Int_t order); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp); RooMoment*R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooAbsCachedReal.html:22896,cache,cache,22896,root/html528/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html528/RooAbsCachedReal.html,1,['cache'],['cache']
Performance,"sArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooSuperCategory.html:16252,cache,cache,16252,root/html534/RooSuperCategory.html,https://root.cern,https://root.cern/root/html534/RooSuperCategory.html,2,['cache'],['cache']
Performance,"sArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidRooAbsCategoryLValue::setBin(Int_t ibin, const char* rangeName = 0); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); voidRooAbsCategoryLValue::setConstant(Bool_t value = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); virtual Bool_tsetIndex(Int_t index, Bool_t printError = kTRUE); virtual Bool_tsetLabel(const char* label, Bool_t printError = kTRUE); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidsetRange(const char* rangeName, const char* stateNameList); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCategory.html:15926,cache,cache,15926,root/html534/RooCategory.html,https://root.cern,https://root.cern/root/html534/RooCategory.html,2,['cache'],['cache']
Performance,"sArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidsetEps(Double_t e); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDerivative.html:22430,cache,cache,22430,root/html526/RooDerivative.html,https://root.cern,https://root.cern/root/html526/RooDerivative.html,1,['cache'],['cache']
Performance,"sArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2Binding<double,double,double>&operator=(const RooCFunction2Binding<double,double,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_double_double_.html:19880,optimiz,optimizeCacheMode,19880,root/html602/RooCFunction2Binding_double_double_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_double_double_.html,4,['optimiz'],['optimizeCacheMode']
Performance,"sArg* owner = 0, Int_t maxSize = 2, Bool_t clearCacheOnServerRedirect = kTRUE, Bool_t allowOptimize = kFALSE); Constructor of object cache manager for given owner. If clearCacheOnServerRedirect is true; all cache elements will be cleared when a server redirect is intercepted by the cache manager.; This is the default strategy and should only be overridden when you really understand; what you're doing as properly implementing server redirect in cache elements can get very; complicated, especially if there are (cyclical) reference back to the owning object. RooObjCacheManager(const RooObjCacheManager& other, RooAbsArg* owner = 0); Copy constructor. ~RooObjCacheManager(); Destructor. Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Intercept server redirect calls. If clearOnRedirect was set, sterilize; the cache (i.e. keep the structure but delete all contents). If not; forward serverRedirect to cache elements. void operModeHook(); Intercept changes to cache operation mode and forward to cache elements. void optimizeCacheMode(const RooArgSet& , RooArgSet& , RooLinkedList& ); Intercept calls to perform automatic optimization of cache mode operation.; Forward calls to existing cache elements and save configuration of; cache mode optimization so that it can be applied on new cache elements; upon insertion. void sterilize(). void insertObjectHook(RooAbsCacheElement& ); Set owner link on all object inserted into cache.; Also if cache mode optimization was requested, apply; it now to cache element being inserted. void printCompactTreeHook(ostream& , const char* ); Add details on cache contents when printing in tree mode. void findConstantNodes(const RooArgSet& , RooArgSet& , RooLinkedList& ); If clearOnRedirect is false, forward constant term optimization calls to; cache elements. void doClearObsList(Bool_t flag); { _clearObsList = flag ; }. Bool_t clearObsList(); { return _clearObsList ; }. void setClearOnRedirect(Bool_t flag); { _clearOnRedi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooObjCacheManager.html:5057,cache,cache,5057,root/html534/RooObjCacheManager.html,https://root.cern,https://root.cern/root/html534/RooObjCacheManager.html,12,['cache'],['cache']
Performance,"sArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; sta",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooEffProd.html:38563,cache,cache,38563,root/html532/RooEffProd.html,https://root.cern,https://root.cern/root/html532/RooEffProd.html,2,['cache'],['cache']
Performance,"sArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooRealProxy_effEfficiency function; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; RooArgSet*_fixedNset! Fixed normalization set overriding default normalization set (if provided); static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to act",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooEffProd.html:36531,cache,cache,36531,root/html526/RooEffProd.html,https://root.cern,https://root.cern/root/html526/RooEffProd.html,3,['cache'],['cache']
Performance,"sArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_lowestOrder; static Int_tRooPri",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooPolynomial.html:40070,cache,cache,40070,root/html534/RooPolynomial.html,https://root.cern,https://root.cern/root/html534/RooPolynomial.html,2,['cache'],['cache']
Performance,"sArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; TIterator*_coefIter! do not persist; RooListProxy_coefList; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; TArrayD_limits; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; Int_t_nBins; static I",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooParametricStepFunction.html:40971,cache,cache,40971,root/html534/RooParametricStepFunction.html,https://root.cern,https://root.cern/root/html534/RooParametricStepFunction.html,2,['cache'],['cache']
Performance,sArg::_cacheListlist of caches; Bool_t_cdfBoundariesUse boundary conditions for CDFs.; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAICRegistry_codeReg! Auxiliary class keeping tracking of analytical integration code; RooDataHist*_dataHistUnowned pointer to underlying histogram; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooSetProxy_depListList of observables mapped onto histogram observables; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; TIterator*_histObsIter!; RooArgSet_histObsListList of observables defining dimensions of histogram; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intOrderInterpolation order; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeR,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooHistFunc.html:35324,cache,cache,35324,root/html602/RooHistFunc.html,https://root.cern,https://root.cern/root/html602/RooHistFunc.html,14,"['Cache', 'cache']","['Cached', 'cache']"
Performance,sArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_nset! Normalization set to be passed along to contents; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; ma,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFormulaVar.html:31707,cache,cache,31707,root/html526/RooFormulaVar.html,https://root.cern,https://root.cern/root/html526/RooFormulaVar.html,2,['cache'],['cache']
Performance,sArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_nset! Normalization set to be passed along to contents; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*Roo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooFormulaVar.html:32374,cache,cache,32374,root/html530/RooFormulaVar.html,https://root.cern,https://root.cern/root/html530/RooFormulaVar.html,1,['cache'],['cache']
Performance,sArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooArgSet*_nset! Normalization set to be passed along to contents; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFormulaVar.html:32817,cache,cache,32817,root/html532/RooFormulaVar.html,https://root.cern,https://root.cern/root/html532/RooFormulaVar.html,2,['cache'],['cache']
Performance,sArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistryRooAbsAnaConvPdf::_codeReg! Registry of analytical integration codes; RooObjCacheManagerRooAbsAnaConvPdf::_coefNormMgrCoefficient normalization manager; RooArgSet*RooAbsAnaConvPdf::_convNormSet! Subset of last normalization that applies to convolutions; RooListProxyRooAbsAnaConvPdf::_convSetSet of (resModel (x) basisFunc) convolution objects; TIterator*RooAbsAnaConvPdf::_convSetIter! Iterator over _convNormSet; RooRealVar*RooAbsAnaConvPdf::_convVar! Convolution variable; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsAnaConvPdf::_isCopy; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; RooResolutionModel*RooAbsAnaCo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDecay.html:37921,cache,cache,37921,root/html526/RooDecay.html,https://root.cern,https://root.cern/root/html526/RooDecay.html,5,['cache'],['cache']
Performance,sArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_t,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenericPdf.html:37811,cache,cache,37811,root/html526/RooGenericPdf.html,https://root.cern,https://root.cern/root/html526/RooGenericPdf.html,1,['cache'],['cache']
Performance,sArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; TString_formExprFormula expression string; RooFormula*_formula! Formula engine ; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Pr,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooGenericPdf.html:38193,cache,cache,38193,root/html528/RooGenericPdf.html,https://root.cern,https://root.cern/root/html528/RooGenericPdf.html,4,['cache'],['cache']
Performance,"sArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCFunction3Ref<VO,VI1,VI2,VI3> Streamer(TBuffer& ); C",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCFunction3Binding_double_unsigned_int_double_double_.html:35402,cache,cache,35402,root/html534/RooCFunction3Binding_double_unsigned_int_double_double_.html,https://root.cern,https://root.cern/root/html534/RooCFunction3Binding_double_unsigned_int_double_double_.html,4,['cache'],['cache']
Performance,"sArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,double,double,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction3PdfBinding_double_double_double_double_.html:40440,cache,cache,40440,root/html532/RooCFunction3PdfBinding_double_double_double_double_.html,https://root.cern,https://root.cern/root/html532/RooCFunction3PdfBinding_double_double_double_double_.html,2,['cache'],['cache']
Performance,"sArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_t_boolValue! Transient cache for bool values from tree branches ; UChar_t_byteValue! Transient cache for byte values from tree branches ; static Bool_t_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_t_floatValue! Transient cache for floating point values from tree branches ; Bool_t_forceNumIntForce numerical integration if flag set; static Bool_t_globalSelectCompGlobal activation switch for component selection; static Bool_t_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_t_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TString_labelPlot label for objects value; RooArgSet*_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooAbsArg::Op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsReal.html:30951,cache,cache,30951,root/html534/RooAbsReal.html,https://root.cern,https://root.cern/root/html534/RooAbsReal.html,13,"['Cache', 'cache']","['Cached', 'cache', 'caches']"
Performance,"sArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsMoment&operator=(const RooAbsMoment&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsMoment.html:19421,optimiz,optimizeCacheMode,19421,root/html602/RooAbsMoment.html,https://root.cern,https://root.cern/root/html602/RooAbsMoment.html,4,['optimiz'],['optimizeCacheMode']
Performance,"sArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooCFunction2Binding<double,unsigned int,double>&operator=(const RooCFunction2Binding<double,unsigned int,double>&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceO",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooCFunction2Binding_double_unsigned_int_double_.html:19844,optimiz,optimizeCacheMode,19844,root/html602/RooCFunction2Binding_double_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html602/RooCFunction2Binding_double_unsigned_int_double_.html,4,['optimiz'],['optimizeCacheMode']
Performance,"sArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooLinearVar&operator=(const RooLinearVar&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooLinearVar.html:23482,optimiz,optimizeCacheMode,23482,root/html602/RooLinearVar.html,https://root.cern,https://root.cern/root/html602/RooLinearVar.html,4,['optimiz'],['optimizeCacheMode']
Performance,"sArg::observableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooProfileLL&operator=(const RooProfileLL&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProfileLL.html:19821,optimiz,optimizeCacheMode,19821,root/html602/RooProfileLL.html,https://root.cern,https://root.cern/root/html602/RooProfileLL.html,4,['optimiz'],['optimizeCacheMode']
Performance,"sArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateIndexList(). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGenCategory.html:19900,Cache,CacheMode,19900,root/html534/RooGenCategory.html,https://root.cern,https://root.cern/root/html534/RooGenCategory.html,1,['Cache'],['CacheMode']
Performance,"sArg::registerProxy(RooListProxy& proxy); voidRooAbsArg::setProxyNormSet(const RooArgSet* nset); voidRooAbsArg::setShapeDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::setTreeBranchStatus(TTree& t, Bool_t active); voidRooAbsArg::setValueDirty(const RooAbsArg* source) const; virtual voidRooAbsCategory::syncCache(const RooArgSet* set = 0); RooCatTypeRooAbsCategory::traceEval() const; virtual Bool_tRooAbsCategory::traceEvalHook(RooCatType) const; voidRooAbsArg::unRegisterProxy(RooArgProxy& proxy); voidRooAbsArg::unRegisterProxy(RooSetProxy& proxy); voidRooAbsArg::unRegisterProxy(RooListProxy& proxy); voidupdateIndexList(). Data Members; public:. enum RooAbsArg::ConstOpCode { Activate; DeActivate; ConfigChange; ValueChange; };; enum RooAbsArg::CacheMode { Always; NotAdvised; Never; };; enum RooAbsArg::OperMode { Auto; AClean; ADirty; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. public:. static map<RooAbsArg*,TRefArray*>RooAbsArg::_ioEvoListtemporary holding list for proxies needed in schema evolution ; static stack<RooAbsArg*>RooAbsArg::_ioReadStackreading stack ; static const UInt_tRooAbsArg::fnv1a32start; static const ULong64_tRooAbsArg::fnv1a64start. protected:. set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsCategory::_byteValue! Transient cache for byte values from tree branches; deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooSetProxy_catSetSet of input category; RooRefCountListRooAbsArg::_clien",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooMultiCategory.html:19706,Cache,CacheMode,19706,root/html534/RooMultiCategory.html,https://root.cern,https://root.cern/root/html534/RooMultiCategory.html,1,['Cache'],['CacheMode']
Performance,"sArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsHiddenReal.html:22254,cache,cache,22254,root/html526/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html526/RooAbsHiddenReal.html,41,['cache'],['cache']
Performance,"sArg::removeServer(RooAbsArg& server, Bool_t force = kFALSE); voidRooAbsArg::replaceServer(RooAbsArg& oldServer, RooAbsArg& newServer, Bool_t valueProp, Bool_t shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; voidsetVerbose(Bool_t clientFlag = kTRUE, Bool_t serverFlag = kTRUE); TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMembe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealMPFE.html:22839,cache,cache,22839,root/html526/RooRealMPFE.html,https://root.cern,https://root.cern/root/html526/RooRealMPFE.html,1,['cache'],['cache']
Performance,"sArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidsetBin(Int_t ibin, const char* rangeName = 0); virtual voidsetBin(Int_t ibin, const RooAbsBinning& binning); virtual voidsetBinFast(Int_t ibin, const RooAbsBinning& binning); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); voidsetConstant(Bool_t value = kTRUE); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); virtual voidsetVal(Double_t value); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidSho",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsRealLValue.html:26585,cache,cache,26585,root/html532/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html532/RooAbsRealLValue.html,1,['cache'],['cache']
Performance,"sArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void operModeHook ();  ; virtual void optimizeDirtyHook (const RooArgSet *);  ; void printAttribList (std::ostream &os) const;  Transient boolean attributes (not copied in ctor) ;  ; void registerProxy (RooArgProxy &proxy);  Register an RooArgProxy in the proxy list. ;  ; void registerProxy (RooListProxy &proxy);  Register an RooListProxy in the proxy list. ;  ; void registerProxy (RooSetProxy &proxy);  Register an RooSetProxy in the proxy list. ;  ; void setProxyNormSet (const RooArgSet *nset);  Forward a change in the cached normalization argset to all the registered proxies. ;  ; void setShapeDirty (const RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoErr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:55283,optimiz,optimizeDirtyHook,55283,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,2,['optimiz'],['optimizeDirtyHook']
Performance,"sBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*TEntryList::fBlocksblocks with indices of passing events (TEntryListBlocks); TEntryList*TEntryList::fCurrent! currently filled entry list; TDirectory*TEntryList::fDirectory! Pointer to directory holding this tree; Long64_tTEntryList::fEntriesToProcessused on proof to set the number of entries to process in a packet; Long64_tfEntrythe entry number, when the list is used for subentries; TStringTEntryList::fFileNamename of the file, where the tree is; Long64_tTEntryList::fLastIndexQueried! used to optimize GetEntry() function from a loop ; Long64_tTEntryList::fLastIndexReturned! used to optimize GetEntry() function from a loop; TEntryListArray*fLastSubListQueried! last sublist checked by GetSubListForEntry; TList*TEntryList::fListsa list of underlying entry lists for each tree of a chain; Long64_tTEntryList::fNnumber of entries in the list; Int_tTEntryList::fNBlocksnumber of TEntryListBlocks; TStringTNamed::fNameobject identifier; Bool_tTEntryList::fReapplyIf true, TTree::Draw will 'reapply' the original cut; Bool_tTEntryList::fShift! true when some sub-lists don't correspond to trees; ULong_tTEntryList::fStringHash! Hash value of a string of treename and filename; TIter*fSubListIter! to iterate over fSubLists and keep last one checked; TList*fSubListsa list of underlying entry lists for each event of a TEntryList; TStringTNamed::fTitleobject title; TStringTEntryList::fTreeNamename of the tree; Int_tTEntryList::fTreeNumber! the index of the tree in the chain (used when the entry. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void Init(); Initialize data members, called by Reset. TEntryListArray(); default c-tor. TEntryListArray(const char* name, const char* title); c-tor wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TEntryListArray.html:10812,optimiz,optimize,10812,root/html532/TEntryListArray.html,https://root.cern,https://root.cern/root/html532/TEntryListArray.html,8,['optimiz'],['optimize']
Performance,"sCategoryLValue.cxx. ◆ RooAbsCategoryLValue() [3/3]. RooAbsCategoryLValue::RooAbsCategoryLValue ; (; const RooAbsCategoryLValue & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 56 of file RooAbsCategoryLValue.cxx. Member Function Documentation. ◆ Class(). static TClass * RooAbsCategoryLValue::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsCategoryLValue::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsCategoryLValue::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 123 of file RooAbsCategoryLValue.h. ◆ copyCache(). void RooAbsCategoryLValue::copyCache ; (; const RooAbsArg * ; source, . bool ; valueOnly = false, . bool ; setValDirty = true . ). overrideprotectedvirtual . Copy the cached value from given source and raise dirty flag. ; It is the callers responsibility to ensure that the sources cache is clean(valid) before this function is called, e.g. by calling syncCache() on the source. ; Reimplemented from RooAbsCategory.; Definition at line 123 of file RooAbsCategoryLValue.cxx. ◆ DeclFileName(). static const char * RooAbsCategoryLValue::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 123 of file RooAbsCategoryLValue.h. ◆ getBin() [1/2]. Int_t RooAbsCategoryLValue::getBin ; (; const char * ; = nullptr); const. inlineoverridevirtual . Get the index of the plot bin for the current value of this category. ; Implements RooAbsLValue.; Definition at line 81 of file RooAbsCategoryLValue.h. ◆ getBin() [2/2]. Int_t RooAbsCategoryLValue::getBin ; (; const RooAbsBinning * ; ); const. inlineoverridevirtual . Implements RooAbsLValue.; Definition at line 97 of file RooAbsCategoryLValue.h. ◆ getBinningNames(). std::list< std::string > RooAbsCategoryLValue::getBinningNames ; (; ); const. inlineoverridevirtual . Implemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategoryLValue.html:48222,cache,cache,48222,doc/master/classRooAbsCategoryLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategoryLValue.html,1,['cache'],['cache']
Performance,"sCut(), you must use the pointer to the current TTree to call the method GetEntry(entry). The parameter entry is always the local entry number in the current tree. Assuming that fChain is the pointer to the TChain being processed, use. fChain->GetTree()->GetEntry(entry);; To create a selector call:; root[] T->MakeSelector(""MySelector"");; Where T is the TTree and MySelector is the name of created class and the name of the .h and .C files. The resulting TSelector is the argument to TTree::Process. The argument can be the file name or a pointer to the selector object.; root[] T->Process(""MySelector.C"","""",1000,100);; This call will interpret the class defined in MySelector.C and process 1000 entries beginning with entry 100. The file name can be appended with a “+” or a “++” to use ACLiC.; root[] T->Process(""MySelector.C++"","""",1000,100);; When appending a “++”, the class will be compiled and dynamically loaded.; root[] T->Process(""MySelector.C+"","""",1000,100);; When appending a “+”, the class will also be compiled and dynamically loaded. When it is called again, it recompiles only if the macro (MySelector.C) has changed since it was compiled last. If not, it loads the existing library. The next example shows how to create a selector with a pointer:; MySelector *selector = (MySelector *)TSelector::GetSelector(""MySelector.C+"");; T->Process(selector);; Using this form, you can do things like:; selector->public_attribute1 = init_value;; for (int i=0; i<limit; i++) {; T->Process(selector);; selector->public_attribute1 =; function(selector->public_attribute2);; }; TTree::Process() is aware of PROOF, ROOT parallel processing facility. If PROOF is setup, it divides the processing amongst the slave CPUs.; 12.22.1 Performance Benchmarks. The program $ROOTSYS/test/bench.cxx compares the I/O performance of STL vectors to the ROOT native TClonesArrays collection class. It creates trees with and without compression for the following cases: vector<THit>, vector<THit*>, TClonesArray(TOb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:646318,load,loaded,646318,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loaded']
Performance,"sData > RooAbsData::reduce ; (; const RooFormulaVar & ; cutVar); const. Create a subset of the data set by applying the given cut on the data points. ; The 'cutVar' formula variable is used to select the subset of data points to be retained in the reduced data collection. ; Definition at line 485 of file RooAbsData.cxx. ◆ reduceEng(). virtual std::unique_ptr< RooAbsData > RooAbsData::reduceEng ; (; const RooArgSet & ; varSubset, . const RooFormulaVar * ; cutVar, . const char * ; cutRange = nullptr, . std::size_t ; nStart = 0, . std::size_t ; = std::numeric_limits< std::size_t >::max() . ); const. protectedpure virtual . Implemented in RooDataHist, and RooDataSet. ◆ reset(). void RooAbsData::reset ; (; ). virtual . Reimplemented in RooDataHist.; Definition at line 330 of file RooAbsData.cxx. ◆ resetBuffers(). void RooAbsData::resetBuffers ; (; ). Definition at line 2344 of file RooAbsData.cxx. ◆ resetCache(). void RooAbsData::resetCache ; (; ). protectedvirtual . Internal method – Remove cached function values. ; Definition at line 354 of file RooAbsData.cxx. ◆ rmsVar(). RooRealVar * RooAbsData::rmsVar ; (; const RooRealVar & ; var, . const char * ; cutSpec = nullptr, . const char * ; cutRange = nullptr . ); const. Create a RooRealVar containing the RMS of observable 'var' in this dataset. ; If cutSpec and/or cutRange are specified the moment is calculated on the subset of the data which pass the C++ cut specification expression 'cutSpec' and/or are inside the range named 'cutRange' ; Definition at line 1094 of file RooAbsData.cxx. ◆ setArgStatus(). void RooAbsData::setArgStatus ; (; const RooArgSet & ; set, . bool ; active . ). protectedvirtual . Definition at line 370 of file RooAbsData.cxx. ◆ setDefaultStorageType(). void RooAbsData::setDefaultStorageType ; (; RooAbsData::StorageType ; s). static . Definition at line 130 of file RooAbsData.cxx. ◆ setDirtyProp(). void RooAbsData::setDirtyProp ; (; bool ; flag). Control propagation of dirty flags from observables in ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsData.html:65639,cache,cached,65639,doc/master/classRooAbsData.html,https://root.cern,https://root.cern/doc/master/classRooAbsData.html,1,['cache'],['cached']
Performance,"sDataStore::addColumns ; (; const RooArgList & ; varList). Definition at line 60 of file RooAbsDataStore.cxx. ◆ append(). virtual void RooAbsDataStore::append ; (; RooAbsDataStore & ; other). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ attachBuffers(). virtual void RooAbsDataStore::attachBuffers ; (; const RooArgSet & ; extObs). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ attachCache(). virtual void RooAbsDataStore::attachCache ; (; const RooAbsArg * ; newOwner, . const RooArgSet & ; cachedVars . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ cacheArgs(). virtual void RooAbsDataStore::cacheArgs ; (; const RooAbsArg * ; cacheOwner, . RooArgSet & ; varSet, . const RooArgSet * ; nset = nullptr, . bool ; skipZeroWeights = false . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ cachedVars(). const RooArgSet & RooAbsDataStore::cachedVars ; (; ); const. inline . Definition at line 130 of file RooAbsDataStore.h. ◆ cacheOwner(). virtual const RooAbsArg * RooAbsDataStore::cacheOwner ; (; ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ changeObservableName(). virtual bool RooAbsDataStore::changeObservableName ; (; const char * ; from, . const char * ; to . ). pure virtual . Implemented in RooCompositeDataStore, RooTreeDataStore, and RooVectorDataStore. ◆ checkInit(). virtual void RooAbsDataStore::checkInit ; (; ); const. inlinevirtual . Reimplemented in RooTreeDataStore.; Definition at line 137 of file RooAbsDataStore.h. ◆ Class(). static TClass * RooAbsDataStore::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * RooAbsDataStore::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t RooAbsDataStore::Class_Version ; (; ). inli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsDataStore.html:19217,cache,cachedVars,19217,doc/master/classRooAbsDataStore.html,https://root.cern,https://root.cern/doc/master/classRooAbsDataStore.html,1,['cache'],['cachedVars']
Performance,"sEdit::ResolveTypedef (GetName(), kTRUE);; 1667 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1668 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1669 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1670 fgClassTypedefHash->Remove (htmp);; 1671 delete htmp;; 1672 break;; 1673 }; 1674 }; 1675 }; 1676 ; 1677 // Not owning lists, don't call Delete(); 1678 // But this still need to be done first because the TList destructor; 1679 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1680 delete fStreamer; fStreamer =nullptr;; 1681 delete fAllPubData; fAllPubData =nullptr;; 1682 delete fAllPubMethod; fAllPubMethod=nullptr;; 1683 ; 1684 delete fPersistentRef.load();; 1685 ; 1686 if (fBase.load()); 1687 (*fBase).Delete();; 1688 delete fBase.load(); fBase = nullptr;; 1689 ; 1690 if (fData.load()); 1691 (*fData).Delete();; 1692 delete fData.load(); fData = nullptr;; 1693 ; 1694 if (fUsingData.load()); 1695 (*fUsingData).Delete();; 1696 delete fUsingData.load(); fUsingData = nullptr;; 1697 ; 1698 if (fEnums.load()); 1699 (*fEnums).Delete();; 1700 delete fEnums.load(); fEnums = nullptr;; 1701 ; 1702 if (fFuncTemplate); 1703 fFuncTemplate->Delete();; 1704 delete fFuncTemplate; fFuncTemplate = nullptr;; 1705 ; 1706 if (fMethod.load()); 1707 (*fMethod).Delete();; 1708 delete fMethod.load(); fMethod=nullptr;; 1709 ; 1710 if (fRealData); 1711 fRealData->Delete();; 1712 delete fRealData; fRealData=nullptr;; 1713 ; 1714 if (fStreamerInfo); 1715 fStreamerInfo->Delete();; 1716 delete fStreamerInfo; fStreamerInfo = nullptr;; 1717 ; 1718 if (fDeclFileLine >= -1); 1719 TClass::RemoveClass(this);; 1720 ; 1721 gCling->ClassInfo_Delete(fClassInfo);; 1722 fClassInfo=nullptr;; 1723 ; 1724 if (fClassMenuList); 1725 fClassMenuList->Delete();; 1726 delete fClassMenuList; fClassMenuList=nullptr;; 1727 ; 1728 fIsOffsetStreamerSet=kFALSE;; 1729 ; 1730 if ( fIsA ) delete fIsA;; 1731 ; 1732 if ( fRefProxy ) fRefPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:65202,load,load,65202,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['load']
Performance,"sEdit::ResolveTypedef (GetName(), kTRUE);; 1734 TIter next (fgClassTypedefHash->GetListForObject (resolvedThis));; 1735 while ( TNameMapNode* htmp = static_cast<TNameMapNode*> (next()) ) {; 1736 if (resolvedThis == htmp->String() && htmp->fOrigName == GetName()) {; 1737 fgClassTypedefHash->Remove (htmp);; 1738 delete htmp;; 1739 break;; 1740 }; 1741 }; 1742 }; 1743 ; 1744 // Not owning lists, don't call Delete(); 1745 // But this still need to be done first because the TList destructor; 1746 // does access the object contained (via GetObject()->TestBit(kCanDelete)); 1747 delete fStreamer; fStreamer =nullptr;; 1748 delete fAllPubData; fAllPubData =nullptr;; 1749 delete fAllPubMethod; fAllPubMethod=nullptr;; 1750 ; 1751 delete fPersistentRef.load();; 1752 ; 1753 if (fBase.load()); 1754 (*fBase).Delete();; 1755 delete fBase.load(); fBase = nullptr;; 1756 ; 1757 if (fData.load()); 1758 (*fData).Delete();; 1759 delete fData.load(); fData = nullptr;; 1760 ; 1761 if (fUsingData.load()); 1762 (*fUsingData).Delete();; 1763 delete fUsingData.load(); fUsingData = nullptr;; 1764 ; 1765 if (fEnums.load()); 1766 (*fEnums).Delete();; 1767 delete fEnums.load(); fEnums = nullptr;; 1768 ; 1769 if (fFuncTemplate); 1770 fFuncTemplate->Delete();; 1771 delete fFuncTemplate; fFuncTemplate = nullptr;; 1772 ; 1773 if (fMethod.load()); 1774 (*fMethod).Delete();; 1775 delete fMethod.load(); fMethod=nullptr;; 1776 ; 1777 if (fRealData); 1778 fRealData->Delete();; 1779 delete fRealData; fRealData=nullptr;; 1780 ; 1781 if (fStreamerInfo); 1782 fStreamerInfo->Delete();; 1783 delete fStreamerInfo; fStreamerInfo = nullptr;; 1784 ; 1785 if (fDeclFileLine >= -1); 1786 TClass::RemoveClass(this);; 1787 ; 1788 gCling->ClassInfo_Delete(fClassInfo);; 1789 fClassInfo=nullptr;; 1790 ; 1791 if (fClassMenuList); 1792 fClassMenuList->Delete();; 1793 delete fClassMenuList; fClassMenuList=nullptr;; 1794 ; 1795 fIsOffsetStreamerSet=kFALSE;; 1796 ; 1797 if ( fIsA ) delete fIsA;; 1798 ; 1799 if ( fRefProxy ) fRefPr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:67953,load,load,67953,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['load']
Performance,"sEffective parameters of this p.d.f.; RooRealProxy_pdf1First input p.d.f; RooRealProxy_pdf2Second input p.d.f; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; Double_t_shift1; Double_t_shift2; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; RooRealProxy_xConvolution observable; RooRealProxy_xprimeInput function representing value of convolution observable; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooFFTConvPdf(co",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFFTConvPdf.html:48817,cache,cache,48817,root/html534/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html534/RooFFTConvPdf.html,4,['cache'],['cache']
Performance,"sFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTree()->GetEntries()) {; 3586 if (tree->LoadTree(i) < 0) {; 3587 break;; 3588 }; 3589 if ( withIndex ) {; 3590 withIndex = R__HandleIndex( onIndexError, this, tree );; 3591 }; 3592 if (this->GetDirectory()) {; 3593 TFile* file2 = this->GetDirectory()->GetFile();; 3594 if (file2 && (file2->GetEND() > TTree::GetMaxTreeSize())) {; 3595 if (this->GetDirectory() == (TDirectory*) file2) {; 3596 this->ChangeFile(file2);; 3597 }; 3598 }; 3599 }; 3600 TTreeCloner cloner(tree->GetTree(), this, option, TTreeCloner::kNoWarnings);; 3601 if (cloner.IsValid()) {; 3602 this->SetEntries(this->GetEntries() + tree->GetTree()->GetEntries());; 3603 if (cacheSize != -1) cloner.SetCacheSize(cacheSize);; 3604 cloner.Exec();; 3605 } else {; 3606 if (i == 0) {; 3607 Warning(""CopyEntries"",""%s"",cloner.GetWarning());; 3608 // If the first cloning does not work, something is really wrong; 3609 // (since apriori the source and target are exactly the same structure!); 3610 return -1;; 3611 } else {; 3612 if (cloner.NeedConversion()) {; 3613 TTree *localtree = tree->GetTree();; 3614 Long64_t tentries = localtree->GetEntries();; 3615 if (needCopyAddresses) {; 3616 // Copy MakeClass status.; 3617 tree->SetMakeClass(fMakeClass);; 3618 // Copy branch addresses.; 3619 CopyAddresses(tree);; 3620 }; 3621 for (Long64_t ii = 0; ii < tentries; ii++) {; 3622 if (localtree->GetEntry(ii) <= 0) {; 3623 break;; 3624 }; 3625 this->Fill();; 3626 }; 3627 if (needCopyAddresses); 3628 tree->ResetBranchAddresses();; 3629 if (this->GetTreeIndex()) {; 3630 this->GetTreeIndex()->Append(tree->GetTree()->GetTreeIndex(), true);; 3631 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:142779,cache,cacheSize,142779,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cacheSize']
Performance,"sMembertrue if we proxy an unsplit data member; Bool_tfIsaPointertrue if we proxy a data member of pointer type; TTree*fLastTreeTTree containing the last entry read; Int_tfMemberOffset; Int_tfOffsetOffset inside the object; ROOT::TBranchProxy*fParentProxy to a parent object; Long64_tfReadLast entry read; void*fWherememory location of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchProxy(); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name = 0); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name, const char* membername); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, ROOT::TBranchProxy* parent, const char* membername, const char* top = 0, const char* name = 0); Constructor. ~TBranchProxy(); Typical Destructor. void Reset(); Completely reset the object. void Print(); Display the content of the object. Bool_t Setup(); Initialize/cache the necessary information. TBranchProxy(). TBranchProxy* GetProxy(); { return this; }. Bool_t IsInitialized(). Bool_t IsaPointer() const. Bool_t Read(). Bool_t ReadEntries(). TClass * GetClass(). void* GetWhere() const; { return fWhere; }. TVirtualCollectionProxy * GetCollection(); { return fCollection; }. void * GetStart(UInt_t = 0); protected:. void * GetClaStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in TClonesArray. void * GetStlStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in STL Collection. Int_t GetOffset(); { return fOffset; }. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id$ » Last generated: 2015-03-10 17:12; This page has ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__TBranchProxy.html:3070,cache,cache,3070,root/html534/ROOT__TBranchProxy.html,https://root.cern,https://root.cern/root/html534/ROOT__TBranchProxy.html,2,['cache'],['cache']
Performance,"sMembertrue if we proxy an unsplit data member; Bool_tfIsaPointertrue if we proxy a data member of pointer type; TTree*fLastTreeTTree containing the last entry read; Int_tfMemberOffset; Int_tfOffsetOffset inside the object; ROOT::TBranchProxy*fParentProxy to a parent object; Long64_tfReadLast entry read; void*fWherememory location of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchProxy(); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name = 0); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name, const char* membername); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, ROOT::TBranchProxy* parent, const char* membername, const char* top = 0, const char* name = 0); Constructor. ~TBranchProxy(); Typical Destructor. void Reset(); Completely reset the object. void Print(); Display the content of the object. Bool_t Setup(); Initialize/cache the necessary information. TBranchProxy(). TBranchProxy* GetProxy(); { return this; }. Bool_t IsInitialized(). Bool_t IsaPointer() const. Bool_t Read(). Bool_t ReadEntries(). TClass * GetClass(). void* GetWhere() const; { return fWhere; }. TVirtualCollectionProxy * GetCollection(); { return fCollection; }. void * GetStart(UInt_t = 0); protected:. void * GetClaStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in TClonesArray. void * GetStlStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in STL Collection. Int_t GetOffset(); { return fOffset; }. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id: TBranchProxy.h 36449 2010-10-28 20:52:17Z pcanal $",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/ROOT__TBranchProxy.html:3070,cache,cache,3070,root/html528/ROOT__TBranchProxy.html,https://root.cern,https://root.cern/root/html528/ROOT__TBranchProxy.html,2,['cache'],['cache']
Performance,"sMembertrue if we proxy an unsplit data member; Bool_tfIsaPointertrue if we proxy a data member of pointer type; TTree*fLastTreeTTree containing the last entry read; Int_tfMemberOffset; Int_tfOffsetOffset inside the object; ROOT::TBranchProxy*fParentProxy to a parent object; Long64_tfReadLast entry read; void*fWherememory location of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchProxy(); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name = 0); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name, const char* membername); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, ROOT::TBranchProxy* parent, const char* membername, const char* top = 0, const char* name = 0); Constructor. ~TBranchProxy(); Typical Destructor. void Reset(); Completely reset the object. void Print(); Display the content of the object. Bool_t Setup(); Initialize/cache the necessary information. TBranchProxy(). TBranchProxy* GetProxy(); { return this; }. Bool_t IsInitialized(). Bool_t IsaPointer() const. Bool_t Read(). Bool_t ReadEntries(). TClass * GetClass(). void* GetWhere() const; { return fWhere; }. TVirtualCollectionProxy * GetCollection(); { return fCollection; }. void * GetStart(UInt_t = 0); protected:. void * GetClaStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in TClonesArray. void * GetStlStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in STL Collection. Int_t GetOffset(); { return fOffset; }. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id: TBranchProxy.h 41244 2011-10-06 19:42:35Z pcanal $",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/ROOT__TBranchProxy.html:3070,cache,cache,3070,root/html532/ROOT__TBranchProxy.html,https://root.cern,https://root.cern/root/html532/ROOT__TBranchProxy.html,2,['cache'],['cache']
Performance,"sMembertrue if we proxy an unsplit data member; Bool_tfIsaPointertrue if we proxy a data member of pointer type; TTree*fLastTreeTTree containing the last entry read; Int_tfMemberOffset; Int_tfOffsetOffset inside the object; ROOT::TBranchProxy*fParentProxy to a parent object; Long64_tfReadLast entry read; void*fWherememory location of the data. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBranchProxy(); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name = 0); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, const char* top, const char* name, const char* membername); Constructor. TBranchProxy(ROOT::TBranchProxyDirector* boss, ROOT::TBranchProxy* parent, const char* membername, const char* top = 0, const char* name = 0); Constructor. ~TBranchProxy(); Typical Destructor. void Reset(); Completely reset the object. void Print(); Display the content of the object. Bool_t Setup(); Initialize/cache the necessary information. TBranchProxy(). TBranchProxy* GetProxy(); { return this; }. Bool_t IsInitialized(). Bool_t IsaPointer() const. Bool_t Read(). Bool_t ReadEntries(). TClass * GetClass(). void* GetWhere() const; { return fWhere; }. TVirtualCollectionProxy * GetCollection(); { return fCollection; }. void * GetStart(UInt_t = 0); protected:. void * GetClaStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in TClonesArray. void * GetStlStart(UInt_t i = 0); return the address of the start of the object being proxied. Assumes; that Setup() has been called. Assumes the object containing this data; member is held in TClonesArray. » Author: Philippe Canal 01/06/2004 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers and al. *; » Last changed: root/treeplayer:$Id: TBranchProxy.h 27129 2009-01-13 08:22:29Z pcanal $ » Last generated: 2009-12-07 13:44; This ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/ROOT__TBranchProxy.html:3052,cache,cache,3052,root/html526/ROOT__TBranchProxy.html,https://root.cern,https://root.cern/root/html526/ROOT__TBranchProxy.html,1,['cache'],['cache']
Performance,sMirror. TGaxis* TRatioPlot::fLowerGXaxisMirror = nullptr. protected . Lower mirror of the x axis. ; Definition at line 116 of file TRatioPlot.h. ◆ fLowerGYaxis. TGaxis* TRatioPlot::fLowerGYaxis = nullptr. protected . Lower graphical y axis. ; Definition at line 114 of file TRatioPlot.h. ◆ fLowerGYaxisMirror. TGaxis* TRatioPlot::fLowerGYaxisMirror = nullptr. protected . Lower mirror of the y axis. ; Definition at line 118 of file TRatioPlot.h. ◆ fLowerPad. TPad* TRatioPlot::fLowerPad = nullptr. protected . The pad which contains the calculated lower plot part. ; Definition at line 76 of file TRatioPlot.h. ◆ fLowTopMargin. Float_t TRatioPlot::fLowTopMargin = 0.05. protected . Stores the top margin of the lower pad. ; Definition at line 132 of file TRatioPlot.h. ◆ fLowYaxis. TAxis* TRatioPlot::fLowYaxis = nullptr. protected . Clone of the lower y axis. ; Definition at line 121 of file TRatioPlot.h. ◆ fMode. Int_t TRatioPlot::fMode = 0. protected . Stores which calculation is supposed to be performed as specified by user option. ; Definition at line 84 of file TRatioPlot.h. ◆ fOption. TString TRatioPlot::fOption. protected . Stores the option which is given in the constructor as a string. ; Definition at line 86 of file TRatioPlot.h. ◆ fParentPad. TVirtualPad* TRatioPlot::fParentPad = nullptr. protected . Stores the pad the ratio plot was created in. ; Definition at line 74 of file TRatioPlot.h. ◆ fRatioGraph. TGraph* TRatioPlot::fRatioGraph = nullptr. protected . Stores the lower plot's graph. ; Definition at line 94 of file TRatioPlot.h. ◆ fRightMargin. Float_t TRatioPlot::fRightMargin = 0.1. protected . Stores the common right margin of both pads. ; Definition at line 136 of file TRatioPlot.h. ◆ fSharedXAxis. TAxis* TRatioPlot::fSharedXAxis = nullptr. protected . X axis that stores the range for both plots. ; Definition at line 110 of file TRatioPlot.h. ◆ fShowConfidenceIntervals. Bool_t TRatioPlot::fShowConfidenceIntervals = kTRUE. protected . Stores whether to sho,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTRatioPlot.html:49963,perform,performed,49963,doc/master/classTRatioPlot.html,https://root.cern,https://root.cern/doc/master/classTRatioPlot.html,1,['perform'],['performed']
Performance,"sMoment;  CRooAbsNumGenerator;  CRooAbsOptTestStatistic;  ►CRooAbsPdfRooAbsPdf is the abstract interface for all probability density functions The class provides hybrid analytical/numerical normalization for its implementations, error tracing and a MC generator interface ;  CCacheElemNormalization set with for above integral ;  CGenSpec;  CRooAbsProxy;  ►CRooAbsRealRooAbsReal is the common abstract base class for objects that represent a real value and implements functionality common to all real-valued objects such as the ability to plot them, to construct integrals of them, the ability to advertise (partial) analytical integrals etc ;  CEvalError;  CPlotOpt;  CRooAbsRealLValue;  CRooAbsRootFinder;  CRooAbsSelfCachedPdf;  CRooAbsSelfCachedReal;  CRooAbsString;  CRooAbsStudy;  CRooAbsTestStatistic;  CRooAcceptReject;  CRooAdaptiveGaussKronrodIntegrator1D;  CRooAdaptiveIntegratorND;  CRooAddGenContext;  ►CRooAddition;  CCacheElemIterator over set ;  ►CRooAddModel;  CCacheElemTransiet cache with transformed values of coefficients ;  CIntCacheElem;  ►CRooAddPdf;  CCacheElemTransiet cache with transformed values of coefficients ;  CRooAICRegistry;  CRooArgList;  CRooArgProxy;  CRooArgSet;  CRooArgusBGRooArgusBG is a RooAbsPdf implementation describing the ARGUS background shape ;  CRooBCPEffDecayPDF describing decay time distribution of B meson including effects of standard model CP violation ;  CRooBCPGenDecay;  CRooBDecay;  CRooBernstein;  CRooBifurGauss;  CRooBinIntegrator;  CRooBinnedGenContext;  CRooBinning;  CRooBinningCategory;  CRooBlindTools;  CRooBMixDecay;  CRooBreitWigner;  CRooBrentRootFinder;  CRooBukinPdf;  CRooCachedPdf;  CRooCachedReal;  CRooCacheManager;  CRooCategory;  CRooCategoryProxy;  CRooCategorySharedProperties;  CRooCatType;  CRooCBShape;  CRooCFunction1Binding;  CRooCFunction1Map;  CRooCFunction1PdfBinding;  CRooCFunction1Ref;  CRooCFunction2Binding;  CRooCFunction2Map;  CRooCFunction2PdfBinding;  CRooCFunction2Ref;  CRooCFunction3Binding;  CRo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html606/annotated.html:81178,cache,cache,81178,root/html606/annotated.html,https://root.cern,https://root.cern/root/html606/annotated.html,2,['cache'],['cache']
Performance,"sName); 337{; 338 return TClass::GetClass(className);; 339}; 340 ; 341////////////////////////////////////////////////////////////////////////////////; 342/// Return the current Process-ID.; 343 ; 344TProcessID *TBuffer::ReadProcessID(UShort_t pidf); 345{; 346 if (!pidf) return TProcessID::GetPID(); //may happen when cloning an object; 347 return nullptr;; 348}; 349 ; 350////////////////////////////////////////////////////////////////////////////////; 351/// Always return 0 (current processID).; 352 ; 353UShort_t TBuffer::WriteProcessID(TProcessID *); 354{; 355 return 0;; 356}; 357 ; 358////////////////////////////////////////////////////////////////////////////////; 359/// Push a new data cache area onto the list of area to be used for; 360/// temporarily store 'missing' data members.; 361 ; 362void TBuffer::PushDataCache(TVirtualArray *obj); 363{; 364 fCacheStack.push_back(obj);; 365}; 366 ; 367////////////////////////////////////////////////////////////////////////////////; 368/// Return the 'current' data cache area from the list of area to be used for; 369/// temporarily store 'missing' data members.; 370 ; 371TVirtualArray *TBuffer::PeekDataCache() const; 372{; 373 if (fCacheStack.empty()) return nullptr;; 374 return fCacheStack.back();; 375}; 376 ; 377////////////////////////////////////////////////////////////////////////////////; 378/// Pop and Return the 'current' data cache area from the list of area to be used for; 379/// temporarily store 'missing' data members.; 380 ; 381TVirtualArray *TBuffer::PopDataCache(); 382{; 383 TVirtualArray *val = PeekDataCache();; 384 fCacheStack.pop_back();; 385 return val;; 386}; 387 ; 388////////////////////////////////////////////////////////////////////////////////; 389/// Byte-swap N primitive-elements in the buffer.; 390/// Bulk API relies on this function.; 391 ; 392Bool_t TBuffer::ByteSwapBuffer(Long64_t n, EDataType type); 393{; 394 char *input_buf = GetCurrent();; 395 if ((type == EDataType::kShort_t) || (type == ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBuffer_8cxx_source.html:12236,cache,cache,12236,doc/master/TBuffer_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBuffer_8cxx_source.html,1,['cache'],['cache']
Performance,"sPdf Class ReferenceRooFit » RooFit. ; Two-dimensional kernel estimation PDF. ; This function has been superseded by the more general RooNDKeysPdf. ; Definition at line 25 of file Roo2DKeysPdf.h. Public Member Functions;  Roo2DKeysPdf (const char *name, const char *title, RooAbsReal &xx, RooAbsReal &yy, RooDataSet &data, TString options=""a"", double widthScaleFactor=1.0);  Constructor. ;  ;  Roo2DKeysPdf (const Roo2DKeysPdf &other, const char *name=nullptr);  Copy constructor. ;  ;  ~Roo2DKeysPdf () override;  Destructor. ;  ; Int_t calculateBandWidth (Int_t kernel=-999);  Calculates the kernel bandwidth for x & y and the probability look up table _p[i][j]. ;  ; TObject * clone (const char *newname) const override;  ; double evaluate () const override;  Evaluates the kernel estimation for x,y, interpolating between the points if necessary. ;  ; Int_t getBandWidthType () const;  ; double getMean (const char *axis) const;  ; void getOptions (void) const;  ; double getSigma (const char *axis) const;  ; TClass * IsA () const override;  ; Int_t loadDataSet (RooDataSet &data, TString options);  Loads a new data set into the class instance. ;  ; void PrintInfo (std::ostream &) const;  Prints out _p[_nPoints][_nPoints] indicating the domain limits. ;  ; void setOptions (TString options);  ; void setWidthScaleFactor (double widthScaleFactor);  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void writeHistToFile (char *outputFile, const char *histName) const;  Plots the PDF as a histogram and saves it to a file, so that it can be loaded in as a Roo2DHist PDF in the future to save on calculation time. ;  ; void writeNTupleToFile (char *outputFile, const char *name) const;  Saves the data and calculated bandwidths to a file, as a record of what produced the PDF and to give a reduced data set in order to facilitate re-calculation in the future. ;  ; void writeToFile (char *outputFile, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRoo2DKeysPdf.html:1359,load,loadDataSet,1359,doc/master/classRoo2DKeysPdf.html,https://root.cern,https://root.cern/doc/master/classRoo2DKeysPdf.html,1,['load'],['loadDataSet']
Performance,"sPdf::CacheElem Class Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Public Attributes |; List of all members ; RooAbsPdf::CacheElem Class Reference. ; Normalization set with for above integral. ; Definition at line 322 of file RooAbsPdf.h. Public Member Functions;  CacheElem (RooAbsReal &norm);  ;  ~CacheElem () override;  Destructor of normalization cache element. ;  ; RooArgList containedArgs (Action) override;  ;  Public Member Functions inherited from RooAbsCacheElement;  RooAbsCacheElement ();  ; virtual ~RooAbsCacheElement ();  ; virtual void findConstantNodes (const RooArgSet &obs, RooArgSet &cacheList, RooLinkedList &processedNodes);  Interface for constant term optimization calls. ;  ; virtual TClass * IsA () const;  ; virtual void operModeHook (RooAbsArg::OperMode);  Interface for changes of operation mode. ;  ; virtual void optimizeCacheMode (const RooArgSet &obs, RooArgSet &optNodes, RooLinkedList &processedNodes);  Interface for cache optimization calls. ;  ; virtual void printCompactTreeHook (std::ostream &, const char *, Int_t curElem, Int_t totElem);  Hook function to print cache guts in tree printing mode of RooAbsArgs. ;  ; virtual bool redirectServersHook (const RooAbsCollection &, bool, bool, bool);  Interface for server redirect calls. ;  ; void setOwner (RooAbsArg *owner);  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  . Public Attributes; std::unique_ptr< RooAbsReal > _norm;  . Additional Inherited Members;  Public Types inherited from RooAbsCacheElement; enum  Action { OperModeChange; , OptimizeCaching; , FindConstantNodes; };  ;  Static Public Member Functions inherited from RooAbsCacheElement; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ;  Protected Attributes inherited from RooAbsCac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf_1_1CacheElem.html:956,optimiz,optimizeCacheMode,956,doc/master/classRooAbsPdf_1_1CacheElem.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf_1_1CacheElem.html,3,"['cache', 'optimiz']","['cache', 'optimization', 'optimizeCacheMode']"
Performance,"sPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; RooRealProxy_t; RooRealProxy_tau; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; RooDecay::DecayType_type; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDecay.html:40535,cache,cache,40535,root/html526/RooDecay.html,https://root.cern,https://root.cern/root/html526/RooDecay.html,2,['cache'],['cache']
Performance,"sPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManager_normIntMgrThe integration cache manager; RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealSumPdf.html:39575,cache,cache,39575,root/html526/RooRealSumPdf.html,https://root.cern,https://root.cern/root/html526/RooRealSumPdf.html,2,['cache'],['cache']
Performance,"sPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooRealProxy_origModelOriginal resolution model; RooRealProxy_origPdfOriginal input PDF; RooRealProxy_origVarOriginal convolution variable; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooNumConvPdf.html:41558,cache,cache,41558,root/html526/RooNumConvPdf.html,https://root.cern,https://root.cern/root/html526/RooNumConvPdf.html,2,['cache'],['cache']
Performance,"sPdf::_normMgrThe cache manager; TStringRooAbsPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyk; RooRealProxym0; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooLognormal.html:39377,cache,cache,39377,root/html528/RooLognormal.html,https://root.cern,https://root.cern/root/html528/RooLognormal.html,2,['cache'],['cache']
Performance,"sPdf::_normRangeNormalization range; static TStringRooAbsPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/Roo2DKeysPdf.html:40719,cache,cache,40719,root/html530/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html530/Roo2DKeysPdf.html,20,['cache'],['cache']
Performance,"sPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxysigma; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooGaussian.html:39978,cache,cache,39978,root/html532/RooGaussian.html,https://root.cern,https://root.cern/root/html532/RooGaussian.html,8,['cache'],['cache']
Performance,"sPdf::_normRangeOverride; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxymean; RooRealProxywidth; RooRealProxyx.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooBreitWigner.html:40106,cache,cache,40106,root/html532/RooBreitWigner.html,https://root.cern,https://root.cern/root/html532/RooBreitWigner.html,2,['cache'],['cache']
Performance,"sPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,double,unsigned int>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html:39099,cache,cache,39099,root/html526/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html,https://root.cern,https://root.cern/root/html526/RooCFunction3PdfBinding_double_unsigned_int_double_unsigned_int_.html,4,['cache'],['cache']
Performance,"sPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction3Ref<double,unsigned int,unsigned int,double>funcFunction pointer reference; RooRealProxyxArgument reference; RooRealProxyyArgument reference; RooRealProxyzArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html:39099,cache,cache,39099,root/html526/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html,https://root.cern,https://root.cern/root/html526/RooCFunction3PdfBinding_double_unsigned_int_unsigned_int_double_.html,4,['cache'],['cache']
Performance,"sPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooCFunction1Ref<double,int>funcFunction pointer reference; RooRealProxyxArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCFunction1PdfBinding_double_int_.html:40234,cache,cache,40234,root/html532/RooCFunction1PdfBinding_double_int_.html,https://root.cern,https://root.cern/root/html532/RooCFunction1PdfBinding_double_int_.html,2,['cache'],['cache']
Performance,"sPdf; extendedTerm(double sumEntries, RooArgSet const *nset, double sumEntriesW2=0.0, bool doOffset=false) constRooAbsPdf; extendedTerm(RooAbsData const &data, bool weightSquared, bool doOffset=false) constRooAbsPdf; extendMode() constRooAbsPdfinlinevirtual; ExtendMode enum nameRooAbsPdf; Fatal(const char *method, const char *msgfmt,...) constTObjectvirtual; fBitsTObjectprivate; fgDtorOnlyTObjectprivatestatic; fgObjectStatTObjectprivatestatic; FillBuffer(char *&buffer)TNamedvirtual; fillDataHist(RooDataHist *hist, const RooArgSet *nset, double scaleFactor, bool correctForBinVolume=false, bool showProgress=false) constRooAbsReal; fillHistogram(TH1 *hist, const RooArgList &plotVars, double scaleFactor=1, const RooArgSet *projectedVars=nullptr, bool scaling=true, const RooArgSet *condObs=nullptr, bool setError=true) constRooAbsReal; fillTreeBranch(TTree &t) overrideRooAbsRealprotectedvirtual; findConstantNodes(const RooArgSet &observables, RooArgSet &cacheList)RooAbsArg; findConstantNodes(const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes)RooAbsArg; findInnerMostIntegration(const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) constRooAbsRealprotected; findNewServer(const RooAbsCollection &newSet, bool nameChange) constRooAbsArg; FindObject(const char *name) constTObjectvirtual; FindObject(const TObject *obj) constTObjectvirtual; findRoot(RooRealVar &x, double xmin, double xmax, double yval)RooAbsReal; findServer(const char *name) constRooAbsArginline; findServer(const RooAbsArg &arg) constRooAbsArginline; findServer(Int_t index) constRooAbsArginline; fitTo(RooAbsData &data, CmdArgs_t const &... cmdArgs)RooAbsPdfinline; fitToImpl(RooAbsData &data, const RooLinkedList &cmdList)RooAbsPdfprotectedvirtual; fixAddCoefNormalization(const RooArgSet &addNormSet=RooArgSet(), bool force=true)RooAbsRealvirtual; fixAddCoefRange(const char *rangeName=nullptr, bool force=true)RooAbsRealvirtual; fNameTNamedprotected; forceAnalyticalInt(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsPdf-members.html:14266,cache,cacheList,14266,doc/master/classRooAbsPdf-members.html,https://root.cern,https://root.cern/doc/master/classRooAbsPdf-members.html,2,['cache'],['cacheList']
Performance,"sReal.; Definition at line 310 of file RooGExpModel.cxx. ◆ generateEvent(). void RooGExpModel::generateEvent ; (; Int_t ; code). overridevirtual . Interface for generation of an event using the algorithm corresponding to the specified code. ; The meaning of each code is defined by the getGenerator() implementation. The default implementation does nothing. ; Reimplemented from RooAbsPdf.; Definition at line 944 of file RooGExpModel.cxx. ◆ getAnalyticalIntegral(). Int_t RooGExpModel::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 648 of file RooGExpModel.cxx. ◆ getGenerator(). Int_t RooGExpModel::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Load generatedVars with the subset of directVars that we can generate events for, and return a code that specifies the generator algorithm we will use. ; A code of zero indicates that we cannot generate any of the directVars (in this case, nothing should be added to generatedVars). Any non-zero codes will be passed to our generateEvent() implementation, but otherwise its value is arbitrary. The default implementation of this method returns zero. Subclasses will usually implement this method using the matchArgs() methods to advertise the algorithms they provide. ; Reimplemented from RooAbsPdf.; Definition at line 936 of file RooGExpModel.cxx. ◆ IsA(). TClass * RooGExpModel::IsA ; (; ); const. inlineov",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooGExpModel.html:86501,perform,performed,86501,doc/master/classRooGExpModel.html,https://root.cern,https://root.cern/doc/master/classRooGExpModel.html,1,['perform'],['performed']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsCachedReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedReal.html:10908,cache,cacheList,10908,root/html526/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedReal.html,4,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&RooAbsOptTestStatistic::function(); const RooAbsReal&R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooChi2Var.html:12448,cache,cacheList,12448,root/html526/RooChi2Var.html,https://root.cern,https://root.cern/root/html526/RooChi2Var.html,4,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooAbsReal&function(); const RooAbsReal&function() const; RooFunc",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsOptTestStatistic.html:11352,cache,cacheList,11352,root/html526/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html526/RooAbsOptTestStatistic.html,1,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooAr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsHiddenReal.html:10538,cache,cacheList,10538,root/html526/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html526/RooAbsHiddenReal.html,44,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooPlot*RooAbsRealLValue::frame() const; RooPlot*RooAbsRealLValue",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooLinearVar.html:12292,cache,cacheList,12292,root/html526/RooLinearVar.html,https://root.cern,https://root.cern/root/html526/RooLinearVar.html,1,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooPlot*frame() const; RooPlot*frame(const RooLinkedList& cmdList",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsRealLValue.html:11860,cache,cacheList,11860,root/html526/RooAbsRealLValue.html,https://root.cern,https://root.cern/root/html526/RooAbsRealLValue.html,1,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tRooAbsReal::forceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); TString*format(const RooCmdArg& formatArg) const; TString*format(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooRealVar.html:11867,cache,cacheList,11867,root/html526/RooRealVar.html,https://root.cern,https://root.cern/root/html526/RooRealVar.html,1,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tforceAnalyticalInt(const RooAbsArg& dep) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& p",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooProduct.html:10315,cache,cacheList,10315,root/html526/RooProduct.html,https://root.cern,https://root.cern/root/html526/RooProduct.html,1,['cache'],['cacheList']
Performance,"sReal::EvalErrorIterRooAbsReal::evalErrorIter(); static Bool_tRooAbsReal::evalErrorLoggingEnabled(); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); RooExpensiveObjectCache&RooAbsArg::expensiveObjectCache() const; virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; virtual voidTNamed::FillBuffer(char*& buffer); RooDataHist*RooAbsReal::fillDataHist(RooDataHist* hist, const RooArgSet* nset, Double_t scaleFactor, Bool_t correctForBinVolume = kFALSE, Bool_t showProgress = kFALSE) const; TH1*RooAbsReal::fillHistogram(TH1* hist, const RooArgList& plotVars, Double_t scaleFactor = 1, const RooArgSet* projectedVars = 0, Bool_t scaling = kTRUE, const RooArgSet* condObs = 0, Bool_t setError = kTRUE) const; Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList); Bool_tRooAbsArg::findConstantNodes(const RooArgSet& observables, RooArgSet& cacheList, RooLinkedList& processedNodes); RooAbsArg*RooAbsArg::findNewServer(const RooAbsCollection& newSet, Bool_t nameChange) const; virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject* obj) const; Double_tRooAbsReal::findRoot(RooRealVar& x, Double_t xmin, Double_t xmax, Double_t yval); RooAbsArg*RooAbsArg::findServer(const char* name) const; RooAbsArg*RooAbsArg::findServer(const RooAbsArg& arg) const; RooAbsArg*RooAbsArg::findServer(Int_t index) const; virtual voidRooAbsReal::fixAddCoefNormalization(const RooArgSet& addNormSet = RooArgSet(), Bool_t force = kTRUE); virtual voidRooAbsReal::fixAddCoefRange(const char* rangeName = 0, Bool_t force = kTRUE); virtual Bool_tforceAnalyticalInt(const RooAbsArg&) const; virtual voidRooAbsReal::forceNumInt(Bool_t flag = kTRUE); RooFunctor*RooAbsReal::functor(const RooArgList& obs, const RooArgList& pars ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsCachedReal.html:11011,cache,cacheList,11011,root/html526/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsCachedReal.html,1,['cache'],['cacheList']
Performance,"sReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManager_cacheMgr! The cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooArgSet*_curNormSet! Current normalization set; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; TVectorD*_mref; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMomentMorph.html:42500,cache,cache,42500,root/html602/RooMomentMorph.html,https://root.cern,https://root.cern/root/html602/RooMomentMorph.html,10,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"sReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; const ROOT::Math::IBaseFunctionOneDim*funcFunctor; RooRealProxyvarArgument reference.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFunctor1DBinding.html:33353,cache,cache,33353,root/html532/RooFunctor1DBinding.html,https://root.cern,https://root.cern/root/html532/RooFunctor1DBinding.html,2,['cache'],['cache']
Performance,"sReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooRealProxy_offsetOffset of transformation; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooRealProxy_slopeSlope of transformation; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; RooRealProxy_varInput observable; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooLinearVar(const char* name, const char* title, RooAbsRealLValue& variable, const RooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooLinearVar.html:39641,cache,cache,39641,root/html534/RooLinearVar.html,https://root.cern,https://root.cern/root/html534/RooLinearVar.html,4,['cache'],['cache']
Performance,"sReal::_uintValue! Transient cache for unsigned integer values from tree branches; TStringRooAbsReal::_unitUnit for objects value; Bool_t_valid; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooRealIntegral(). RooRealIntegral(const char* name, const char* title, const RooAbsReal& function, const RooArgSet& depList, const RooArgSet* funcNormSet = 0, const RooNumIntConfig* config = 0, const char* rangeName = 0); Construct integral of 'function' over observables in 'depList'; in range 'rangeName' with normalization observables 'funcNormSet'; (for p.d.f.s). In the integral is performed to the maximum extent; possible the internal (analytical) integrals advertised by function.; The other integrations are performed numerically. The optional; config object prescribes how these numeric integrations are configured. void autoSelectDirtyMode(); Set appropriate cache operation mode for integral depending on cache operation; mode of server objects. Bool_t servesExclusively(const RooAbsArg* server, const RooArgSet& exclLVBranches, const RooArgSet& allBranches) const; Utility function that returns true if 'object server' is a server; to exactly one of the RooAbsArgs in 'exclLVBranches'. Bool_t initNumIntegrator() const; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const. Double_t getValV(const Ro",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooRealIntegral.html:39280,perform,performed,39280,root/html602/RooRealIntegral.html,https://root.cern,https://root.cern/root/html602/RooRealIntegral.html,4,['perform'],['performed']
Performance,"sReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TApplication::EStatusBitsTApplication::kProcessRemotely; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TApplication*TApplication::fAppRemoteCurrent remote application, if defined; TList*TQObject::fListOfConnections! list of connections to this object; TList*TQObject::fListOfSignals! list of signals from this object; Bool_tTQObject::fSignalsBlocked! flag used for suppression of signals; static Bool_tTQObject::fgAllSignalsBlockedflag used for suppression of all signals; static TList*TApplication::fgApplicationsList of available applications. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); Create a TApplication derived for use with interactive ROOT from python. A; set of standard, often used libs is loaded if bLoadLibs is true (default). Bool_t CreatePyROOTApplication(Bool_t bLoadLibs = kTRUE); Create a TPyROOTApplication. Returns false if gApplication is not null. Bool_t InitROOTGlobals(); Setup the basic ROOT globals gBenchmark, gStyle, gProgname, if not already; set. Always returns true. Bool_t InitROOTMessageCallback(); Install ROOT message handler which will turn ROOT error message into; python exceptions. Always returns true. void dummy(); {}. TPyROOTApplication(const char* acn, Int_t* argc, char** argv, Bool_t bLoadLibs = kTRUE); { }. » Last changed: Tue Jun 2 15:18:22 2015 » Last generated: 2015-06-02 15:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/PyROOT__TPyROOTApplication.html:14152,load,loaded,14152,root/html604/PyROOT__TPyROOTApplication.html,https://root.cern,https://root.cern/root/html604/PyROOT__TPyROOTApplication.html,2,['load'],['loaded']
Performance,"sSaved status of all classes.Definition TROOT.cxx:1096; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3189; TROOT::GetGitBranchconst char * GetGitBranch() constDefinition TROOT.h:224; TROOT::fForceStyleBool_t fForceStyleForce setting of current style when reading objects.Definition TROOT.h:133; TROOT::FromPopUpBool_t FromPopUp() constDefinition TROOT.h:207; TROOT::GetSelectedPrimitiveconst TObject * GetSelectedPrimitive() constDefinition TROOT.h:270; TROOT::MakeDefCanvasTCanvas * MakeDefCanvas() constReturn a default canvas.Definition TROOT.cxx:1554; TROOT::fTypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::IsLineProcessingBool_t IsLineProcessing() constDefinition TROOT.h:284; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3168; TROOT::GetListOfCanvasesTSeqCollection * GetListOfCanvases() constDefinition TROOT.h:240; TROOT::AListOfEnums_tstd::atomic< TListOfEnums * > AListOfEnums_tDefinition TROOT.h:109; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8h_source.html:34004,load,load,34004,doc/v632/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8h_source.html,1,['load'],['load']
Performance,"sSaved status of all classes.Definition TROOT.cxx:1096; TROOT::GetTTFFontDirstatic const TString & GetTTFFontDir()Get the fonts directory in the installation. Static utility function.Definition TROOT.cxx:3193; TROOT::GetGitBranchconst char * GetGitBranch() constDefinition TROOT.h:224; TROOT::fForceStyleBool_t fForceStyleForce setting of current style when reading objects.Definition TROOT.h:133; TROOT::FromPopUpBool_t FromPopUp() constDefinition TROOT.h:207; TROOT::GetSelectedPrimitiveconst TObject * GetSelectedPrimitive() constDefinition TROOT.h:270; TROOT::MakeDefCanvasTCanvas * MakeDefCanvas() constReturn a default canvas.Definition TROOT.cxx:1554; TROOT::fTypesTCollection * fTypesList of data types definition.Definition TROOT.h:141; TROOT::GetColorTColor * GetColor(Int_t color) constReturn address of color with index color.Definition TROOT.cxx:1536; TROOT::IsLineProcessingBool_t IsLineProcessing() constDefinition TROOT.h:284; TROOT::GetGlobalTGlobal * GetGlobal(const char *name, Bool_t load=kFALSE) constReturn pointer to global variable by name.Definition TROOT.cxx:1631; TROOT::FindSTLClassTClass * FindSTLClass(const char *name, Bool_t load, Bool_t silent=kFALSE) constreturn a TClass object corresponding to 'name' assuming it is an STL container.Definition TROOT.cxx:1484; TROOT::fStreamerInfoTSeqCollection * fStreamerInfoList of active StreamerInfo classes.Definition TROOT.h:159; TROOT::Appendvoid Append(TObject *obj, Bool_t replace=kFALSE) overrideAppend object to this directory.Definition TROOT.cxx:1047; TROOT::GetIconPathstatic const TString & GetIconPath()Get the icon path in the installation. Static utility function.Definition TROOT.cxx:3172; TROOT::GetListOfCanvasesTSeqCollection * GetListOfCanvases() constDefinition TROOT.h:240; TROOT::AListOfEnums_tstd::atomic< TListOfEnums * > AListOfEnums_tDefinition TROOT.h:109; TROOT::GetListOfGlobalFunctionsTCollection * GetListOfGlobalFunctions(Bool_t load=kFALSE)Return list containing the TFunctions currently defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:34003,load,load,34003,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,1,['load'],['load']
Performance,"sShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooAbsData *dset;  ;  R__DEPRECATED (6, 36, ""Use observableOverlaps()."") inline bool dependentOverlaps(const RooArgSet *depList;  ;  R__DEPRECATED (6, 36, ""Use checkObservables()."") inline bool checkDependents(const RooArgSet *nset) const;  ;  R__DEPRECATED (6, 36, ""Use recursiveCheckObservables()."") inline bool recursiveCheckDependents(const RooArgSet *nset) const;  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:40187,cache,cache,40187,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['cache'],['cache']
Performance,"sTObject::kCannotPick; static TObject::EStatusBitsTObject::kHasUUID; static TObject::EStatusBitsTObject::kInvalidObject; static TObject::(anonymous)TObject::kIsOnHeap; static TObject::EStatusBitsTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. void*fBinData! binary data, assigned with http call; Long_tfBinDataLength! length of binary data; TConditionfCond! condition used to wait for processing; TStringfContent! text content (if any); TStringfContentType! type of content; TStringfFileName! file name; TStringfHeader! response header like ContentEncoding, Cache-Control and so on; TStringfMethod! request method like GET or POST; TStringfPathName! item path; void*fPostData! binary data received with post request; Long_tfPostDataLength! length of binary data; TStringfQuery! additional arguments; TStringfRequestHeader! complete header, provided with request; TStringfTopName! top item name; TStringfUserName! authenticated user name (if any); Int_tfZipping! indicate if content should be zipped. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; THttpCallArg(); constructor. ~THttpCallArg(); destructor. TString AccessHeader(TString& buf, const char* name, const char* value = 0, Bool_t doing_set = kFALSE); method used to get or set http header in the string buffer; Header has following format:; field1 : value1\r\n; field2 : value2\r\n; Such format corresponds to header format in HTTP requests. TString CountHeader(const TString& buf, Int_t number = -1111) const; method used to counter number of headers or returns name of specified header. void SetPostData(void* data, L",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/THttpCallArg.html:7671,Cache,Cache-Control,7671,root/html604/THttpCallArg.html,https://root.cern,https://root.cern/root/html604/THttpCallArg.html,1,['Cache'],['Cache-Control']
Performance,"sTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files); TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeData(); Constructors, factory methods etc. {}. const TTree * GetTree() const; { return _tree; }. » Last changed: Tue Jun 2 13:14:49 2015 » Last generated: 2015-06-02 13:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooTreeData.html:16511,cache,cached,16511,root/html602/RooTreeData.html,https://root.cern,https://root.cern/root/html602/RooTreeData.html,4,['cache'],['cached']
Performance,"sTObject::kIsReferenced; static TObject::EStatusBitsTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*RooAbsData::_cacheIter! Iterator over cached variables; RooArgSetRooAbsData::_cachedVars! External variables cached with this data set; RooAbsDataStore*RooAbsData::_dstoreData storage implementation; TIterator*RooAbsData::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<string,RooAbsData*>RooAbsData::_ownedComponentsOwned external components; RooArgSetRooAbsData::_varsDimensions of this data set; static RooAbsData::StorageTypeRooAbsData::defaultStorageType; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TString_blindStringBlinding string (optionally read from ASCII files); TTree*_treeTTree holding the data points; RooArgSet_truthTruth variables. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooTreeData(); Constructors, factory methods etc. {}. const TTree * GetTree() const; { return _tree; }. » Last changed: Tue Jun 2 15:36:15 2015 » Last generated: 2015-06-02 15:36; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooTreeData.html:16511,cache,cached,16511,root/html604/RooTreeData.html,https://root.cern,https://root.cern/root/html604/RooTreeData.html,4,['cache'],['cached']
Performance,sTObject::kMustCleanup; static RooPrintable::ContentsOptionRooPrintable::kName; static TObject::EStatusBitsTObject::kNoContextMenu; static TObject::(anonymous)TObject::kNotDeleted; static TObject::EStatusBitsTObject::kObjInCanvas; static TObject::(anonymous)TObject::kOverwrite; static TObject::(anonymous)TObject::kSingleKey; static RooPrintable::StyleOptionRooPrintable::kSingleLine; static RooPrintable::StyleOptionRooPrintable::kStandard; static RooPrintable::ContentsOptionRooPrintable::kTitle; static RooPrintable::StyleOptionRooPrintable::kTreeStructure; static RooPrintable::ContentsOptionRooPrintable::kValue; static RooPrintable::StyleOptionRooPrintable::kVerbose; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TIterator*RooAbsDataStore::_cacheIter! Iterator over cached variables; RooArgSetRooAbsDataStore::_cachedVars; Bool_tRooAbsDataStore::_doDirtyPropSwitch do (de)activate dirty state propagation when loading a data point; TIterator*RooAbsDataStore::_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; RooArgSetRooAbsDataStore::_vars; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. RooVectorDataStore*_cache! Optimization cache; RooAbsArg*_cacheOwner! Cache owner; vector<RooVectorDataStore::CatVector*>_catStoreList; Double_t_curWgtWeight of current event; Double_t_curWgtErrWeight of current event; Double_t_curWgtErrHiWeight of current event; Double_t_curWgtErrLoWeight of current event; Double_t*_extSumW2Array! External sum of weights array; Double_t*_extWgtArray! External weight array; Double_t*_extWgtErrHiArray! External weight array - high error; Double_t*_extWgtErrLoArray! External weight array - low error; RooVectorDataStore::CatVector**_firstCat! do not persist; RooVectorDataStore::RealVector**_firstReal! do not persist; RooVectorDataStore::RealFullVector**_firstRealF! do not persist; Bool_t_forcedUpdate! Request for forced cache upd,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooVectorDataStore.html:11322,cache,cached,11322,root/html602/RooVectorDataStore.html,https://root.cern,https://root.cern/root/html602/RooVectorDataStore.html,8,"['cache', 'load']","['cached', 'loading']"
Performance,sTestStatistic::_nGofNumber of sub-contexts; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist. Pointer to global instance of string that matches object named; RooArgSet*RooAbsOptTestStatistic::_normSetPointer to set with observables used for normalization; Int_tRooAbsTestStatistic::_numSetsTotal number of partitions in parallel calculation mode; Double_tRooAbsTestStatistic::_offset! Offset; Double_tRooAbsTestStatistic::_offsetCarry! avoids loss of precision; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooAbsOptTestStatistic::_optimized!; RooAbsData*RooAbsOptTestStatistic::_origDataOriginal data; RooAbsReal*RooAbsOptTestStatistic::_origFuncOriginal function; Bool_tRooAbsOptTestStatistic::_ownDataDo we own the dataset; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxyRooAbsTestStatistic::_paramSetParameters of the test statistic (=parameters of the input function); Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooArgSet*RooAbsOptTestStatistic::_projDepsSet of projected observable; const RooArgSet*RooAbsTestStatistic::_projDepsPointer to set with projected observables; RooRefArrayRooAbsArg::_proxyListlist of proxies; stringRooAbsTestStatistic::_rangeNameName of range in which to calculate test statistic; RooArgSet_rrvArgsSet of real-valued observables; TIterator*_rrvIter! Iterator over set of real-valued observables; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches; TStringRooAbsOptTestStatistic::_sealNoticeUser-defined notice shown when reading a sealed likelihood; Bool_tRooAbsOptTestStatistic::_sealedIs test statistic sealed -- i.e. no access to data; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsA,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooXYChi2Var.html:42587,cache,cache,42587,root/html602/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html602/RooXYChi2Var.html,4,['cache'],['cache']
Performance,"sThe number of distinct computation graphs that have been processed; This function triggers the event loop of all computation graphs which relate to the given RResultHandles. The advantage compared to running the event loop implicitly by accessing the RResultPtr is that the event loops will run concurrently. Therefore, the overall computation of all results is generally more efficient. It should be noted that user-defined operations (e.g., Filters and Defines) of the different RDataFrame graphs are assumed to be safe to call concurrently.; ROOT::RDataFrame df1(""tree1"", ""file1.root"");; auto r1 = df1.Histo1D(""var1"");; ; ROOT::RDataFrame df2(""tree2"", ""file2.root"");; auto r2 = df2.Sum(""var2"");; ; // RResultPtr -> RResultHandle conversion is automatic; ROOT::RDF::RunGraphs({r1, r2});; ROOT::RDataFrameROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree ,...Definition RDataFrame.hxx:41; ROOT::RDF::RunGraphsunsigned int RunGraphs(std::vector< RResultHandle > handles)Trigger the event loop of multiple RDataFrames concurrently.Definition RDFHelpers.cxx:66. Definition at line 66 of file RDFHelpers.cxx. ◆ SaveGraph() [1/2]. template<typename NodeType > . std::string ROOT::RDF::SaveGraph ; (; NodeType ; node). Create a graphviz representation of the dataframe computation graph, return it as a string. ; Parameters. [in]nodeany node of the graph. Called on the head (first) node, it prints the entire graph. Otherwise, only the branch the node belongs to. The output can be displayed with a command akin to dot -Tpng output.dot > output.png && open output.png.; Note that ""hanging"" Defines, i.e. Defines without downstream nodes, will not be displayed by SaveGraph as they are effectively optimized away from the computation graph.; Note that SaveGraph is not thread-safe and must not be called concurrently from different threads. ; Definition at line 120 of file RDFHelpers.hxx. ◆ SaveGraph() [2/2]. template<typename NodeType > . void ROOT::RDF::Sav",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/namespaceROOT_1_1RDF.html:14655,concurren,concurrently,14655,doc/master/namespaceROOT_1_1RDF.html,https://root.cern,https://root.cern/doc/master/namespaceROOT_1_1RDF.html,2,['concurren'],['concurrently']
Performance,"sU1IntervalOverlappingByMinMax(Float_t minM, Float_t maxM, Float_t minQ, Float_t maxQ); static voidLoadMacro(const char* mac); static voidMacro(const char* mac); TEveUtil&operator=(const TEveUtil&); static voidSetColorBrightness(Float_t value, Bool_t full_redraw = kFALSE); static voidSetupEnvironment(); static voidSetupGUI(); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; private:. static TObjArray*fgDefaultColors. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void SetupEnvironment(); Setup Include and Macro paths.; Since inclusion into ROOT this does nothing but could; potentially be reactivated if some common macros are established; and shipped with binary ROOT (in macros/eve). For example, these; might be used to spawn specific GUI / GL configurations. void SetupGUI(); Setup icon pictures and mime-types. Bool_t CheckMacro(const char* mac); Checks if macro 'mac' is loaded. void AssertMacro(const char* mac); Load and execute macro 'mac' if it has not been loaded yet. void Macro(const char* mac); Execute macro 'mac'. Do not reload the macro. void LoadMacro(const char* mac); Makes sure that macro 'mac' is loaded, but do not reload it. void ColorFromIdx(Color_t ci, UChar_t* col, Bool_t alpha = kTRUE); Fill col with RGBA values corresponding to index ci. If alpha; is true, set alpha component of col to 255.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Color_t ci, UChar_t* col, Char_t transparency); Fill col with RGBA values corresponding to index ci and transparency.; ROOT's indexed color palette does not support transparency. void ColorFromIdx(Float_t f1, Color_t c1, Float_t f2, Color_t c2, UChar_t* col, Bool_t alpha = kTRUE); Fill col with weighted RGBA values corresponding to; color-indices c1 and c2. If alpha is true, set alpha component; of col to 255. Color_t* FindColorVar(TObject* obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEveUtil.html:2299,load,loaded,2299,root/html534/TEveUtil.html,https://root.cern,https://root.cern/root/html534/TEveUtil.html,2,['load'],['loaded']
Performance,"sWithLock, TListOfFunctions, TListOfFunctionTemplates, and TSelectorList.; Definition at line 95 of file THashList.cxx. ◆ AddLast() [2/2]. void THashList::AddLast ; (; TObject * ; obj, . Option_t * ; opt . ). overridevirtual . Add object at the end of the list and also store option. ; Storing an option is useful when one wants to change the behaviour of an object a little without having to create a complete new copy of the object. This feature is used, for example, by the Draw() method. It allows the same object to be drawn in different ways. ; Reimplemented from TList.; Reimplemented in TListOfDataMembers, TListOfEnums, TListOfEnumsWithLock, TListOfFunctions, TListOfFunctionTemplates, and TSelectorList.; Definition at line 110 of file THashList.cxx. ◆ AverageCollisions(). Float_t THashList::AverageCollisions ; (; ); const. Return the average collision rate. ; The higher the number the longer the linked lists in the hashtable, the slower the lookup. If the number is high, or lookup noticeably too slow, perform a Rehash(). ; Definition at line 178 of file THashList.cxx. ◆ Class(). static TClass * THashList::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * THashList::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t THashList::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 72 of file THashList.h. ◆ Clear(). void THashList::Clear ; (; Option_t * ; option = """"). overridevirtual . Remove all objects from the list. ; Does not delete the objects unless the THashList is the owner (set via SetOwner()). ; Implements TCollection.; Reimplemented in TListOfEnums, TListOfEnumsWithLock, TListOfDataMembers, TListOfFunctions, and TListOfFunctionTemplates.; Definition at line 189 of file THashList.cxx. ◆ DeclFileName(). static const char * THashList::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declara",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHashList.html:27766,perform,perform,27766,doc/master/classTHashList.html,https://root.cern,https://root.cern/doc/master/classTHashList.html,1,['perform'],['perform']
Performance,s[fBNb]; Long64_t*TFileCacheRead::fBSeek[fBNseek]; Int_t*TFileCacheRead::fBSeekIndex[fBNseek]; Int_t*TFileCacheRead::fBSeekLen[fBNseek]; Int_t*TFileCacheRead::fBSeekPos[fBNseek]; Int_tTFileCacheRead::fBSeekSize; Long64_t*TFileCacheRead::fBSeekSort[fBNseek]; Int_t*TFileCacheRead::fBSeekSortLen[fBNseek]; TList*fBrNames! list of branch names in the cache; TObjArray*fBranches! List of branches to be stored in the cache; char*TFileCacheRead::fBuffer[fBufferSize] buffer of contiguous prefetched blocks; Int_tTFileCacheRead::fBufferLenCurrent buffer length (<= fBufferSize); Int_tTFileCacheRead::fBufferSizeAllocated size of fBuffer (at a given time); Int_tTFileCacheRead::fBufferSizeMinOriginal size of fBuffer; Long64_tTFileCacheRead::fBytesReadNumber of bytes read for this cache; Long64_tTFileCacheRead::fBytesReadExtraNumber of extra bytes (overhead) read by the readahead buffer; Bool_tTFileCacheRead::fEnablePrefetchingreading by prefetching asynchronously; Bool_tfEnabled! cache enabled for cached reading; Long64_tfEntryCurrent! current lowest entry number in the cache; Long64_tfEntryMax! last entry in the cache; Long64_tfEntryMin! first entry in the cache; Long64_tfEntryNext! next entry number where cache must be filled; TFile*TFileCacheRead::fFilePointer to file; Int_tfFillTimes! how many times we can fill the current buffer; Bool_tfFirstBuffer! true if first buffer is used for prefetching; Long64_tfFirstEntry! save the value of the first entry; Bool_tfFirstTime! save the fact that we processes the first entry; Bool_tfIsLearning! true if cache is in learning mode; Bool_tfIsManual! true if cache is StopLearningPhase was used; Bool_tTFileCacheRead::fIsSortedTrue if fSeek array is sorted; Bool_tTFileCacheRead::fIsTransferredTrue when fBuffer contains something valid; Int_t*TFileCacheRead::fLen[fNb] Length of long buffers; Int_tfNReadMissNumber of blocks read and not found in the chache; Int_tfNReadOkNumber of blocks read and found in the cache; Int_tfNReadPrefNumber of blocks ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TTreeCache.html:19067,cache,cached,19067,root/html602/TTreeCache.html,https://root.cern,https://root.cern/root/html602/TTreeCache.html,4,['cache'],['cached']
Performance,"sa;; 763/// ia++;; 764/// ib++;; 765/// if (ia > na) {ok = kTRUE; break;}; 766/// if (ib > nb) {ok = kTRUE; break;}; 767/// }; 768/// rdmax = TMath::Max(rdmax,TMath::Abs(rdiff));; 769/// }; 770/// ~~~; 771///; 772/// For the last case, a=b, the algorithm advances each array by one index in an; 773/// attempt to move through the equality. However, this is incorrect when one or; 774/// the other of a or b (or both) have a repeated value, call it x. For the KS; 775/// statistic to be computed properly, rdiff needs to be calculated after all of; 776/// the a and b at x have been tallied (this is due to the definition of the; 777/// empirical distribution function; another way to convince yourself that the; 778/// old CERNLIB method is wrong is that it implies that the function defined as the; 779/// difference between a and b is multi-valued at x -- besides being ugly, this; 780/// would invalidate Kolmogorov's theorem).; 781///; 782/// The solution is to just add while-loops into the equality-case handling to; 783/// perform the tally:; 784///; 785/// ~~~ {.cpp}; 786/// } else {; 787/// double x = a[ia-1];; 788/// while(a[ia-1] == x && ia <= na) {; 789/// rdiff -= sa;; 790/// ia++;; 791/// }; 792/// while(b[ib-1] == x && ib <= nb) {; 793/// rdiff += sb;; 794/// ib++;; 795/// }; 796/// if (ia > na) {ok = kTRUE; break;}; 797/// if (ib > nb) {ok = kTRUE; break;}; 798/// }; 799/// ~~~; 800///; 801/// ### Note:; 802/// A good description of the Kolmogorov test can be seen at:; 803/// http://www.itl.nist.gov/div898/handbook/eda/section3/eda35g.htm; 804 ; 805Double_t TMath::KolmogorovTest(Int_t na, const Double_t *a, Int_t nb, const Double_t *b, Option_t *option); 806{; 807// LM: Nov 2010: clean up and returns now a zero distance when vectors are the same; 808 ; 809 TString opt = option;; 810 opt.ToUpper();; 811 ; 812 Double_t prob = -1;; 813// Require at least two points in each graph; 814 if (!a || !b || na <= 2 || nb <= 2) {; 815 Error(""KolmogorovTest"",""Sets must have more ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMath_8cxx_source.html:26229,perform,perform,26229,doc/master/TMath_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TMath_8cxx_source.html,1,['perform'],['perform']
Performance,"sage logger; TMVA::MethodBase *constfMethodThe MVA method to be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; TStringfOptimizationFitTypewhich type of optimisation procedure to be used ; map<TString,TMVA::Interval>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). std::vector< int > GetScanIndices(int val, vector<int> base); helper function to scan through the all the combinations in the; parameter space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distribu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html:2940,optimiz,optimize,2940,root/html530/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html530/TMVA__OptimizeConfigParameters.html,3,['optimiz'],['optimize']
Performance,"sage logger; TMVA::MethodBase *constfMethodThe MVA method to be evaluated; TH1D*fMvaBkgMVA distrituion for bakgr. events, used for spline fit; TH1D*fMvaBkgFineBinMVA distrituion for bakgr. events; TH1D*fMvaSigMVA distrituion for signal events, used for spline fit; TH1D*fMvaSigFineBinMVA distrituion for signal events; TStringfOptimizationFitTypewhich type of optimisation procedure to be used ; map<TString,TMVA::Interval>fTuneParametersparameters included in the tuning; map<TString,Double_t>fTunedParametersparameters included in the tuning. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); Constructor which sets either ""Classification or Regression"". ~OptimizeConfigParameters(); the destructor (delete the OptimizeConfigParameters, store the graph and .. delete it). std::map<TString,Double_t> optimize(). void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html:2780,optimiz,optimize,2780,root/html528/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html528/TMVA__OptimizeConfigParameters.html,1,['optimiz'],['optimize']
Performance,"saging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void initSlave(RooAbsReal& real, RooAbsData& indata, const RooArgSet& projDeps, const char* rangeName, const char* addCoefRangeName). ~RooAbsOptTestStatistic(); Destructor. Double_t combinedValue(RooAbsReal** gofArray, Int_t nVal) const; Method to combined test statistic results calculated into partitions into; the global result. This default implementation adds the partition return; values. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Catch server redirect calls and forward to internal clone of function. void printCompactTreeHook(ostream& os, const char* indent = """"); Catch print hook function and forward to function clone. void constOptimizeTestStatistic(RooAbsArg::ConstOpCode opcode, Bool_t doAlsoTrackingOpt = kTRUE); Driver function to propagate constant term optimizations in test statistic.; If code Activate is sent, constant term optimization will be executed.; If code Deacivate is sent, any existing constant term optimizations will; be abanoned. If codes ConfigChange or ValueChange are sent, any existing; constant term optimizations will be redone. void optimizeCaching(); This method changes the value caching logic for all nodes that depends on any of the observables; as defined by the given dataset. When evaluating a test statistic constructed from the RooAbsReal; with a dataset the observables are guaranteed to change with every call, thus there is no point; in tracking these changes which result in a net overhead. Thus for observable-dependent nodes,; the evaluation mechanism is changed from being dependent on a 'valueDirty' flag to guaranteed evaluation.; On the dataset side, the observables objects are modified to no longer send valueDirty messages; to their client. void optimiz",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooAbsOptTestStatistic.html:38341,optimiz,optimizations,38341,root/html532/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html532/RooAbsOptTestStatistic.html,3,['optimiz'],['optimizations']
Performance,"same object to be drawn in different ways. void AddAt(TObject* obj, Int_t idx); Insert object at location idx in the list. void AddAfter(const TObject* after, TObject* obj); Insert object after object after in the list. void AddAfter(TObjLink* after, TObject* obj); Insert object after object after in the list. void AddBefore(const TObject* before, TObject* obj); Insert object before object before in the list. void AddBefore(TObjLink* before, TObject* obj); Insert object before object before in the list. void Clear(Option_t* option); Remove all objects from the list. Does not delete the objects unless; the THashList is the owner (set via SetOwner()). void Delete(Option_t* option = """"); Delete all TDataMember object files. TObject * FindObject(const char* name) const; Specialize FindObject to do search for the; a enum just by name or create it if its not already in the list. TObject* FindObject(const TObject* obj) const. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. TIterator* MakeIterator(Bool_t dir = kIterForward) const. TObject* At(Int_t idx) const. TObject* After(const TObject* obj) const. TObject* Before(const TObject* obj) const. TObject* First() const. TObjLink* FirstLink() const. TObject** GetObjectRef(const TObject* obj) const. TObject* Last() const. TObjLink* LastLink() const. Int_t GetLas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnumsWithLock.html:13136,load,loaded,13136,root/html602/TListOfEnumsWithLock.html,https://root.cern,https://root.cern/root/html602/TListOfEnumsWithLock.html,4,['load'],['loaded']
Performance,"same we could do by hand, but with a lot less effort.; This produces code that is type safe, but does have different drawbacks:. Templates make code harder to read.; At the time of writing this documentation, some compilers can be very slow when dealing with templates.; It does not solve the problem when a container has to hold a heterogeneous set of objects.; The system can end up generating a great deal of code; each container/object combination has its own code, a phenomenon that is sometimes referred to as code bloat.; The Standard Template Library (STL) is part on ANSI C++, and includes a set of template containers. 17 Physics Vectors; The physics vector classes describe vectors in three and four dimensions and their rotation algorithms. The classes were ported to root from CLHEP see:; http://www.cern.ch/clhep/manual/UserGuide/Vector/vector.html; 17.1 The Physics Vector Classes; In order to use the physics vector classes you will have to load the Physics library:; gSystem.Load(""libPhysics.so"");; There are four classes in this package. They are:; TVector3 is a general three-vector. A TVector3 may be expressed in Cartesian, polar, or cylindrical coordinates. Methods include dot and cross products, unit vectors and magnitudes, angles between vectors, and rotations and boosts. There are also functions of particular use to HEP, like pseudo-rapidity, projections, and transverse part of a TVector3, and kinetic methods on 4-vectors such as Invariant Mass of pairs or containers of particles.; TLorentzVector is a general four-vector class, which can be used either for the description of position and time (x, y, z, t) or momentum and energy (px, py, pz, E). TRotation is a class describing a rotation of a TVector3 object. TLorentzRotation is a class to describe the Lorentz transformations including Lorentz boosts and rotations. In addition, a TVector2 is a basic implementation of a vector in two dimensions and is not part of the CLHEP translation.; 17.2 TVector3. TVector3 i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:857919,Load,Load,857919,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,1,['Load'],['Load']
Performance,sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0193 sec ; Factory : Test method: DNN_CPU for Classification performance; : ; : Evaluate deep neural network on CPU using batches with size = 1000; : ; TFHandler_DNN_CPU : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.12216 0.20255 [ -1.0614 1.0246 ]; : myvar2: -0.12333 0.30492 [ -1.2280 0.99911 ]; : var3: 0.097148 0.21347 [ -1.0158 0.99984 ]; : var4: 0.17495 0.23851 [ -1.2661 1.0694 ]; : -----------------------------------------------------------; DNN_CPU : [dataset] : Evaluation of DNN_CPU on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.333 sec ; Factory : Test method: SVM for Classification performance; : ; SVM : [dataset] : Evaluation of SVM on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.287 sec ; Factory : Test method: BDT for Classification performance; : ; BDT : [dataset] : Evaluation of BDT on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.571 sec ; Factory : Test method: RuleFit for Classification performance; : ; RuleFit : [dataset] : Evaluation of RuleFit on testing sample (10000 events); : Elapsed time for evaluation of 10000 events: 0.0137 sec ; Factory : ␛[1mEvaluate all methods␛[0m; Factory : Evaluate classifier: Cuts; : ; <WARNING> : You have asked for histogram MVA_EFF_BvsS which does not seem to exist in *Results* .. better don't use it ; <WARNING> : You have asked for histogram EFF_BVSS_TR which does not seem to exist in *Results* .. better don't use it ; TFHandler_Cuts : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : myvar1: 0.21781 1.7248 [ -9.8605 7.9024 ]; : myvar2: -0.062175 1.1106 [ -4.0854 4.0259 ]; : var3: 0.16451 1.0589 [ -5.3563 4.6422 ]; : var4: 0.43566 1.2253 [ -6.9675 5.0307 ]; : -----------------------------------------------------------; Factory : Evalu,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:68225,perform,performance,68225,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['perform'],['performance']
Performance,"scale is true (default), the corresponding; scaling gets calculated from the current window size. Bool_t SavePictureScale(const TString& fileName, Float_t scale, Bool_t pixel_object_scale = kTRUE); Save picture with given scale to current window size.; If pixel_object_scale is true (default), the same scaling is; used. void DrawGuides(); Draw reference marker and coordinate axes. void DrawDebugInfo(); If in debug mode draw camera aids and overall bounding box. void PreDraw(); Perform GL work which must be done before each draw. void PostDraw(); Perform GL work which must be done after each draw. void FadeView(Float_t alpha); Draw a rectangle (background color and given alpha) across the; whole viewport. void MakeCurrent() const; Make GL context current. void SwapBuffers() const; Swap GL buffers. Bool_t RequestSelect(Int_t x, Int_t y); Post request for selection render pass viewer, picking objects; around the window point (x,y). Bool_t DoSelect(Int_t x, Int_t y); Perform GL selection, picking objects overlapping WINDOW; area described by 'rect'. Return kTRUE if selection should be; changed, kFALSE otherwise.; Select lock should already been taken in other thread in; TGLViewer::ReqSelect(). Bool_t RequestSecondarySelect(Int_t x, Int_t y); Request secondary select. Bool_t DoSecondarySelect(Int_t x, Int_t y); Secondary selection. void ApplySelection(); Process result from last selection (in fSelRec) and; extract a new current selection from it.; Here we only use physical shape. Bool_t RequestOverlaySelect(Int_t x, Int_t y); Post request for secondary selection rendering of selected object; around the window point (x,y). Bool_t DoOverlaySelect(Int_t x, Int_t y); Perform GL selection, picking overlay objects only.; Return TRUE if the selected overlay-element has changed. void AutoFade(Float_t fade, Float_t time = 1, Int_t steps = 10); Animate fading from curernt value to fade over given time (sec); and number of steps. void UseDarkColorSet(); Use the dark color-set. void U",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGLViewer.html:28064,Perform,Perform,28064,root/html532/TGLViewer.html,https://root.cern,https://root.cern/root/html532/TGLViewer.html,4,['Perform'],['Perform']
Performance,"scene (via; a TPad; repaint; at; present),; and; thus; collect; these; objects if; the; internal viewer state changes. It does this presently by forcing a repaint; on the attached TPad object - hence the reason for putting all publishing to; the viewer in the attached pad objects Paint() method. We will likely remove; this requirement in the future, indicating the rebuild request via a normal; ROOT signal, which the client can detect. Physical IDs; TVirtualViewer3D provides for two methods of object addition:virtual Int_t AddObject(const; TBuffer3D & buffer, Bool_t * addChildren = 0); virtual Int_t AddObject(UInt_t physicalID, const TBuffer3D & buffer, Bool_t * addChildren = 0); If you use the first (simple) case a viewer using logical/physical pairs; will generate IDs for each physical object internally. In the second you; can specify; a unique identifier from the client, which allows the viewer to be more; efficient. It can now cache both logical and physical objects, and only discard; physical; objects no longer of interest as part of scene rebuilds. Child Objects; In many geometries there is a rigid containment hierarchy, and so if the viewer; is not interested in a certain object due to limits/size then it will also; not be interest in any of the contained branch of descendents. Both AddObject(); methods have an addChildren parameter. The viewer will complete this (if passed); indicating if children (contained within the one just sent) are worth adding. Recyling TBuffer3D ; Once add AddObject() has been called, the contents are copied to the viewer; internally. You are free to destroy this object, or recycle it for the next; object if suitable. Function Members (Methods);      This is an abstract class, constructors will not be documented.;     Look at the header to check for available constructors.; public:. virtual~TVirtualViewer3D(); voidTObject::AbstractMethod(const char* method) const; virtual voidAddCompositeOp(UInt_t operation); virtual Int_tAddObject(con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TVirtualViewer3D.html:10290,cache,cache,10290,root/html528/TVirtualViewer3D.html,https://root.cern,https://root.cern/root/html528/TVirtualViewer3D.html,10,['cache'],['cache']
Performance,"sconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 2387/// If file is null the existing write cache is deleted.; 2388 ; 2389void TFile::SetCacheWrite(TFileCacheWrite *cache); 2390{; 2391 if (!cache && fCacheWrite) delete fCacheWrite;; 2392 fCacheWrite = cache;; 2393}; 2394 ; 2395////////////////////////////////////////////////////////////////////////////////; 2396/// Return the size in bytes of the file header.; 2397 ; 2398Int_t TFile::Sizeof() const; 2399{; 2400 return 0;; 2401}; 2402 ; 2403////////////////////////////////////////////////////////////////////////////////; 2404/// Stream a TFile object.; 2405 ; 2406void TFile::Streamer(TB",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:84384,cache,cache,84384,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,3,['cache'],['cache']
Performance,"screte) The binning used for the FFT sampling is controlled by the binning named ""cache"" in the convolution observable convVar. If such a binning is not set, the same number of bins as for convVar will be used. ; [in]pdfConvVarIf the variable used for convolution is a PDF, itself, pass the PDF here, and pass the convolution variable to convVar. See also rf210_angularconv.C in the roofit tutorials . Definition at line 248 of file RooFFTConvPdf.cxx. ◆ RooFFTConvPdf() [4/4]. RooFFTConvPdf::RooFFTConvPdf ; (; const RooFFTConvPdf & ; other, . const char * ; name = nullptr . ). Copy constructor. ; Definition at line 272 of file RooFFTConvPdf.cxx. ◆ ~RooFFTConvPdf(). RooFFTConvPdf::~RooFFTConvPdf ; (; ). override . Destructor. ; Definition at line 292 of file RooFFTConvPdf.cxx. Member Function Documentation. ◆ actualObservables(). RooFit::OwningPtr< RooArgSet > RooFFTConvPdf::actualObservables ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return the observables to be cached given the normalization set nset. ; If the cache observable is in nset then this is; the convolution observable plus; any member of nset that is either a RooCategory,; or was previously specified through setCacheObservables(). In case the cache observable is not in nset, then it is; the convolution observable plus; all member of nset that are observables of this p.d.f. . Implements RooAbsCachedPdf.; Definition at line 778 of file RooFFTConvPdf.cxx. ◆ actualParameters(). RooFit::OwningPtr< RooArgSet > RooFFTConvPdf::actualParameters ; (; const RooArgSet & ; nset); const. overrideprotectedvirtual . Return the parameters on which the cache depends given normalization set nset. ; For this p.d.f these are the parameters of the input p.d.f. but never the convolution variable, in case it is not part of nset. ; Implements RooAbsCachedPdf.; Definition at line 833 of file RooFFTConvPdf.cxx. ◆ bufferFraction(). double RooFFTConvPdf::bufferFraction ; (; ); const. inline . Return value of buffer ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooFFTConvPdf.html:87042,cache,cached,87042,doc/master/classRooFFTConvPdf.html,https://root.cern,https://root.cern/doc/master/classRooFFTConvPdf.html,1,['cache'],['cached']
Performance,"scribes ntrack to be written as a 16-bit integer (rather than a 32-bit integer).; ""ntrack/I2""; With this Branch method, you can also add a leaf that holds an entire array of variables. To add an array of floats use the f[n] notation when describing the leaf.; Float_t f[10];; tree->Branch(""fBranch"",f,""f[10]/F"");; You can also add an array of variable length:; {; TFile *f = new TFile(""peter.root"",""recreate"");; Int_t nPhot;; Float_t E[500];; TTree* nEmcPhotons = new TTree(""nEmcPhotons"",""EMC Photons"");; nEmcPhotons->Branch(""nPhot"",&nPhot,""nPhot/I"");; nEmcPhotons->Branch(""E"",E,""E[nPhot]/F"");; }; See “Example 2: A Tree with a C Structure” below ($ROOTSYS/tutorials/tree/tree2.C) and staff.C at the beginning of this chapter.; 12.10 Adding a TBranch to Hold an Object; To write a branch to hold an event object, we need to load the definition of the Event class, which is in $ROOTSYS/test/libEvent.so (if it doesn’t exist type make in $ROOTSYS/test). An object can be saved in a tree if a ROOT dictionary for its class has been generated and loaded.; root[] .L libEvent.so; First, we need to open a file and create a tree.; root[] TFile *f = new TFile(""AFile.root"",""RECREATE""); root[] TTree *tree = new TTree(""T"",""A Root Tree""); We need to create a pointer to an Event object that will be used as a reference in the TTree::Branch method. Then we create a branch with the TTree::Branch method.; root[] Event *event = new Event(); root[] tree->Branch(""EventBranch"",""Event"",&event,32000,99); To add a branch to hold an object we use the signature above. The first parameter is the name of the branch. The second parameter is the name of the class of the object to be stored. The third parameter is the address of a pointer to the object to be stored.; Note that it is an address of a pointer to the object, not just a pointer to the object.; The fourth parameter is the buffer size and is by default 32000 bytes. It is the number of bytes of data for that branch to save to a buffer until it is saved to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:541457,load,loaded,541457,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loaded']
Performance,"scribinb the collection (if any). TClassStreamer * GetStreamer() const; Return the Streamer Class allowing streaming (if any). ClassStreamerFunc_t GetStreamerFunc() const; Get a wrapper/accessor function around this class custom streamer (member function). TVirtualIsAProxy* GetIsAProxy() const; Return the proxy implementing the IsA functionality. TClass * GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); Static method returning pointer to TClass of the specified class name.; If load is true an attempt is made to obtain the class by loading; the appropriate shared library (directed by the rootmap file).; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members); Returns 0 in case class is not found. THashTable * GetClassShortTypedefHash(); Return the class' names massaged with TClassEdit::ShortType with kDropStlDefault. TClass * GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); Return pointer to class with name. VoidFuncPtr_t GetDict(const char* cname); Return a pointer to the dictionary loading function generated by; rootcint. VoidFuncPtr_t GetDict(const type_info& info); Return a pointer to the dictionary loading function generated by; rootcint. TDataMember * GetDataMember(const char* datamember) const; Return pointer to datamember object with name ""datamember"". Long_t GetDataMemberOffset(const char* membername) const; return offset for member name. name can be a data member in; the class itself, one of its base classes, or one member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built. TRealData* GetRealData(const char* name) const; -- Return pointer to TRealData element with name ""name"". Name can be a data member in the class itself,; one of its base classes, or a member in; one of the aggregated classes. In case of an emulated class, the list of emulated TRealData is built.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TClass.html:27234,load,load,27234,root/html528/TClass.html,https://root.cern,https://root.cern/root/html528/TClass.html,6,['load'],['load']
Performance,"scribing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object of class TListOfDataMembers. void Update(TDictionary* member); Move the member or data member to the expect set of list. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TDictionary* member); Mark 'func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfDataMembers(const TListOfDataMembers& ). TListOfDataMembers& operator=(const TListOfDataMembers& ). Bool_t IsLoaded() const; { return fIsLoaded; }. TClass * GetClass() const; { return fClass; }. void SetClass(TClass* cl); { fClass = cl; }. » Author: Philippe Canal Aug 2013 » Copyright (C) 1995-2013, Rene Brun and Fons Rademaker",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfDataMembers.html:14994,Load,Load,14994,root/html604/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html604/TListOfDataMembers.html,2,['Load'],['Load']
Performance,"scribing the data member corresponding to the Decl 'id'.; The skipChecks flag controls the consistency checks performed inspecting; the AST. In some cases, we explicitely alter the datamembers in the; typesystem with respect to the AST and therefore we must not enforce; consistency. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of data members and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject* Remove(TObject* obj); Remove object from the list. TObject* Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Streamer(TBuffer& ); Stream an object of class TListOfDataMembers. void Update(TDictionary* member); Move the member or data member to the expect set of list. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TDictionary* member); Mark 'func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfDataMembers(const TListOfDataMembers& ). TListOfDataMembers& operator=(const TListOfDataMembers& ). Bool_t IsLoaded() const; { return fIsLoaded; }. void SetClass(TClass* cl); { fClass = cl; }. » Author: Philippe Canal Aug 2013 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfDataMembers.html:14735,Load,Load,14735,root/html602/TListOfDataMembers.html,https://root.cern,https://root.cern/root/html602/TListOfDataMembers.html,2,['Load'],['Load']
Performance,"scription of TEveWindowSlot ;  CTEveWindowTabEncapsulates TGTab into an eve-window ;  CTExecTExec is a utility class that can be used to execute a C++ command when some event happens in a pad ;  ►CTExMapThis class stores a (key,value) pair using an external hash ;  CAssoc_t;  CTExMapIter;  CTF11-Dim function class ;  CTF12A projection of a TF2 along X or Y ;  CTF1ConvolutionClass wrapping convolution of two functions ;  CTF1Editor;  CTF1NormSumClass adding two functions: c1*f1+c2*f2 ;  CTF1ParametersTF1 Parameters class ;  CTF2A 2-Dim function with parameters ;  CTF2GLGL renderer for TF2 ;  CTF3A 3-Dim function with parameters ;  CTFastCgi;  CTFeldmanCousinsClass to calculate the CL upper limit using the Feldman-Cousins method as described in PRD V57 #7, p3873-3889 ;  CTFFTComplex;  CTFFTComplexReal;  CTFFTReal;  CTFFTRealComplex;  CTFileA ROOT file is a suite of consecutive data records (TKey instances) with a well defined format ;  CTFileCacheReadA cache when reading files over the network ;  CTFileCacheWriteA cache when writing files over the network ;  CTFileCollectionClass that contains a list of TFileInfo's and accumulated meta data information about its entries ;  CTFileDrawMapThis class is automatically called by TFile::DrawMap ;  CTFileHandler;  CTFileInfoClass describing a generic file including meta information ;  CTFileInfoMeta;  CTFileIter;  CTFileMergeInfo;  CTFileMergerThis class provides file copy and merging services ;  CTFileOpenHandleClass holding info about the file being opened ;  CTFilePrefetchThe prefetching mechanism uses two classes (TFilePrefetch and TFPBlock) to prefetch in advance a block of tree entries ;  CTFileSet;  CTFileStager;  ►CTFitEditor;  CFuncParamData_tTF1Convolution object ;  CTFitParametersDialog;  CTFitResultExtends the ROOT::Fit::Result class with a TNamed inheritance providing easy possibility for I/O ;  CTFitResultPtrProvides an indirection to the TFitResult class and with a semantics identical to a TFitResult pointer, i.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v608/annotated.html:135311,cache,cache,135311,doc/v608/annotated.html,https://root.cern,https://root.cern/doc/v608/annotated.html,1,['cache'],['cache']
Performance,"se = kFALSE, TString indent = """") const; Print fit result to stream 'os'. In Verbose mode, the contant parameters and; the initial and final values of the floating parameters are printed.; Standard mode only the final values of the floating parameters are printed. void fillCorrMatrix(const vector<double>& globalCC, const TMatrixDSym& corrs, const TMatrixDSym& covs); Function called by RooMinimizer. void fillLegacyCorrMatrix() const; Sanity check. void fillCorrMatrix(); Internal utility method to extract the correlation matrix and the; global correlation coefficients from the MINUIT memory buffer and; fill the internal arrays. Bool_t isIdentical(const RooFitResult& other, Double_t tol = 5e-5, Double_t tolCorr = 1e-4, Bool_t verbose = kTRUE) const; Return true if this fit result is identical to other within tolerance 'tol' on fitted values; and tolerance 'tolCor' on correlation coefficients. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed by gMinuit, interpreting; the fit parameters as the given varList of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in his RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix (Note that Vred _is_ a simple sub-matrix of V,; row/columns are ordered to matched the convention given in input argument 'params'. TMatrixDSym conditionalCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooFitResult.html:14398,perform,performed,14398,root/html532/RooFitResult.html,https://root.cern,https://root.cern/root/html532/RooFitResult.html,4,['perform'],['performed']
Performance,"se = kFALSE, TString indent = """") const; Print fit result to stream 'os'. In Verbose mode, the contant parameters and; the initial and final values of the floating parameters are printed.; Standard mode only the final values of the floating parameters are printed. void fillCorrMatrix(const vector<double>& globalCC, const TMatrixDSym& corrs, const TMatrixDSym& covs); Function called by RooMinimizer. void fillLegacyCorrMatrix() const; Sanity check. void fillCorrMatrix(); Internal utility method to extract the correlation matrix and the; global correlation coefficients from the MINUIT memory buffer and; fill the internal arrays. Bool_t isIdentical(const RooFitResult& other, Double_t tol = 5e-5, Double_t tolCorr = 1e-4, Bool_t verbose = kTRUE) const; Return true if this fit result is identical to other within tolerance 'tol' on fitted values; and tolerance 'tolCor' on correlation coefficients. RooFitResult* lastMinuitFit(const RooArgList& varList = RooArgList()); Import the results of the last fit performed by gMinuit, interpreting; the fit parameters as the given varList of parameters. void setCovarianceMatrix(TMatrixDSym& V); Store externally provided correlation matrix in his RooFitResult ;. TH2* correlationHist(const char* name = ""correlation_matrix"") const; Return TH2D of correlation matrix. const TMatrixDSym& covarianceMatrix() const; Return covariance matrix. TMatrixDSym reducedCovarianceMatrix(const RooArgList& params) const; Return a reduced covariance matrix, which is calculated as; ___ -1; Vred = V22 = V11 - V12 * V22 * V21. Where V11,V12,V21,V22 represent a block decomposition of the covariance matrix into observables that; are propagated (labeled by index '1') and that are not propagated (labeled by index '2'), and V22bar; is the Shur complement of V22, calculated as shown above. (Note that Vred is _not_ a simple sub-matrix of V). const TMatrixDSym& correlationMatrix() const; Return correlation matrix ;. RooAbsPdf* createHessePdf(const RooArgSet& params) con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFitResult.html:13878,perform,performed,13878,root/html526/RooFitResult.html,https://root.cern,https://root.cern/root/html526/RooFitResult.html,3,['perform'],['performed']
Performance,"se class into the buffer. ;  ;  Public Member Functions inherited from TStreamerElement;  TStreamerElement ();  Default ctor. ;  ;  TStreamerElement (const char *name, const char *title, Int_t offset, Int_t dtype, const char *typeName);  Create a TStreamerElement object. ;  ; virtual ~TStreamerElement ();  TStreamerElement dtor. ;  ; virtual Bool_t CannotSplit () const;  Returns true if the element cannot be split, false otherwise. ;  ; Int_t GetArrayDim () const;  ; Int_t GetArrayLength () const;  ; TClass * GetClass () const;  ; virtual Int_t GetExecID () const;  Returns the TExec id for the EXEC instruction in the comment field of a TRef data member. ;  ; Double_t GetFactor () const;  ; virtual const char * GetFullName () const;  Return element name including dimensions, if any Note that this function stores the name into a static array. ;  ; Int_t GetMaxIndex (Int_t i) const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the element represent an entity that is not ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBase.html:3142,cache,cached,3142,doc/master/classTStreamerBase.html,https://root.cern,https://root.cern/doc/master/classTStreamerBase.html,1,['cache'],['cached']
Performance,"se class of the object or a (non-static and non-transient) data member of the object. If the base class or data member is itself a class, then there will also be a streamerinfo object in the record for that class. In this way, each class is recursively decomposed into its atomic elements, each of which is a simple type (e.g. ""int""). A ""long"" or ""unsigned long"" member is always written as an 8 byte quantity, even if it occupies only 4 bytes in memory.; A data member of a class is marked transient on the line of its declaration by a comment beginning with ""//!"". Such members are not written to disk, nor is there any streamerinfo for such a member.; A data member that is a C++ pointer (not to be confused with ""pointers to persistent; objects"" described below) is never written to disk as a pointer value. If it is a pointer to an object, the object itself (or 0 (4 bytes) if the pointer value is NULL) is written. If the declaration line has a comment beginning with ""//->"", this indicates that the pointer value will never be null, which allows a performance optimization. Another optimization is that if two or more pointers pointing to the same object are streamed in the same I/O operation, the object is written only once. The remaining pointers reference the object through a unique object identifier. This saves space and avoids the infinite loop that might otherwise arise if the directed graph of object instance pointer references contains a cycle.; If a data member is a pointer to a simple type, the Streamer presumes it is an array, with the dimension defined in a comment of the form ""//[<length>]"", where length is either an integer constant or a variable that is an integer data member of the class. If a variable is used, it must be defined ahead of its use or in a base class.; The above describes the function of the StreamerInfo record in decomposing a self-identifying object if the user uses the streamer generated by ""rootcint"". There are two reasons why a user may need",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rootio.html:8544,perform,performance,8544,doc/master/rootio.html,https://root.cern,https://root.cern/doc/master/rootio.html,2,"['optimiz', 'perform']","['optimization', 'performance']"
Performance,"se of error and TSelector::GetStatus() in; in case of success. The code in filename is loaded (interpreted or compiled, see below),; filename must contain a valid class implementation derived from TSelector,; where TSelector has the following member functions:. Begin(): called every time a loop on the tree starts,; a convenient place to create your histograms.; SlaveBegin(): called after Begin(), when on PROOF called only on the; slave servers.; Process(): called for each event, in this function you decide what; to read and fill your histograms.; SlaveTerminate: called at the end of the loop on the tree, when on PROOF; called only on the slave servers.; Terminate(): called at the end of the loop on the tree,; a convenient place to draw/fit your histograms. If filename is of the form file.C, the file will be interpreted.; If filename is of the form file.C++, the file file.C will be compiled; and dynamically loaded.; If filename is of the form file.C+, the file file.C will be compiled; and dynamically loaded. At next call, if file.C is older than file.o; and file.so, the file.C is not compiled, only file.so is loaded. NOTE1; It may be more interesting to invoke directly the other Process function; accepting a TSelector* as argument.eg; MySelector *selector = (MySelector*)TSelector::GetSelector(filename);; selector->CallSomeFunction(..);; mytree.Process(selector,..);. NOTE2; One should not call this function twice with the same selector file; in the same script. If this is required, proceed as indicated in NOTE1,; by getting a pointer to the corresponding TSelector,eg; workaround 1. void stubs1() {; TSelector *selector = TSelector::GetSelector(""h1test.C"");; TFile *f1 = new TFile(""stubs_nood_le1.root"");; TTree *h1 = (TTree*)f1->Get(""h1"");; h1->Process(selector);; TFile *f2 = new TFile(""stubs_nood_le1_coarse.root"");; TTree *h2 = (TTree*)f2->Get(""h1"");; h2->Process(selector);; }; or use ACLIC to compile the selector; workaround 2. void stubs2() {; TFile *f1 = new TFile(""st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreePlayer.html:49784,load,loaded,49784,root/html528/TTreePlayer.html,https://root.cern,https://root.cern/root/html528/TTreePlayer.html,16,['load'],['loaded']
Performance,"se values can be changed; by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search; The minimizer algorithm used (by default Minuit) can be changed by callinga; ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); Other option for the minimizer can be set using the static method of the MinimizerOptions class. Note that this method will always do first a grid search in contrast to GetMinimum. Double_t GetMaximumXY(Double_t& x, Double_t& y) const; Compute the X and Y values corresponding to the maximum value of the function; Return the maximum value of the function; See TF2::GetMinimumXY. Double_t GetMinimum(Double_t* x) const; return minimum/maximum value of the function; To find the minimum on a range, first set this range via the SetRange function; If a vector x of coordinate is passed it will be used as starting point for the minimum.; In addition on exit x will contain the coordinate values at the minimuma; If x is NULL or x is inifinity or NaN, first, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search; The minimizer algorithm used (by default Minuit) can be changed by callinga; ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); Other option for the minimizer can be set using the static method of the MinimizerOptions class. Double_t GetMaximum(Double_t* x) const; return maximum value of the function; See TF2::GetMinimum. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function value; corresponding to cursor position px,py. Double_t GetRandom(); Return a random number following this function shape*-; *-* ====================================================; -. Double_t GetRandom(Double_t xmin, Do",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF2.html:27543,perform,performed,27543,root/html604/TF2.html,https://root.cern,https://root.cern/root/html604/TF2.html,2,['perform'],['performed']
Performance,"se values can be changed; by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search; The minimizer algorithm used (by default Minuit) can be changed by callinga; ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); Other option for the minimizer can be set using the static method of the MinimizerOptions class. Note that this method will always do first a grid search in contrast to GetMinimum. Double_t GetMaximumXY(Double_t& x, Double_t& y) const; Compute the X and Y values corresponding to the maximum value of the function; Return the maximum value of the function; See TF2::GetMinimumXY. Double_t GetMinimum(Double_t* x) const; return minimum/maximum value of the function; To find the minimum on a range, first set this range via the SetRange function; If a vector x of coordinate is passed it will be used as starting point for the minimum.; In addition on exit x will contain the coordinate values at the minimuma; If x is NULL or x is inifinity or NaN, first, a grid search is performed to find the initial estimate of the; minimum location. The range of the function is divided into fNpx and fNpy; sub-ranges. If the function is ""good"" (or ""bad""), these values can be changed; by SetNpx and SetNpy functions; Then, a minimization is used with starting values found by the grid search; The minimizer algorithm used (by default Minuit) can be changed by callinga; ROOT::Math::Minimizer::SetDefaultMinimizerType(""..""); Other option for the minimizer can be set using the static method of the MinimizerOptions class. Double_t GetMaximum(Double_t* x) const; return maximum value of the function; See TF2::GetMinimum. char * GetObjectInfo(Int_t px, Int_t py) const; Redefines TObject::GetObjectInfo.; Displays the function value; corresponding to cursor position px,py. Double_t GetRandom(); Return a random number following this function shape. Double_t GetRandom(Double_t xmin, Double_t xmax); Return a random number following this function sh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF2.html:34166,perform,performed,34166,root/html602/TF2.html,https://root.cern,https://root.cern/root/html602/TF2.html,2,['perform'],['performed']
Performance,"se {; 3553 onIndexError = kBuild;; 3554 }; 3555 Ssiz_t cacheSizeLoc = opt.Index(""cachesize="");; 3556 Long64_t cacheSize = -1;; 3557 if (cacheSizeLoc != TString::kNPOS) {; 3558 // If the parse faile, cacheSize stays at -1.; 3559 Ssiz_t cacheSizeEnd = opt.Index("" "",cacheSizeLoc+10) - (cacheSizeLoc+10);; 3560 TSubString cacheSizeStr( opt(cacheSizeLoc+10,cacheSizeEnd) );; 3561 auto parseResult = ROOT::FromHumanReadableSize(cacheSizeStr,cacheSize);; 3562 if (parseResult == ROOT::EFromHumanReadableSize::kParseFail) {; 3563 Warning(""CopyEntries"",""The cachesize option can not be parsed: %s. The default size will be used."",cacheSizeStr.String().Data());; 3564 } else if (parseResult == ROOT::EFromHumanReadableSize::kOverflow) {; 3565 double m;; 3566 const char *munit = nullptr;; 3567 ROOT::ToHumanReadableSize(std::numeric_limits<decltype(cacheSize)>::max(),false,&m,&munit);; 3568 ; 3569 Warning(""CopyEntries"",""The cachesize option is too large: %s (%g%s max). The default size will be used."",cacheSizeStr.String().Data(),m,munit);; 3570 }; 3571 }; 3572 if (gDebug > 0 && cacheSize != -1) Info(""CopyEntries"",""Using Cache size: %lld\n"",cacheSize);; 3573 ; 3574 Long64_t nbytes = 0;; 3575 Long64_t treeEntries = tree->GetEntriesFast();; 3576 if (nentries < 0) {; 3577 nentries = treeEntries;; 3578 } else if (nentries > treeEntries) {; 3579 nentries = treeEntries;; 3580 }; 3581 ; 3582 if (fastClone && (nentries < 0 || nentries == tree->GetEntriesFast())) {; 3583 // Quickly copy the basket without decompression and streaming.; 3584 Long64_t totbytes = GetTotBytes();; 3585 for (Long64_t i = 0; i < nentries; i += tree->GetTree()->GetEntries()) {; 3586 if (tree->LoadTree(i) < 0) {; 3587 break;; 3588 }; 3589 if ( withIndex ) {; 3590 withIndex = R__HandleIndex( onIndexError, this, tree );; 3591 }; 3592 if (this->GetDirectory()) {; 3593 TFile* file2 = this->GetDirectory()->GetFile();; 3594 if (file2 && (file2->GetEND() > TTree::GetMaxTreeSize())) {; 3595 if (this->GetDirectory() == (TDirectory*)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:141509,cache,cacheSizeStr,141509,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['cache'],['cacheSizeStr']
Performance,"se, bool gettreeheader=false);  Enable/Disable PROOF processing on the current default Proof (gProof). ;  ; void SetWeight (Double_t w=1, Option_t *option="""") override;  Set chain weight. ;  ; void Streamer (TBuffer &) override;  Stream a class object. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; virtual void UseCache (Int_t maxCacheSize=10, Int_t pageSize=0);  Dummy function kept for back compatibility. ;  ;  Public Member Functions inherited from TTree;  TTree ();  Default constructor and I/O constructor. ;  ;  TTree (const char *name, const char *title, Int_t splitlevel=99, TDirectory *dir=(::ROOT::Internal::TDirectoryAtomicAdapter{}));  Normal tree constructor. ;  ;  TTree (const TTree &tt)=delete;  ;  ~TTree () override;  Destructor. ;  ; void AddAllocationCount (UInt_t count);  ; virtual Int_t AddBranchToCache (const char *bname, bool subbranches=false);  Add branch with name bname to the Tree cache. ;  ; virtual Int_t AddBranchToCache (TBranch *branch, bool subbranches=false);  Add branch b to the Tree cache. ;  ; void AddClone (TTree *);  Add a cloned tree to our list of trees to be notified whenever we change our branch addresses or when we are deleted. ;  ; virtual void AddTotBytes (Int_t tot);  ; virtual void AddZipBytes (Int_t zip);  ; virtual Long64_t AutoSave (Option_t *option="""");  AutoSave tree header every fAutoSave bytes. ;  ; virtual Int_t Branch (const char *folder, Int_t bufsize=32000, Int_t splitlevel=99);  Create one branch for each element in the folder. ;  ; TBranch * Branch (const char *name, char *address, const char *leaflist, Int_t bufsize=32000);  ; template<class T > ; TBranch * Branch (const char *name, const char *classname, T **addobj, Int_t bufsize=32000, Int_t splitlevel=99);  ; template<class T > ; TBranch * Branch (const char *name, const char *classname, T *obj, Int_t bufsize=32000, Int_t splitlevel=99);  ; virtual TBranch * Branch (const char *name, const char *classname, void *addobj, Int_t bufsize=32",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTChain.html:13067,cache,cache,13067,doc/v632/classTChain.html,https://root.cern,https://root.cern/doc/v632/classTChain.html,2,['cache'],['cache']
Performance,"se, the method TGeoManager::Safety () is invoked. A safety value less than TGeoShape::Tolerance() will set the flag IsOnBoundary to true. On the other hand, a safety value bigger than the proposed step will stop the computation of the distance to next boundary, returning the current geometry location with the meaning that the proposed step is safe.; The next stage is to check if computation of the distance to a give physical object specified by a path was required. If this is the case, the modeller changes the state to point to the required object, converts the current point and direction coordinates to the local frame of this object and computes the distance to its shape. The node returned is the one pointed by the input path in case the shape is crossed; otherwise the returned value is NULL. In case the distance to next crossed boundary is required, the current point has to be physically INSIDE the shape pointed by the current volume. This is only insured in case a call to TGeoManager::FindNode() was performed for the current point. Therefore, the first step is to convert the global current point and direction in the local reference frame of the current volume and to compute the distance to exit its shape from inside. The returned value is again compared to the maximum allowed step (the proposed one) and in case the distance is safe no other action is performed and the proposed step is approved. In case the boundary is closer, the computed distance is taken as maximum allowed step. For optimization purposed, for particles starting very close to the current volume boundary (less than 0.01 microns) and exiting the algorithm stops here.; After computing the distance to exit the current node, the distance to the daughter of the current volume which is crossed next is computed by TGeoManager::FindNextDaughterBoundary(). This computes the distance to all daughter candidates that can be possibly crossed by using volume voxelization. The algorithm is efficient in average ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/group__Geometry.html:133530,perform,performed,133530,doc/master/group__Geometry.html,https://root.cern,https://root.cern/doc/master/group__Geometry.html,3,['perform'],['performed']
Performance,"se. RooCompositeDataStore(const RooCompositeDataStore& other, const RooArgSet& vars, const char* newname = 0); Update index category pointer, if it is contained in input argument vars. ~RooCompositeDataStore(); Destructor. Bool_t valid() const; Return true if currently loaded coordinate is considered valid within; the current range definitions of all observables. Int_t fill(); Forward fill request to appropriate subset. Double_t sumEntries() const; Forward fill request to appropriate subset. const RooArgSet* get(Int_t index) const; Load the n-th data point (n='idx') in memory; and return a pointer to the internal RooArgSet; holding its coordinates. Double_t weight() const. Double_t weight(Int_t index) const. Double_t weightError(RooAbsData::ErrorType etype = RooAbsData::Poisson) const. void weightError(Double_t& lo, Double_t& hi, RooAbsData::ErrorType etype = RooAbsData::Poisson) const. Bool_t isWeighted() const. void loadValues(const RooAbsDataStore* tds, const RooFormulaVar* select = 0, const char* rangeName = 0, Int_t nStart = 0, Int_t nStop = 2000000000). Bool_t changeObservableName(const char* from, const char* to); Change name of internal observable named 'from' into 'to'. RooAbsArg* addColumn(RooAbsArg& var, Bool_t adjustRange = kTRUE); WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all; arguments, but only does for the first one here... RooArgSet* addColumns(const RooArgList& varList); WVE ownership issue here!! Caller (a RooAbsData) should take ownership of all; arguments, but only does for the first one here... RooAbsDataStore* merge(const RooArgSet& allvars, list<RooAbsDataStore*> dstoreList). void append(RooAbsDataStore& other). Int_t numEntries() const. void reset(). void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0). void setArgStatus(const RooArgSet& set, Bool_t active). void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Initialize cache of dataset: attach variables of ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooCompositeDataStore.html:11147,load,loadValues,11147,root/html532/RooCompositeDataStore.html,https://root.cern,https://root.cern/root/html532/RooCompositeDataStore.html,2,['load'],['loadValues']
Performance,"se.; Nodes can be declared as ""overlapping"" in case they do overlap with other nodes inside the same container or extrude this container. Non-overlapping nodes can be created with:; TGeoVolume::AddNode(TGeoVolume *daughter, Int_t copy_No, TGeoMatrix *matr);; TGeoMatrixGeometrical transformation package.Definition TGeoMatrix.h:38; TGeoVolumeTGeoVolume, TGeoVolumeMulti, TGeoVolumeAssembly are the volume classes.Definition TGeoVolume.h:43; TGeoVolume::AddNodevirtual TGeoNode * AddNode(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:975; int; The creation of overlapping nodes can be done with a similar prototype:; TGeoVolume::AddNodeOverlap(same arguments);; TGeoVolume::AddNodeOverlapvirtual void AddNodeOverlap(TGeoVolume *vol, Int_t copy_no, TGeoMatrix *mat=nullptr, Option_t *option="""")Add a TGeoNode to the list of nodes.Definition TGeoVolume.cxx:1044; When closing the geometry, overlapping nodes perform a check of possible overlaps with their neighbours. These are stored and checked all the time during navigation, therefore navigation is slower when embedding such nodes into geometry.; Node have visualization attributes as volume have. When undefined by users, painting a node on a pad will take the corresponding volume attributes. Definition at line 39 of file TGeoNode.h. Public Types; enum  { ;   kGeoNodeMatrix = (1ULL << ( 14 )); , kGeoNodeOffset = (1ULL << ( 15 )); , kGeoNodeVC = (1ULL << ( 16 )); , kGeoNodeOverlap = (1ULL << ( 17 )); , ;   kGeoNodeCloned = (1ULL << ( 18 )). };  ;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoNode.html:3531,perform,perform,3531,doc/master/classTGeoNode.html,https://root.cern,https://root.cern/doc/master/classTGeoNode.html,1,['perform'],['perform']
Performance,"se::GetXmaxDouble_t GetXmax(Int_t ivar) constDefinition MethodBase.h:357; TMVA::MethodBase::GetMulticlassTrainingEfficiencyvirtual std::vector< Float_t > GetMulticlassTrainingEfficiency(std::vector< std::vector< Float_t > > &purity)Definition MethodBase.cxx:2715; TMVA::MethodBase::fDataSetInfoDataSetInfo & fDataSetInfoDefinition MethodBase.h:607; TMVA::MethodBase::fHasMVAPdfsBool_t fHasMVAPdfsMVA Pdfs are created for this classifier.Definition MethodBase.h:680; TMVA::MethodBase::WriteStateToStreamvoid WriteStateToStream(std::ostream &tf) constgeneral method used in writing the header of the weight files where the used variables,...Definition MethodBase.cxx:1267; TMVA::MethodBase::GetRarityvirtual Double_t GetRarity(Double_t mvaVal, Types::ESBType reftype=Types::kBackground) constcompute rarity:Definition MethodBase.cxx:2285; TMVA::MethodBase::fUseDecorrBool_t fUseDecorrDefinition MethodBase.h:723; TMVA::MethodBase::SetTuneParametersvirtual void SetTuneParameters(std::map< TString, Double_t > tuneParameters)set the tuning parameters according to the argument This is just a dummy .Definition MethodBase.cxx:644; TMVA::MethodBase::GetTrainTimeDouble_t GetTrainTime() constDefinition MethodBase.h:162; TMVA::MethodBase::SetBaseDirvoid SetBaseDir(TDirectory *methodDir)Definition MethodBase.h:373; TMVA::MethodBase::ReadStateFromStreamvoid ReadStateFromStream(std::istream &tf)read the header from the weight files of the different MVA methodsDefinition MethodBase.cxx:1590; TMVA::MethodBase::AddVarsXMLTovoid AddVarsXMLTo(void *parent) constwrite variable info to XMLDefinition MethodBase.cxx:1762; TMVA::MethodBase::HelpBool_t Help() constDefinition MethodBase.h:504; TMVA::MethodBase::fSplRefBTSpline1 * fSplRefBDefinition MethodBase.h:703; TMVA::MethodBase::fJobNameTString fJobNameDefinition MethodBase.h:614; TMVA::MethodBase::fIPyCurrentIterUInt_t fIPyCurrentIterDefinition MethodBase.h:450; TMVA::MethodBase::GetTransformationHandlerTransformationHandler & GetTransformationHandle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodBase_8h_source.html:59654,tune,tuneParameters,59654,doc/master/MethodBase_8h_source.html,https://root.cern,https://root.cern/doc/master/MethodBase_8h_source.html,1,['tune'],['tuneParameters']
Performance,"se::fFactory; TMatrixDSparsefKkt; Int_tTQpLinSolverBase::fMclo; Int_tTQpLinSolverBase::fMcup; Int_tTQpLinSolverBase::fMy; Int_tTQpLinSolverBase::fMz; TVectorDTQpLinSolverBase::fNomegaInvstores a critical diagonal matrix as a vector; Int_tTQpLinSolverBase::fNxdimensions of the vectors in the general QP formulation; Int_tTQpLinSolverBase::fNxlo; Int_tTQpLinSolverBase::fNxupdimensions of the upper and lower bound vectors; TVectorDTQpLinSolverBase::fRhsright-hand side of the system; TDecompSparsefSolveSparse; TVectorDTQpLinSolverBase::fXloIndex; TVectorDTQpLinSolverBase::fXupIndexindex matrices for the upper and lower bounds on x and Cx. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TQpLinSolverSparse(TQpProbSparse* factory, TQpDataSparse* data); Constructor. TQpLinSolverSparse(const TQpLinSolverSparse& another); Copy constructor. void Factor(TQpDataBase* prob, TQpVar* vars); Sets up the matrix for the main linear system in ""augmented system"" form. void PutXDiagonal(TVectorD& xdiag); Places the diagonal resulting from the bounds on x into the augmented system matrix. void PutZDiagonal(TVectorD& zdiag); Places the diagonal resulting from the bounds on Cx into the augmented system matrix. void SolveCompressed(TVectorD& rhs); Perform the actual solve using the factors produced in factor.; rhs on input contains the aggregated right-hand side of the augmented system;; on output contains the solution in aggregated form . TQpLinSolverSparse & operator=(const TQpLinSolverSparse& source); Assignment operator. TQpLinSolverSparse(); {}. virtual ~TQpLinSolverSparse(); {}. » Author: Eddy Offermann May 2004 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/quadp:$Id: TQpLinSolverSparse.h 20882 2007-11-19 11:31:26Z rdm $ » Last generated: 2011-11-03 20:22; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TQpLinSolverSparse.html:7668,Perform,Perform,7668,root/html532/TQpLinSolverSparse.html,https://root.cern,https://root.cern/root/html532/TQpLinSolverSparse.html,1,['Perform'],['Perform']
Performance,"se; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with cache contents to copied instances of functions. void setArgStatus(const RooArgSet& set, Bool_t active). void setDirtyProp(Bool_t flag); Control propagation of dirty flags from observables in dataset. RooAbsData* reduce(const RooCmdArg& arg1, const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg()); Create a reduced copy of this dataset. The caller takes ownership of the returned dataset. The following optional named arguments are accepted. SelectVars(const RooArgSet& vars) -- Only retain the listed observables in the output datas",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsData.html:14667,cache,cacheArgs,14667,root/html530/RooAbsData.html,https://root.cern,https://root.cern/root/html530/RooAbsData.html,1,['cache'],['cacheArgs']
Performance,"se; kTreeStructure; };. protected:. TString_convVarNameName of convolution variable; RooRealVar*_cvModelConvolution variable in resModel event; RooRealVar*_cvOutConvolution variable in output event; RooRealVar*_cvPdfConvolution variable in PDFxTruth event; UInt_tRooAbsGenContext::_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendModeRooAbsGenContext::_extendModeExtended mode capabilities of p.d.f.; RooDataSet*RooAbsGenContext::_genData! Data being generated; Bool_tRooAbsGenContext::_isValidIs context in valid state?; RooArgSet*_modelCloneSetOwner of resModel clone; RooAbsGenContext*_modelGenResolution model generator context; RooArgSet*_modelVarsHolder of resModel event; RooArgSet*_modelVarsOwnedOwning version of modelVars ;; static Int_tRooPrintable::_nameLength; Int_tRooAbsGenContext::_nextProtoIndexNext prototype event to load according to LUT; TStringRooAbsGenContext::_normRangeNormalization range of pdf; RooArgSet*_pdfCloneSetOwner of PDF clone; RooAbsGenContext*_pdfGenPhysics model generator context; RooArgSet*_pdfVarsHolder of PDF x truth event; RooArgSet*_pdfVarsOwnedOwning version of pdfVars ;; Int_t*RooAbsGenContext::_protoOrderLUT with traversal order of prototype data; RooArgSetRooAbsGenContext::_protoVarsPrototype observables; const RooDataSet*RooAbsGenContext::_prototypePointer to prototype dataset; RooArgSet*RooAbsGenContext::_theEventPointer to observable event being generated; Bool_tRooAbsGenContext::_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooConvGenContext(const RooAbsAnaConvPdf& model, const RooArgSet& vars, const RooDataSet* prototype = 0, const RooArgSet* auxProto = 0, Bool_t _verbose = kFALSE); Constructor for specialized generator context for analytical convolutions. Builds a generator for the physics PDF convoluted with the truth model; and a generator for the res",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooConvGenContext.html:8704,load,load,8704,root/html528/RooConvGenContext.html,https://root.cern,https://root.cern/root/html528/RooConvGenContext.html,6,['load'],['load']
Performance,"seCount() << std::endl;; 1341 // should we apply droput to the loss ??; 1342 minValError += deepNet.Loss(inputTensor, outputMatrix, weights, false, includeRegularization);; 1343 }; 1344 // add Regularization term; 1345 Double_t regzTerm = (includeRegularization) ? deepNet.RegularizationTerm() : 0.0;; 1346 minValError /= (Double_t)(nValidationSamples / settings.batchSize);; 1347 minValError += regzTerm;; 1348 ; 1349 ; 1350 // create a pointer to base class VOptimizer; 1351 std::unique_ptr<DNN::VOptimizer<Architecture_t, Layer_t, DeepNet_t>> optimizer;; 1352 ; 1353 // initialize the base class pointer with the corresponding derived class object.; 1354 switch (O) {; 1355 ; 1356 case EOptimizer::kSGD:; 1357 optimizer = std::unique_ptr<DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>>(; 1358 new DNN::TSGD<Architecture_t, Layer_t, DeepNet_t>(settings.learningRate, deepNet, settings.momentum));; 1359 break;; 1360 ; 1361 case EOptimizer::kAdam: {; 1362 optimizer = std::unique_ptr<DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>>(; 1363 new DNN::TAdam<Architecture_t, Layer_t, DeepNet_t>(; 1364 deepNet, settings.learningRate, settings.optimizerParams[""ADAM_beta1""],; 1365 settings.optimizerParams[""ADAM_beta2""], settings.optimizerParams[""ADAM_eps""]));; 1366 break;; 1367 }; 1368 ; 1369 case EOptimizer::kAdagrad:; 1370 optimizer = std::unique_ptr<DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>>(; 1371 new DNN::TAdagrad<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate,; 1372 settings.optimizerParams[""ADAGRAD_eps""]));; 1373 break;; 1374 ; 1375 case EOptimizer::kRMSProp:; 1376 optimizer = std::unique_ptr<DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>>(; 1377 new DNN::TRMSProp<Architecture_t, Layer_t, DeepNet_t>(deepNet, settings.learningRate, settings.momentum,; 1378 settings.optimizerParams[""RMSPROP_rho""],; 1379 settings.optimizerParams[""RMSPROP_eps""]));; 1380 break;; 1381 ; 1382 case EOptimizer::kAdadelta:; 1383 optimizer = std::unique_ptr<DNN::TAdadelta<Architect",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/MethodDL_8cxx_source.html:53851,optimiz,optimizer,53851,doc/master/MethodDL_8cxx_source.html,https://root.cern,https://root.cern/doc/master/MethodDL_8cxx_source.html,1,['optimiz'],['optimizer']
Performance,"seFunc. Definition at line 232 of file IParamFunction.h. ◆ BaseGradFunc. template<class T > . using ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::BaseGradFunc = IGradientFunctionMultiDimTempl<T>. Definition at line 231 of file IParamFunction.h. ◆ BaseParamFunc. template<class T > . using ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::BaseParamFunc = IParametricFunctionMultiDimTempl<T>. Definition at line 230 of file IParamFunction.h. Constructor & Destructor Documentation. ◆ ~IParametricGradFunctionMultiDimTempl(). template<class T > . ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::~IParametricGradFunctionMultiDimTempl ; (; ). inlineoverride . Virtual Destructor (no operations) ; Definition at line 238 of file IParamFunction.h. Member Function Documentation. ◆ DoEval(). template<class T > . T ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::DoEval ; (; const T * ; x); const. inlineoverrideprivatevirtual . Implement the ROOT::Math::IBaseFunctionMultiDim interface DoEval(x) using the cached parameter values. ; Reimplemented from ROOT::Math::IParametricFunctionMultiDimTempl< T >.; Reimplemented in ROOT::Math::WrappedMultiTF1Templ< T >.; Definition at line 307 of file IParamFunction.h. ◆ DoEvalPar(). template<class T > . T ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::DoEvalPar ; (; const T * ; x, . const double * ; p . ); const. overrideprivatepure virtual . Implementation of the evaluation function using the x values and the parameters. ; Must be implemented by derived classes ; Implements ROOT::Math::IParametricFunctionMultiDimTempl< T >.; Implemented in ROOT::Math::WrappedMultiTF1Templ< T >. ◆ DoParameterDerivative(). template<class T > . virtual T ROOT::Math::IParametricGradFunctionMultiDimTempl< T >::DoParameterDerivative ; (; const T * ; x, . const double * ; p, . unsigned int ; ipar . ); const. privatepure virtual . Evaluate the partial derivative w.r.t a parameter ipar , to be implemented by the derived classes. ; Implemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html:5962,cache,cached,5962,doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1IParametricGradFunctionMultiDimTempl.html,1,['cache'],['cached']
Performance,"seNonDerived = false . ); const. Fill supplied list with all leaf nodes of the arg tree, starting with ourself as top node. ; A leaf node is node that has no servers declared. ; Definition at line 472 of file RooAbsArg.cxx. ◆ localNoDirtyInhibit(). bool RooAbsArg::localNoDirtyInhibit ; (; ); const. inline . Definition at line 675 of file RooAbsArg.h. ◆ makeLegacyIterator(). RooAbsArg::RefCountListLegacyIterator_t * RooAbsArg::makeLegacyIterator ; (; const RefCountList_t & ; list); const. private . Definition at line 2464 of file RooAbsArg.cxx. ◆ namePtr(). const TNamed * RooAbsArg::namePtr ; (; ); const. inline . De-duplicated pointer to this object's name. ; This can be used for fast name comparisons. like if (namePtr() == other.namePtr()). NoteTNamed::GetName() will return a pointer that's different for each object, but namePtr() always points to a unique instance. ; Definition at line 535 of file RooAbsArg.h. ◆ numCaches(). Int_t RooAbsArg::numCaches ; (; ); const. Return number of registered caches. ; Definition at line 2136 of file RooAbsArg.cxx. ◆ numProxies(). Int_t RooAbsArg::numProxies ; (; ); const. Return the number of registered proxies. ; Definition at line 1457 of file RooAbsArg.cxx. ◆ observableOverlaps() [1/2]. bool RooAbsArg::observableOverlaps ; (; const RooAbsData * ; dset, . const RooAbsArg & ; testArg . ); const. Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; Definition at line 914 of file RooAbsArg.cxx. ◆ observableOverlaps() [2/2]. bool RooAbsArg::observableOverlaps ; (; const RooArgSet * ; depList, . const RooAbsArg & ; testArg . ); const. Test if any of the dependents of the arg tree (as determined by getObservables) overlaps with those of the testArg. ; Definition at line 924 of file RooAbsArg.cxx. ◆ operator=(). RooAbsArg & RooAbsArg::operator= ; (; const RooAbsArg & ; other). delete . ◆ operator==(). virtual bool RooAbsArg::operator== ; (; const RooAbsArg & ; other); c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:76519,cache,caches,76519,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['cache'],['caches']
Performance,"seRegulatorzjh; TRandom3*TMVA::MethodANNBase::frgenrandom number generator for various uses. private:. TMVA::MethodMLP::EBPTrainingModefBPModebackprop learning mode (sequential or batch); Int_tfBatchSizebatch size, only matters if in batch learning mode; TStringfBpModeSbackprop learning mode option string (sequential or batch); boolfCalculateErrorscompute inverse hessian matrix at the end of the training; Double_tfDecayRatedecay rate for above learning rate; vector<std::pair<Float_t,Float_t> >*fDeviationsFromTargetsdeviation from the targets, event weight; Bool_tfEpochMoncreate and fill epoch-wise monitoring histograms (makes outputfile big!); Double_tfGA_SC_factorGA settings: SC_factor; Int_tfGA_SC_rateGA settings: SC_rate; Int_tfGA_SC_stepsGA settings: SC_steps; Int_tfGA_nstepsGA settings: number of steps; Int_tfGA_preCalcGA settings: number of pre-calc steps; Double_tfLastAlphaline search variable; Double_tfLearnRatelearning rate for synapse weight adjustments; Double_tfPriorzjh; vector<Double_t>fPriorDevzjh; Int_tfResetStepreset time (how often we clear hessian matrix); Float_tfSamplingEpochfraction of epochs where sampling is used; Float_tfSamplingFractionfraction of events which is sampled for training; Bool_tfSamplingTestingThe testing sample is sampled; Bool_tfSamplingTrainingThe training sample is sampled; Float_tfSamplingWeightchanging factor for event weights when sampling is turned on; Double_tfTauline search variable; Int_tfTestRatetest for overtraining performed at each #th epochs; TStringfTrainMethodStraining method option param; TMVA::MethodMLP::ETrainingMethodfTrainingMethodmethod of training, BP or GA; Int_tfUpdateLimitzjh; boolfUseRegulatorzjh; Float_tfWeightRangesuppress outliers for the estimator calculation; static const Bool_tfgPRINT_BATCHdebug flags; static const Int_tfgPRINT_ESTIMATOR_INCdebug flags; static const Bool_tfgPRINT_SEQdebug flags. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; MethodMLP(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TMVA__MethodMLP.html:21940,perform,performed,21940,root/html530/TMVA__MethodMLP.html,https://root.cern,https://root.cern/root/html530/TMVA__MethodMLP.html,5,['perform'],['performed']
Performance,"seTransform(const TMVA::Event*const , Int_t cls) const; apply the principal component analysis; TODO: implementation of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*>& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-02 16:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TMVA__VariablePCATransform.html:11811,Perform,Perform,11811,root/html604/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html604/TMVA__VariablePCATransform.html,1,['Perform'],['Perform']
Performance,"seTransform(const TMVA::Event*const , Int_t cls) const; apply the principal component analysis; TODO: implementation of inverse transformation; Log() << kFATAL << ""Inverse transformation for PCA transformation not yet implemented. Hence, this transformation cannot be applied together with regression. Please contact the authors if necessary."" << Endl;. void CalculatePrincipalComponents(const vector<TMVA::Event*>& ); calculate the principal components for the signal and the background data; it uses the MakePrincipal method of ROOT's TPrincipal class. void X2P(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Calculate the principal components from the original data vector; x, and return it in p (function extracted from TPrincipal::X2P); It's the users responsibility to make sure that both x and p are; of the right size (i.e., memory must be allocated for p). void P2X(vector<Float_t>& , const vector<Float_t>& , Int_t cls) const; Perform the back-transformation from the principal components; pc, and return x; It's the users responsibility to make sure that both x and pc are; of the right size (i.e., memory must be allocated for p). void WriteTransformationToStream(ostream& ) const; write mean values to stream. void AttachXMLTo(void* parent); create XML description of PCA transformation. void ReadFromXML(void* trfnode); Read the transformation matrices from the xml node. void ReadTransformationFromStream(istream& , const TString& ); Read mean values from input stream. void MakeFunction(ostream& fout, const TString& fncName, Int_t part, UInt_t trCounter, Int_t cls); creates C++ code fragment of the PCA transform for inclusion in standalone C++ class. VariablePCATransform( DataSetInfo& dsi ). » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generated: 2015-06-30 15:18; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please sen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__VariablePCATransform.html:11803,Perform,Perform,11803,root/html602/TMVA__VariablePCATransform.html,https://root.cern,https://root.cern/root/html602/TMVA__VariablePCATransform.html,1,['Perform'],['Perform']
Performance,sed by RooFit ;  CRooNumCdfClass RooNumCdf is an implementation of RooNumRunningInt specialized to calculate cumulative distribution functions from p.d.f.s ;  CRooNumConvolutionNumeric 1-dimensional convolution operator PDF ;  CRooNumConvPdfNumeric 1-dimensional convolution operator PDF ;  CRooNumGenConfigRooNumGenConfig holds the configuration parameters of the various numeric integrators used by RooRealIntegral ;  CRooNumGenFactoryRooNumGenFactory is a factory to instantiate numeric integrators from a given function binding and a given configuration ;  CRooNumIntConfigRooNumIntConfig holds the configuration parameters of the various numeric integrators used by RooRealIntegral ;  CRooNumIntFactoryRooNumIntFactory is a factory to instantiate numeric integrators from a given function binding and a given configuration ;  ►CRooNumRunningIntClass RooNumRunningInt is an implementation of RooAbsCachedReal that represents a running integral ;  CRICacheElem;  CRooObjCacheManagerClass RooObjCacheManager is an implementation of class RooCacheManager<RooAbsCacheElement> and specializes in the storage of cache elements that contain RooAbsArg objects ;  CRooParamBinningClass RooParamBinning is an implementation of RooAbsBinning that constructs a binning with a range definition that depends on external RooAbsReal objects ;  CRooParametricStepFunctionThe Parametric Step Function PDF is a binned distribution whose parameters are the heights of each bin ;  CRooParamHistFunc;  ►CRooPlotA RooPlot is a plot frame and a container for graphics objects within that frame ;  CDrawOpt;  CRooPlotableClass RooPotable is a base class for objects that can be inserted into RooPlots and take advantage of its internal normalization and axis range adjustment features ;  CRooPoissonPoisson pdf ;  CRooPolynomialRooPolynomial implements a polynomial p.d.f of the form ;  CRooPolyVarClass RooPolyVar is a RooAbsReal implementing a polynomial in terms of a list of RooAbsReal coefficients ;  CRooPrintableRoo,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v616/annotated.html:122777,cache,cache,122777,doc/v616/annotated.html,https://root.cern,https://root.cern/doc/v616/annotated.html,1,['cache'],['cache']
Performance,"sed bytes of a page into the memory buffer provided by sealedPage. ; The sealed page can be used subsequently in a call to RPageSink::CommitSealedPage. The fSize and fNElements member of the sealedPage parameters are always set. If sealedPage.fBuffer is nullptr, no data will be copied but the returned size information can be used by the caller to allocate a large enough buffer and call LoadSealedPage again. ; Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ LoadStructure(). void ROOT::Experimental::Internal::RPageSource::LoadStructure ; (; ). Loads header and footer without decompressing or deserializing them. ; This can be used to asynchronously open a file in the background. The method is idempotent and it is called as a first step in Attach(). Pages sources may or may not make use of splitting loading and processing meta-data. Therefore, LoadStructure() may do nothing and defer loading the meta-data to Attach(). ; Definition at line 188 of file RPageStorage.cxx. ◆ LoadStructureImpl(). virtual void ROOT::Experimental::Internal::RPageSource::LoadStructureImpl ; (; ). protectedpure virtual . Implemented in ROOT::Experimental::Internal::RPageSourceFriends, ROOT::Experimental::Internal::RPageSourceDaos, and ROOT::Experimental::Internal::RPageSourceFile. ◆ operator=() [1/2]. RPageSource & ROOT::Experimental::Internal::RPageSource::operator= ; (; const RPageSource & ; ). delete . ◆ operator=() [2/2]. RPageSource & ROOT::Experimental::Internal::RPageSource::operator= ; (; RPageSource && ; ). delete . ◆ PrepareLoadCluster(). void ROOT::Experimental::Internal::RPageSource::PrepareLoadCluster ; (; const RCluster::RKey & ; clusterKey, . ROnDiskPageMap & ; pageZeroMap, . std::function< void(DescriptorId_t, NTupleSize_t, const RClusterDescriptor::RPageRange::RPageInfo &)> ; perPageFunc . ). protected . Prepare a page range read for the column set in clusterKey. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html:17481,load,loading,17481,doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1Internal_1_1RPageSource.html,1,['load'],['loading']
Performance,"sed when a key (or basket) is transfered from one file to the other. ;  ; void SetReadParam (Int_t mapsize) override;  Set the initial size of the map used to store object and class references during reading. ;  ; void SetWriteParam (Int_t mapsize) override;  Set the initial size of the hashtable used to store object and class references during writing. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TagStreamerInfo (TVirtualStreamerInfo *info) override;  Mark the classindex of the current file as using this TStreamerInfo. ;  ; Int_t WriteClones (TClonesArray *a, Int_t nobjects) override;  Interface to TStreamerInfo::WriteBufferClones. ;  ; template<class T > ; Int_t WriteObject (const T *objptr, Bool_t cacheReuse=kTRUE);  ; virtual void WriteObject (const TObject *obj, Bool_t cacheReuse)=0;  ; void WriteObject (const TObject *obj, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; Int_t WriteObjectAny (const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; UShort_t WriteProcessID (TProcessID *pid) override;  Check if the ProcessID pid is already in the file. ;  ;  Public Member Functions inherited from TBuffer;  TBuffer (EMode mode);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz, void *buf, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  Create an I/O buffer object. ;  ; virtual ~TBuffer ();  Delete an I/O buffer object. ;  ; void AutoExpand (Int_t size_needed);  Automatically calculate a new size and expand the buffer to fit at least size_needed. ;  ; char * Buffer () const;  ; Int_t BufferSize () const;  ; Bool_t ByteSwapBuffer (Long64_t n, EDataType type);  Byte-swap N primitive-elements in the buffer. ;  ; virtual void ClassBegin (const TClass *, Version_t=-1)=0;  ; virtual void ClassEnd (const TClass *)=0;  ; virtual void ClassMember (const char *, const c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferText.html:10014,cache,cacheReuse,10014,doc/master/classTBufferText.html,https://root.cern,https://root.cern/doc/master/classTBufferText.html,1,['cache'],['cacheReuse']
Performance,"sed when a key (or basket) is transfered from one file to the other. ;  ; void SetReadParam (Int_t mapsize) override;  Set the initial size of the map used to store object and class references during reading. ;  ; void SetWriteParam (Int_t mapsize) override;  Set the initial size of the hashtable used to store object and class references during writing. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void TagStreamerInfo (TVirtualStreamerInfo *info) override;  Mark the classindex of the current file as using this TStreamerInfo. ;  ; Int_t WriteClones (TClonesArray *a, Int_t nobjects) override;  Interface to TStreamerInfo::WriteBufferClones. ;  ; template<class T > ; Int_t WriteObject (const T *objptr, Bool_t cacheReuse=kTRUE);  ; virtual void WriteObject (const TObject *obj, Bool_t cacheReuse)=0;  ; void WriteObject (const TObject *obj, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; Int_t WriteObjectAny (const void *obj, const TClass *ptrClass, Bool_t cacheReuse=kTRUE) override;  Write object to I/O buffer. ;  ; UShort_t WriteProcessID (TProcessID *pid) override;  Check if the ProcessID pid is already in the file. ;  ;  Public Member Functions inherited from TBuffer;  TBuffer (EMode mode);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz);  Create an I/O buffer object. ;  ;  TBuffer (EMode mode, Int_t bufsiz, void *buf, Bool_t adopt=kTRUE, ReAllocCharFun_t reallocfunc=nullptr);  Create an I/O buffer object. ;  ; virtual ~TBuffer ();  Delete an I/O buffer object. ;  ; void AutoExpand (Int_t size_needed);  Automatically calculate a new size and expand the buffer to fit at least size_needed. ;  ; char * Buffer () const;  ; Int_t BufferSize () const;  ; Bool_t ByteSwapBuffer (Long64_t n, EDataType type);  Byte-swap N primitive-elements in the buffer. ;  ; void DetachBuffer ();  ; void Expand (Int_t newsize, Bool_t copy=kTRUE);  Expand (or shrink) the I/O buffer to newsize bytes. ;  ; Int_t GetBufferVersion",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTBufferJSON.html:28273,cache,cacheReuse,28273,doc/master/classTBufferJSON.html,https://root.cern,https://root.cern/doc/master/classTBufferJSON.html,4,['cache'],['cacheReuse']
Performance,"sed; in the main training loop. void TrainAllMethods(); iterates through all booked methods and calls training. void TestAllMethods(). void MakeClass(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void PrintHelpMessage(const TString& methodTitle = """") const; Print predefined help message of classifier; iterate over methods and test. void EvaluateAllVariables(TString options = """"); iterates over all MVA input varables and evaluates them. void EvaluateAllMethods( void ); iterates over all MVAs that have been booked, and calls their evaluation methods. const char* GetName() const; { return ""Factory""; }. void AddRegressionTree(TTree* tree, Double_t weight = 1.0, TMVA::Types::ETreeType treetype = Types::kMaxTreeType); special case: regression. void AddRegressionTarget(const TString& expression, const TString& title = """", const TString& unit = """", Double_t min = 0, Double_t max = 0). MethodBase* BookMethod(TString theMethodName, TString methodTitle, TString theOption = """"). void OptimizeAllMethodsForClassification(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); { OptimizeAllMethods(fomType,fitType); }. void OptimizeAllMethodsForRegression(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); { OptimizeAllMethods(fomType,fitType); }. void TrainAllMethodsForClassification( void ); { TrainAllMethods(); }. void TrainAllMethodsForRegression( void ); { TrainAllMethods(); }. Bool_t Verbose( void ); { return fVerbose; }. TDirectory* RootBaseDir(); { return (TDirectory*)fgTargetFile; }. » Author: Andreas Hoecker, Peter Speckmayer, Joerg Stelzer, Helge Voss, Kai Voss, Eckhard von Toerne, Jan Therhaag » Copyright (c) 2005-2011: *; » Last changed: root/tmva $Id: Factory.h 40005 2011-06-27 15:29:10Z stelzer $ » Last generated: 2011-11-03 20:19; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__Factory.html:20503,Optimiz,OptimizeAllMethodsForClassification,20503,root/html532/TMVA__Factory.html,https://root.cern,https://root.cern/root/html532/TMVA__Factory.html,4,['Optimiz'],"['OptimizeAllMethods', 'OptimizeAllMethodsForClassification', 'OptimizeAllMethodsForRegression']"
Performance,"sedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3115; TROOT::~TROOTvirtual ~TROOT()Clean up and free resources used by ROOT (files, network sockets, shared memory segments,...Definition TROOT.cxx:867; TROOT::fColorsTSeqCollection * fColorsList of colors.Definition TROOT.h:153; TROOT::GetGlobalFunctionWithPrototypeTFunction * GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1718; TROOT::GetListOfBrowsersTSeqCollection * GetListOfBrowsers() constDefinition TROOT.h:245; TROOT::ReadingObjectBool_t ReadingObject() constDeprecated (will be removed in next release).Definition TROOT.cxx:2460; TROOT::fStylesTSeqCollection * fStylesList of styles.Definition TROOT.h:150; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Execute a macro in the interpreter.Definition TROOT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TROOT_8cxx_source.html:155926,load,load,155926,doc/v632/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"sedObjectsTSeqCollection * fClosedObjectsList of closed objects from the list of files and sockets, so we can delete them if neededCl.Definition TROOT.h:145; TROOT::fTasksTSeqCollection * fTasksList of tasks.Definition TROOT.h:152; TROOT::fClipboardTSeqCollection * fClipboardList of clipboard objects.Definition TROOT.h:163; TROOT::GetGitDateconst char * GetGitDate()Return date/time make was run.Definition TROOT.cxx:2474; TROOT::SetEditorModevoid SetEditorMode(const char *mode="""")Set editor mode.Definition TROOT.cxx:2704; TROOT::GetTutorialDirstatic const TString & GetTutorialDir()Get the tutorials directory in the installation. Static utility function.Definition TROOT.cxx:3119; TROOT::~TROOTvirtual ~TROOT()Clean up and free resources used by ROOT (files, network sockets, shared memory segments,...Definition TROOT.cxx:867; TROOT::fColorsTSeqCollection * fColorsList of colors.Definition TROOT.h:153; TROOT::GetGlobalFunctionWithPrototypeTFunction * GetGlobalFunctionWithPrototype(const char *name, const char *proto=nullptr, Bool_t load=kFALSE)Return pointer to global function by name.Definition TROOT.cxx:1718; TROOT::GetListOfBrowsersTSeqCollection * GetListOfBrowsers() constDefinition TROOT.h:245; TROOT::ReadingObjectBool_t ReadingObject() constDeprecated (will be removed in next release).Definition TROOT.cxx:2460; TROOT::fStylesTSeqCollection * fStylesList of styles.Definition TROOT.h:150; TROOT::fVersionDateInt_t fVersionDateDate of ROOT version (ex 951226)Definition TROOT.h:116; TROOT::GetListOfColorsTSeqCollection * GetListOfColors() constDefinition TROOT.h:232; TROOT::MacroLongptr_t Macro(const char *filename, Int_t *error=nullptr, Bool_t padUpdate=kTRUE)Execute a macro in the interpreter.Definition TROOT.cxx:2316; TROOT::fBuiltTimeInt_t fBuiltTimeTime of ROOT built.Definition TROOT.h:119; TROOT::AddExtraInterpreterArgsstatic const std::vector< std::string > & AddExtraInterpreterArgs(const std::vector< std::string > &args)Provide command line arguments to the inter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:156102,load,load,156102,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,1,['load'],['load']
Performance,"see our simple world:; root[] top->SetLineColor(kMagenta);; root[] gGeoManager->SetTopVisible(); // the TOP is invisible; root[] top->Draw();; 18.1.2 Example 2: A Geometrical Hierarchy Look and Feel; Before going further, let us get a look and feel of interacting with the modeller. For this, we will use one of the examples illustrating the geometry package. To get an idea on the geometry structure created in this example, just look at the link: http://root.cern.ch/root/html/tutorials/geom/rootgeom.C.html. You will notice that this is a bit more complex that just creating the “world” since several other volumes are created and put together in a hierarchy. The purpose here is just to learn how to interact with a geometry that is already built, but just few hints on the building steps in this example might be useful. The geometry here represents the word ROOT that is replicated in some symmetric manner. You might for instance ask some questions after having a first look:; Q: “OK, I understand the first lines that load the libGeom library and create a geometry manager object. I also recognize from the previous example the following lines creating some materials and media, but what about the geometrical transformations below?”; A: As explained before, the model that we are trying to create is a hierarchy of volumes based on containment. This is accomplished by positioning some volumes inside others. Any volume is an un-positioned object in the sense that it defines only a local frame (matching the one of its shape). In order to fully define the mother-daughter relationship between two volumes one has to specify how the daughter will be positioned inside. This is accomplished by defining a local geometrical transformation of the daughter with respect to the mother coordinate system. These transformations will be subsequently used in the example.; Q: “I see the lines defining the top level volume as in the previous example, but what about the other volumes named REPLICA and",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:879621,load,load,879621,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['load']
Performance,"see tutorial math.exampleFunctor.C for an example of using this constructor. This constructor is used only when using CINT.; In compiled mode the template constructor is used and in that case className is not needed. void CreateFromCintClass(const char* name, void* ptr, Double_t xmin, Double_t xmax, Int_t npar, const char* cname, const char* fname); Internal function used to create from TF1 from an interpreter CINT class; with the specified type (className) and member function name (methodName). TF1& operator=(const TF1& rhs); Operator =. ~TF1(); TF1 default destructor. void AbsValue(Bool_t reject = kTRUE); Static function: set the fgAbsValue flag.; By default TF1::Integral uses the original function value to compute the integral; However, TF1::Moment, CentralMoment require to compute the integral; using the absolute value of the function. void Browse(TBrowser* b); Browse. void Copy(TObject& f1) const; Copy this F1 to a new F1.; Note that the cached integral with its related arrays are not copied; (they are also set as transient data members). Double_t Derivative(Double_t x, Double_t* params = 0, Double_t epsilon = 0.001) const; Returns the first derivative of the function at point x,; computed by Richardson's extrapolation method (use 2 derivative estimates; to compute a third, more accurate estimation); first, derivatives with steps h and h/2 are computed by central difference formulas. the final estimate ; ""Numerical Methods for Scientists and Engineers"", H.M.Antia, 2nd edition"". if the argument params is null, the current function parameters are used,; otherwise the parameters in params are used. the argument eps may be specified to control the step size (precision).; the step size is taken as eps*(xmax-xmin).; the default value (0.001) should be good enough for the vast majority; of functions. Give a smaller value if your function has many changes; of the second derivative in the function range. Getting the error via TF1::DerivativeError:; (total error = roundo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TF1.html:31506,cache,cached,31506,root/html534/TF1.html,https://root.cern,https://root.cern/root/html534/TF1.html,2,['cache'],['cached']
Performance,"seen by the decompressor.; 63 Long64_t fUnzipObjSize; ///< Uncompressed bytes produced by the decompressor.; 64 Double_t fCompress; ///< Tree compression factor; 65 TString fName; ///< Name of this TTreePerfStats; 66 TString fHostInfo; ///< Name of the host system, ROOT version and date; 67 TFile *fFile; ///<! Pointer to the file containing the Tree; 68 TTree *fTree; ///<! Pointer to the Tree being monitored; 69 TGraphErrors *fGraphIO ; ///< Pointer to the graph with IO data; 70 TGraphErrors *fGraphTime ; ///< Pointer to the graph with timestamp info; 71 TPaveText *fPave; ///< Pointer to annotation pavetext; 72 TStopwatch *fWatch; ///< TStopwatch pointer; 73 TGaxis *fRealTimeAxis; ///< Pointer to TGaxis object showing real-time; 74 TText *fHostInfoText; ///< Graphics Text object with the fHostInfo data; 75 ; 76 std::unordered_map<TBranch*, size_t> fBranchIndexCache; // Cache the index of the branch in the cache's array.; 77 std::vector<std::vector<BasketInfo> > fBasketsInfo; // Details on which baskets was used, cached, 'miss-cached' or read uncached.Browse; 78 ; 79 BasketInfo &GetBasketInfo(TBranch *b, size_t basketNumber);; 80 BasketInfo &GetBasketInfo(size_t bi, size_t basketNumber);; 81 ; 82 void SetFile(TFile *newfile) override {; 83 fFile = newfile;; 84 }; 85 ; 86public:; 87 TTreePerfStats();; 88 TTreePerfStats(const char *name, TTree *T);; 89 ~TTreePerfStats() override;; 90 void Browse(TBrowser *b) override;; 91 Int_t DistancetoPrimitive(Int_t px, Int_t py) override;; 92 void Draw(Option_t *option="""") override;; 93 void ExecuteEvent(Int_t event, Int_t px, Int_t py) override;; 94 virtual void Finish();; 95 Long64_t GetBytesRead() const override {return fBytesRead;}; 96 virtual Long64_t GetBytesReadExtra() const {return fBytesReadExtra;}; 97 virtual Double_t GetCpuTime() const {return fCpuTime;}; 98 virtual Double_t GetDiskTime() const {return fDiskTime;}; 99 TGraphErrors *GetGraphIO() {return fGraphIO;}; 100 TGraphErrors *GetGraphTime() {return fGraphTime;}; 1",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTreePerfStats_8h_source.html:3486,cache,cached,3486,doc/master/TTreePerfStats_8h_source.html,https://root.cern,https://root.cern/doc/master/TTreePerfStats_8h_source.html,2,['cache'],['cached']
Performance,"seful in determining a more efficient decomposition of the requested integral. ; Reimplemented from RooAbsReal.; Definition at line 455 of file RooAddModel.cxx. ◆ getCompIntList(). void RooAddModel::getCompIntList ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset, . pRooArgList & ; compIntList, . Int_t & ; code, . const char * ; isetRangeName . ); const. protected . Check if this configuration was created before. ; Definition at line 477 of file RooAddModel.cxx. ◆ getGenerator(). Int_t RooAddModel::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Return pseud-code that indicates if all components can do internal generation (1) or not (0) ; Reimplemented from RooAbsPdf.; Definition at line 663 of file RooAddModel.cxx. ◆ getProjCache(). AddCacheElem * RooAddModel::getProjCache ; (; const RooArgSet * ; nset, . const RooArgSet * ; iset = nullptr . ); const. protected . Retrieve cache element with for calculation of p.d.f value with normalization set nset and integrated over iset in range 'rangeName'. ; If cache element does not exist, create and fill it on the fly. The cache contains suplemental normalization terms (in case not all added p.d.f.s have the same observables), projection integrals to calculated transformed fraction coefficients when a frozen reference frame is provided and projection integrals for similar transformations when a frozen reference range is provided. ; Definition at line 308 of file RooAddModel.cxx. ◆ IsA(). TClass * RooAddModel::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsPdf.; Definition at line 131 of file RooAddModel.h. ◆ isDirectGenSafe(). bool RooAddModel::isDirectGenSafe ; (; const RooAbsArg & ; arg); const. overridevirtual . Direct generation is safe if all components say so. ; Reimplemented from RooAbsPdf.; Definition at line 646 of file RooAddModel.cxx. ◆ pdfList(). const R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddModel.html:87453,cache,cache,87453,doc/master/classRooAddModel.html,https://root.cern,https://root.cern/doc/master/classRooAddModel.html,1,['cache'],['cache']
Performance,"sel); virtual voidTObject::SetUniqueID(UInt_t uid); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual voidTObject::UseCurrentStyle(); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringfParListList of PARs to be loaded; TProof*fProofProof; TStringfSelNameName of the selector to be run. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~TProofBenchRun(); destructor. const char * GetSelName(); { return fSelName; }. const char * GetParList(); { return fParList; }. void SetSelName(const char* sel); { fSelName = sel; }. void SetParList(const char* pars); { fParList = pars; }. void Run(Long64_t nevents, Int_t start = -1, Int_t stop = -1, Int_t step = -1, Int_t ntries = -1, Int_t debug = -1, Int_t draw = -1). void Print(Option_t* option = """") const. » Author: Sangsu Ryu 22/06/2010 » Copyright (C) 1995-2005, Rene Brun and Fons Rademakers. *; » Last changed: root/proof:$Id$ » Last generated: 2015-03-14 16:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofBenchRun.html:5718,load,loaded,5718,root/html534/TProofBenchRun.html,https://root.cern,https://root.cern/root/html534/TProofBenchRun.html,2,['load'],['loaded']
Performance,"selector needs to initialize; // a new tree or chain. Typically here the branch addresses and branch; // pointers of the tree will be set.; // It is normally not necessary to make changes to the generated; // code, but the routine can be extended by the user if needed.; // Init() will be called many times when running on PROOF; // (once per file to be processed).;  ; // Associate the reader and the tree; fReader.SetTree(tree);; };  ; void TutorialSelector::SlaveBegin(TTree *tree); {; // SlaveBegin() is a good place to create histograms.; // For PROOF, this is called for each worker.; // The TTree* is there for backward compatibility; e.g. PROOF passes 0.;  ; fEff = new TEfficiency(""eff"", ""Moun trigger efficiency"", 100, 0., 10.);; // Add to output list (needed for PROOF); GetOutputList()->Add(fEff);; };  ; Bool_t TutorialSelector::Process(Long64_t entry); {; // The Process() function is called for each entry in the tree to be; // processed. The entry argument specifies which entry in the currently; // loaded tree is to be processed.; // It can be passed to either EventSelector::GetEntry() or TBranch::GetEntry(); // to read either all or the required parts of the TTree.; //; // This function should contain the ""body"" of the analysis: select relevant; // tree entries, run algorithms on the tree entry and typically fill histograms.;  ; // *** 1. *** Tell the reader to load the data for this entry:; fReader.SetEntry(entry);;  ; // *** 2. *** Do the actual analysis; int tagMuon = gRandom->Integer(fRaPt.GetSize());;  ; if (fRaTriggered[tagMuon]) {; for (int iMuon = 0, nMuons = fRaPt.GetSize(); iMuon < nMuons; ++iMuon) {; // All but the tag muon can be probe muons; if (iMuon != tagMuon) {; 	 // Fill the efficiency object with; 	 // - whether this muon has triggered; 	 // - the pT of this muon.; 	 fEff->Fill(fRaTriggered[iMuon], fRaPt[iMuon]);; }; }; };  ; return kTRUE;; };  ; void TutorialSelector::Terminate(); {; // The Terminate() function is the last function to be calle",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/tutorialselectorc.html:4599,load,loaded,4599,d/tutorialselectorc.html,https://root.cern,https://root.cern/d/tutorialselectorc.html,1,['load'],['loaded']
Performance,"sename(macro).h or .hh, is also uploaded. The default is to load the macro also on the client; notOnClient can be used to avoid loading on the client. On masters, if uniqueWorkers is kTRUE, the macro is loaded on unique workers only, and collection is not done; if uniqueWorkers is kFALSE, collection from the previous request is done, and broadcasting + collection from the other workers is done. The wrks arg can be used on the master to limit the set of workers. Returns 0 in case of success and -1 in case of error. ; Reimplemented in TProofLite.; Definition at line 8628 of file TProof.cxx. ◆ LoadPackage(). Int_t TProof::LoadPackage ; (; const char * ; package, . Bool_t ; notOnClient = kFALSE, . TList * ; loadopts = 0, . TList * ; workers = 0 . ). private . Load specified package. ; Executes the PROOF-INF/SETUP.C script on all active nodes. If notOnClient = true, don't load package on the client. The default is to load the package also on the client. The argument 'loadopts' specify a list of objects to be passed to the SETUP. The objects in the list must be streamable; the SETUP macro will be executed like this: SETUP.C(loadopts). Returns 0 in case of success and -1 in case of error. ; Definition at line 8069 of file TProof.cxx. ◆ LogMessage(). void TProof::LogMessage ; (; const char * ; msg, . Bool_t ; all . ). Log a message into the appropriate window by emitting a signal. ; Definition at line 6414 of file TProof.cxx. ◆ LogViewer(). void TProof::LogViewer ; (; const char * ; url = 0, . Int_t ; sessionidx = 0 . ). static . Start the log viewer window usign the plugin manager. ; Definition at line 12470 of file TProof.cxx. ◆ MakePlayer(). TVirtualProofPlayer * TProof::MakePlayer ; (; const char * ; player = 0, . TSocket * ; s = 0 . ). protectedvirtual . Construct a TProofPlayer object. ; The player string specifies which player should be created: remote, slave, sm (supermaster) or base. Default is remote. Socket is needed in case a slave player is created. ; Reimplemen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProof.html:115250,load,loadopts,115250,doc/master/classTProof.html,https://root.cern,https://root.cern/doc/master/classTProof.html,1,['load'],['loadopts']
Performance,"sent the size of column columnname, and are not meant to be written out with that name (which is not a valid C++ variable name). Instead, go through an Alias(): df.Alias(""nbar"", ""#bar"").Cache<std::size_t>(..., {""nbar""}). Example usage:; Types and columns specified: auto cache_some_cols_df = df.Cache<double, MyClass, int>({""col0"", ""col1"", ""col2""});; double; Types inferred and columns specified (this invocation relies on jitting): auto cache_some_cols_df = df.Cache({""col0"", ""col1"", ""col2""});; Types inferred and columns selected with a regexp (this invocation relies on jitting): auto cache_all_cols_df = df.Cache(myRegexp);. Definition at line 1459 of file RInterface.hxx. ◆ Cache() [2/4]. template<typename Proxied , typename DataSource = void> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; const ColumnNames_t & ; columnList). inline . Save selected columns in memory. ; Parameters. [in]columnListcolumns to be cached in memory . Returnsa RDataFrame that wraps the cached dataset.; See the previous overloads for more information. ; Definition at line 1471 of file RInterface.hxx. ◆ Cache() [3/4]. template<typename Proxied , typename DataSource = void> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; std::initializer_list< std::string > ; columnList). inline . Save selected columns in memory. ; Parameters. [in]columnListcolumns to be cached in memory. . Returnsa RDataFrame that wraps the cached dataset.; See the previous overloads for more information. ; Definition at line 1546 of file RInterface.hxx. ◆ Cache() [4/4]. template<typename Proxied , typename DataSource = void> . RInterface< RLoopManager > ROOT::RDF::RInterface< Proxied, DataSource >::Cache ; (; std::string_view ; columnNameRegexp = """"). inline . Save selected columns in memory. ; Parameters. [in]columnNameRegexpThe regular expression to match the column names to be selected. The presence of a '^' and a '$' at the end of the string is impli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:43703,cache,cached,43703,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['cache'],['cached']
Performance,"sequence is that now when an object is stored in a split branch the rule is associtated with the branch of the last of the rule’s sources rather than the last of the object’s data member.; Properly support TStreamerInfo written by ROOT v4.00.; Fix the ordering of the keys in a TFile being written; in particular fixing the result of GetKey and FindKey which were no longer returning the lastest cycle for a TFile being written since v5.34/11. Networking Libraries; HTTP Server; Command Interface; One can now register an arbitrary command to the server, which become visible in the web browser. Then, when the item is clicked by the user, the command ends-up in a gROOT->ProcessLineSync() call.; Custom Properties; Custom properties can be configured for any item in the server. For example, one could configure an icon for each item visible in the browser. Or one could ‘hide’ any item from the user (but keep access with normal http requests). With such properties one could specify which item is drawn when web page is loaded, or configure monitoring. See tutorials/http/httpcontrol.C macro for more details.; Method Calls; Implement exe.json requests to be able to execute any method of registered objects. This request is used to provide remote TTree::Draw() functionality.; Misc; Correctly set ‘Cache-Control’ headers when replying to http requests. Better support of STL containers when converting objects into json with TBufferJSON class.; JavaScript ROOT. Several files can now be loaded simultaneously; Use d3.time.scale to display time scales; Implemented drag and drop to superimpose histograms or graphs; Allow selection of drawing option via context menu; Better support of touch devices; Provide simple layout, making it default; Allow to open ROOT files in online session (via url parameter); One could monitor simultaneously objects from server and root files; Implement ‘autocol’ draw option - when superimposing histograms, their line colors will be automatically assigned; Impleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v604/release-notes.html:9276,load,loaded,9276,doc/v604/release-notes.html,https://root.cern,https://root.cern/doc/v604/release-notes.html,1,['load'],['loaded']
Performance,"ser function accessing the TTree data directly; If the formula contains a file name, TTree::MakeProxy will be used to load and execute this file. In particular it will draw the result of a function with the same name as the file. The function will be executed in a context where the name of the branches can be used as a C++ variable.; For example draw px using the file hsimple.root (generated by the hsimple.C tutorial), we need a file named hsimple.cxx: double hsimple() {; return px;; }; hsimpleDefinition hsimple.py:1; MakeProxy can then be used indirectly via the TTree::Draw interface as follow: new TFile(""hsimple.root""); ntuple->Draw(""hsimple.cxx"");; Drawth1 Draw(); A more complete example is available in the tutorials directory: h1analysisProxy.cxx, h1analysProxy.h and h1analysisProxyCut.C which reimplement the selector found in h1analysis.C; The main features of this facility are:. on-demand loading of branches; ability to use the 'branchname' as if it was a data member; protection against array out-of-bound; ability to use the branch data as object (when the user code is available). See TTree::MakeProxy for more details. Making a Profile histogram; In case of a 2-Dim expression, one can generate a TProfile histogram instead of a TH2F histogram by specifying option=prof or option=profs or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of y:x>>pf where pf is an existing TProfile histogram. Making a 2D Profile histogram; In case of a 3-Dim expression, one can generate a TProfile2D histogram instead of a TH3F histogram by specifying option=prof or option=profs. or option=profi or option=profg ; the trailing letter select the way the bin error are computed, See TProfile2D::SetErrorOption for details on the differences. The option=prof is automatically selected in case of z:y:x>>pf where pf is an existing TProf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTree.html:127964,load,loading,127964,doc/v632/classTTree.html,https://root.cern,https://root.cern/doc/v632/classTTree.html,2,['load'],['loading']
Performance,"serData.cxx:43; ROOT::RBrowserDataCleanup::fDataRBrowserData & fDataDefinition RBrowserData.cxx:45; ROOT::RBrowserDataCleanup::RBrowserDataCleanupRBrowserDataCleanup(RBrowserData &_data)Definition RBrowserData.cxx:48; ROOT::RBrowserDataCleanup::RecursiveRemovevoid RecursiveRemove(TObject *obj) overrideRecursively remove this object from a list.Definition RBrowserData.cxx:50; ROOT::RBrowserDataWay to browse (hopefully) everything in ROOT.Definition RBrowserData.hxx:37; ROOT::RBrowserData::SetTopElementvoid SetTopElement(std::shared_ptr< Browsable::RElement > elem)set top element for browsingDefinition RBrowserData.cxx:88; ROOT::RBrowserData::fLastSortedItemsstd::vector< const Browsable::RItem * > fLastSortedItems! sorted child items, used in requestsDefinition RBrowserData.hxx:51; ROOT::RBrowserData::fWorkingPathBrowsable::RElementPath_t fWorkingPath! path showed in BreadcrumbDefinition RBrowserData.hxx:43; ROOT::RBrowserData::RemoveFromCachebool RemoveFromCache(void *obj)Remove object from cache If nullptr specified - removes no-longer-valid elements Returns true if any ...Definition RBrowserData.cxx:380; ROOT::RBrowserData::GetSubElementstd::shared_ptr< Browsable::RElement > GetSubElement(const Browsable::RElementPath_t &path)Returns sub-element starting from top, using cached data.Definition RBrowserData.cxx:308; ROOT::RBrowserData::fCachestd::vector< std::pair< Browsable::RElementPath_t, std::shared_ptr< Browsable::RElement > > > fCache! already requested elementsDefinition RBrowserData.hxx:45; ROOT::RBrowserData::fCleanupHandlestd::unique_ptr< TObject > fCleanupHandle! cleanup handle for RecursiveRemoveDefinition RBrowserData.hxx:54; ROOT::RBrowserData::DecomposePathBrowsable::RElementPath_t DecomposePath(const std::string &path, bool relative_to_work_element)Decompose path to elements Returns array of names for each element in the path, first element either ...Definition RBrowserData.cxx:155; ROOT::RBrowserData::fLastAllChildsbool fLastAllChilds! if all chlds w",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RBrowserData_8cxx_source.html:15948,cache,cache,15948,doc/master/RBrowserData_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RBrowserData_8cxx_source.html,2,['cache'],['cache']
Performance,"sert it in prefetchBuffers list. void ReadListOfBlocks(); Get blocks specified in prefetchBlocks. Bool_t BinarySearchReadList(TFPBlock* , Long64_t , Int_t , Int_t* ); Search for a requested element in a block and return the index. Long64_t GetWaitTime(); Return the time spent wating for buffer to be read in microseconds. Bool_t ReadBuffer(char* , Long64_t , Int_t ); Return a prefetched element. void ReadBlock(Long64_t* , Int_t* , Int_t ); Create a TFPBlock object or recycle one and add it to the prefetchBlocks list. void AddPendingBlock(TFPBlock* ); Safe method to add a block to the pendingList. TFPBlock* GetPendingBlock(); Safe method to remove a block from the pendingList. void AddReadBlock(TFPBlock* ); Safe method to add a block to the readList. TFPBlock* CreateBlockObj(Long64_t* , Int_t* , Int_t ); Create a new block or recycle an old one. TThread* GetThread() const; Return reference to the consumer thread. void SetFile(TFile* ); Change the file. Int_t ThreadStart(); Used to start the consumer thread. TThread::VoidRtnFunc_t ThreadProc(void* ); Execution loop of the consumer thread. Int_t SumHex(const char* ); Sum up individual hex values to obtain a decimal value. Bool_t CheckBlockInCache(char*& , TFPBlock* ); Test if the block is in cache. char* GetBlockFromCache(const char* , Int_t ); Return a buffer from cache. void SaveBlockInCache(TFPBlock* ); Save the block content in cache. Bool_t CheckCachePath(const char* ); Validate the input file cache path. Bool_t SetCache(const char* ); Set the path of the cache directory. TFilePrefetch(TFile* ). TMutex* GetMutexSynch() const; { return fMutexSynch; }. » Author: Elvin Sindrilaru 19/05/2011 » Copyright (C) 1995-2011, Rene Brun and Fons Rademakers. *; » Last changed: root/io:$Id: TFilePrefetch.h 41698 2011-11-01 21:22:54Z pcanal $ » Last generated: 2011-11-03 20:13; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TFilePrefetch.html:7985,cache,cache,7985,root/html532/TFilePrefetch.html,https://root.cern,https://root.cern/root/html532/TFilePrefetch.html,10,['cache'],['cache']
Performance,"sert(clinfo);; 3840 }; 3841 }; 3842 }; 3843 }; 3844 ; 3845 // Write the StreamerInfo list even if it is empty.; 3846 fClassIndex->fArray[0] = 2; //to prevent adding classes in TStreamerInfo::TagFile; 3847 ; 3848 if (listOfRules.GetEntries()) {; 3849 // Only add the list of rules if we have something to say.; 3850 list.Add(&listOfRules);; 3851 }; 3852 ; 3853 //free previous StreamerInfo record; 3854 if (fSeekInfo) MakeFree(fSeekInfo,fSeekInfo+fNbytesInfo-1);; 3855 //Create new key; 3856 TKey key(&list,""StreamerInfo"",GetBestBuffer(), this);; 3857 fKeys->Remove(&key);; 3858 fSeekInfo = key.GetSeekKey();; 3859 fNbytesInfo = key.GetNbytes();; 3860 SumBuffer(key.GetObjlen());; 3861 key.WriteFile(0);; 3862 ; 3863 fClassIndex->fArray[0] = 0;; 3864 ; 3865 list.RemoveLast(); // remove the listOfRules.; 3866}; 3867 ; 3868////////////////////////////////////////////////////////////////////////////////; 3869/// Open a file for reading through the file cache.; 3870///; 3871/// The file will be downloaded to the cache and opened from there.; 3872/// If the download fails, it will be opened remotely.; 3873/// The file will be downloaded to the directory specified by SetCacheFileDir().; 3874 ; 3875TFile *TFile::OpenFromCache(const char *name, Option_t *, const char *ftitle,; 3876 Int_t compress, Int_t netopt); 3877{; 3878 TFile *f = nullptr;; 3879 ; 3880 if (fgCacheFileDir == """") {; 3881 ::Warning(""TFile::OpenFromCache"",; 3882 ""you want to read through a cache, but you have no valid cache ""; 3883 ""directory set - reading remotely"");; 3884 ::Info(""TFile::OpenFromCache"", ""set cache directory using TFile::SetCacheFileDir()"");; 3885 } else {; 3886 TUrl fileurl(name);; 3887 ; 3888 if ((!strcmp(fileurl.GetProtocol(), ""file""))) {; 3889 // it makes no sense to read local files through a file cache; 3890 if (!fgCacheFileForce); 3891 ::Warning(""TFile::OpenFromCache"",; 3892 ""you want to read through a cache, but you are reading ""; 3893 ""local files - CACHEREAD disabled"");; 3894 } else {; 3895 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:140714,cache,cache,140714,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"serted in a TList. //; 22// //; 23//////////////////////////////////////////////////////////////////////////; 24 ; 25#include ""TSeqCollection.h""; 26#include ""TString.h""; 27 ; 28#include <iterator>; 29#include <memory>; 30 ; 31const Bool_t kSortAscending = kTRUE;; 32const Bool_t kSortDescending = !kSortAscending;; 33 ; 34class TObjLink;; 35class TListIter;; 36 ; 37 ; 38class TList : public TSeqCollection {; 39 ; 40friend class TListIter;; 41 ; 42protected:; 43 using TObjLinkPtr_t = std::shared_ptr<TObjLink>;; 44 using TObjLinkWeakPtr_t = std::weak_ptr<TObjLink>;; 45 ; 46 TObjLinkPtr_t fFirst; //! pointer to first entry in linked list; 47 TObjLinkPtr_t fLast; //! pointer to last entry in linked list; 48 TObjLinkWeakPtr_t fCache; //! cache to speedup sequential calling of Before() and After() functions; 49 Bool_t fAscending; //! sorting order (when calling Sort() or for TSortedList); 50 ; 51 TObjLink *LinkAt(Int_t idx) const;; 52 TObjLink *FindLink(const TObject *obj, Int_t &idx) const;; 53 ; 54 TObjLinkPtr_t *DoSort(TObjLinkPtr_t *head, Int_t n);; 55 ; 56 Bool_t LnkCompare(const TObjLinkPtr_t &l1, const TObjLinkPtr_t &l2);; 57 TObjLinkPtr_t NewLink(TObject *obj, const TObjLinkPtr_t &prev = nullptr);; 58 TObjLinkPtr_t NewOptLink(TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev = nullptr);; 59 TObjLinkPtr_t NewLink(TObject *obj, TObjLink *prev);; 60 TObjLinkPtr_t NewOptLink(TObject *obj, Option_t *opt, TObjLink *prev);; 61 // virtual void DeleteLink(TObjLink *lnk);; 62 ; 63 void InsertAfter(const TObjLinkPtr_t &newlink, const TObjLinkPtr_t &prev);; 64 ; 65private:; 66 TList(const TList&) = delete;; 67 TList& operator=(const TList&) = delete;; 68 ; 69public:; 70 typedef TListIter Iterator_t;; 71 ; 72 TList() : fAscending(kTRUE) { }; 73 ; 74 TList(TObject *) R__DEPRECATED(6, 34, ""The argument is ignored. Use the default constructor TList::TList()."") : fAscending(kTRUE) { } // for backward compatibility, don't use; 75 ; 76 virtual ~TList();; 77 void Clear(Option_t *op",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8h_source.html:1601,cache,cache,1601,doc/master/TList_8h_source.html,https://root.cern,https://root.cern/doc/master/TList_8h_source.html,1,['cache'],['cache']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsCachedReal&operator=(const RooAbsCachedReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCachedReal.html:20117,optimiz,optimizeCacheMode,20117,root/html602/RooAbsCachedReal.html,https://root.cern,https://root.cern/root/html602/RooAbsCachedReal.html,4,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooAbsHiddenReal&operator=(const RooAbsHiddenReal&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsHiddenReal.html:19675,optimiz,optimizeCacheMode,19675,root/html602/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html602/RooAbsHiddenReal.html,4,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooChangeTracker&operator=(const RooChangeTracker&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooArgSetparameters() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooChangeTracker.html:19815,optimiz,optimizeCacheMode,19815,root/html602/RooChangeTracker.html,https://root.cern,https://root.cern/root/html602/RooChangeTracker.html,4,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooConstraintSum&operator=(const RooConstraintSum&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooConstraintSum.html:19517,optimiz,optimizeCacheMode,19517,root/html602/RooConstraintSum.html,https://root.cern,https://root.cern/root/html602/RooConstraintSum.html,4,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooFracRemainder&operator=(const RooFracRemainder&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooFracRemainder.html:19450,optimiz,optimizeCacheMode,19450,root/html602/RooFracRemainder.html,https://root.cern,https://root.cern/root/html602/RooFracRemainder.html,4,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooMultiBinomial&operator=(const RooMultiBinomial&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiBinomial.html:19817,optimiz,optimizeCacheMode,19817,root/html602/RooMultiBinomial.html,https://root.cern,https://root.cern/root/html602/RooMultiBinomial.html,4,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooNumRunningInt&operator=(const RooNumRunningInt&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNumRunningInt.html:19957,optimiz,optimizeCacheMode,19957,root/html602/RooNumRunningInt.html,https://root.cern,https://root.cern/root/html602/RooNumRunningInt.html,4,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooParamHistFunc&operator=(const RooParamHistFunc&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooParamHistFunc.html:19260,optimiz,optimizeCacheMode,19260,root/html602/RooParamHistFunc.html,https://root.cern,https://root.cern/root/html602/RooParamHistFunc.html,4,['optimiz'],['optimizeCacheMode']
Performance,"servableOverlaps(const RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); RooUnblindOffset&operator=(const RooUnblindOffset&); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindOffset.html:19793,optimiz,optimizeCacheMode,19793,root/html602/RooUnblindOffset.html,https://root.cern,https://root.cern/root/html602/RooUnblindOffset.html,4,['optimiz'],['optimizeCacheMode']
Performance,"servables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. RooAbsCachedReal::FuncCacheElem* createCache(const RooArgSet* nset) const; Interface function to create an internal cache object that represent; each cached function configuration. This interface allows to create and; return a class derived from RooAbsCachedReal::FuncCacheElem so that; a derived class fillCacheObject implementation can utilize extra functionality; defined in such a derived cache class. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. void operModeHook(). RooCachedReal(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that rep",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:38873,cache,cacheFunc,38873,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,8,['cache'],"['cache', 'cacheFunc']"
Performance,"servables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. RooCachedReal(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that represent the cache hist",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooCachedReal.html:35739,cache,cacheFunc,35739,root/html530/RooCachedReal.html,https://root.cern,https://root.cern/root/html530/RooCachedReal.html,4,['cache'],"['cache', 'cacheFunc']"
Performance,"servables of the function. RooCachedReal(const char* name, const char* title, RooAbsReal& _func, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixed set of cache observables does not match the observables; defined in the use context of the p.d.f the cache is still filled; completely. Ee.g. when it is specified to cache x and p and only x; is a observable in the given use context the cache histogram will; store sampled values for all values of observable x and parameter p.; In such a mode of operation the cache will also not be recalculated; if the observable p changes. RooCachedReal(const RooCachedReal& other, const char* name = 0); Copy constructor. ~RooCachedReal(); Destructor. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. RooCachedReal(); {}. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that represent the cache histogram; will use spe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedReal.html:34933,cache,cacheFunc,34933,root/html526/RooCachedReal.html,https://root.cern,https://root.cern/root/html526/RooCachedReal.html,4,['cache'],"['cache', 'cacheFunc']"
Performance,"servables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:36002,cache,cache,36002,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['cache'],['cache']
Performance,"servables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (RooExpensiveObjectCache &cache);  ; R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATED(6, 36, ""Use getObservables()."") RooFit R__DEPRECATE",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:39372,cache,cache,39372,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['cache'],['cache']
Performance,"served from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; bool areIdentical (const RooDataHist &dh1, const RooDataHist &dh2);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; double evaluate () const override;  Return the current value: The value of the bin enclosing the current coordinates of the dependents, normalized by the histograms contents. ;  ; bool importWorkspaceHook (RooWorkspace &ws) override;  Check if our datahist is already in the workspace. ;  ; void ioStreamerPass2 () override;  Schema evolution: if histObsList wasn't filled from persistence (v1) then fill it here. ;  ;  Protected Member Functions inherited from RooAbsReal; void attachToTree (TTree &t, Int_t bufSize=32000) override;  Attach object to a branch of given TTree. ;  ; void attachToVStore (RooVectorDataStore &vstore) override;  ; void copyCache (const RooAbsArg *source, bool valueOnly=false, bool setValDirty=true) override;  Copy the cached value of another RooAbsArg to our cache. ;  ; RooFit::OwningPtr< RooAbsReal > createIntObj (const RooArgSet &iset, const RooArgSet *nset, const RooNumIntConfig *cfg, const char *rangeName) const;  Internal utility function for createIntegral() that creates the actual integral object. ;  ; void fillTreeBranch (TTree &t) override;  Fill the tree branch that associated with this object with its current value. ;  ; void findInnerMostIntegration (const RooArgSet &allObs, RooArgSet &innerObs, const char *rangeName) const;  Utility function for createIntObj() that aids in the construct of recursive integrals over functions with multiple observables with parameterized ranges. ;  ; TString integralNameSuffix (const RooArgSet &iset, const RooArgSet *nset=nullptr, const char *rangeName=nullptr, bool omitEmpty=false) const;  Construct string with unique suffix name to give to integral object that encodes integrated observables, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHistFunc.html:50154,cache,cached,50154,doc/master/classRooHistFunc.html,https://root.cern,https://root.cern/doc/master/classRooHistFunc.html,2,['cache'],"['cache', 'cached']"
Performance,"server socket (unless we will use it; // later to wait for another connection).; ss->Close();. TMonitor *mon = new TMonitor;; mon->Add(s0);; mon->Add(s1);. while (1) {; TMessage *mess;; TSocket *s;; s = mon->Select();; s->Recv(mess);; ...; }; }; The full code for the example above is in $ROOTSYS/tutorials/net/hserv.C and; $ROOTSYS/tutorials/net/hclient.C.; 23 Threads; A thread is an independent flow of control that operates within the same address space as other independent flows of controls within a process. In most UNIX systems, thread and process characteristics are grouped into a single entity called a process. Sometimes, threads are called ""lightweight processes’’.; Note: This introduction is adapted from the AIX 4.3 Programmer’s Manual.; 23.1 Threads and Processes; In traditional single-threaded process systems, a process has a set of properties. In multi-threaded systems, these properties are divided between processes and threads.; 23.1.1 Process Properties; A process in a multi-threaded system is the changeable entity. It must be considered as an execution frame. It has all traditional process attributes, such as:. Process ID, process group ID, user ID, and group ID; Environment; Working directory. A process also provides a common address space and common system resources:. File descriptors; Signal actions; Shared libraries; Inter-process communication tools (such as message queues, pipes, semaphores, or shared memory). 23.1.2 Thread Properties; A thread is the schedulable entity. It has only those properties that are required to ensure its independent flow of control. These include the following properties:. Stack; Scheduling properties (such as policy or priority); Set of pending and blocked signals; Some thread-specific data (TSD). An example of thread-specific data is the error indicator, errno. In multi-threaded systems, errno is no longer a global variable, but usually a subroutine returning a thread-specific errno value. Some other systems may provide",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1101590,multi-thread,multi-threaded,1101590,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['multi-thread'],['multi-threaded']
Performance,"server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; virtual const char * cacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache ()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooRealMPFE.html:35914,cache,cache,35914,doc/master/classRooRealMPFE.html,https://root.cern,https://root.cern/doc/master/classRooRealMPFE.html,1,['cache'],['cache']
Performance,"server. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables);  Activate cache mode optimization with given definition of observables. ;  ; virtual void optimizeCacheMode (const RooArgSet &observables, RooArgSet &optNodes, RooLinkedList &processedNodes);  Activate cache mode optimization with given definition of observables. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; bool findConstantNodes (const RooArgSet &observables, RooArgSet &cacheList, RooLinkedList &processedNodes);  Find branch nodes with all-constant parameters, and add them to the list of nodes that can be cached with a dataset in a test statistic calculation. ;  ; virtual CacheMode canNodeBeCached () const;  ; virtual void setCacheAndTrackHints (RooArgSet &);  ; bool isShapeDirty () const;  ; bool isValueDirty () const;  ; bool isValueDirtyAndClear () const;  ; bool isValueOrShapeDirtyAndClear () const;  ; void registerCache (RooAbsCache &cache);  Register RooAbsCache with this object. ;  ; void unRegisterCache (RooAbsCache &cache);  Unregister a RooAbsCache. Called from the RooAbsCache destructor. ;  ; Int_t numCaches () const;  Return number of registered caches. ;  ; RooAbsCache * getCache (Int_t index) const;  Return registered cache object by index. ;  ; OperMode operMode () const;  Query the operation mode of this node. ;  ; void setOperMode (OperMode mode, bool recurseADirty=true);  Set the operation mode of this node. ;  ; void setValueDirty ();  Mark the element dirty. This forces a re-evaluation when a value is requested. ;  ; void setShapeDirty ();  Notify that a shape-like property (e.g. binning) has changed. ;  ; const char * aggregateCacheUniqueSuffix () const;  ; void wireAllCaches ();  ; RooExpensiveObjectCache & expensiveObjectCache () const;  ; virtual void setExpensiveObjectCache (Roo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooChi2Var.html:39284,cache,cache,39284,doc/master/classRooChi2Var.html,https://root.cern,https://root.cern/doc/master/classRooChi2Var.html,1,['cache'],['cache']
Performance,"ses; A user’s own classes can be accessed after loading, either directly or indirectly, the library that contains the dictionary. One easy way of obtaining such a library, is by using ACLiC:; $ cat MyClass.C; class MyClass {; public:. MyClass(int value = 0) {; m_value = value;; }. void SetValue(int value) {; m_value = value;; }. int GetValue() {; return m_value;; }. private:; int m_value;; };. $ echo .L MyClass.C+ | root.exe -b; [...]; Info in <TUnixSystem::ACLiC>: creating shared library [..]/./MyClass_C.so; $; Then you can use it, for example, like so:; from ROOT import gSystem. # load library with MyClass dictionary; gSystem.Load('MyClass_C'). # get MyClass from ROOT; from ROOT import MyClass; # use MyClass; m = MyClass(42); print(m.GetValue()); You can also load a macro directly, but if you do not use ACLiC, you will be restricted to use the default constructor of your class, which is otherwise fully functional. For example:; from ROOT import gROOT. # load MyClass definition macro (append '+' to use ACLiC); gROOT.LoadMacro('MyClass.C'). # get MyClass from ROOT; from ROOT import MyClass. # use MyClass; m = MyClass(); m.SetValue(42); print(m.GetValue()); 20 The Tutorials and Tests; This chapter is a guide to the examples that come with the installation of ROOT. They are located in two directories: $ROOTSYS/tutorials and $ROOTSYS/test.; 20.1 $ROOTSYS/tutorials. The tutorials directory contains many example scripts. To have all examples working you must have write permission and you will need to executehsimple.C first. If you do not have write permission in the directory$ROOTSYS/tutorials, copy the entire directory to your area. The script hsimple.C displays a histogram as it is being filled, and creates a ROOT file used by the other examples.; To execute it type:; $ cd $ROOTSYS/tutorials; $ root; -------------------------------------------------------------------------; | Welcome to ROOT 6.10/01 http://root.cern.ch |; | (c) 1995-2017, The ROOT Team |; | Built for m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1073556,load,load,1073556,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['load']
Performance,"set in range named rangeName with integrand normalized over observables in nset. ; Definition at line 211 of file RooAbsReal.h. ◆ createIntegral() [3/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet & ; nset, . const RooNumIntConfig & ; cfg, . const char * ; rangeName = nullptr . ); const. inline . Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ; Definition at line 216 of file RooAbsReal.h. ◆ createIntegral() [4/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const RooNumIntConfig * ; cfg = nullptr, . const char * ; rangeName = nullptr . ); const. virtual . Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. If nset is specified the integrand is request to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented in RooAbsRealLValue, RooBinSamplingPdf, and RooRealIntegral.; Definition at line 551 of file RooAbsReal.cxx. ◆ createIntegral() [5/6]. RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAbsReal.html:88298,perform,performed,88298,doc/v632/classRooAbsReal.html,https://root.cern,https://root.cern/doc/v632/classRooAbsReal.html,1,['perform'],['performed']
Performance,"set in range named rangeName with integrand normalized over observables in nset. ; Definition at line 211 of file RooAbsReal.h. ◆ createIntegral() [3/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet & ; nset, . const RooNumIntConfig & ; cfg, . const char * ; rangeName = nullptr . ); const. inline . Create integral over observables in iset in range named rangeName with integrand normalized over observables in nset while using specified configuration for any numeric integration. ; Definition at line 216 of file RooAbsReal.h. ◆ createIntegral() [4/6]. RooFit::OwningPtr< RooAbsReal > RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const RooNumIntConfig * ; cfg = nullptr, . const char * ; rangeName = nullptr . ); const. virtual . Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. If nset is specified the integrand is request to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented in RooAbsRealLValue, RooBinSamplingPdf, and RooRealIntegral.; Definition at line 553 of file RooAbsReal.cxx. ◆ createIntegral() [5/6]. RooAbsReal::createIntegral ; (; const RooArgSet & ; iset, . const RooCmdArg & ; arg1, . const RooCmdArg & ; arg2 = {}, . const RooCmdArg & ; arg3 = {}, . const RooCmdArg ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsReal.html:87030,perform,performed,87030,doc/master/classRooAbsReal.html,https://root.cern,https://root.cern/doc/master/classRooAbsReal.html,1,['perform'],['performed']
Performance,set of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Bool_tRooAbsTestStatistic::_doOffsetApply interval value offset to control numeric precision?; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Double_tRooAbsTestStatistic::_evalCarry! carry of Kahan sum in evaluatePartition; Int_tRooAbsTestStatistic::_extSet! Number of designated set to calculated extended term; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; RooAbsReal*RooAbsTestStatistic::_funcPointer to original input function; RooAbsReal*_funcClonePointer to internal clone of input function; RooArgSet*_funcCloneSetSet owning all components of internal clone of input function; RooArgSet*_funcObsSetList of observables in the pdf expression; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; pRooAbsTestStatistic*RooAbsTestStatistic::_gofArray! Array of sub-contexts representing part of the combined test statistic; RooAbsTestStatistic::GOFOpModeRooAbsTestStatistic::_gofOpModeOperation mode of test statistic instance; vector<RooFit::MPSplit>RooAbsTestStatistic::_gofSplitMode! GOF MP Split mode specified by component (when Auto is active); static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsOptTestStatistic.html:38723,cache,cache,38723,root/html602/RooAbsOptTestStatistic.html,https://root.cern,https://root.cern/root/html602/RooAbsOptTestStatistic.html,4,['cache'],['cache']
Performance,"set to the event # of the first miss. ;  ; bool fFirstTime {true};  ! save the fact that we processes the first entry ;  ; bool fIsLearning {true};  ! true if cache is in learning mode ;  ; bool fIsManual {false};  ! true if cache is StopLearningPhase was used ;  ; Long64_t fLastMiss {-1};  ! set to the event # of the last miss. ;  ; bool fLearnPrefilling {false};  ! true if we are in the process of executing LearnPrefill ;  ; std::unique_ptr< MissCache > fMissCache;  ! Cache contents for misses ;  ; Int_t fNbranches {0};  ! Number of branches in the cache ;  ; Long64_t fNextClusterStart {-1};  ! End+1 of the cluster(s) where the current content was picked out ;  ; Int_t fNMissReadMiss {0};  Number of blocks read and not found in either cache. ;  ; Int_t fNMissReadOk {0};  Number of blocks read, not found in the primary cache, and found in the secondary cache. ;  ; Int_t fNMissReadPref {0};  Number of blocks read into the secondary (""miss"") cache. ;  ; Int_t fNReadMiss {0};  Number of blocks read and not found in the cache. ;  ; Int_t fNReadOk {0};  Number of blocks read and found in the cache. ;  ; Int_t fNReadPref {0};  Number of blocks that were prefetched. ;  ; bool fOneTime {false};  ! used in the learning phase ;  ; bool fOptimizeMisses {false};  ! true if we should optimize cache misses. ;  ; EPrefillType fPrefillType;  Whether a pre-filling is enabled (and if applicable which type) ;  ; bool fReadDirectionSet {false};  ! read direction established ;  ; bool fReverseRead {false};  ! reading in reverse mode ;  ; TTree * fTree {nullptr};  ! pointer to the current Tree ;  ;  Protected Attributes inherited from TFileCacheRead; Bool_t fAsyncReading;  ; Bool_t fBIsSorted;  ; Bool_t fBIsTransferred;  ; Int_t * fBLen;  [fBNb] ;  ; Int_t fBNb;  ; Int_t fBNseek;  ; Int_t fBNtot;  ; Long64_t * fBPos;  [fBNb] ;  ; Long64_t * fBSeek;  [fBNseek] ;  ; Int_t * fBSeekIndex;  [fBNseek] ;  ; Int_t * fBSeekLen;  [fBNseek] ;  ; Int_t * fBSeekPos;  [fBNseek] ;  ; Int_t fBSeekSize;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:29232,cache,cache,29232,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['cache'],['cache']
Performance,"set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; Bool_tRooResolutionModel::_ownBasisFlag indicating ownership of _basis ; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; RooRefArrayRooAbsArg::_proxyListlist of proxies; Double_tRooAbsPdf::_rawValue; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsPdf::_selectCompComponent selection flag for RooAbsPdf::plotCompOn; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumGenConfig*RooAbsPdf::_specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxyrlife; RooRealProxyrsf; RooRealProxysigma; RooRealProxyssf; RooRealProxyRooResolutionModel::xDependent/convolution variable.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooGExpModel.html:45950,cache,cache,45950,root/html534/RooGExpModel.html,https://root.cern,https://root.cern/root/html534/RooGExpModel.html,2,['cache'],['cache']
Performance,"set) const override;  Parameters of the cache. ;  ; PdfCacheElem * createCache (const RooArgSet *nset) const override;  Create and return a derived MorphCacheElem. ;  ; double evaluate () const override;  Dummy. ;  ; void fillCacheObject (PdfCacheElem &cache) const override;  Fill the cache with the interpolated shape. ;  ; const char * inputBaseName () const override;  Return base name component for cache components in this case a string encoding the names of both end point p.d.f.s. ;  ;  Protected Member Functions inherited from RooAbsCachedPdf; virtual const char * binningName () const;  ; std::string cacheNameSuffix (const RooArgSet &nset) const;  Construct string with unique suffix for cache objects based on observable names that define cache configuration. ;  ; void disableCache (bool flag);  ; void doEval (RooFit::EvalContext &) const override;  Base function for computing multiple values of a RooAbsReal. ;  ; PdfCacheElem * getCache (const RooArgSet *nset, bool recalculate=true) const;  Retrieve cache object associated with given choice of observables. ;  ; virtual TString histNameSuffix () const;  ; virtual const char * payloadUniqueSuffix () const;  ; virtual RooAbsArg & pdfObservable (RooAbsArg &histObservable) const;  ;  Protected Member Functions inherited from RooAbsPdf;  RooAbsPdf (const RooAbsPdf &other, const char *name=nullptr);  Copy constructor. ;  ; virtual std::unique_ptr< RooAbsReal > createNLLImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the NLL creation routine. ;  ; virtual std::unique_ptr< RooFitResult > fitToImpl (RooAbsData &data, const RooLinkedList &cmdList);  Protected implementation of the likelihood fitting routine. ;  ; bool isActiveNormSet (RooArgSet const *normSet) const;  Checks if normSet is the currently active normalization set of this PDF, meaning is exactly the same object as the one the _normSet member points to (or both are nullptr). ;  ; double normalizeWithNaNPacking (double rawVal, ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooIntegralMorph.html:65843,cache,cache,65843,doc/master/classRooIntegralMorph.html,https://root.cern,https://root.cern/doc/master/classRooIntegralMorph.html,1,['cache'],['cache']
Performance,"set, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); virtual voidresetCache(); virtual voidsetArgStatus(const RooArgSet& set, Bool_t active). Data Members; public:. enum ErrorType { Poisson; SumW2; None; Auto; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. TIterator*_cacheIter! Iterator over cached variables; RooArgSet_cachedVars! External variables cached with this data set; RooAbsDataStore*_dstoreData storage implementation; TIterator*_iterator! Iterator over dimension variables; static Int_tRooPrintable::_nameLength; map<std::string,RooAbsData*>_ownedComponentsOwned external components; RooArgSet_varsDimensions of this data set; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void claimVars(RooAbsData* ). Bool_t releaseVars(RooAbsData* ); If return value is true variables can be deleted. ~RooAbsData(); Destructor; cout << ""deleting dataset "" << this << endl ;. Bool_t changeObservableName(const char* from, const char* to). void fill(). Int_t numEntries() const. void reset(). const RooArgSet* get(Int_t index) const. void cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); Internal method -- Cache given set of functions with data. void resetCache(); Internal method -- Remove cached function values. void attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); Internal method -- Attach dataset copied with c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooAbsData.html:13805,cache,cached,13805,root/html530/RooAbsData.html,https://root.cern,https://root.cern/root/html530/RooAbsData.html,2,['cache'],['cached']
Performance,"set, the automatically generated Streamercan call directly the method TClass::WriteBuffer. Bypassing the Streamer improves the performance when writing/reading the objects in the TClonesArray. However, the drawback is when a TClonesArray is written with split=0 bypassing the Streamer, the StreamerInfoof the class in the array being optimized, one cannot later use the TClonesArray with split > 0. For example, there is a problem with the following scenario: a class Foo has a TClonesArray of Bar objects the Foo object is written with split=0 to Tree T1. In this case the StreamerInfo for the class Bar is created in optimized mode in such a way that data members of the same type are written as an array improving the I/O performance. In a new program, T1 is read and a new Tree T2 is created with the object Foo in split > 1.; When the T2branch is created, the StreamerInfo for the class Bar is created with no optimization (mandatory for the split mode). The optimized Bar StreamerInfo is going to be used to read the TClonesArray in T1. The result will be Bar objects with data member values not in the right sequence. The solution to this problem is to call BypassStreamer(kFALSE) for the TClonesArray. In this case, the normal Bar::Streamer function will be called. The Bar::Streamer function works OK independently if the Bar StreamerInfohad been generated in optimized mode or not.; 11.4 Pointers and References in Persistency; An object pointer as a data member presents a challenge to the streaming software. If the object pointed to is saved every time, it could create circular dependencies and consume a large amount of disk space. The network of references must be preserved on disk and recreated upon reading the file.; If you use independent I/O operations for pointers and their referenced objects you can use the TRef class. Later in this section is an example that compares disk space, memory usage, and I/O times of C++ pointers and TRefs. In general, a TRef is faster than C++ b",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:477779,optimiz,optimized,477779,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['optimiz'],['optimized']
Performance,"set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramSetSet of parameters to which constraints apply; Int_tRooAbsReal::_plotBinsNumber of plot bins; Double_tRooAbsReal::_plotMaxMaximum of plot range; Double_tRooAbsReal::_plotMinMinimum of plot range; Bool_tRooAbsArg::_prohibitServerRedirect! Prohibit server redirects -- Debugging tool; TListRooAbsArg::_proxyListlist of proxies; Char_tRooAbsReal::_sbyteValue! Transient cache for signed byte values from tree branches ; Bool_tRooAbsReal::_selectComp! Component selection flag for RooAbsPdf::plotCompOn; RooRefCountListRooAbsArg::_serverListlist of server objects; RooListProxy_set1Set of constraint terms; TIterator*_setIter1! do not persist; Bool_tRooAbsArg::_shapeDirtyFlag set if value needs recalculating because input shapes modified; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooConstraintSum.html:32871,cache,cache,32871,root/html530/RooConstraintSum.html,https://root.cern,https://root.cern/root/html530/RooConstraintSum.html,1,['cache'],['cache']
Performance,"set; static TDictionary::ESTLTypeTDictionary::kUnorderedSet; static TDictionary::ESTLTypeTDictionary::kVector; static TObject::(anonymous)TObject::kWriteDelete; static TObject::(anonymous)TObject::kZombie. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClass!pointer to parent class; TClassReffClassPtrpointer to the base class TClass; Int_tfDeltaBaseClassInfo_t offset (INT_MAX if unset); BaseClassInfo_t*fInfo!pointer to CINT base class info; Int_tfPropertyBaseClassInfo_t's properties; Int_tfSTLTypecache of IsSTLContainer(). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCling::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta(); Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). ROOT::ESTLType IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. void Streamer(TBuffer& ); Stream an object of TBaseClass. Triggers the calculation of the; cache variables to store them. TBaseClass(const TBaseClass& ). TBaseClass& operator=(const TBaseClass& ). Bool_t IsFolder() const; {return kTRUE;}. void SetClass(TClass* cl); { fClass = cl; }. » Author: Fons Rademakers 08/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-06-02 15:38; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TBaseClass.html:8066,load,load,8066,root/html604/TBaseClass.html,https://root.cern,https://root.cern/root/html604/TBaseClass.html,4,"['cache', 'load']","['cache', 'load']"
Performance,"set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches ; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; static RooCategory*_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Bool_tRooAbsArg::_isConstant! Cached isConstant status ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsHiddenReal.html:33347,cache,cache,33347,root/html534/RooAbsHiddenReal.html,https://root.cern,https://root.cern/root/html534/RooAbsHiddenReal.html,7,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedPdf::_cacheMgrThe cache manager ; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedPdf.html:38253,cache,cache,38253,root/html526/RooAbsSelfCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedPdf.html,4,['cache'],['cache']
Performance,"set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooObjCacheManagerRooAbsCachedReal::_cacheMgrThe cache manager; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedReal::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; static Int_tRooPrintable::_nameLength; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; Int_tRooAbsReal::_plotBinsNumber of plot bins; D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsSelfCachedReal.html:31618,cache,cache,31618,root/html526/RooAbsSelfCachedReal.html,https://root.cern,https://root.cern/root/html526/RooAbsSelfCachedReal.html,14,['cache'],['cache']
Performance,"set<string>RooAbsArg::_boolAttribBoolean attributes; set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; static RooCategory*RooAbsHiddenReal::_dummyBlindState; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for this node; static Int_tRooPrintable::_nameLength; TNamed*RooAbsArg::_namePtr! Do not persist.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooUnblindCPAsymVar.html:35493,cache,cache,35493,root/html602/RooUnblindCPAsymVar.html,https://root.cern,https://root.cern/root/html602/RooUnblindCPAsymVar.html,56,"['Cache', 'cache']","['Cached', 'cache']"
Performance,"set<string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); Bool_tRooAbsReal::_boolValue! Transient cache for bool values from tree branches; UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue; TMatrixDSym_cov; TMatrixDSym_covI; Bool_tRooAbsArg::_deleteWatch! Delete watch flag; Double_t_det; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; Bool_tRooAbsArg::_fastAllow fast access mode in getVal() and proxies; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; map<int,RooMultiVarGaussian::GenData>_genCache!; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsReal::_hideOffsetOffset hiding flag; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches; Bool_tRooAbsArg::_isConstant! Cached isConstant status; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Bool_tRooAbsArg::_localNoInhibitDirty! Prevent 'AlwaysDirty' mode for th",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooMultiVarGaussian.html:42425,cache,cache,42425,root/html602/RooMultiVarGaussian.html,https://root.cern,https://root.cern/root/html602/RooMultiVarGaussian.html,4,['cache'],['cache']
Performance,"setErrorCounters(Int_t resetValue = 10); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(basic_ostream<char,char_traits<char> >& out, Option_t* option = """"); virtual Bool_tRooAbsPdf::selfNormalized() const; TIterator*RooAbsArg::serverIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); static voidRooAbsArg::setACleanADirty(Bool_t flag); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); static voidRooAbsReal::setCacheCheck(Bool_t flag); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); voidSetErrorTolerance(Double_t t); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); voidSetForceSum(Bool_t flag); voidRooAbsPdf::setGeneratorConfig(); voidRooAbsPdf::setGeneratorConfig(const RooNumGenConfig& config); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidSetMaxIters(Int_t mi); virtual voidTNamed::SetName(const char* name)MENU ; virtual voidTNamed::SetNameTitle(const char* name, const char* title); voidRooAbsPdf::setNormRange(const char* rangeName); voidRooAbsPdf::setNormRangeOverride(const char* rangeName); voidRooAbsPdf::setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbs",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooNonCentralChiSquare.html:28356,cache,cache,28356,root/html528/RooNonCentralChiSquare.html,https://root.cern,https://root.cern/root/html528/RooNonCentralChiSquare.html,1,['cache'],['cache']
Performance,set] : Elapsed time for evaluation of 4000 events: 0.105 sec ; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; Factory : ␛[1mEvaluate all methods␛[0m; : Evaluate multiclass classification method: BDTG; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_BDTG : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: MLP; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_MLP : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classification method: PDEFoam; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; : Creating multiclass response histograms...; : Creating multiclass performance histograms...; TFHandler_PDEFoam : Variable Mean RMS [ Min Max ]; : -----------------------------------------------------------; : var1: 0.070153 1.0224 [ -4.0592 3.5808 ]; : var2: 0.30372 1.0460 [ -3.6952 3.7877 ]; : var3: 0.12152 1.1222 [ -3.6800 3.9200 ]; : var4: -0.072602 1.2766 [ -4.8486 4.2221 ]; : -----------------------------------------------------------; : Evaluate multiclass classif,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAMulticlass_8C.html:21655,perform,performance,21655,doc/master/TMVAMulticlass_8C.html,https://root.cern,https://root.cern/doc/master/TMVAMulticlass_8C.html,1,['perform'],['performance']
Performance,"sets;  ; TTreeReader * fTreeReader;  Tree reader we belong to. ;  . #include <TTreeReaderValue.h>. Inheritance diagram for TTreeReaderValue< T >:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Member Typedef Documentation. ◆ NonConstT_t. template<typename T > . using TTreeReaderValue< T >::NonConstT_t = typename std::remove_const<T>::type. Definition at line 178 of file TTreeReaderValue.h. Constructor & Destructor Documentation. ◆ TTreeReaderValue() [1/2]. template<typename T > . TTreeReaderValue< T >::TTreeReaderValue ; (; ). delete . ◆ TTreeReaderValue() [2/2]. template<typename T > . TTreeReaderValue< T >::TTreeReaderValue ; (; TTreeReader & ; tr, . const char * ; branchname . ). inline . Definition at line 180 of file TTreeReaderValue.h. Member Function Documentation. ◆ Get(). template<typename T > . T * TTreeReaderValue< T >::Get ; (; ). inline . Return a pointer to the value of the current entry. ; Return a nullptr and print an error if no entry has been loaded yet. The returned address is guaranteed to stay constant while a given TTree is being read from a given file, unless the branch addresses are manipulated directly (e.g. through TTree::SetBranchAddress()). The address might also change when the underlying TTree/TFile is switched, e.g. when a TChain switches files. ; Definition at line 189 of file TTreeReaderValue.h. ◆ GetDerivedTypeName(). template<typename T > . const char * TTreeReaderValue< T >::GetDerivedTypeName ; (; ); const. inlineoverrideprotectedvirtual . Get the template argument as a string. ; Implements ROOT::Internal::TTreeReaderValueBase.; Definition at line 211 of file TTreeReaderValue.h. ◆ operator*(). template<typename T > . T & TTreeReaderValue< T >::operator* ; (; ). inline . Return a reference to the value of the current entry. ; Equivalent to dereferencing the pointer returned by Get(). Behavior is undefined if no entry has been loaded yet. Most likely a crash will occur. ; Definition ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeReaderValue.html:6416,load,loaded,6416,doc/master/classTTreeReaderValue.html,https://root.cern,https://root.cern/doc/master/classTTreeReaderValue.html,1,['load'],['loaded']
Performance,settings in a variable object (like ROOT::Fit::ParamsSettings) ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 367 of file Minuit2Minimizer.cxx. ◆ GlobalCC(). double ROOT::Minuit2::Minuit2Minimizer::GlobalCC ; (; unsigned int ; i); const. overridevirtual . get global correlation coefficient for the variable i. ; This is a number between zero and one which gives the correlation between the i-th variable and that linear combination of all other variables which is most strongly correlated with i. If the variable is fixed or const the return value is zero ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 835 of file Minuit2Minimizer.cxx. ◆ Hesse(). bool ROOT::Minuit2::Minuit2Minimizer::Hesse ; (; ). overridevirtual . perform a full calculation of the Hessian matrix for error calculation If a valid minimum exists the calculation is done on the minimum point otherwise is performed in the current set values of parameters Status code of minimizer is updated according to the following convention (in case Hesse failed) status += 100*hesseStatus where hesse status is: status = 1 : hesse failed status = 2 : matrix inversion failed status = 3 : matrix is not pos defined ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 1204 of file Minuit2Minimizer.cxx. ◆ IsFixedVariable(). bool ROOT::Minuit2::Minuit2Minimizer::IsFixedVariable ; (; unsigned int ; ivar); const. overridevirtual . query if an existing variable is fixed (i.e. ; considered constant in the minimization) note that by default all variables are not fixed ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 356 of file Minuit2Minimizer.cxx. ◆ MinGradient(). const double * ROOT::Minuit2::Minuit2Minimizer::MinGradient ; (; ); const. inlineoverridevirtual . return pointer to gradient values at the minimum ; Reimplemented from ROOT::Math::Minimizer.; Definition at line 146 of file Minuit2Minimizer.h. ◆ Minimize(). bool ROOT::Minuit2::Minuit2Minimizer::Minimize ; (; ). over,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html:19113,perform,perform,19113,doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Minuit2_1_1Minuit2Minimizer.html,2,['perform'],"['perform', 'performed']"
Performance,se}. protected . ! true if cache was automatically created ; Definition at line 66 of file TTreeCache.h. ◆ fBranches. TObjArray* TTreeCache::fBranches {nullptr}. protected . ! List of branches to be stored in the cache ; Definition at line 51 of file TTreeCache.h. ◆ fBrNames. TList* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:52866,cache,cache,52866,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"sg = ""p.d.f normalization integral is zero or negative: "" + std::to_string(normVal);; 287 logEvalError(msg.c_str());; 288 clearValueAndShapeDirty();; 289 return RooNaNPacker::packFloatIntoNaN(-normVal + (rawVal < 0. ? -rawVal : 0.));; 290 }; 291 ; 292 if (rawVal < 0.) {; 293 logEvalError(Form(""p.d.f value is less than zero (%f), trying to recover"", rawVal));; 294 clearValueAndShapeDirty();; 295 return RooNaNPacker::packFloatIntoNaN(-rawVal);; 296 }; 297 ; 298 if (TMath::IsNaN(rawVal)) {; 299 logEvalError(""p.d.f value is Not-a-Number"");; 300 clearValueAndShapeDirty();; 301 return rawVal;; 302 }; 303 ; 304 return (rawVal == 0. && normVal == 0.) ? 0. : rawVal / normVal;; 305}; 306 ; 307 ; 308////////////////////////////////////////////////////////////////////////////////; 309/// Return current value, normalized by integrating over; 310/// the observables in `nset`. If `nset` is 0, the unnormalized value; 311/// is returned. All elements of `nset` must be lvalues.; 312///; 313/// Unnormalized values are not cached.; 314/// Doing so would be complicated as `_norm->getVal()` could; 315/// spoil the cache and interfere with returning the cached; 316/// return value. Since unnormalized calls are typically; 317/// done in integration calls, there is no performance hit.; 318 ; 319double RooAbsPdf::getValV(const RooArgSet* nset) const; 320{; 321 ; 322 // Special handling of case without normalization set (used in numeric integration of pdfs); 323 if (!nset) {; 324 RooArgSet const* tmp = _normSet ;; 325 _normSet = nullptr ;; 326 double val = evaluate() ;; 327 _normSet = tmp ;; 328 ; 329 return TMath::IsNaN(val) ? 0. : val;; 330 }; 331 ; 332 ; 333 // Process change in last data set used; 334 bool nintChanged(false) ;; 335 if (!isActiveNormSet(nset) || _norm==nullptr) {; 336 nintChanged = syncNormalization(nset) ;; 337 }; 338 ; 339 // Return value of object. Calculated if dirty, otherwise cached value is returned.; 340 if (isValueDirty() || nintChanged || _norm->isValueDirty()) {",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:11849,cache,cached,11849,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['cache'],['cached']
Performance,"sgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(). Data Members; public:. enum EEventType { kUnDefined; kPacket; kStart; kStop; kFile; kFileOpen; kFileRead; kRate; kNumEventType; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TVirtualPerfStats *& CurrentPerfStats(); Return the current ROOT perf stats if any. const char * EventType(TVirtualPerfStats::EEventType type); Return the name of the event type. virtual ~TVirtualPerfStats(); {}. void SimpleEvent(TVirtualPerfStats::EEventType type). void PacketEvent(const char* slave, const char* slavename, const char* filename, Long64_t eventsprocessed, Double_t latency, Double_t proctime, Double_t cputime, Long64_t bytesRead). void FileOpenEvent(TFile* file, const char* filename, Double_t start). void FileReadEvent(TFile* file, Int_t len, Double_t start). void UnzipEvent(TObject* tree, Long64_t pos, Double_t start, Int_t complen, Int_t objlen). void RateEvent(Double_t proctime, Double_t deltatime, Long64_t eventsprocessed, Long64_t bytesRead). Long64_t GetBytesRead() const. void SetNumEvents(Long64_t num). Long64_t GetNumEvents() const. » Author: Kristjan Gulbrandsen 11/05/04 » Copyright (C) 1995-2004, Rene Brun and Fons Rademakers. *; » Last changed: root/base:$Id$ » Last generated: 2015-03-15 16:41; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TVirtualPerfStats.html:6885,latency,latency,6885,root/html534/TVirtualPerfStats.html,https://root.cern,https://root.cern/root/html534/TVirtualPerfStats.html,2,['latency'],['latency']
Performance,"sgfmt,...) const;  Issue warning message. ;  . Static Public Member Functions; static TFileOpenHandle * AsyncOpen (const char *name, Option_t *option="""", const char *ftitle="""", Int_t compress=ROOT::RCompressionSetting::EDefaults::kUseCompiledDefault, Int_t netopt=0);  Submit an asynchronous open request. ;  ; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static Bool_t Cp (const char *src, const char *dst, Bool_t progressbar=kTRUE, UInt_t buffersize=1000000);  Allows to copy file from src to dst URL. ;  ; static TFile *& CurrentFile ();  Return the current ROOT file if any. ;  ; static const char * DeclFileName ();  ; static EAsyncOpenStatus GetAsyncOpenStatus (const char *name);  Get status of the async open request related to 'name'. ;  ; static EAsyncOpenStatus GetAsyncOpenStatus (TFileOpenHandle *handle);  Get status of the async open request related to 'handle'. ;  ; static const char * GetCacheFileDir ();  Get the directory where to locally stage/cache remote files. ;  ; static const TUrl * GetEndpointUrl (const char *name);  Get final URL for file being opened asynchronously. ;  ; static Long64_t GetFileBytesRead ();  Static function returning the total number of bytes read from all files. ;  ; static Long64_t GetFileBytesWritten ();  Static function returning the total number of bytes written to all files. ;  ; static Long64_t GetFileCounter ();  ; static Int_t GetFileReadCalls ();  Static function returning the total number of read calls from all files. ;  ; static Bool_t GetOnlyStaged ();  Returns staged only flag. ;  ; static UInt_t GetOpenTimeout ();  Returns open timeout (in ms). ;  ; static Int_t GetReadaheadSize ();  Static function returning the readahead buffer size. ;  ; static Bool_t GetReadStreamerInfo ();  If the streamerinfos are to be read at file opening. ;  ; static EFileType GetType (const char *name, Option_t *option="""", TString *prefix=nullptr);  Resolve the file type as a",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTFile.html:31319,cache,cache,31319,doc/v632/classTFile.html,https://root.cern,https://root.cern/doc/v632/classTFile.html,2,['cache'],['cache']
Performance,"sh value returned by the TString::Hash() after converting name to a TString. ; Reimplemented from THashList.; Definition at line 51 of file THashList.cxx. ◆ FindObject() [2/3]. TObject * TListOfDataMembers::FindObject ; (; const char * ; name); const. overridevirtual . Specialize FindObject to do search for the a data member just by name or create it if its not already in the list. ; Reimplemented from THashList.; Definition at line 182 of file TListOfDataMembers.cxx. ◆ FindObject() [3/3]. TObject * THashList::FindObject ; (; const TObject * ; obj); const. overridevirtual . Find object using its hash value (returned by its Hash() member). ; Reimplemented from THashList.; Definition at line 52 of file THashList.cxx. ◆ Get() [1/2]. TDictionary * TListOfDataMembers::Get ; (; DataMemberInfo_t * ; info, . bool ; skipChecks = kFALSE . ). Return (after creating it if necessary) the TDataMember describing the data member corresponding to the Decl 'id'. ; The skipChecks flag controls the consistency checks performed inspecting the AST. In some cases, we explicitly alter the datamembers in the typesystem with respect to the AST and therefore we must not enforce consistency. ; Definition at line 273 of file TListOfDataMembers.cxx. ◆ Get() [2/2]. TDictionary * TListOfDataMembers::Get ; (; DeclId_t ; id). Return (after creating it if necessary) the TDataMember describing the data member corresponding to the Decl 'id'. ; Definition at line 216 of file TListOfDataMembers.cxx. ◆ GetClass(). TClass * TListOfDataMembers::GetClass ; (; ); const. inline . Definition at line 90 of file TListOfDataMembers.h. ◆ IsA(). TClass * TListOfDataMembers::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from THashList.; Definition at line 102 of file TListOfDataMembers.h. ◆ IsLoaded(). Bool_t TListOfDataMembers::IsLoaded ; (; ); const. inline . Definition at line 79 of file TListOfDataMembers.h. ◆ Load(). void TListOfDataMembers::Load ; (; ). Load ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTListOfDataMembers.html:29878,perform,performed,29878,doc/master/classTListOfDataMembers.html,https://root.cern,https://root.cern/doc/master/classTListOfDataMembers.html,1,['perform'],['performed']
Performance,"sh.; 8167///; 8168/// ### CASE 1 : autof > 0; 8169///; 8170/// autof is the number of consecutive entries after which TTree::Fill will; 8171/// flush all branch buffers to disk.; 8172///; 8173/// ### CASE 2 : autof < 0; 8174///; 8175/// When filling the Tree the branch buffers will be flushed to disk when; 8176/// more than autof bytes have been written to the file. At the first FlushBaskets; 8177/// TTree::Fill will replace fAutoFlush by the current value of fEntries.; 8178///; 8179/// Calling this function with autof<0 is interesting when it is hard to estimate; 8180/// the size of one entry. This value is also independent of the Tree.; 8181///; 8182/// The Tree is initialized with fAutoFlush=-30000000, ie that, by default,; 8183/// the first AutoFlush will be done when 30 MBytes of data are written to the file.; 8184///; 8185/// ### CASE 3 : autof = 0; 8186///; 8187/// The AutoFlush mechanism is disabled.; 8188///; 8189/// Flushing the buffers at regular intervals optimize the location of; 8190/// consecutive entries on the disk by creating clusters of baskets.; 8191///; 8192/// A cluster of baskets is a set of baskets that contains all; 8193/// the data for a (consecutive) set of entries and that is stored; 8194/// consecutively on the disk. When reading all the branches, this; 8195/// is the minimum set of baskets that the TTreeCache will read.; 8196 ; 8197void TTree::SetAutoFlush(Long64_t autof /* = -30000000 */ ); 8198{; 8199 // Implementation note:; 8200 //; 8201 // A positive value of autoflush determines the size (in number of entries) of; 8202 // a cluster of baskets.; 8203 //; 8204 // If the value of autoflush is changed over time (this happens in; 8205 // particular when the TTree results from fast merging many trees),; 8206 // we record the values of fAutoFlush in the data members:; 8207 // fClusterRangeEnd and fClusterSize.; 8208 // In the code we refer to a range of entries where the size of the; 8209 // cluster of baskets is the same (i.e the value o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:318223,optimiz,optimize,318223,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['optimiz'],['optimize']
Performance,"shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueAndShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooIntegralMorph.html:5895,cache,cacheUniqueSuffix,5895,root/html532/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html532/RooIntegralMorph.html,2,['cache'],['cacheUniqueSuffix']
Performance,"shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsCachedPdf::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); Bool_tcacheAlpha() const; virtual const char*RooAbsArg::cacheUniqueSuffix() const; Bool_tRooAbsPdf::canBeExtended() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsPdf::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidTNamed::Clear(Option_t* option = """"); static voidRooAbsPdf::clearEvalError(); static voidRooAbsReal::clearEvalErrorLog(); voidRooAbsArg::clearShapeDirty() const; voidRooAbsArg::clearValueDirty() const; TIterator*RooAbsArg::clientIterator() const; virtual TObject*clone(const char* newname) const; virtual TObject*RooAbsArg::Clone(const char* newname = 0) const; virtual RooAbsArg*RooAbsArg::cloneTree(const char* newname = 0) const; virtual Int_tRooAbsArg::Compare(const TObject* other) const; virtual voidRooAbsArg::constOptimizeTestStatistic(RooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooIntegralMorph.html:5895,cache,cacheUniqueSuffix,5895,root/html528/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html528/RooIntegralMorph.html,2,['cache'],['cacheUniqueSuffix']
Performance,"shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; const RooArgList&boundaries(); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = RooCmdArg::none(), RooCmdArg arg6 = RooCmdArg::none(), RooCmdArg arg7 = RooCmdArg::none(), RooCmdArg arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, RooCmdArg arg1 = RooCmdArg::none(), RooCmdArg arg2 = RooCmdArg::none(), RooCmdArg arg3 = RooCmdArg::none(), RooCmdArg arg4 = RooCmdArg::none(), RooCmdArg arg5 = R",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooStepFunction.html:2471,cache,cacheUniqueSuffix,2471,root/html528/RooStepFunction.html,https://root.cern,https://root.cern/root/html528/RooStepFunction.html,1,['cache'],['cacheUniqueSuffix']
Performance,"shapeProp = kFALSE); const char*RooAbsArg::aggregateCacheUniqueSuffix() const; virtual Double_tRooAbsReal::analyticalIntegral(Int_t code, const char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; const RooArgList&boundaries(); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooStepFunction.html:2471,cache,cacheUniqueSuffix,2471,root/html530/RooStepFunction.html,https://root.cern,https://root.cern/root/html530/RooStepFunction.html,3,['cache'],['cacheUniqueSuffix']
Performance,"shapeProp); voidTObject::ResetBit(UInt_t f); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProduct.html:24066,cache,cache,24066,root/html534/RooProduct.html,https://root.cern,https://root.cern/root/html534/RooProduct.html,2,['cache'],['cache']
Performance,"shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Mon Jul 4 15:23:08 2011 » Last generated: 2011-07-04 15:23; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/RooIntegralMorph.html:47517,cache,cache,47517,root/html530/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html530/RooIntegralMorph.html,3,['cache'],"['cache', 'cacheAlpha']"
Performance,"shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Sat Oct 9 06:58:30 2010 » Last generated: 2010-10-09 06:58; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooIntegralMorph.html:46957,cache,cache,46957,root/html528/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html528/RooIntegralMorph.html,3,['cache'],"['cache', 'cacheAlpha']"
Performance,"shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Thu Nov 3 20:08:25 2011 » Last generated: 2011-11-03 20:08; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooIntegralMorph.html:47924,cache,cache,47924,root/html532/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html532/RooIntegralMorph.html,6,['cache'],"['cache', 'cacheAlpha']"
Performance,"shapes at the end points of the interpolation parameter alpha; If doCacheAlpha is true, a two-dimensional cache is constructed in; both alpha and x. RooIntegralMorph(const RooIntegralMorph& other, const char* name = 0); Copy constructor. RooArgSet* actualObservables(const RooArgSet& nset) const; Observable to be cached for given choice of normalization.; Returns the 'x' observable unless doCacheAlpha is set in which; case a set with both x and alpha. RooArgSet* actualParameters(const RooArgSet& nset) const; Parameters of the cache. Returns parameters of both pdf1 and pdf2; and parameter cache, in case doCacheAlpha is not set. const char* inputBaseName() const; Return base name component for cache components in this case; a string encoding the names of both end point p.d.f.s. void fillCacheObject(RooAbsCachedPdf::PdfCacheElem& cache) const; Fill the cache with the interpolated shape. RooAbsCachedPdf::PdfCacheElem* createCache(const RooArgSet* nset) const; Create and return a derived MorphCacheElem. Double_t evaluate() const; Dummy. void preferredObservableScanOrder(const RooArgSet& obs, RooArgSet& orderedObs) const; Indicate to the RooAbsCachedPdf base class that for the filling of the; cache the traversal of the x should be in the innermost loop, to minimize; recalculation of the one-dimensional internal cache for a fixed value of alpha. RooIntegralMorph(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooIntegralMorph(*this,newname); }. virtual ~RooIntegralMorph(); { }. Bool_t selfNormalized() const; P.d.f is self normalized. void setCacheAlpha(Bool_t flag); Activate caching of p.d.f. shape for all values of alpha as well. Bool_t cacheAlpha() const; If true caching of p.d.f for all alpha values is active. » Last changed: Tue Jun 2 15:31:37 2015 » Last generated: 2015-06-02 15:31; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooIntegralMorph.html:51958,cache,cache,51958,root/html604/RooIntegralMorph.html,https://root.cern,https://root.cern/root/html604/RooIntegralMorph.html,6,['cache'],"['cache', 'cacheAlpha']"
Performance,"shared_ptr will be removed. ; Remove canvas from global canvas lists, will be destroyed once last shared_ptr is disappear. ; Definition at line 225 of file RCanvas.cxx. ◆ ResolveSharedPtrs(). void ROOT::Experimental::RCanvas::ResolveSharedPtrs ; (; ). To resolve problem with storing of shared pointers Call this method when reading canvas from the file Can be called many times - after reinitialization of shared pointers no changes will be performed. ; Definition at line 299 of file RCanvas.cxx. ◆ Run(). void ROOT::Experimental::RCanvas::Run ; (; double ; tm = 0.). Run canvas functionality for given time (in seconds) ; Run canvas functionality for the given time (in seconds) Used to process canvas-related actions in the appropriate thread context.; Must be regularly called when canvas created and used in extra thread. Time parameter specifies minimal execution time in seconds - if default value 0 is used, just all pending actions will be performed. When canvas is not yet displayed - just performs sleep for given time interval.; Example of usage:; void draw_canvas(bool &run_loop, std::make_shared<RH1D> hist); {; auto canvas = RCanvas::Create(""Canvas title"");; canvas->Draw(hist)->SetLineColor(RColor::kBlue);; canvas->Show();; while (run_loop) {; pHist->Fill(1);; canvas->Modified();; canvas->Update();; canvas->Run(0.1); // process canvas events; }; ; canvas->Remove();; }; ; int main(); {; RAxisConfig xaxis(100, -10., 10.);; auto pHist = std::make_shared<RH1D>(xaxis);; bool run_loop = true;; ; std::thread thrd(draw_canvas, run_loop, pHist);; std::this_thread::sleep_for(std::chrono::seconds(100));; run_loop = false;; thrd.join();; return 0;; }; mainint main()Definition Prototype.cxx:12; ROOT::Experimental::RCanvas::Createstatic std::shared_ptr< RCanvas > Create(const std::string &title)Create new canvas instance.Definition RCanvas.cxx:89; ROOT::Experimental::RColor::kBluestatic R__DLLEXPORT constexpr RGB_t kBlueDefinition RColor.hxx:186. Definition at line 285 of file RCan",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html:15854,perform,performs,15854,doc/master/classROOT_1_1Experimental_1_1RCanvas.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RCanvas.html,1,['perform'],['performs']
Performance,"sher, ""Category_Fisher_2"",""!H:!V:Fisher"" );; ; // Likelihood with categories; TMVA::MethodBase* liCat = factory->BookMethod( dataloader, TMVA::Types::kCategory, ""LikelihoodCat"","""" );; mcat = dynamic_cast<TMVA::MethodCategory*>(liCat);; mcat->AddMethod( ""abs(eta)<=1.3"",theCat1Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_1"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; mcat->AddMethod( ""abs(eta)>1.3"", theCat2Vars, TMVA::Types::kLikelihood,; ""Category_Likelihood_2"",""!H:!V:TransformOutput:PDFInterpol=Spline2:NSmoothSig[0]=20:NSmoothBkg[0]=20:NSmoothBkg[1]=10:NSmooth=1:NAvEvtPerBin=50"" );; ; // Now you can tell the factory to train, test, and evaluate the MVAs; ; // Train MVAs using the set of training events; factory->TrainAllMethods();; ; // Evaluate all MVAs using the set of test events; factory->TestAllMethods();; ; // Evaluate and compare performance of all configured MVAs; factory->EvaluateAllMethods();; ; // --------------------------------------------------------------; ; // Save the output; outputFile->Close();; ; std::cout << ""==> Wrote root file: "" << outputFile->GetName() << std::endl;; std::cout << ""==> TMVAClassificationCategory is done!"" << std::endl;; ; // Clean up; delete factory;; delete dataloader;; ; // Launch the GUI for the root macros; if (!gROOT->IsBatch()) TMVA::TMVAGui( outfileName );; }; int main( int argc, char** argv ); {; TMVAClassificationCategory();; return 0;; }; DataLoader.h; MethodCategory.h; mainint main()Definition Prototype.cxx:12; Bool_tbool Bool_tDefinition RtypesCore.h:63; Double_tdouble Double_tDefinition RtypesCore.h:59; kTRUEconstexpr Bool_t kTRUEDefinition RtypesCore.h:93; TChain.h; TFile.h; inputOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void inputDefinition TGWin32VirtualXProxy.cxx:142; TMVAGui.h; TObjString.h; TROOT.h; gROOT#defin",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassificationCategory_8C.html:33149,perform,performance,33149,doc/master/TMVAClassificationCategory_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassificationCategory_8C.html,1,['perform'],['performance']
Performance,"shevPol.h:34; TMVA_SOFIE_GNN_Parser.h2h2Definition TMVA_SOFIE_GNN_Parser.py:188; . To control the bar width (default is the bin width) TH1::SetBarWidth() should be used.; To control the bar offset (default is 0) TH1::SetBarOffset() should be used.; These two parameters are useful when several histograms are plotted using the option SAME. They allow to plot the histograms next to each other. The SCATter plot option (legacy draw option); AttentionUse of option SCAT has been deprecated. It was the default drawing option for 2D and 3D histograms. The new default option is COL (heat-map).; For each cell (i,j) a number of points proportional to the cell content is drawn. A maximum of kNMAX points per cell is drawn. If the maximum is above kNMAX contents are normalized to kNMAX (kNMAX=2000). If option is of the form scat=ff, (eg scat=1.8, scat=1e-3), then ff is used as a scale factor to compute the number of dots. scat=1 is the default.; By default the scatter plot is painted with a ""dot marker"" which not scalable (see the TAttMarker documentation). To change the marker size, a scalable marker type should be used. For instance a circle (marker style 20).; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto hscat = new TH2F(""hscat"",""Option SCATter example (default for 2D histograms) "",40,-4,4,40,-20,20);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; hscat->Fill(px,5*py);; hscat->Fill(3+0.5*px,2*py-10.);; }; hscat->Draw(""scat=0.5""); // This a legacy draw option. Please consider using TScatter; }. The ARRow option; Shows gradient between adjacent cells. For each cell (i,j) an arrow is drawn The orientation of the arrow follows the cell gradient.; {; auto c1 = new TCanvas(""c1"",""c1"",600,400);; auto harr = new TH2F(""harr"",""Option ARRow example"",20,-4,4,20,-20,20);; harr->SetLineColor(kRed);; float px, py;; for (Int_t i = 0; i < 25000; i++) {; gRandom->Rannor(px,py);; harr->Fill(px,5*py);; harr->Fill(3+0.5*px,2*py-10.,0.1);; }; harr->Draw(""ARR"");; }.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHistPainter.html:38084,scalab,scalable,38084,doc/master/classTHistPainter.html,https://root.cern,https://root.cern/doc/master/classTHistPainter.html,1,['scalab'],['scalable']
Performance,"sholds ();  Update the cumulative threshold table from the current coefficient values. ;  ;  Protected Member Functions inherited from RooAbsGenContext; virtual RooDataSet * createDataSet (const char *name, const char *title, const RooArgSet &obs);  Create an empty dataset to hold the events that will be generated. ;  ; void resampleData (double &ratio);  Rescale existing output buffer with given ratio. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; std::vector< double > _coefThresh;  [_nComp] Array of coefficient thresholds ;  ; std::vector< std::unique_ptr< RooAbsGenContext > > _gcList;  List of component generator contexts. ;  ; bool _isModel;  Are we generating from a RooAddPdf or a RooAddModel. ;  ; Int_t _nComp;  Number of PDF components. ;  ; AddCacheElem * _pcache = nullptr;  ! RooAddPdf cache element ;  ; RooAbsPdf * _pdf;  Pointer to cloned p.d.f. ;  ; std::unique_ptr< RooArgSet > _pdfSet;  Set owned all nodes of internal clone of p.d.f. ;  ; std::unique_ptr< RooArgSet > _vars;  ;  Protected Attributes inherited from RooAbsGenContext; UInt_t _expectedEvents;  Number of expected events from extended p.d.f. ;  ; RooAbsPdf::ExtendMode _extendMode;  Extended mode capabilities of p.d.f. ;  ; RooDataSet * _genData = nullptr;  ! Data being generated ;  ; bool _isValid;  Is context in valid state? ;  ; Int_t _nextProtoIndex;  Next prototype event to load according to LUT. ;  ; TString _normRange;  Normalization range of pdf. ;  ; std::vector< Int_t > _protoOrder;  LUT with traversal order of prototype data. ;  ; const RooDataSet * _prototype;  Pointer to prototype dataset. ;  ; RooArgSet _protoVars;  Prototype observables. ;  ; RooArgSet _theEvent;  Pointer to observable event being generated. ;  ; bool _verbose;  Verbose messaging? ;  ;  Protected Attributes inherited from TNa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAddGenContext.html:15861,cache,cache,15861,doc/master/classRooAddGenContext.html,https://root.cern,https://root.cern/doc/master/classRooAddGenContext.html,1,['cache'],['cache']
Performance,"should be set to true for parallel minimization of likelihoods!; 928 * Note that it is currently not recommended to use Modular likelihoods without any parallelization enabled in the minimization, since; 929 * some features such as offsetting might not yet work in this case.; 930 * </table>; 931 */; 932 ; 933 ; 934/** @brief Protected implementation of the NLL creation routine.; 935 *; 936 * This virtual function can be overridden in case you want to change the NLL creation logic for custom PDFs.; 937 *; 938 * \note Never call this function directly. Instead, call RooAbsPdf::createNLL().; 939 */; 940 ; 941std::unique_ptr<RooAbsReal> RooAbsPdf::createNLLImpl(RooAbsData &data, const RooLinkedList &cmdList); 942{; 943 return RooFit::FitHelpers::createNLL(*this, data, cmdList);; 944}; 945 ; 946 ; 947/** @fn RooAbsPdf::fitTo(); 948 *; 949 * @brief Fit PDF to given dataset.; 950 *; 951 * If dataset is unbinned, an unbinned maximum likelihood is performed.; 952 * If the dataset is binned, a binned maximum likelihood is performed.; 953 * By default the fit is executed through the MINUIT commands MIGRAD, HESSE in succession.; 954 *; 955 * @param data Reference to a RooAbsData object representing the dataset.; 956 * @param cmdArgs Variadic template arguments representing optional command arguments.; 957 * You can pass either an arbitrary number of RooCmdArg instances; 958 * or a single RooLinkedList that points to the RooCmdArg objects.; 959 * @return An owning pointer to the created RooAbsReal NLL object.; 960 * @return RooFitResult with fit status and parameters if option Save() is used, `nullptr` otherwise. The user takes ownership of the fit result.; 961 *; 962 * @tparam CmdArgs_t Template types for optional command arguments.; 963 * Can either be an arbitrary number of RooCmdArg or a single RooLinkedList.; 964 *; 965 * \note This front-end function should not be re-implemented in derived PDF types.; 966 * If you mean to customize the likelihood fitting routine,; 967 * you",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html:43712,perform,performed,43712,doc/master/RooAbsPdf_8cxx_source.html,https://root.cern,https://root.cern/doc/master/RooAbsPdf_8cxx_source.html,1,['perform'],['performed']
Performance,"should you encounter them. RNTuple is still in pre-production. The on-disk format is scheduled to be finalized by the end of 2024. Thus, we appreciate feedback and suggestions for improvement.; Histogram Libraries. Implement the FLT_MAX mechanism for THStack::GetMaximum() and THStack::GetMiniumum().; Print a warning when the range given to TAxis::SetRange is invalid.; Fix projection name in TH3 as requested here. Parallelism. The ROOT::Experimental::TFuture template has been removed. RooFit Libraries; New CPU likelihood evaluation backend by default; The new vectorizing CPU evaluation backend is not the default for RooFit likelihoods. Likelihood minimization is now up to 10x faster on a single CPU core.; If you experience unexpected problems related to the likelihood evaluation, you can revert back to the old backend by passing RooFit::EvalBackend(""legacy"") to RooAbsPdf::fitTo() or RooAbsPdf::createNLL().; In case you observe any slowdowns with the new likelihood evaluation, please open a GitHub issue about this, as such a performance regression is considered a bug.; Asymptotically correct uncertainties for extended unbinned likelihood fits; Added correct treatment of extended term in asymptotically correct method for uncertainty determination in the presence of weights. This improvement will allow for extended unbinned maximum likelihood fits to use the asymptotically correct method when using the RooFit::AsymptoticError() command argument in RooAbsPdf::fitTo(). See also this writeup on extended weighted fits that is also linked from the reference guide. The pull request that introduced this feature might also be a good reference.; Compile your code with memory safe interfaces; If you define the ROOFIT_MEMORY_SAFE_INTERFACES preprocessor macro, the RooFit interface changes in a way such that memory leaks are avoided.; The most prominent effect of this change is that many functions that used to return an owning pointer (e.g., a pointer to an object that you need to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/release-notes.html:8539,perform,performance,8539,doc/v632/release-notes.html,https://root.cern,https://root.cern/doc/v632/release-notes.html,1,['perform'],['performance']
Performance,"sian"", p, meanP, sigma);; ; // configure proposal function; PdfProposal pdfProposal(pGaussian);; pdfProposal.AddMapping(meanP, p); // each call of Propose(xPrime, x), meanP in; // the proposal function will be updated to; // the value of p in x. this will center the; // proposal function about x's p when; // proposing for xPrime; ; // To improve performance, PdfProposal has the ability to cache a specified; // number of proposals. If you don't call this function, the default cache size; // is 1, which can be slow.; pdfProposal.SetCacheSize(desiredCacheSize);; pwinID h TVirtualViewer3D TVirtualGLPainter pDefinition TGWin32VirtualGLProxy.cxx:51; RooGaussianPlain Gaussian p.d.f.Definition RooGaussian.h:24; RooRealVarVariable that can be changed from the outside.Definition RooRealVar.h:37; RooStats::PdfProposalPdfProposal is a concrete implementation of the ProposalFunction interface.Definition PdfProposal.h:30; sigmaconst Double_t sigmaDefinition h1analysisProxy.h:11; PdfProposal currently uses a fixed cache size. Adaptive caching methods are in the works for future versions. ; Definition at line 30 of file PdfProposal.h. Public Member Functions;  PdfProposal ();  By default, PdfProposal does NOT own the PDF that serves as the proposal density function. ;  ;  PdfProposal (RooAbsPdf &pdf);  By default, PdfProposal does NOT own the PDF that serves as the proposal density function. ;  ;  ~PdfProposal () override;  ; virtual void AddMapping (RooRealVar &proposalParam, RooAbsReal &update);  specify a mapping between a parameter of the proposal function and a parameter of interest. ;  ; virtual const RooAbsPdf * GetPdf () const;  Get the PDF is the proposal density function. ;  ; double GetProposalDensity (RooArgSet &x1, RooArgSet &x2) override;  Return the probability of proposing the point x1 given the starting point x2. ;  ; TClass * IsA () const override;  ; bool IsSymmetric (RooArgSet &x1, RooArgSet &x2) override;  Determine whether or not the proposal density is symmet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html:1906,cache,cache,1906,doc/master/classRooStats_1_1PdfProposal.html,https://root.cern,https://root.cern/doc/master/classRooStats_1_1PdfProposal.html,1,['cache'],['cache']
Performance,"sible alternative name (default template; 1482/// parameter, typedefs template arguments, typedefed name).; 1483 ; 1484TClass *TROOT::FindSTLClass(const char *name, Bool_t load, Bool_t silent) const; 1485{; 1486 // Example of inputs are; 1487 // vector<int> (*); 1488 // vector<Int_t>; 1489 // vector<long long>; 1490 // vector<Long_64_t> (*); 1491 // vector<int, allocator<int> >; 1492 // vector<Int_t, allocator<int> >; 1493 //; 1494 // One of the possibly expensive operation is the resolving of the typedef; 1495 // which can provoke the parsing of the header files (and/or the loading; 1496 // of clang pcms information).; 1497 ; 1498 R__LOCKGUARD(gInterpreterMutex);; 1499 ; 1500 // Remove std::, allocator, typedef, add Long64_t, etc. in just one call.; 1501 std::string normalized;; 1502 TClassEdit::GetNormalizedName(normalized, name);; 1503 ; 1504 TClass *cl = nullptr;; 1505 if (normalized != name) cl = TClass::GetClass(normalized.c_str(),load,silent);; 1506 ; 1507 if (load && cl==nullptr) {; 1508 // Create an Emulated class for this container.; 1509 cl = gInterpreter->GenerateTClass(normalized.c_str(), kTRUE, silent);; 1510 }; 1511 ; 1512 return cl;; 1513}; 1514 ; 1515////////////////////////////////////////////////////////////////////////////////; 1516/// Return pointer to class with name. Obsolete, use TClass::GetClass directly; 1517 ; 1518TClass *TROOT::GetClass(const char *name, Bool_t load, Bool_t silent) const; 1519{; 1520 return TClass::GetClass(name,load,silent);; 1521}; 1522 ; 1523 ; 1524////////////////////////////////////////////////////////////////////////////////; 1525/// Return pointer to class from its name. Obsolete, use TClass::GetClass directly; 1526/// See TClass::GetClass; 1527 ; 1528TClass *TROOT::GetClass(const std::type_info& typeinfo, Bool_t load, Bool_t silent) const; 1529{; 1530 return TClass::GetClass(typeinfo,load,silent);; 1531}; 1532 ; 1533////////////////////////////////////////////////////////////////////////////////; 1534/// Return add",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8cxx_source.html:58113,load,load,58113,doc/master/TROOT_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8cxx_source.html,4,['load'],['load']
Performance,"sible for deleting it. ; Definition at line 923 of file RooAbsRealLValue.cxx. ◆ createHistogram() [11/11]. TH1 * RooAbsRealLValue::createHistogram ; (; const char * ; name, . RooArgList & ; vars, . const char * ; tAxisLabel, . double * ; xlo, . double * ; xhi, . Int_t * ; nBins . ). static . Create 1-, 2- or 3-d ROOT histogram with labels taken from the variables in 'vars' and the with range and binning specified in xlo,xhi and nBins. ; The dimensions of the arrays xlo,xhi, nBins should match the number of objects in vars. ; Definition at line 897 of file RooAbsRealLValue.cxx. ◆ createIntegral(). RooFit::OwningPtr< RooAbsReal > RooAbsRealLValue::createIntegral ; (; const RooArgSet & ; iset, . const RooArgSet * ; nset = nullptr, . const RooNumIntConfig * ; cfg = nullptr, . const char * ; rangeName = nullptr . ); const. overridevirtual . Create an object that represents the integral of the function over one or more observables listed in iset. ; The actual integration calculation is only performed when the return object is evaluated. The name of the integral object is automatically constructed from the name of the input function, the variables it integrates and the range integrates over. If nset is specified the integrand is request to be normalized over nset (only meaningful when the integrand is a pdf). If rangename is specified the integral is performed over the named range, otherwise it is performed over the domain of each integrated observable. If cfg is specified it will be used to configure any numeric integration aspect of the integral. It will not force the integral to be performed numerically, which is decided automatically by RooRealIntegral. ; Reimplemented from RooAbsReal.; Definition at line 1056 of file RooAbsRealLValue.cxx. ◆ DeclFileName(). static const char * RooAbsRealLValue::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 164 of file RooAbsRealLValue.h. ◆ fitRangeOKForPlotting(). bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsRealLValue.html:75526,perform,performed,75526,doc/master/classRooAbsRealLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsRealLValue.html,1,['perform'],['performed']
Performance,"sient) override;; 561};; 562 ; 563////////////////////////////////////////////////////////////////////////////////; 564/// Print value of member mname.; 565///; 566/// This method is called by the ShowMembers() method for each; 567/// data member when object.Dump() is invoked.; 568///; 569/// - cl is the pointer to the current class; 570/// - pname is the parent name (in case of composed objects); 571/// - mname is the data member name; 572/// - add is the data member address; 573 ; 574void TDumpMembers::Inspect(TClass *cl, const char *pname, const char *mname, const void *add, Bool_t /* isTransient */); 575{; 576 const Int_t kvalue = 30;; 577#ifdef R__B64; 578 const Int_t ktitle = 50;; 579#else; 580 const Int_t ktitle = 42;; 581#endif; 582 const Int_t kline = 1024;; 583 Int_t cdate = 0;; 584 Int_t ctime = 0;; 585 UInt_t *cdatime = nullptr;; 586 char line[kline];; 587 ; 588 TDataType *membertype;; 589 EDataType memberDataType = kNoType_t;; 590 const char *memberName;; 591 const char *memberFullTypeName;; 592 const char *memberTitle;; 593 Bool_t isapointer;; 594 Bool_t isbasic;; 595 Bool_t isarray;; 596 ; 597 if (TDataMember *member = cl->GetDataMember(mname)) {; 598 if (member->GetDataType()) {; 599 memberDataType = (EDataType)member->GetDataType()->GetType();; 600 }; 601 memberName = member->GetName();; 602 memberFullTypeName = member->GetFullTypeName();; 603 memberTitle = member->GetTitle();; 604 isapointer = member->IsaPointer();; 605 isbasic = member->IsBasic();; 606 membertype = member->GetDataType();; 607 isarray = member->GetArrayDim();; 608 } else if (!cl->IsLoaded()) {; 609 // The class is not loaded, hence it is 'emulated' and the main source of; 610 // information is the StreamerInfo.; 611 TVirtualStreamerInfo *info = cl->GetStreamerInfo();; 612 if (!info) return;; 613 const char *cursor = mname;; 614 while ( (*cursor)=='*' ) ++cursor;; 615 TString elname( cursor );; 616 Ssiz_t pos = elname.Index(""["");; 617 if ( pos != kNPOS ) {; 618 elname.Remove( pos );;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:21131,load,loaded,21131,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"sient) override;; 628};; 629 ; 630////////////////////////////////////////////////////////////////////////////////; 631/// Print value of member mname.; 632///; 633/// This method is called by the ShowMembers() method for each; 634/// data member when object.Dump() is invoked.; 635///; 636/// - cl is the pointer to the current class; 637/// - pname is the parent name (in case of composed objects); 638/// - mname is the data member name; 639/// - add is the data member address; 640 ; 641void TDumpMembers::Inspect(TClass *cl, const char *pname, const char *mname, const void *add, Bool_t /* isTransient */); 642{; 643 const Int_t kvalue = 30;; 644#ifdef R__B64; 645 const Int_t ktitle = 50;; 646#else; 647 const Int_t ktitle = 42;; 648#endif; 649 const Int_t kline = 1024;; 650 Int_t cdate = 0;; 651 Int_t ctime = 0;; 652 UInt_t *cdatime = nullptr;; 653 char line[kline];; 654 ; 655 TDataType *membertype;; 656 EDataType memberDataType = kNoType_t;; 657 const char *memberName;; 658 const char *memberFullTypeName;; 659 const char *memberTitle;; 660 Bool_t isapointer;; 661 Bool_t isbasic;; 662 Bool_t isarray;; 663 ; 664 if (TDataMember *member = cl->GetDataMember(mname)) {; 665 if (member->GetDataType()) {; 666 memberDataType = (EDataType)member->GetDataType()->GetType();; 667 }; 668 memberName = member->GetName();; 669 memberFullTypeName = member->GetFullTypeName();; 670 memberTitle = member->GetTitle();; 671 isapointer = member->IsaPointer();; 672 isbasic = member->IsBasic();; 673 membertype = member->GetDataType();; 674 isarray = member->GetArrayDim();; 675 } else if (!cl->IsLoaded()) {; 676 // The class is not loaded, hence it is 'emulated' and the main source of; 677 // information is the StreamerInfo.; 678 TVirtualStreamerInfo *info = cl->GetStreamerInfo();; 679 if (!info) return;; 680 const char *cursor = mname;; 681 while ( (*cursor)=='*' ) ++cursor;; 682 TString elname( cursor );; 683 Ssiz_t pos = elname.Index(""["");; 684 if ( pos != kNPOS ) {; 685 elname.Remove( pos );;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:23829,load,loaded,23829,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loaded']
Performance,"sientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; virtual voidShowMembers(TMemberInspector& insp, char* parent); RooMoment*RooAbsReal::sigma(RooRealVar& obs); RooMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsAnaConvPdf.html:31069,cache,cache,31069,root/html526/RooAbsAnaConvPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsAnaConvPdf.html,61,['cache'],['cache']
Performance,"sification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdDown(TGeoNode* node); Make a daughter of current node current. Can be called only with a valid; daughter node (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * Cr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGeoNavigator.html:13615,perform,performance,13615,root/html602/TGeoNavigator.html,https://root.cern,https://root.cern/root/html602/TGeoNavigator.html,2,['perform'],['performance']
Performance,"sification; Double_tfStep! step to be done from current point and direction; Int_tfThreadId! thread id for this navigator; TGeoNode*fTopNode! top physical node. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TGeoNavigator(); dummy constructor. TGeoNavigator(TGeoManager* geom); Default constructor. TGeoNavigator(const TGeoNavigator& ); Copy constructor. TGeoNavigator& operator=(const TGeoNavigator& ); assignment operator. ~TGeoNavigator(); Destructor. void BuildCache(Bool_t dummy = kFALSE, Bool_t nodeid = kFALSE); Builds the cache for physical nodes and global matrices. Bool_t cd(const char* path = """"); Browse the tree of nodes starting from top node according to pathname.; Changes the path accordingly. Bool_t CheckPath(const char* path) const; Check if a geometry path is valid without changing the state of the navigator. void CdNode(Int_t nodeid); Change current path to point to the node having this id.; Node id has to be in range : 0 to fNNodes-1 (no check for performance reasons). void CdDown(Int_t index); Make a daughter of current node current. Can be called only with a valid; daughter index (no check). Updates cache accordingly. void CdUp(); Go one level up in geometry. Updates cache accordingly.; Determine the overlapping state of current node. void CdTop(); Make top level node the current node. Updates the cache accordingly.; Determine the overlapping state of current node. void CdNext(); Do a cd to the node found next by FindNextBoundary. void GetBranchNames(Int_t* names) const; Fill volume names of current branch into an array. void GetBranchNumbers(Int_t* copyNumbers, Int_t* volumeNumbers) const; Fill node copy numbers of current branch into an array. void GetBranchOnlys(Int_t* isonly) const; Fill node copy numbers of current branch into an array. TGeoNode * CrossDivisionCell(); Cross a division cell. Distance to exit contained in fStep, current node; points to the cell node. TGeoNode * CrossBoundaryAndLocate(Bool",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoNavigator.html:13035,perform,performance,13035,root/html532/TGeoNavigator.html,https://root.cern,https://root.cern/root/html532/TGeoNavigator.html,2,['perform'],['performance']
Performance,"signal componentforced to zero; # and save those parameters too; ; bkgfrac.setVal(1); bkgfrac.setConstant(True); bkgfrac.removeError(); model.fitTo(refData, PrintLevel=-1); ; w.saveSnapshot(""reference_fit_bkgonly"", params, True); ; ; # Create model and dataset; # -----------------------------------------------; ; w = ROOT.RooWorkspace(""w""); fillWorkspace(w); ; # Exploit convention encoded in named set ""parameters"" and ""observables""; # to use workspace contents w/o need for introspected; model = w[""model""]; ; # Generate data from p.d.f. in given observables; data = model.generate(w.set(""observables""), 1000); ; # Fit model to data; model.fitTo(data, PrintLevel=-1); ; # Plot fitted model and data on frame of first (only) observable; frame = (w.set(""observables"").first()).frame(); data.plotOn(frame); model.plotOn(frame); ; # Overlay plot with model with reference parameters as stored in snapshots; w.loadSnapshot(""reference_fit""); model.plotOn(frame, LineColor=""r""); w.loadSnapshot(""reference_fit_bkgonly""); model.plotOn(frame, LineColor=""r"", LineStyle=""--""); ; # Draw the frame on the canvas; c = ROOT.TCanvas(""rf510_wsnamedsets"", ""rf503_wsnamedsets"", 600, 600); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; c.SaveAs(""rf510_wsnamedsets.png""); ; # Print workspace contents; w.Print(); ; # Workspace will remain in memory after macro finishes; ROOT.gDirectory.Add(w); [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooAddPdf::model; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooChebychev::bkg; [#1] INFO:ObjectHandling -- RooWorkspace::import(w) importing RooRealVar::x; [#1] INFO:Obj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf510__wsnamedsets_8py.html:4361,load,loadSnapshot,4361,doc/master/rf510__wsnamedsets_8py.html,https://root.cern,https://root.cern/doc/master/rf510__wsnamedsets_8py.html,1,['load'],['loadSnapshot']
Performance,"signed integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Bool_t_useDefaultGenUse default or distributed event generator; Double_tRooAbsReal::_valueCache for current value of object; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooProdPdf(); Default constructor. RooProdPdf(const char* name, const char* title, Double_t cutOff = 0); Dummy constructor. RooProdPdf(const char* name, const char* title, RooAbsPdf& pdf1, RooAbsPdf& pdf2, Double_t cutOff = 0); Constructor with 2 PDFs (most frequent use case). The optional cutOff parameter can be used as a speed optimization if; one or more of the PDF have sizable regions with very small values,; which would pull the entire product of PDFs to zero in those regions. After each PDF multiplication, the running product is compared with; the cutOff parameter. If the running product is smaller than the; cutOff value, the product series is terminated and remaining PDFs; are not evaluated. There is no magic value of the cutOff, the user should experiment; to find the appropriate balance between speed and precision.; If a cutoff is specified, the PDFs most likely to be small should; be put first in the product. The default cutOff value is zero. RooProdPdf(const char* name, const char* title, const RooArgList& pdfList, Double_t cutOff = 0); Constructor from a list of PDFs. The optional cutOff parameter can be used as a speed optimization if; one or more of the PDF have sizable regions with very small values,; which would pull the entire product of PDFs to zero in those regions. After each PDF multiplication, the running product is compared with; the cut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooProdPdf.html:47548,optimiz,optimization,47548,root/html534/RooProdPdf.html,https://root.cern,https://root.cern/root/html534/RooProdPdf.html,2,['optimiz'],['optimization']
Performance,"simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response; nothing to do here - all taken care of by TMultiLayerPerceptron. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". MethodTMlpANN(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& theData, const TString& theOption = ""3000:N-1:N-2"", TDirectory* theTargetDir = 0). void SetHiddenLayer(TString hiddenlayer = """"); { fHiddenLayer=hiddenlayer; }. const Ranking* CreateRanking(); ranking o",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TMVA__MethodTMlpANN.html:20213,load,load,20213,root/html602/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html602/TMVA__MethodTMlpANN.html,4,['load'],['load']
Performance,"simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response; nothing to do here - all taken care of by TMultiLayerPerceptron. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void SetHiddenLayer(TString hiddenlayer = """"); { fHiddenLayer=hiddenlayer; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id$ » Last generate",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodTMlpANN.html:19026,load,load,19026,root/html534/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodTMlpANN.html,2,['load'],['load']
Performance,"simply a number); or relative to the number of input nodes to the neural net (N); * there is always a single node in the output layer; example: a net with 6 input nodes and ""Hiddenlayers=N-1,N-2"" has 6,5,4,1 nodes in the; layers 1,2,3,4, repectively. void ProcessOptions(); builds the neural network as specified by the user. Double_t GetMvaValue(Double_t* err = 0, Double_t* errUpper = 0); calculate the value of the neural net for the current event. void Train( void ); performs TMlpANN training; available learning methods:. TMultiLayerPerceptron::kStochastic; TMultiLayerPerceptron::kBatch; TMultiLayerPerceptron::kSteepestDescent; TMultiLayerPerceptron::kRibierePolak; TMultiLayerPerceptron::kFletcherReeves; TMultiLayerPerceptron::kBFGS. TMultiLayerPerceptron wants test and training tree at once; so merge the training and testing trees from the MVA factory first:. void AddWeightsXMLTo(void* parent) const; write weights to xml file. void ReadWeightsFromXML(void* wghtnode); rebuild temporary textfile from xml weightfile and load this; file into MLP. void ReadWeightsFromStream(istream& istr); read weights from stream; since the MLP can not read from the stream, we; 1st: write the weights to temporary file. void MakeClass(const TString& classFileName = TString("""")) const; create reader class for classifier -> overwrites base class function; create specific class for TMultiLayerPerceptron. void MakeClassSpecific(ostream& , const TString& ) const; write specific classifier response; nothing to do here - all taken care of by TMultiLayerPerceptron. void GetHelpMessage() const; get help message text. typical length of text line:; ""|--------------------------------------------------------------|"". void SetHiddenLayer(TString hiddenlayer = """"); { fHiddenLayer=hiddenlayer; }. const Ranking* CreateRanking(); ranking of input variables. { return 0; }. » Author: Andreas Hoecker, Joerg Stelzer, Helge Voss, Kai Voss » Copyright (c) 2005: *; » Last changed: root/tmva $Id: MethodTMlpANN.h",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TMVA__MethodTMlpANN.html:18343,load,load,18343,root/html528/TMVA__MethodTMlpANN.html,https://root.cern,https://root.cern/root/html528/TMVA__MethodTMlpANN.html,4,['load'],['load']
Performance,"sing Keras""); else:; # book PyKeras method only if Keras model could be created; print(""Booking Keras model "", rnn_types[i]); factory.BookMethod(; dataloader,; TMVA.Types.kPyKeras,; ""PyKeras_"" + rnn_types[i],; H=True,; V=False,; VarTransform=None,; FilenameModel=modelName,; FilenameTrainedModel=""trained_"" + modelName,; NumEpochs=maxepochs,; BatchSize=batchSize,; GpuOptions=""allow_growth=True"",; ); ; ; # use BDT in case not using Keras or TMVA DL; if not useKeras or not useTMVA_BDT:; useTMVA_BDT = True; ; ; ## Book TMVA BDT; ; ; if useTMVA_BDT:; factory.BookMethod(; dataloader,; TMVA.Types.kBDT,; ""BDTG"",; H=True,; V=False,; NTrees=100,; MinNodeSize=""2.5%"",; BoostType=""Grad"",; Shrinkage=0.10,; UseBaggedBoost=True,; BaggedSampleFraction=0.5,; nCuts=20,; MaxDepth=2,; ); ; ; ## Train all methods; factory.TrainAllMethods(); ; print(""nthreads = {}"".format(ROOT.GetThreadPoolSize())); ; # ---- Evaluate all MVAs using the set of test events; factory.TestAllMethods(); ; # ----- Evaluate and compare performance of all configured MVAs; factory.EvaluateAllMethods(); ; # check method; ; # plot ROC curve; c1 = factory.GetROCCurve(dataloader); c1.Draw(); ; if outputFile:; outputFile.Close(); formatOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGW",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html:61363,perform,performance,61363,doc/master/TMVA__RNN__Classification_8py.html,https://root.cern,https://root.cern/doc/master/TMVA__RNN__Classification_8py.html,1,['perform'],['performance']
Performance,"sing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are already initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TDataSetManagerFile.html:13298,cache,cache,13298,root/html534/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html534/TDataSetManagerFile.html,12,['cache'],"['cache', 'cachedir']"
Performance,"sing remote repositories. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TDataSetManagerFile(const char* group, const char* user, const char* ins). Main constructor. TDataSetManagerFile(const char* ins). Main constructor. void Init(); Do the real inititialization. void InitLocalCache(); Init the local cache if required. void ParseInitOpts(const char* opts); Parse the input string and set the init bits accordingly; Format is; dir:<datasetdir> [mss:<mss-url>] [opt:<base-options>]; The <datasetdir> is mandatory.; See TDataSetManager::ParseInitOpts for the available; base options.; The base options are laready initialized by the base constructor. const char * GetDataSetPath(const char* group, const char* user, const char* dsName, TString& md5path, Bool_t local = kFALSE); Returns path of the indicated dataset. The extension is '.root' for all files; except for 'dsName==ls' which have extension '.txt'.; If 'local' is kTRUE the local cache path is returned instead in the form; <cachedir>/<group>.<user>.<dsName>.<ext>.; NB: contains a static TString for result, so copy result before using twice. Int_t NotifyUpdate(const char* group, const char* user, const char* dspath, Long_t mtime, const char* checksum = 0); Save into the <datasetdir>/kDataSet_DataSetList file the name of the updated; or created or modified dataset. For still existing datasets, fill the; modification date in seconds anf the checksum.; Returns 0 on success, -1 on error. Int_t CreateLsFile(const char* group, const char* user, Long_t& mtime, TString& checksum); Create or recreate the dataset lists for 'uri'.; The list are saved in text form in 'uri'/ls.txt for fast browsing and in; 'uri'/ls.root in form of TMacro for optimized and portable transfer.; Return 0 on success, 1 if the file was empty, -1 on error. Bool_t BrowseDataSets(const char* group, const char* user, const char* dsName, UInt_t option, TObject* target); Adds the dataset in the folder of group, user to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TDataSetManagerFile.html:12676,cache,cache,12676,root/html528/TDataSetManagerFile.html,https://root.cern,https://root.cern/root/html528/TDataSetManagerFile.html,8,['cache'],"['cache', 'cachedir']"
Performance,"sion tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1782 of file RooAbsArg.cxx. ◆ optimizeCacheMode() [2/2]. void RooAbsArg::optimizeCacheMode ; (; const RooArgSet & ; observables, . RooArgSet & ; optimizedNodes, . RooLinkedList & ; processedNodes . ). virtual . Activate cache mode optimization with given definition of observables. ; The cache operation mode of all objects in the expression tree will modified such that all nodes that depend directly or indirectly on any of the listed observables will be set to ADirty, as they are expected to change every time. This save change tracking overhead for nodes that are a priori known to change every time ; Definition at line 1801 of file RooAbsArg.cxx. ◆ optimizeDirtyHook(). virtual void RooAbsArg::optimizeDirtyHook ; (; const RooArgSet * ; ). inlineprotectedvirtual . Definition at line 564 of file RooAbsArg.h. ◆ overlaps(). bool RooAbsArg::overlaps ; (; const RooAbsArg & ; testArg, . bool ; valueOnly = false . ); const. Test if any of the nodes of tree are shared with that of the given tree. ; Definition at line 900 of file RooAbsArg.cxx. ◆ ownedComponents(). const RooArgSet * RooAbsArg::ownedComponents ; (; ); const. inline . Definition at line 519 of file RooAbsArg.h. ◆ Print(). void RooAbsArg::Print ; (; Option_t * ; options = nullptr); const. inlineoverridevirtual . Print the object to the defaultPrintStream(). ; Parameters. [in]optionsV print verbose. T print a tree structure with all children. . Reimplemented from TObject.; Definition at line 294 of file RooAbsArg.h. ◆ printAddress(). void RooAbsArg::printAddress ; (; std::ostream & ; os); const. overridevirtual . Print address of this RooAbsArg. ; Reimplemented from RooPrintable.; Definition at line 1546 of file RooAbsArg.cxx. ◆ pr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsArg.html:79155,optimiz,optimizeDirtyHook,79155,doc/master/classRooAbsArg.html,https://root.cern,https://root.cern/doc/master/classRooAbsArg.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"sis code is running. When called from main thread and can_run_immediately==kTRUE, will be executed immediately.; Returns kTRUE when was executed. ; Definition at line 681 of file THttpServer.cxx. ◆ Unregister(). Bool_t THttpServer::Unregister ; (; TObject * ; obj). Unregister object. ; Unregister object in folders hierarchy.; See TRootSniffer::UnregisterObject() for more details ; Definition at line 1253 of file THttpServer.cxx. ◆ UnregisterWS(). void THttpServer::UnregisterWS ; (; std::shared_ptr< THttpWSHandler > ; ws). Unregister WS handler. ; Unregister WS handler to the THttpServer. ; Definition at line 1272 of file THttpServer.cxx. ◆ VerifyFilePath(). Bool_t THttpServer::VerifyFilePath ; (; const char * ; fname). staticprotected . Checked that filename does not contains relative path below current directory. ; Used to prevent access to files below current directory ; Definition at line 562 of file THttpServer.cxx. Member Data Documentation. ◆ fArgs. std::queue<std::shared_ptr<THttpCallArg> > THttpServer::fArgs. protected . ! submitted arguments ; Definition at line 58 of file THttpServer.h. ◆ fCors. std::string THttpServer::fCors. protected . ! CORS: sets Access-Control-Allow-Origin header for ProcessRequest responses ; Definition at line 54 of file THttpServer.h. ◆ fCorsCredentials. std::string THttpServer::fCorsCredentials. protected . ! CORS: add Access-Control-Allow-Credentials: true response header ; Definition at line 55 of file THttpServer.h. ◆ fDefaultPage. std::string THttpServer::fDefaultPage. protected . ! file name for default page name ; Definition at line 50 of file THttpServer.h. ◆ fDefaultPageCont. std::string THttpServer::fDefaultPageCont. protected . ! content of default html page ; Definition at line 51 of file THttpServer.h. ◆ fDrawPage. std::string THttpServer::fDrawPage. protected . ! file name for drawing of single element ; Definition at line 52 of file THttpServer.h. ◆ fDrawPageCont. std::string THttpServer::fDrawPageCont. protected . !",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTHttpServer.html:39314,queue,queue,39314,doc/master/classTHttpServer.html,https://root.cern,https://root.cern/doc/master/classTHttpServer.html,1,['queue'],['queue']
Performance,"sistency checks, default fit range as the whole histogram but without under- and overflows, and declaration of the fit parameters). Note that the histograms are not copied, only references are used. Parameters. [in]datahistogram to be fitted ; [in]MCsarray of TH1* corresponding template distributions ; [in]optioncan be used to control the print level of the minimization algorithm; option = ""Q"" : quite - no message is printed; option = ""V"" : verbose - max print out; option = """" : default: print initial fraction values and result . Definition at line 193 of file TFractionFitter.cxx. ◆ ~TFractionFitter(). TFractionFitter::~TFractionFitter ; (; ). override . TFractionFitter default destructor. ; Definition at line 257 of file TFractionFitter.cxx. Member Function Documentation. ◆ CheckConsistency(). void TFractionFitter::CheckConsistency ; (; ). private . Function used internally to check the consistency between the various histograms. ; Checks are performed on nonexistent or empty histograms, the precise histogram class, and the number of bins. In addition, integrals over the ""allowed"" bin ranges are computed. Any inconsistency results in a error. ; Definition at line 484 of file TFractionFitter.cxx. ◆ CheckParNo(). void TFractionFitter::CheckParNo ; (; Int_t ; parm); const. private . Function for internal use, checking parameter validity An invalid parameter results in an error. ; Definition at line 327 of file TFractionFitter.cxx. ◆ Class(). static TClass * TFractionFitter::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TFractionFitter::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TFractionFitter::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 112 of file TFractionFitter.h. ◆ ComputeChisquareLambda(). void TFractionFitter::ComputeChisquareLambda ; (; ). private . Method used internally to compute the likelihood rat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTFractionFitter.html:22830,perform,performed,22830,doc/master/classTFractionFitter.html,https://root.cern,https://root.cern/doc/master/classTFractionFitter.html,1,['perform'],['performed']
Performance,"siteFrame::IsArranged(TGFrameElement* ptr) const; virtual Bool_tTGCompositeFrame::IsComposite() const; Bool_tTGFrame::IsDNDSource() const; Bool_tTGFrame::IsDNDTarget() const; virtual Bool_tTGCompositeFrame::IsEditable() const; Bool_tTGWidget::IsEnabled() const; virtual Bool_tTGObject::IsEqual(const TObject* obj) const; virtual Bool_tTObject::IsFolder() const; virtual Bool_tTGCompositeFrame::IsLayoutBroken() const; virtual Bool_tTGWindow::IsMapped(); virtual Bool_tTGCompositeFrame::IsMapSubwindows() const; Bool_tTGTextView::IsMarked() const; Bool_tTObject::IsOnHeap() const; Bool_tTGTextView::IsReadOnly() const; virtual Bool_tTGTextView::IsSaved(); virtual Bool_tTObject::IsSortable() const; Bool_tTGCompositeFrame::IsVisible(TGFrame* f) const; Bool_tTGCompositeFrame::IsVisible(TGFrameElement* ptr) const; Bool_tTObject::IsZombie() const; long&ios_base::iword(int __ix); virtual voidTGTextView::Layout(); virtual Bool_tTGTextView::LoadBuffer(const char* txtbuf); virtual Bool_tTGTextView::LoadFile(const char* fname, long startpos = 0, long length = -1); virtual voidTGWindow::LowerWindow(); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTObject::ls(Option_t* option = """") const; virtual voidTGFrame::MapRaised(); virtual voidTGCompositeFrame::MapSubwindows(); virtual voidTGFrame::MapWindow(); virtual voidTGTextView::Marked(Bool_t mark)SIGNAL ; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; virtual voidTGFrame::Move(Int_t x, Int_t y); virtual voidTGFrame::MoveResize(Int_t x, Int_t y, UInt_t w = 0, UInt_t h = 0); virtual Int_tTGCompositeFrame::MustCleanup() const; charbasic_ios<char,char_traits<char> >::narrow(basic_ios<char,char_traits<char> >::char_type __c, char __dfault) const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOfVe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TGTextViewostream.html:12465,Load,LoadFile,12465,root/html604/TGTextViewostream.html,https://root.cern,https://root.cern/root/html604/TGTextViewostream.html,1,['Load'],['LoadFile']
Performance,"sition on file of buffers to be prefetched (sorted); Int_t*fSeekSortLen[fNseek] Length of buffers to be prefetched (sorted). Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TFileCacheRead(); Default Constructor. TFileCacheRead(TFile* file, Int_t buffersize); Creates a TFileCacheRead data structure. ~TFileCacheRead(); Destructor. void Prefetch(Long64_t pos, Int_t len); Add block of length len at position pos in the list of blocks to; be prefetched. If pos <= 0 the current blocks (if any) are reset. void Print(Option_t* option = """") const; Print cache statistics, like; ******TreeCache statistics for file: cms2.root ******; Reading............................: 72761843 bytes in 7 transactions; Readahead..........................: 256000 bytes with overhead = 0 bytes; Average transaction................: 10394.549000 Kbytes; Number of blocks in current cache..: 210, total size: 6280352. if option = ""a"" the list of blocks in the cache is printed; NB: this function is automatically called by TTreeCache::Print. Int_t ReadBuffer(char* buf, Long64_t pos, Int_t len); Read buffer at position pos.; If pos is in the list of prefetched blocks read from fBuffer,; otherwise need to make a normal read from file. Returns -1 in case of; read error, 0 in case not in cache, 1 in case read from cache. Int_t ReadBufferExt(char* buf, Long64_t pos, Int_t len, Int_t& loc); Base function for ReadBuffer. Also gives out the position; of the block in the internal buffer. This helps TTreeCacheUnzip to avoid; doing twice the binary search. void SetFile(TFile* file); Set the file using this cache and reset the current blocks (if any). void Sort(); Sort buffers to be prefetched in increasing order of positions.; Merge consecutive blocks if necessary. TFileCacheRead(const TFileCacheRead& ). TFileCacheRead& operator=(const TFileCacheRead& ). void AddBranch(TBranch* , Bool_t = kFALSE); {}. void AddBranch(const char* , Bool_t = kFALSE); {}. Int_t GetBufferSize(",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TFileCacheRead.html:8065,cache,cache,8065,root/html528/TFileCacheRead.html,https://root.cern,https://root.cern/root/html528/TFileCacheRead.html,1,['cache'],['cache']
Performance,"sityCorrection);  Import data from given set of TH1/2/3 into this RooDataHist. ;  ; void initialize (const char *binningName=nullptr, bool fillTree=true);  Initialization procedure: allocate weights array, calculate multipliers needed for N-space to 1-dim array jump table, and fill the internal tree with all bin center coordinates. ;  ; double interpolateDim (int iDim, double xval, size_t centralIdx, int intOrder, bool correctForBinSize, bool cdfBoundaries);  Perform boundary safe 'intOrder'-th interpolation of weights in dimension 'dim' at current value 'xval'. ;  ; std::unique_ptr< RooAbsData > reduceEng (const RooArgSet &varSubset, const RooFormulaVar *cutVar, const char *cutRange=nullptr, std::size_t nStart=0, std::size_t nStop=std::numeric_limits< std::size_t >::max()) const override;  Implementation of RooAbsData virtual method that drives the RooAbsData::reduce() methods. ;  ;  Protected Member Functions inherited from RooAbsData; bool allClientsCached (RooAbsArg *, const RooArgSet &);  Utility function that determines if all clients of object 'var' appear in given list of cached nodes. ;  ; virtual void attachCache (const RooAbsArg *newOwner, const RooArgSet &cachedVars);  Internal method – Attach dataset copied with cache contents to copied instances of functions. ;  ; virtual void cacheArgs (const RooAbsArg *owner, RooArgSet &varSet, const RooArgSet *nset=nullptr, bool skipZeroWeights=false);  Internal method – Cache given set of functions with data. ;  ; double corrcov (const RooRealVar &x, const RooRealVar &y, const char *cutSpec, const char *cutRange, bool corr) const;  Internal method to calculate single correlation and covariance elements. ;  ; RooFit::OwningPtr< TMatrixDSym > corrcovMatrix (const RooArgList &vars, const char *cutSpec, const char *cutRange, bool corr) const;  Return covariance matrix from data for given list of observables. ;  ; RooRealVar * dataRealVar (const char *methodname, const RooRealVar &extVar) const;  Internal method to check",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooDataHist.html:35824,cache,cached,35824,doc/master/classRooDataHist.html,https://root.cern,https://root.cern/doc/master/classRooDataHist.html,1,['cache'],['cached']
Performance,"siveObjectCache::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ clearAll(). void RooExpensiveObjectCache::clearAll ; (; ). Clear all cache elements. ; Definition at line 164 of file RooExpensiveObjectCache.cxx. ◆ clearObj(). bool RooExpensiveObjectCache::clearObj ; (; Int_t ; uniqueID). Clear cache element with given unique ID Retrieve payload object of cache element with given unique ID. ; Definition at line 131 of file RooExpensiveObjectCache.cxx. ◆ DeclFileName(). static const char * RooExpensiveObjectCache::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ empty(). bool RooExpensiveObjectCache::empty ; (; ); const. inline . Definition at line 44 of file RooExpensiveObjectCache.h. ◆ getObj(). const TObject * RooExpensiveObjectCache::getObj ; (; Int_t ; uniqueID). Retrieve payload object of cache element with given unique ID. ; Definition at line 115 of file RooExpensiveObjectCache.cxx. ◆ importCacheObjects(). void RooExpensiveObjectCache::importCacheObjects ; (; RooExpensiveObjectCache & ; other, . const char * ; ownerName, . bool ; verbose = false . ). Definition at line 296 of file RooExpensiveObjectCache.cxx. ◆ instance(). RooExpensiveObjectCache & RooExpensiveObjectCache::instance ; (; ). static . Return reference to singleton instance. ; Definition at line 58 of file RooExpensiveObjectCache.cxx. ◆ IsA(). TClass * RooExpensiveObjectCache::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 81 of file RooExpensiveObjectCache.h. ◆ print(). void RooExpensiveObjectCache::print ; (; ); const. Definition at line 259 of file RooExpensiveObjectCache.cxx. ◆ registerObject(). bool RooExpensiveObjectCache::registerObject ; (; const char * ; ownerName, . const char * ; objectName, . TObject & ; cacheObj",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooExpensiveObjectCache.html:13638,cache,cache,13638,doc/master/classRooExpensiveObjectCache.html,https://root.cern,https://root.cern/doc/master/classRooExpensiveObjectCache.html,1,['cache'],['cache']
Performance,"size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TFileCacheRead.; Reimplemented in TTreeCacheUnzip.; Definition at line 1899 of file TTreeCache.cxx. ◆ ProcessMiss(). bool TTreeCache::ProcessMiss ; (; Long64_t ; pos, . int ; len . ). private . ! Given a file read not in the miss cache, handle (possibly) loading the data. ; Process a cache miss; (pos, len) isn't in the buffer.; The first time we have a miss, we buffer as many baskets we can (up to the maximum size of the TTreeCache) in memory from all branches that are not in the prefetch list.; Subsequent times, we fetch all the buffers corresponding to branches that had previously seen misses. If it turns out the (pos, len) isn't in the list of branches, we treat this as if it was the first miss.; Returns true if we were able to pull the data into the miss cache. ; Definition at line 863 of file TTreeCache.cxx. ◆ ReadBuffer(). Int_t TTreeCache::ReadBuffer ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len . ). overridevi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:45504,cache,cachedbranches,45504,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['cache'],"['cached', 'cachedbranches']"
Performance,"size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TTreeCache.; Definition at line 947 of file TTreeCacheUnzip.cxx. ◆ ReadBufferExt(). Int_t TTreeCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 961 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 501 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCacheUnzip.html:33724,cache,cachedbranches,33724,doc/v632/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/v632/classTTreeCacheUnzip.html,2,['cache'],"['cached', 'cachedbranches']"
Performance,"size of a square matrix; totalstatic unsigned int totalDefinition TGWin32ProxyDefs.h:40; bytesOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t Int_t Int_t Window_t TString Int_t GCValues_t GetPrimarySelectionOwner GetDisplay GetScreen GetColormap GetNativeEvent const char const char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t bytesDefinition TGWin32VirtualXProxy.cxx:245. if option = ""a"" the list of blocks in the cache is printed see also class TTreePerfStats.; if option contains 'cachedbranches', the list of branches being cached is printed. . Reimplemented from TTreeCache.; Definition at line 948 of file TTreeCacheUnzip.cxx. ◆ ReadBufferExt(). Int_t TTreeCacheUnzip::ReadBufferExt ; (; char * ; buf, . Long64_t ; pos, . Int_t ; len, . Int_t & ; loc . ). overridevirtual . Reimplemented from TFileCacheRead.; Definition at line 962 of file TTreeCacheUnzip.cxx. ◆ ResetCache(). void TTreeCacheUnzip::ResetCache ; (; ). overridevirtual . This will delete the list of buffers that are in the unzipping cache and will reset certain values in the cache. ; This name is ambiguos because the method doesn't reset the whole cache, only the part related to the unzipping Note: This method is completely different from TTreeCache::ResetCache(), in that method we were cleaning the prefetching buffer while here we delete the information about the unzipped buffers ; Reimplemented from TTreeCache.; Definition at line 502 of file TTreeCacheUnzip.cxx. ◆ SetBufferSize(). Int_t TTreeCacheUnzip::SetBufferSize ;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeCacheUnzip.html:33728,cache,cachedbranches,33728,doc/master/classTTreeCacheUnzip.html,https://root.cern,https://root.cern/doc/master/classTTreeCacheUnzip.html,2,['cache'],"['cached', 'cachedbranches']"
Performance,"size of branches in cache; static Int_tTTreeCache::fgLearnEntriesNumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TTreeCacheUnzip.html:12624,cache,cache,12624,root/html528/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html528/TTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"size of branches in cache; static Int_tTTreeCache::fgLearnEntriesnumber of entries used for learning mode; static TTreeCacheUnzip::EParUnzipModefgParallelIndicate if we want to activate the parallelism; static Double_tfgRelBuffSizeThis is the percentage of the TTreeCacheUnzip that will be used. private:. char*fCompBuffer; Int_tfCompBufferSize. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TTreeCacheUnzip(); Default Constructor. TTreeCacheUnzip(TTree* tree, Int_t buffersize = 0); Constructor. void Init(); Initialization procedure common to all the constructors. ~TTreeCacheUnzip(); destructor. (in general called by the TFile destructor; destructor. (in general called by the TFile destructor). void AddBranch(TBranch* b, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. void AddBranch(const char* branch, Bool_t subbranches = kFALSE); add a branch to the list of branches to be stored in the cache; this function is called by TBranch::GetBasket. Bool_t FillBuffer(). void SetEntryRange(Long64_t emin, Long64_t emax); Set the minimum and maximum entry number to be processed; this information helps to optimize the number of baskets to read; when prefetching the branch buffers. void StopLearningPhase(); It's the same as TTreeCache::StopLearningPhase but we guarantee that; we start the unzipping just after getting the buffers. void UpdateBranches(TTree* tree, Bool_t owner = kFALSE); update pointer to current Tree and recompute pointers to the branches in the cache. Bool_t IsParallelUnzip(); Static function that tells wether the multithreading unzipping; is activated. Bool_t IsActiveThread(); This indicates if the thread is active in this moment...; this variable is very important because if we change it from true to; false the thread will stop... ( see StopThreadTreeCacheUnzip() ). Bool_t IsQueueEmpty(); It says if the queue is empty... useful t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTreeCacheUnzip.html:14605,cache,cache,14605,root/html530/TTreeCacheUnzip.html,https://root.cern,https://root.cern/root/html530/TTreeCacheUnzip.html,1,['cache'],['cache']
Performance,"size of the existing parameters); 187 virtual bool SetVariableValues(const double * x) {; 188 bool ret = true;; 189 unsigned int i = 0;; 190 while ( i <= NDim() && ret) {; 191 ret &= SetVariableValue(i,x[i] ); i++;; 192 }; 193 return ret;; 194 }; 195 virtual bool SetVariableStepSize(unsigned int ivar, double value );; 196 virtual bool SetVariableLowerLimit(unsigned int ivar, double lower);; 197 virtual bool SetVariableUpperLimit(unsigned int ivar, double upper);; 198 /// set the limits of an already existing variable; 199 virtual bool SetVariableLimits(unsigned int ivar, double lower, double upper) {; 200 return SetVariableLowerLimit(ivar,lower) && SetVariableUpperLimit(ivar,upper);; 201 }; 202 virtual bool FixVariable(unsigned int ivar);; 203 virtual bool ReleaseVariable(unsigned int ivar);; 204 virtual bool IsFixedVariable(unsigned int ivar) const;; 205 virtual bool GetVariableSettings(unsigned int ivar, ROOT::Fit::ParameterSettings & pars) const;; 206 ; 207 /// set the initial range of an existing variable; 208 virtual bool SetVariableInitialRange(unsigned int /* ivar */, double /* mininitial */, double /* maxinitial */) {; 209 return false;; 210 }; 211 ; 212 /// method to perform the minimization; 213 virtual bool Minimize() = 0;; 214 ; 215 /// return minimum function value; 216 virtual double MinValue() const = 0;; 217 ; 218 /// return pointer to X values at the minimum; 219 virtual const double * X() const = 0;; 220 ; 221 /// return expected distance reached from the minimum (re-implement if minimizer provides it; 222 virtual double Edm() const { return -1; }; 223 ; 224 /// return pointer to gradient values at the minimum; 225 virtual const double * MinGradient() const { return nullptr; }; 226 ; 227 /// number of function calls to reach the minimum; 228 virtual unsigned int NCalls() const { return 0; }; 229 ; 230 /// number of iterations to reach the minimum; 231 virtual unsigned int NIterations() const { return NCalls(); }; 232 ; 233 /// this is <= Function().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/Minimizer_8h_source.html:9924,perform,perform,9924,doc/master/Minimizer_8h_source.html,https://root.cern,https://root.cern/doc/master/Minimizer_8h_source.html,1,['perform'],['perform']
Performance,"size was not fixed (old files and; 606/// case where autoflush was explicitly set to zero), we need estimate; 607/// a cluster size in relation to the size of the cache.; 608///; 609/// After this value is calculated once for the TClusterIterator, it is; 610/// cached and reused in future calls.; 611 ; 612Long64_t TTree::TClusterIterator::GetEstimatedClusterSize(); 613{; 614 auto autoFlush = fTree->GetAutoFlush();; 615 if (autoFlush > 0) return autoFlush;; 616 if (fEstimatedSize > 0) return fEstimatedSize;; 617 ; 618 Long64_t zipBytes = fTree->GetZipBytes();; 619 if (zipBytes == 0) {; 620 fEstimatedSize = fTree->GetEntries() - 1;; 621 if (fEstimatedSize <= 0); 622 fEstimatedSize = 1;; 623 } else {; 624 Long64_t clusterEstimate = 1;; 625 Long64_t cacheSize = fTree->GetCacheSize();; 626 if (cacheSize == 0) {; 627 // Humm ... let's double check on the file.; 628 TFile *file = fTree->GetCurrentFile();; 629 if (file) {; 630 TFileCacheRead *cache = fTree->GetReadCache(file);; 631 if (cache) {; 632 cacheSize = cache->GetBufferSize();; 633 }; 634 }; 635 }; 636 // If neither file nor tree has a cache, use the current default.; 637 if (cacheSize <= 0) {; 638 cacheSize = 30000000;; 639 }; 640 clusterEstimate = fTree->GetEntries() * cacheSize / zipBytes;; 641 // If there are no entries, then just default to 1.; 642 fEstimatedSize = clusterEstimate ? clusterEstimate : 1;; 643 }; 644 return fEstimatedSize;; 645}; 646 ; 647////////////////////////////////////////////////////////////////////////////////; 648/// Move on to the next cluster and return the starting entry; 649/// of this next cluster; 650 ; 651Long64_t TTree::TClusterIterator::Next(); 652{; 653 fStartEntry = fNextEntry;; 654 if (fTree->fNClusterRange || fTree->GetAutoFlush() > 0) {; 655 if (fClusterRange == fTree->fNClusterRange) {; 656 // We are looking at a range which size; 657 // is defined by AutoFlush itself and goes to the GetEntries.; 658 fNextEntry += GetEstimatedClusterSize();; 659 } else {; 660 if (fStartEnt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:24586,cache,cache,24586,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,5,['cache'],"['cache', 'cacheSize']"
Performance,"size=0);  Constructor. ;  ;  ~TTreeCache () override;  Destructor. (in general called by the TFile destructor) ;  ; Int_t AddBranch (const char *branch, bool subbranches=false) override;  Add a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; Int_t AddBranch (TBranch *b, bool subgbranches=false) override;  Add a branch to the list of branches to be stored in the cache this function is called by the user via TTree::AddBranchToCache. ;  ; virtual void Disable ();  ; virtual Int_t DropBranch (const char *branch, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this is to be used by user (thats why we pass the name of the branch). ;  ; virtual Int_t DropBranch (TBranch *b, bool subbranches=false);  Remove a branch to the list of branches to be stored in the cache this function is called by TBranch::GetBasket. ;  ; virtual void Enable ();  ; virtual bool FillBuffer ();  Fill the cache buffer with the branches in the cache. ;  ; const TObjArray * GetCachedBranches () const;  ; EPrefillType GetConfiguredPrefillType () const;  Return the desired prefill type from the environment or resource variable. ;  ; Double_t GetEfficiency () const;  Give the total efficiency of the primary cache... defined as the ratio of blocks found in the cache vs. ;  ; Double_t GetEfficiencyRel () const;  This will indicate a sort of relative efficiency... a ratio of the reads found in the cache to the number of reads so far. ;  ; virtual Int_t GetEntryMax () const;  ; virtual Int_t GetEntryMin () const;  ; virtual EPrefillType GetLearnPrefill () const;  ; Double_t GetMissEfficiency () const;  The total efficiency of the 'miss cache' - defined as the ratio of blocks found in the cache versus the number of blocks prefetched. ;  ; Double_t GetMissEfficiencyRel () const;  Relative efficiency of the 'miss cache' - ratio of the reads found in cache to the number of reads so far.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:13047,cache,cache,13047,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,['cache'],['cache']
Performance,"sizeof(Double_t));; 198 }; 199 void SetLastSafetyForPoint(Double_t safe, Double_t x, Double_t y, Double_t z); 200 {; 201 fLastSafety = safe;; 202 fLastPoint[0] = x;; 203 fLastPoint[1] = y, fLastPoint[2] = z;; 204 }; 205 ; 206 // Check if we have a cached safety value from parallel world, and if this can still be used.; 207 // Return negative value if no cache available.; 208 Double_t GetPWSafetyEstimateFromCache(Double_t cpoint[3]) const; 209 {; 210 // disregard too small or invalid safeties; 211 if (fLastPWSafety < TGeoShape::Tolerance()) {; 212 return -1.;; 213 }; 214 const auto d0 = fLastPWSaftyPnt[0] - cpoint[0];; 215 const auto d1 = fLastPWSaftyPnt[1] - cpoint[1];; 216 const auto d2 = fLastPWSaftyPnt[2] - cpoint[2];; 217 const auto d_sq = d0 * d0 + d1 * d1 + d2 * d2;; 218 // if we have moved too much return -1 as ""invalid""; 219 if (d_sq >= (fLastPWSafety * fLastPWSafety)) {; 220 return -1.;; 221 }; 222 // or return a reasonable cache estimate for safety; 223 return fLastPWSafety - std::sqrt(d_sq);; 224 }; 225 ; 226 // Wrapper for getting the safety from the parallel world.; 227 // Takes care of caching mechanics and talking to the Safety function of parallel world.; 228 Double_t GetPWSafety(Double_t cpoint[3], Double_t saf_max);; 229 ; 230 // enable/disable parallel world safety caching; 231 static void SetPWSafetyCaching(Bool_t b) { fgUsePWSafetyCaching = b; }; 232 static Bool_t IsPWSafetyCaching() { return fgUsePWSafetyCaching; }; 233 ; 234 //--- point/vector reference frame conversion; 235 void LocalToMaster(const Double_t *local, Double_t *master) const { fCache->LocalToMaster(local, master); }; 236 void LocalToMasterVect(const Double_t *local, Double_t *master) const { fCache->LocalToMasterVect(local, master); }; 237 void LocalToMasterBomb(const Double_t *local, Double_t *master) const { fCache->LocalToMasterBomb(local, master); }; 238 void MasterToLocal(const Double_t *master, Double_t *local) const { fCache->MasterToLocal(master, local); }; 239 void Maste",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGeoNavigator_8h_source.html:10991,cache,cache,10991,doc/master/TGeoNavigator_8h_source.html,https://root.cern,https://root.cern/doc/master/TGeoNavigator_8h_source.html,1,['cache'],['cache']
Performance,"sk; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. stringRooAbsTestStatistic::_addCoefRangeNameName of reference to be used for RooAddPdf components; list<RooAbsBinning*>_binList! Bin ranges; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooArgSetRooAbsOptTestStatistic::_cachedNodes! List of nodes that are cached as constant expressions; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAbsData*RooAbsTestStatistic::_dataPointer to original input dataset; RooAbsData*RooAbsOptTestStatistic::_dataClonePointer to internal clone if input data; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Bool_t_extendedIs the input function and extended p.d.f.; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if fla",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooXYChi2Var.html:33217,cache,cache,33217,root/html532/RooXYChi2Var.html,https://root.cern,https://root.cern/root/html532/RooXYChi2Var.html,8,['cache'],"['cache', 'cached', 'caches']"
Performance,"sket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is automatically used by TTree::Draw. The method knows which branches are used in the query and it puts automatically these branches in the cache. The entry range is also inferred automatically. TTree::Process and TSelectors Examples; The user must enable the cache and tell the system which branches to cache and also specify the entry range. It is important to specify the entry range in case only a subset of the events is processed to avoid wasteful caching.; Reading all branches; TTree *T;; f->GetObject(T, ""mytree"");; auto nentries = T->GetEntries();; auto cachesize = 10000000U; // 10 MBytes; T->SetCacheSize(cachesize); //<<<; T->AddBranchToCache(""*"", true); //<<< add all branches to the cache; T->Process(""myselector.C+"");; // In the TSelector::Process function we read all branches; T->GetEntry(i);; // ... Here the entry is processed; f#define f(i)Definition RSh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:6351,cache,cache,6351,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"slaves, but don't wait; for results. If opt is kCollectBuildResults then collect result; from slaves. To be used on the master.; If opt = kBuildAll (default) then submit and wait for results; (to be used on the client).; Returns 0 in case of success and -1 in case of error. Int_t BuildPackageOnClient(const char* package, Int_t opt = 0, TString* path = 0); Build specified package on the client. Executes the PROOF-INF/BUILD.sh; script if it exists on the client.; If opt == 0, both the preparation and building phases are run.; If opt == 1, only the preparation phase (asserting and, eventually, downloading; of the package) is done; '*path' contains the full path to the; package to be passed in the next call; If opt == 2, only the building phase is run using *path .; Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kBuildPackage; case). Keep in sync in case of changes. Int_t LoadPackage(const char* package, Bool_t notOnClient = kFALSE, TList* loadopts = 0); Load specified package. Executes the PROOF-INF/SETUP.C script; on all active nodes. If notOnClient = true, don't load package; on the client. The default is to load the package also on the client.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns 0 in case of success and -1 in case of error. Int_t LoadPackageOnClient(const char* package, TList* loadopts = 0); Load specified package in the client. Executes the PROOF-INF/SETUP.C; script on the client. Returns 0 in case of success and -1 in case of error.; The code is equivalent to the one in TProofServ.cxx (TProof::kLoadPackage; case). Keep in sync in case of changes.; The argument 'loadopts' specify a list of objects to be passed to the SETUP.; The objects in the list must be streamable; the SETUP macro will be executed; like this: SETUP.C(loadopts).; Returns ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:62472,load,loadopts,62472,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,6,"['Load', 'load']","['Load', 'LoadPackage', 'loadopts']"
Performance,"slicedData)); simPdf.plotOn(frame2, Components=""px_ctl"", ProjWData=(sample, slicedData), LineStyle=""--""); ; # The same plot for all the phase space. Here, we can just use the original; # combined dataset.; frame3 = x.frame(Title=""Both samples""); combData.plotOn(frame3); simPdf.plotOn(frame3, ProjWData=(sample, combData)); simPdf.plotOn(frame3, Components=""px,px_ctl"", ProjWData=(sample, combData), LineStyle=""--""); ; c = ROOT.TCanvas(""rf501_simultaneouspdf"", ""rf501_simultaneouspdf"", 1200, 400); c.Divide(3); ; ; def draw(i, frame):; c.cd(i); ROOT.gPad.SetLeftMargin(0.15); frame.GetYaxis().SetTitleOffset(1.4); frame.Draw(); ; ; draw(1, frame1); draw(2, frame2); draw(3, frame3); ; c.SaveAs(""rf501_simultaneouspdf.png""); [#1] INFO:Fitting -- RooAbsPdf::fitTo(simPdf) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_simPdf_combData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 8630.62, estimated distance to minimum: 0.000174671; covariance matrix quality: Full, accurate covariance matrix; Status : MINIMIZE=0 HESSE=0 ; ; Floating Parameter FinalValue +/- Error ; -------------------- --------------------------; a0 6.7634e-02 +/- 6.04e-02; a0_ctl -1.5627e-01 +/- 5.53e-02; a1 -3.8353e-03 +/- 6.32e-02; a1_ctl 3.8442e-01 +/- 4.35e-02; f 1.7952e-01 +/- 1.55e-02; f_ctl 5.2710e-01 +/- 1.25e-02; mean 1.4991e-02 +/- 3.34e-02; mean_ctl -3.0079e+00 +/- 1.04e-02; sigma 3.0450e-01 +/- 8.33e-03; ; [#1] INFO:Plotting -- RooTreeData::plotOn: plotting 1000 events out of 3000 total events; [#1] INFO:Plotting -- RooSimultaneous::plotOn(simPdf) plot on x represents a slice in the index category (sample); [#",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html:5699,optimiz,optimization,5699,doc/master/rf501__simultaneouspdf_8py.html,https://root.cern,https://root.cern/doc/master/rf501__simultaneouspdf_8py.html,2,['optimiz'],['optimization']
Performance,"slot); Int_tTProof::Collect(TProof::ESlaves list = kActive, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tTProof::Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*TProof::GetEnabledPackages() const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tTProof::PollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& emsg); virtual voidTProof::S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofSuperMaster.html:21534,cache,cachedir,21534,root/html534/TProofSuperMaster.html,https://root.cern,https://root.cern/root/html534/TProofSuperMaster.html,2,['cache'],['cachedir']
Performance,"slot); Int_tTProof::Collect(TProof::ESlaves list = kActive, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); Int_tTProof::Collect(TList* slaves, Long_t timeout = -1, Int_t endtype = -1, Bool_t deactonfail = kFALSE); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); TSlave*TProof::CreateSlave(const char* url, const char* ord, Int_t perf, const char* image, const char* workdir); TSlave*TProof::CreateSubmaster(const char* url, const char* ord, const char* image, const char* msd); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; TList*TProof::GetEnabledPackages() const; static Bool_tTProof::GetFileInCmd(const char* cmd, TString& fn); static Int_tTProof::GetInputData(TList* input, const char* cachedir, TString& emsg); TStringGetJobAd(); TList*TProof::GetListOfActiveSlaves() const; TVirtualProofPlayer*TProof::GetPlayer() const; TPluginHandler*TProof::GetProgressDialog() const; Int_tTProof::GetSandbox(TString& sb, Bool_t assert = kFALSE, const char* rc = 0); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; voidTProof::HandleLibIncPath(const char* what, Bool_t add, const char* dirs); Int_tTProof::HandleOutputOptions(TString& opt, TString& target, Int_t action); Int_tTProof::Init(const char* masterurl, const char* conffile, const char* confdir, Int_t loglevel, const char* alias = 0); voidTProof::InitMembers(); virtual TVirtualProofPlayer*TProof::MakePlayer(const char* player = 0, TSocket* s = 0); voidTObject::MakeZombie(); virtual Int_tTProof::PollForNewWorkers(); voidTProof::PrepareInputDataFile(TString& dataFile); Int_tTProof::RemoveWorkers(TList* wrks); static Int_tTProof::SaveInputData(TQueryResult* qr, const char* cachedir, TString& e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofCondor.html:21704,cache,cachedir,21704,root/html534/TProofCondor.html,https://root.cern,https://root.cern/root/html534/TProofCondor.html,2,['cache'],['cachedir']
Performance,"slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions; virtual void DeletePlayer ();  Delete player instance. ;  ; virtual Int_t Fork ();  Fork a child. ;  ; Int_t GetSessionStatus ();  Return the status of this session: 0 idle 1 running 2 being terminated (currently unused) 3 queued 4 idle timed-out (not set in here but in TIdleTOTimer::Notify) This is typically run in the reader thread, so access needs to be protected. ;  ; virtual void HandleArchive (TMessage *mess, TString *slb=0);  Handle archive request. ;  ; virtual Int_t HandleCache (TMessage *mess, TString *slb=0);  Handle here all cache and package requests. ;  ; virtual void HandleCheckFile (TMessage *mess, TString *slb=0);  Handle file checking request. ;  ; virtual Int_t HandleDataSets (TMessage *mess, TString *slb=0);  Handle here requests about datasets. ;  ; virtual void HandleFork (TMessage *mess);  Cloning itself via fork. Not implemented. ;  ; virtual Int_t HandleLibIncPath (TMessage *mess);  Handle lib, inc search paths modification request. ;  ; virtual void HandleProcess (TMessage *mess, TString *slb=0);  Handle processing request. ;  ; virtual void HandleQueryList (TMessage *mess);  Handle request for list of queries. ;  ; virtual void HandleRemove (TMessage *mess, TString *slb=0);  Handle remove request. ;  ; virtual void HandleRetrieve (TMessage *mess, TString *slb=0);  Handle retrieve request. ;  ; virtual void HandleSubmerger (TMessage *mess);  Handle a message of type kPROOF_SUBMERGER. ;  ; virtual Int_t HandleWorkerLists (TMessage *mess);  Handle here all requests t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofServ.html:23295,cache,cache,23295,doc/master/classTProofServ.html,https://root.cern,https://root.cern/doc/master/classTProofServ.html,1,['cache'],['cache']
Performance,"slot_name = 0); voidTClass::IgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTClass::InheritsFrom(const char* cl) const; virtual Bool_tTClass::InheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidTClass::InterpretedShowMembers(void* obj, TMemberInspector& insp, Bool_t isTransient); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeTClass::IsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tTClass::IsFolder() const; Bool_tTClass::IsFolder(void* obj) const; Bool_tTClass::IsForeign() const; Bool_tTClass::IsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tTClass::IsStartingWithTObject() const; Bool_tTClass::IsTObject() const; Bool_tTClass::IsVersioned() const; Bool_tTObject::IsZombie() const; static TClass*TClass::Load(TBuffer& b); static TClass*TClass::LoadClass(const char* requestedname, Bool_t silent); virtual voidTQObject::LowPriority(const char* signal_name, const char* slot_name = 0); virtual voidTClass::ls(Option_t* opt = """") const; voidTClass::MakeCustomMenuList(); Bool_tTClass::MatchLegacyCheckSum(UInt_t checksum) const; voidTObject::MayNotUse(const char* method) const; virtual voidTQObject::Message(const char* msg)SIGNAL ; voidTClass::Move(void* arenaFrom, void* arenaTo) const; void*TClass::New(TClass::ENewType defConstructor = kClassNew, Bool_t quiet = kFALSE) const; void*TClass::New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*TClass::NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*TClass::NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); virtual Int_tTQObject::NumberOfConnections() const; virtual Int_tTQObject::NumberOfSignals() const; voidTObject::Obsolete(const char* method, const char* asOf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:13642,Load,LoadClass,13642,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,2,['Load'],['LoadClass']
Performance,"small compared to the bin content; (see TProfile2D::GetBinError). Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is filled from the buffer; action = 1 histogram is filled and buffer is deleted; The buffer is automatically deleted when the number of entries; in the buffer is greater than the number of entries in the histogram. Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w); accumulate arguments in buffer. When buffer is full, empty the buffer; fBuffer[0] = number of entries in buffer; fBuffer[1] = w of first entry; fBuffer[2] = x of first entry; fBuffer[3] = y of first entry; fBuffer[4] = z of first entry. void Copy(TObject& hnew) const; -*-*-*-*Copy a Profile2D histogram to a new profile2D histogram; *-* =======================================================. Bool_t Divide(TF1* h1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); This function is not implemented. Bool_t Divide(const TH1* h1); Divide this profile2D by h1*-*-; *-* ===========================. this = this/h1. This function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*Replace contents of this profile2D by the division of h1 by h2; *-* ==============================================================. this = c1*h1/(c2*h2). This function return kFALSE if the divide operation failed. Int_t Fill(Double_t x, Double_t y, Double_t z); -*-*-*Fill a Profile2D histogram (no weights); *-* =======================================. Int_t Fill(Double_t x, const char* namey, Double_t z); Fill a Profile2D histogram (no weights). Int_t Fill(const char* namex, const char* namey, Double_t z); Fill a Profile2D histogram (no weights). Int_t Fill(const char* namex, Double_t y, Double_t z); Fill a Profile2D histogram (no weights). Int_t Fill(D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TProfile2D.html:36260,Perform,Performs,36260,root/html602/TProfile2D.html,https://root.cern,https://root.cern/root/html602/TProfile2D.html,2,['Perform'],['Performs']
Performance,"small compared to the bin content; (see TProfile2D::GetBinError). Int_t BufferEmpty(Int_t action = 0); Fill histogram with all entries in the buffer.; action = -1 histogram is reset and refilled from the buffer (called by THistPainter::Paint); action = 0 histogram is filled from the buffer; action = 1 histogram is filled and buffer is deleted; The buffer is automatically deleted when the number of entries; in the buffer is greater than the number of entries in the histogram. Int_t BufferFill(Double_t x, Double_t y, Double_t z, Double_t w); accumulate arguments in buffer. When buffer is full, empty the buffer; fBuffer[0] = number of entries in buffer; fBuffer[1] = w of first entry; fBuffer[2] = x of first entry; fBuffer[3] = y of first entry; fBuffer[4] = z of first entry. void Copy(TObject& hnew) const; -*-*-*-*Copy a Profile2D histogram to a new profile2D histogram; *-* =======================================================. Bool_t Divide(TF1* h1, Double_t c1 = 1); Performs the operation: this = this/(c1*f1); This function is not implemented. Bool_t Divide(const TH1* h1); Divide this profile2D by h1*-*-; *-* ===========================. this = this/h1. This function return kFALSE if the divide operation failed. Bool_t Divide(const TH1* h1, const TH1* h2, Double_t c1 = 1, Double_t c2 = 1, Option_t* option = """"); -*-*Replace contents of this profile2D by the division of h1 by h2; *-* ==============================================================. this = c1*h1/(c2*h2). This function return kFALSE if the divide operation failed. TH1 * DrawCopy(Option_t* option = """") const; Draw a copy of this profile2D histogram*-*-*-; *-* =======================================. Int_t Fill(Double_t x, Double_t y, Double_t z); -*-*-*Fill a Profile2D histogram (no weights); *-* =======================================. Int_t Fill(Double_t x, const char* namey, Double_t z); Fill a Profile2D histogram (no weights). Int_t Fill(const char* namex, const char* namey, Double_t z); Fill a Profi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProfile2D.html:34524,Perform,Performs,34524,root/html534/TProfile2D.html,https://root.cern,https://root.cern/root/html534/TProfile2D.html,1,['Perform'],['Performs']
Performance,"snow.tv_sec,; 1702 (unsigned long)tsnow.tv_nsec,; 1703 thread_id,; 1704 func,; 1705 line);; 1706 va_start(args, fmt);; 1707 vfprintf(DEBUG_TRACE_STREAM, fmt, args);; 1708 va_end(args);; 1709 putc('\n', DEBUG_TRACE_STREAM);; 1710 fflush(DEBUG_TRACE_STREAM);; 1711 funlockfile(DEBUG_TRACE_STREAM);; 1712}; 1713#endif /* NEED_DEBUG_TRACE_FUNC */; 1714 ; 1715 ; 1716#define MD5_STATIC static; 1717#include ""md5.inl""; 1718 ; 1719/* Darwin prior to 7.0 and Win32 do not have socklen_t */; 1720#if defined(NO_SOCKLEN_T); 1721typedef int socklen_t;; 1722#endif /* NO_SOCKLEN_T */; 1723 ; 1724#define IP_ADDR_STR_LEN (50) /* IPv6 hex string is 46 chars */; 1725 ; 1726#if !defined(MSG_NOSIGNAL); 1727#define MSG_NOSIGNAL (0); 1728#endif; 1729 ; 1730 ; 1731/* SSL: mbedTLS vs. no-ssl vs. OpenSSL */; 1732#if defined(USE_MBEDTLS); 1733/* mbedTLS */; 1734#include ""mod_mbedtls.inl""; 1735 ; 1736#elif defined(NO_SSL); 1737/* no SSL */; 1738typedef struct SSL SSL; /* dummy for SSL argument to push/pull */; 1739typedef struct SSL_CTX SSL_CTX;; 1740 ; 1741#elif defined(NO_SSL_DL); 1742/* OpenSSL without dynamic loading */; 1743#include <openssl/bn.h>; 1744#include <openssl/conf.h>; 1745#include <openssl/crypto.h>; 1746#include <openssl/dh.h>; 1747#include <openssl/engine.h>; 1748#include <openssl/err.h>; 1749#include <openssl/opensslv.h>; 1750#include <openssl/pem.h>; 1751#include <openssl/ssl.h>; 1752#include <openssl/tls1.h>; 1753#include <openssl/x509.h>; 1754 ; 1755#if defined(WOLFSSL_VERSION); 1756/* Additional defines for WolfSSL, see; 1757 * https://github.com/civetweb/civetweb/issues/583 */; 1758#include ""wolfssl_extras.inl""; 1759#endif; 1760 ; 1761#if defined(OPENSSL_IS_BORINGSSL); 1762/* From boringssl/src/include/openssl/mem.h:; 1763 *; 1764 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1765 * However, that was written in a time before Valgrind and ASAN. Since we now; 1766 * have those tools, the OpenSSL allocation functions are simply macros around; 1767",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/civetweb_8c_source.html:53350,load,loading,53350,doc/v632/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/v632/civetweb_8c_source.html,1,['load'],['loading']
Performance,"snow.tv_sec,; 1702 (unsigned long)tsnow.tv_nsec,; 1703 thread_id,; 1704 func,; 1705 line);; 1706 va_start(args, fmt);; 1707 vfprintf(DEBUG_TRACE_STREAM, fmt, args);; 1708 va_end(args);; 1709 putc('\n', DEBUG_TRACE_STREAM);; 1710 fflush(DEBUG_TRACE_STREAM);; 1711 funlockfile(DEBUG_TRACE_STREAM);; 1712}; 1713#endif /* NEED_DEBUG_TRACE_FUNC */; 1714 ; 1715 ; 1716#define MD5_STATIC static; 1717#include ""md5.inl""; 1718 ; 1719/* Darwin prior to 7.0 and Win32 do not have socklen_t */; 1720#if defined(NO_SOCKLEN_T); 1721typedef int socklen_t;; 1722#endif /* NO_SOCKLEN_T */; 1723 ; 1724#define IP_ADDR_STR_LEN (50) /* IPv6 hex string is 46 chars */; 1725 ; 1726#if !defined(MSG_NOSIGNAL); 1727#define MSG_NOSIGNAL (0); 1728#endif; 1729 ; 1730 ; 1731/* SSL: mbedTLS vs. no-ssl vs. OpenSSL */; 1732#if defined(USE_MBEDTLS); 1733/* mbedTLS */; 1734#include ""mod_mbedtls.inl""; 1735 ; 1736#elif defined(NO_SSL); 1737/* no SSL */; 1738typedef struct SSL SSL; /* dummy for SSL argument to push/pull */; 1739typedef struct SSL_CTX SSL_CTX;; 1740 ; 1741#elif defined(NO_SSL_DL); 1742/* OpenSSL without dynamic loading */; 1743#include <openssl/bn.h>; 1744#include <openssl/conf.h>; 1745#include <openssl/crypto.h>; 1746#include <openssl/dh.h>; 1747#include <openssl/err.h>; 1748#include <openssl/opensslv.h>; 1749#include <openssl/pem.h>; 1750#include <openssl/ssl.h>; 1751#include <openssl/tls1.h>; 1752#include <openssl/x509.h>; 1753 ; 1754#if defined(WOLFSSL_VERSION); 1755/* Additional defines for WolfSSL, see; 1756 * https://github.com/civetweb/civetweb/issues/583 */; 1757#include ""wolfssl_extras.inl""; 1758#endif; 1759 ; 1760#if defined(OPENSSL_IS_BORINGSSL); 1761/* From boringssl/src/include/openssl/mem.h:; 1762 *; 1763 * OpenSSL has, historically, had a complex set of malloc debugging options.; 1764 * However, that was written in a time before Valgrind and ASAN. Since we now; 1765 * have those tools, the OpenSSL allocation functions are simply macros around; 1766 * the standard memory functions.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/civetweb_8c_source.html:53351,load,loading,53351,doc/master/civetweb_8c_source.html,https://root.cern,https://root.cern/doc/master/civetweb_8c_source.html,1,['load'],['loading']
Performance,"so if you do not; 2348/// already have a pointer to the previous cache (and there was a previous; 2349/// cache), you ought to retrieve (and delete it if needed) using:; 2350///; 2351/// TFileCacheRead *older = myfile->GetCacheRead();; 2352///; 2353/// The action specifies how to behave when detaching a cache from the; 2354/// the TFile. If set to (default) kDisconnect, the contents of the cache; 2355/// will be flushed when it is removed from the file, and it will disconnect; 2356/// the cache object from the file. In almost all cases, this is what you want.; 2357/// If you want to disconnect the cache temporarily from this tree and re-attach; 2358/// later to the same fil, you can set action to kDoNotDisconnect. This will allow; 2359/// things like prefetching to continue in the background while it is no longer the; 2360/// default cache for the TTree. Except for a few expert use cases, kDisconnect is; 2361/// likely the correct setting.; 2362///; 2363/// WARNING: if action=kDoNotDisconnect, you MUST delete the cache before TFile.; 2364///; 2365 ; 2366void TFile::SetCacheRead(TFileCacheRead *cache, TObject* tree, ECacheAction action); 2367{; 2368 if (tree) {; 2369 if (cache) fCacheReadMap->Add(tree, cache);; 2370 else {; 2371 // The only addition to fCacheReadMap is via an interface that takes; 2372 // a TFileCacheRead* so the C-cast is safe.; 2373 TFileCacheRead* tpf = (TFileCacheRead *)fCacheReadMap->GetValue(tree);; 2374 fCacheReadMap->Remove(tree);; 2375 if (tpf && (tpf->GetFile() == this) && (action != kDoNotDisconnect)) tpf->SetFile(0, action);; 2376 }; 2377 }; 2378 if (cache) cache->SetFile(this, action);; 2379 else if (!tree && fCacheRead && (action != kDoNotDisconnect)) fCacheRead->SetFile(0, action);; 2380 // For backward compatibility the last Cache set is the default cache.; 2381 fCacheRead = cache;; 2382}; 2383 ; 2384////////////////////////////////////////////////////////////////////////////////; 2385/// Set a pointer to the write cache.; 2386///; 238",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:83808,cache,cache,83808,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"so re-uses concepts and ideas from the CMS Common Vector package. In contrast to CLHEP or the ROOT physics libraries, GenVector provides class templates for modeling the vectors. The user can control how the vector is internally represented. This is expressed by a choice of coordinate system, which is supplied as a template parameter when the vector is constructed. Furthermore, each coordinate system is itself a template, so that the user can specify the underlying scalar type.; The GenVector classes do not inherit from TObject, therefore cannot be used as in the case of the physics vector classes in ROOT collections.; In addition, to optimize performances, no virtual destructors are provided. In the following paragraphs, the main characteristics of GenVector are described. A more detailed description of all the GenVector classes is available also at http://seal.cern.ch/documents/mathlib/GenVector.pdf; 13.12.1 Main Characteristics; 13.12.1.1 Optimal Runtime Performances; We try to minimize any overhead in the run-time performance. We have deliberately avoided the use of any virtual function and even virtual destructors in the classes. In addition, as much as possible functions are defined as inline. For this reason, we have chosen to use template classes to implement the GenVector concepts instead of abstract or base classes and virtual functions. It is then recommended to avoid using the GenVector classes polymorphically and developing classes inheriting from them.; 13.12.1.2 Points and Vector Concept; Mathematically vectors and points are two distinct concepts. They have different transformations, as vectors only rotate while points rotate and translate. You can add two vectors but not two points and the difference between two points is a vector. We then distinguish for the 3 dimensional case, between points and vectors, modeling them with different classes:. ROOT::Math::DisplacementVector2D and ROOT::Math::DisplacementVector3D template classes describing 2 and 3 ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:719711,perform,performance,719711,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,3,"['Perform', 'perform']","['Performances', 'performance']"
Performance,"sociated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). Bool_t registerObject(const char* ownerName, const char* objectName, TObject& cacheObject, TIterator* parIter); Register object associated with given name and given associated parameters with given values in cache.; The cache will take _ownership_of_object_ and is indexed under the given name (which does not; need to be the name of cacheObject and with given set of dependent parameters with validity for the; current values of those parameters. It can be retrieved later by callin retrieveObject(). const TObject* retrieveObject(const char* name, TClass* tclass, const RooArgSet& params); Retrieve object from cache that was registered under given name with given parameters, _if_; current parameter values match those that were stored in the registry for this object.; The return object is owned by the cache instance. const TObject* getObj(Int_t uniqueID); Retrieve payload object of cache element with given unique ID. Bool_t clearObj(Int_t uniqueID); Clear cache element with given unique ID; Retrieve payload object of cache element with given unique ID. Bool_t setObj(Int_t uniqueID, TObject* obj); Place new payload object in cache element with given unique ID. Cache; will take ownership of provided object!. void clearAll(); Clear all cache elements. void print() const. void importCacheObjects(RooExpensiveObjectCache& other, const char* ownerName, Bool_t verbose = kFALSE). Int_t size() const; { return _map.size() ; }. » Last changed: Mon Dec 7 13:47:31 2009 » Last generated: 2009-12-07 13:47; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooExpensiveObjectCache.html:7941,cache,cache,7941,root/html526/RooExpensiveObjectCache.html,https://root.cern,https://root.cern/root/html526/RooExpensiveObjectCache.html,6,['cache'],['cache']
Performance,"solutionModel::_basisCodeIdentifier code for selected basis function; set<std::string>RooAbsArg::_boolAttribBoolean attributes; set<std::string>RooAbsArg::_boolAttribTransient! Transient boolean attributes (not copied in ctor); UChar_tRooAbsReal::_byteValue! Transient cache for byte values from tree branches ; static Bool_tRooAbsReal::_cacheCheckIf true, always validate contents of clean which outcome of evaluate(); deque<RooAbsCache*>RooAbsArg::_cacheListlist of caches; RooRefCountListRooAbsArg::_clientListlist of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; RooAICRegistry_codeReg! Registry of component analytical integration codes; Double_t*_coefCache! Transiet cache with transformed values of coefficients; Int_t_coefErrCount! Coefficient error counter; TIterator*_coefIter! Iterator over coefficient list; RooListProxy_coefListList of coefficients; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; Bool_t_haveLastCoefFlag indicating if last PDFs coefficient was supplied in the ctor; static RooFormulaVar*RooResolutionModel::_identityIdentity basis function pointe; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddModel.html:38301,cache,cache,38301,root/html526/RooAddModel.html,https://root.cern,https://root.cern/root/html526/RooAddModel.html,4,['cache'],['cache']
Performance,"son distribution; SeparationType the separation criterion applied in the node splitting. Known:; GiniIndex; MisClassificationError; CrossEntropy; SDivSqrtSPlusB. MinNodeSize: minimum percentage of training events in a leaf node (leaf criteria, stop splitting); nCuts: the number of steps in the optimisation of the cut for a node (if < 0, then step size is determined by the events); UseFisherCuts: use multivariate splits using the Fisher criterion; UseYesNoLeaf decide if the classification is done simply by the node type, or the S/B (from the training) in the leaf node; NodePurityLimit the minimum purity to classify a node as a signal node (used in pruning and boosting to determine misclassification error rate); PruneMethod The Pruning method. Known:; NoPruning // switch off pruning completely; ExpectedError; CostComplexity. PruneStrength a parameter to adjust the amount of pruning. Should be large enough such that overtraining is avoided.; PruningValFraction number of events to use for optimizing pruning (only if PruneStrength < 0, i.e. automatic pruning); NegWeightTreatment; IgnoreNegWeightsInTraining Ignore negative weight events in the training.; DecreaseBoostWeight Boost ev. with neg. weight with 1/boostweight instead of boostweight; PairNegWeightsGlobal Pair ev. with neg. and pos. weights in training sample and ""annihilate"" them. MaxDepth maximum depth of the decision tree allowed before further splitting is stopped; SkipNormalization Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events . Implements TMVA::MethodBase.; Definition at line 333 of file MethodBDT.cxx. ◆ DeclFileName(). static const char * TMVA::MethodBDT::DeclFileName ; (; ). inlinestatic . ReturnsName of the file containing the class declaration ; Definition at line 305 of file MethodBDT.h. ◆ DeterminePreselectionCuts(). void TMVA::MethodBDT::DeterminePreselectionCuts ; (; const std::vector< const TMVA::Event * > & ; eventSample). private ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html:47599,optimiz,optimizing,47599,doc/master/classTMVA_1_1MethodBDT.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodBDT.html,1,['optimiz'],['optimizing']
Performance,"sorDataLoader(TTensorDataLoader &&)=default; TMVA::DNN::TTensorDataLoader::fBatchSizesize_t fBatchSizeThe size of a batch.Definition TensorDataLoader.h:144; TMVA::DNN::TTensorDataLoader::fInputLayoutShape_t fInputLayoutThe input data layout (does not include batch size)Definition TensorDataLoader.h:145; TMVA::DNN::TTensorDataLoader::CopyTensorWeightsvoid CopyTensorWeights(HostBuffer_t &buffer, IndexIterator_t begin)Copy weight matrix into the given host buffer.; TMVA::DNN::TTensorDataLoader::Matrix_ttypename Architecture_t::Matrix_t Matrix_tDefinition TensorDataLoader.h:137; TMVA::DNN::TTensorDataLoader::HostBuffer_ttypename Architecture_t::HostBuffer_t HostBuffer_tDefinition TensorDataLoader.h:135; TMVA::DNN::TTensorDataLoader::fBatchDepthsize_t fBatchDepthThe number of matrices in the tensor.Definition TensorDataLoader.h:146; TMVA::DNN::TTensorDataLoader::fNStreamssize_t fNStreamsNumber of buffer pairs.Definition TensorDataLoader.h:153; TMVA::DNN::TTensorDataLoader::fDataconst Data_t & fDataThe data that should be loaded in the batches.Definition TensorDataLoader.h:142; TMVA::DNN::TTensorDataLoader::operator=TTensorDataLoader & operator=(TTensorDataLoader &&)=default; TMVA::DNN::TTensorDataLoader::Tensor_ttypename Architecture_t::Tensor_t Tensor_tDefinition TensorDataLoader.h:138; TMVA::DNN::TTensorDataLoader::endBatchIterator_t end()Definition TensorDataLoader.h:180; TMVA::DNN::TTensorDataLoader::fNSamplessize_t fNSamplesThe total number of samples in the dataset.Definition TensorDataLoader.h:143; TMVA::DNN::TTensorDataLoader::CopyTensorInputvoid CopyTensorInput(HostBuffer_t &buffer, IndexIterator_t begin)Copy input tensor into the given host buffer.; TMVA::DataSetInfoClass that contains all the data information.Definition DataSetInfo.h:62; TMatrixTTMatrixT.Definition TMatrixT.h:40; TMVA::DNN::TensorInputstd::tuple< const std::vector< TMatrixT< Double_t > > &, const TMatrixT< Double_t > &, const TMatrixT< Double_t > & > TensorInputDefinition TensorDataLoader.h:44",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TensorDataLoader_8h_source.html:19640,load,loaded,19640,doc/master/TensorDataLoader_8h_source.html,https://root.cern,https://root.cern/doc/master/TensorDataLoader_8h_source.html,1,['load'],['loaded']
Performance,"source. For a given development platform there can be more than one adequate generator. If you use Visual Studio, “NMake Makefiles” is a generator you can use for building with NMake. By default, CMake chooses the most specific generator supported by your development environment. If you want an alternative generator, you must tell this to CMake with the -G option.; Options and variables; Variables customize how the build will be generated. Options are boolean variables, with possible values ON/OFF. Options and variables are defined on the CMake command line like this:; $ cmake -DVARIABLE=value path/to/source. You can set a variable after the initial CMake invocation to change its value. You can also undefine a variable:; $ cmake -UVARIABLE path/to/source. Variables are stored in the CMake cache. This is a file named CMakeCache.txt stored at the root of your build directory that is generated by cmake. Editing it yourself is not recommended.; Variables are listed in the CMake cache with the variable name and type separated by a colon. You can also specify the variable and type on the CMake command line:; $ cmake -DVARIABLE:TYPE=value path/to/source. Variables in the CMake cache are 'remembered', so you do not need to type them if you execute cmake command again. It is recommended to delete the file CMakeCache.txt to start from a clean configuration. Sitemap. DownloadDownload ROOT; All Releases. DocumentationReference Manual; User's Guides; HowTo; Courses; Building ROOT; Tutorials; Javascript Root; ROOT and Spark; Publications; FAQ. NewsBlog; Workshops. SupportForum; Bug submission guidelines; Submit a Bug; Discourse Mailing List Mode; RootTalk Digest. AboutLicence; Contact Us; Project Founders; Team; Previous Developers. DevelopmentProgram of Work; Code Owners; Release Checklist; Coding Conventions; Shifter's Instructions; Git Primer; Browse Sources; Meetings; ROOT 7; Run the tests; Jenkins; Setup externals from AFS/CVMFS; Doxygen; Benchmarks. ContributeCollaborate wit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/d/building-root.html:23210,cache,cache,23210,d/building-root.html,https://root.cern,https://root.cern/d/building-root.html,1,['cache'],['cache']
Performance,"sp) const; RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs); RooAbsMoment*RooAbsReal::sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig() const; RooNumGenConfig*RooAbsPdf::specialGeneratorConfig(Bool_t createOnTheFly); RooNumIntConfig*RooAbsReal::specialIntegratorConfig() const; RooNumIntConfig*RooAbsReal::specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; virtual Bool_tRooAbsPdf::traceEvalHook(Double_t value) const; Bool_tRooAbsPdf::traceEvalPdf(Double_t value) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); static intRooAbsPdf::verboseEval(); static voidRooAbsPdf::verboseEval(Int_t stat); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; voidwriteHistToFile(char* outputFile, const char* histName) const; voidwriteNTupleToFile(char* outputFile, const char* name) const; voidwriteToFile(char* outputFile, const char* name) const; virtual voidRooAbsReal::writeToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/Roo2DKeysPdf.html:31955,cache,cache,31955,root/html602/Roo2DKeysPdf.html,https://root.cern,https://root.cern/root/html602/Roo2DKeysPdf.html,4,['cache'],['cache']
Performance,"space Internal {; 623template <typename T>; 624TClass *GetClassHelper(Bool_t, Bool_t, std::true_type); 625{; 626 return T::Class();; 627}; 628 ; 629template <typename T>; 630struct TClassGetClassHelper {; 631 static TClass *GetClass(Bool_t load, Bool_t silent) {; 632 return TClass::GetClass(typeid(T), load, silent);; 633 }; 634};; 635 ; 636template <typename F, typename S>; 637struct TClassGetClassHelper<std::pair<F, S> > {; 638 static TClass *GetClass(Bool_t load, Bool_t silent) {; 639 using pair_t = std::pair<F,S>;; 640 size_t hint_offset = offsetof(pair_t, second);; 641 return TClass::GetClass(typeid(std::pair<F, S>), load, silent, hint_offset, sizeof(std::pair<F,S>));; 642 }; 643};; 644 ; 645template <typename T>; 646TClass *GetClassHelper(Bool_t load, Bool_t silent, std::false_type); 647{; 648 return TClassGetClassHelper<T>::GetClass(load, silent);; 649}; 650 ; 651} // namespace Internal; 652} // namespace ROOT; 653 ; 654template <typename T>; 655TClass *TClass::GetClass(Bool_t load, Bool_t silent); 656{; 657 typename std::is_base_of<TObject, T>::type tag;; 658 return ROOT::Internal::GetClassHelper<T>(load, silent, tag);; 659}; 660 ; 661namespace ROOT {; 662 ; 663template <typename T> TClass *GetClass(T * /* dummy */) { return TClass::GetClass<T>(); }; 664template <typename T> TClass *GetClass(const T * /* dummy */) { return TClass::GetClass<T>(); }; 665 ; 666#ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION; 667 // This can only be used when the template overload resolution can distinguish between T* and T**; 668 template <typename T> TClass* GetClass( T** /* dummy */) { return TClass::GetClass<T>(); }; 669 template <typename T> TClass* GetClass(const T** /* dummy */) { return TClass::GetClass<T>(); }; 670 template <typename T> TClass* GetClass( T* const* /* dummy */) { return TClass::GetClass<T>(); }; 671 template <typename T> TClass* GetClass(const T* const* /* dummy */) { return TClass::GetClass<T>(); }; 672#endif; 673 ; 674 extern TClass *CreateClass(const char *",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:33124,load,load,33124,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['load'],['load']
Performance,"space  TestSupport;  ; namespace  TF1Helper;  ; namespace  TMetaUtils;  ; namespace  TreeUtils;  ; namespace  TThreadedObjectUtils;  ; namespace  TypeTraits;  ROOT type_traits extensions. ;  ; namespace  v5;  ; namespace  VecOps;  . Classes; struct  RCompressionSetting;  The global settings depend on a global variable named R__ZipMode which can be modified by a global function named R__SetZipMode. More...;  ; class  RDataFrame;  ROOT's RDataFrame offers a modern, high-level interface for analysis of data stored in TTree , CSV and other data formats, in C++ or Python. More...;  ; class  ROpaqueTaskArena;  ; class  RRangeCast;  Wraps any collection that can be used in range-based loops and applies static_cast<T> or dynamic_cast<T> to each element. More...;  ; class  TBufferMerger;  TBufferMerger is a class to facilitate writing data in parallel from multiple threads, while writing to a single output file. More...;  ; class  TBufferMergerFile;  A TBufferMergerFile is similar to a TMemFile, but when data is written to it, it is appended to the TBufferMerger queue. More...;  ; class  TClassAlt;  ; class  TClassRec;  ; class  TExecutorCRTP;  This class defines an interface to execute the same task multiple times, possibly in parallel and with different arguments every time. More...;  ; class  TForNamespace;  ; class  TIOFeatures;  TIOFeatures provides the end-user with the ability to change the IO behavior of data written via a TTree. More...;  ; class  TMapDeclIdToTClass;  ; class  TMapTypeToClassRec;  ; class  TMapTypeToTClass;  ; class  TModuleGenerator;  ; class  TNumSlots;  Defines the number of threads in some of ROOT's interfaces. More...;  ; class  TProcessExecutor;  This class provides a simple interface to execute the same task multiple times in parallel, possibly with different arguments every time. More...;  ; class  TReadLockGuard;  ; class  TReentrantRWLock;  ; class  TRWMutexImp;  ; class  TRWSpinLock;  ; class  TRWSpinLockReadGuard;  ; class  TRWSpinLockWr",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v628/namespaceROOT.html:2349,queue,queue,2349,doc/v628/namespaceROOT.html,https://root.cern,https://root.cern/doc/v628/namespaceROOT.html,1,['queue'],['queue']
Performance,"space. void optimizeScan(); do the actual optimization using a simple scan method,; i.e. calcualte the FOM for; different tuning paraemters and remember which one is; gave the best FOM. void optimizeFit(); ranges (intervals) in which the fit varies the parameters. Double_t EstimatorFunction(vector<Double_t>& ); return the estimator (from current FOM) for the fitting interface. Double_t GetFOM(); Return the Figure of Merit (FOM) used in the parameter; optimization process. void GetMVADists(); fill the private histograms with the mva distributinos for sig/bkg. Double_t GetSeparation(); return the searation between the signal and background; MVA ouput distribution. Double_t GetROCIntegral(); calculate the area (integral) under the ROC curve as a; overall quality measure of the classification. makeing pdfs out of the MVA-ouput distributions doesn't work; reliably for cases where the MVA-ouput isn't a smooth distribution.; this happens ""frequently"" in BDTs for example when the number of; trees is small resulting in only some discrete possible MVA ouput values.; (I still leave the code here, but use this with care!!! The default; however is to use the distributions!!!. Double_t GetSigEffAtBkgEff(Double_t bkgEff = 0.1); calculate the signal efficiency for a given background efficiency. Double_t GetBkgEffAtSigEff(Double_t sigEff = 0.5); calculate the background efficiency for a given signal efficiency. Double_t GetBkgRejAtSigEff(Double_t sigEff = 0.5); calculate the background rejection for a given signal efficiency. OptimizeConfigParameters(TMVA::MethodBase *const method, map<TString,TMVA::Interval*> tuneParameters, TString fomType = ""Separation"", TString optimizationType = ""GA""); default constructor. MethodBase* GetMethod(); {return fMethod;}. » Last changed: Sat Mar 14 16:44:05 2015 » Last generated: 2015-03-14 16:44; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__OptimizeConfigParameters.html:4866,tune,tuneParameters,4866,root/html534/TMVA__OptimizeConfigParameters.html,https://root.cern,https://root.cern/root/html534/TMVA__OptimizeConfigParameters.html,5,"['Optimiz', 'optimiz', 'tune']","['OptimizeConfigParameters', 'optimizationType', 'tuneParameters']"
Performance,"specGeneratorConfig! MC generator configuration specific for this object; RooNumIntConfig*RooAbsReal::_specIntegratorConfigNumeric integrator configuration specific for this object; map<std::string,std::string>RooAbsArg::_stringAttribString attributes; Int_tRooAbsPdf::_traceCountNumber of traces remaining to print; Bool_tRooAbsReal::_treeVar!do not persist; UInt_tRooAbsReal::_uintValue! Transient cache for unsigned integer values from tree branches ; TStringRooAbsReal::_unitUnit for objects value; Double_tRooAbsReal::_valueCache for current value of object; Int_tRooAbsPdf::_valueCacheIntOrderInterpolation order for numeric integral value cache; Bool_tRooAbsArg::_valueDirtyFlag set if value needs recalculating because input values modified; static Bool_tRooAbsArg::_verboseDirtyStatic flag controlling verbose messaging for dirty state changes; static Int_tRooAbsPdf::_verboseEval; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; RooRealProxypdfProxy to p.d.f being cached. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf); Constructor taking name, title and function to be cached. To control; granularity of the binning of the cache histogram set the desired properties; in the binning named ""cache"" in the observables of the function. The dimensions; of the cache are automatically matched to the number of observables used; in each use context. Multiple cache in different observable may exists; simultanously if the cached p.d.f is used with multiple observable; configurations simultaneously. RooCachedPdf(const char* name, const char* title, RooAbsPdf& _pdf, const RooArgSet& cacheObs); Constructor taking name, title and function to be cached and; fixed choice of variable to cache. To control granularity of the; binning of the cache histogram set the desired properties in the; binning named ""cache"" in the observables of the function.; If the fixe",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooCachedPdf.html:40953,cache,cached,40953,root/html526/RooCachedPdf.html,https://root.cern,https://root.cern/root/html526/RooCachedPdf.html,4,['cache'],['cached']
Performance,"specified in the booking of the method and provide a vector of SV kernels to iterate over in SVKernelFunction. ;  ; virtual std::map< TString, Double_t > OptimizeTuningParameters (TString fomType=""ROCIntegral"", TString fitType=""Minuit"");  Optimize Tuning Parameters This is used to optimise the kernel function parameters and cost. ;  ; virtual void ReadWeightsFromStream (std::istream &)=0;  ; void ReadWeightsFromStream (std::istream &istr);  ; virtual void ReadWeightsFromStream (TFile &);  ; void ReadWeightsFromStream (TFile &fFin);  TODO write IT. ;  ; void ReadWeightsFromXML (void *wghtnode);  ; void Reset (void);  ; void SetCost (Double_t c);  ; void SetGamma (Double_t g);  ; void SetKappa (Double_t k);  ; void SetMGamma (std::string &mg);  Takes as input a string of values for multigaussian gammas and splits it, filling the gamma vector required by the SVKernelFunction. ;  ; void SetMult (Double_t m);  ; void SetOrder (Double_t o);  ; void SetTheta (Double_t t);  ; virtual void SetTuneParameters (std::map< TString, Double_t > tuneParameters);  Set the tuning parameters according to the argument. ;  ; virtual void Streamer (TBuffer &);  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ; void Train (void);  Train SVM. ;  ; void WriteWeightsToStream (TFile &fout) const;  TODO write IT write training sample (TTree) to file. ;  ;  Public Member Functions inherited from TMVA::MethodBase;  MethodBase (const TString &jobName, Types::EMVA methodType, const TString &methodTitle, DataSetInfo &dsi, const TString &theOption="""");  standard constructor ;  ;  MethodBase (Types::EMVA methodType, DataSetInfo &dsi, const TString &weightFile);  constructor used for Testing + Application of the MVA, only (no training), using given WeightFiles ;  ; virtual ~MethodBase ();  destructor ;  ; void AddOutput (Types::ETreeType type, Types::EAnalysisType analysisType);  ; TDirectory * BaseDir () const;  returns the ROOT directory where info/histograms etc of the corresponding",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTMVA_1_1MethodSVM.html:2941,tune,tuneParameters,2941,doc/master/classTMVA_1_1MethodSVM.html,https://root.cern,https://root.cern/doc/master/classTMVA_1_1MethodSVM.html,1,['tune'],['tuneParameters']
Performance,"specified, 'option' can also contain a sorting; 3100/// order for the baskets in the output file.; 3101///; 3102/// There are currently 3 supported sorting order:; 3103///; 3104/// - SortBasketsByOffset (the default); 3105/// - SortBasketsByBranch; 3106/// - SortBasketsByEntry; 3107///; 3108/// When using SortBasketsByOffset the baskets are written in the; 3109/// output file in the same order as in the original file (i.e. the; 3110/// baskets are sorted by their offset in the original file; Usually; 3111/// this also means that the baskets are sorted by the index/number of; 3112/// the _last_ entry they contain); 3113///; 3114/// When using SortBasketsByBranch all the baskets of each individual; 3115/// branches are stored contiguously. This tends to optimize reading; 3116/// speed when reading a small number (1->5) of branches, since all; 3117/// their baskets will be clustered together instead of being spread; 3118/// across the file. However it might decrease the performance when; 3119/// reading more branches (or the full entry).; 3120///; 3121/// When using SortBasketsByEntry the baskets with the lowest starting; 3122/// entry are written first. (i.e. the baskets are sorted by the; 3123/// index/number of the first entry they contain). This means that on; 3124/// the file the baskets will be in the order in which they will be; 3125/// needed when reading the whole tree sequentially.; 3126///; 3127/// For examples of CloneTree, see tutorials:; 3128///; 3129/// - copytree.C:; 3130/// A macro to copy a subset of a TTree to a new TTree.; 3131/// The input file has been generated by the program in; 3132/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3133///; 3134/// - copytree2.C:; 3135/// A macro to copy a subset of a TTree to a new TTree.; 3136/// One branch of the new Tree is written to a separate file.; 3137/// The input file has been generated by the program in; 3138/// $ROOTSYS/test/Event with: Event 1000 1 1 1; 3139 ; 3140TTree* TTree::CloneTree(Long64_t nent",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:124915,perform,performance,124915,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['perform'],['performance']
Performance,"specified. One always can install JSROOT on private web server. When JSROOT is used with THttpServer, the address looks like:; <script type='module'>; import { httpRequest, draw } from 'http://your_root_server:8080/jsrootsys/modules/main.mjs';; let obj = await httpRequest('http://your_root_server:8080/Objects/hist/root.json','object');; await draw('drawing', obj, 'hist');; </script>; Loading main module is enough to get public JSROOT functionality - reading files and drawing objects. One also can load some special components directly like:; <script type='module'>; import { HierarchyPainter } from 'https://root.cern/js/latest/modules/gui.mjs';. let h = new HierarchyPainter(""example"", ""myTreeDiv"");. // configure 'simple' in provided <div> element; // one also can specify ""grid2x2"" or ""flex"" or ""tabs""; h.setDisplay(""simple"", ""myMainDiv"");. // open file and display element; await h.openRootFile('../../files/hsimple.root');; await h.display('hpxpy;1"",""colz');; </script>; After script loading one can configure different parameters in gStyle object. It is instance of the TStyle object and behaves like gStyle variable in ROOT. For instance, to change stat format using to display value in stats box:; import { gStyle } from 'https://root.cern/js/latest/modules/main.mjs';; gStyle.fStatFormat = '7.5g';; There is also settings object which contains all other JSROOT settings. For instance, one can configure custom format for different axes:; import { settings } from 'https://root.cern/js/latest/modules/main.mjs';; settings.XValuesFormat = '4.2g';; settings.YValuesFormat = '6.1f';; One also can use build/jsroot.js bundle to load all functionality at one and access it via JSROOT global handle:; <script src=""https://root.cern/js/latest/build/jsroot.js""></script>; <script>; // getting json string from somewhere; let obj = JSROOT.parse(root_json);; JSROOT.draw('plain', obj, 'colz');; </script>; 1.11.2 Use of JSON; It is strongly recommended to use JSON when communicating with ROOT app",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html:24229,load,loading,24229,root/htmldoc/guides/JSROOT/JSROOT.html,https://root.cern,https://root.cern/root/htmldoc/guides/JSROOT/JSROOT.html,2,['load'],['loading']
Performance,"speed-up the reading of ROOT datasets. . A cache to speed-up the reading of ROOT datasets. Table of Contents. Motivation; General Description; Changes in behaviour; Self-optimization; Examples of usage; Check performance and stats. Motivation: why having a cache is needed?; When writing a TTree, the branch buffers are kept in memory. A typical branch buffersize (before compression) is typically 32 KBytes. After compression, the zipped buffer may be just a few Kbytes. The branch buffers cannot be much larger in case of TTrees with several hundred or thousand branches.; When writing, this does not generate a performance problem because branch buffers are always written sequentially and, thanks to OS optimisations, content is flushed to the output file when a few MBytes of data are available. On the other hand, when reading, one may hit performance problems because of latencies e.g imposed by network. For example in a WAN with 10ms latency, reading 1000 buffers of 10 KBytes each with no cache will imply 10s penalty where a local read of the 10 MBytes would take about 1 second.; The TreeCache tries to prefetch all the buffers for the selected branches in order to transfer a few multi-Megabytes large buffers instead of many multi-kilobytes small buffers. In addition, TTreeCache can sort the blocks to be read in increasing order such that the file is read sequentially.; Systems like xrootd, dCache or httpd take advantage of the TTreeCache in reading ahead as much data as they can and return to the application the maximum data specified in the cache and have the next chunk of data ready when the next request comes. Are there cases for which the usage of TTreeCache is detrimental for performance?; Yes, some corner cases. For example, when reading only a small fraction of all entries such that not all branch buffers are read. General Description; This class acts as a file cache, registering automatically the baskets from the branches being processed via direct manipulation of",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:1328,latency,latency,1328,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,4,"['cache', 'latency']","['cache', 'latency']"
Performance,"splacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar etaval). Change Eta - CylindricalEta3D coordinates only. { fCoordinates.SetEta(etaval); return *this;}. Scalar Dot( const DisplacementVector3D<OtherCoords,Tag> & v); ------ Operations combining two vectors ------; -- need to have the specialized version in order to avoid. Return the scalar (dot) product of two displacement vectors.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. Scalar Dot( const OtherVector & v). Return the scalar (dot) product of two vectors.; It is possible to perform the product for any classes; implementing x(), y() and z() member functions. DisplacementVector3D Cross( const DisplacementVector3D<OtherCoords,Tag> & v). Return vector (cross) product of two displacement vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any type of vector coordinates,; but they must have the same coordinate system tag. DisplacementVector3D Cross( const OtherVector & v). Return vector (cross) product of two vectors,; as a vector in the coordinate system of this class.; It is possible to perform the product for any classes; implementing X(), Y() and Z() member functions. DisplacementVector3D & operator*=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). multiply this vector by a scalar quantity. DisplacementVector3D & operator/=(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a). divide this vector by a scalar quantity. return operator*( Scalar(-1) ). DisplacementVector3D operator/(ROOT::Math::DisplacementVector3D<ROOT::Math::Cartesian3D<double>,ROOT::Math::DefaultCoordinateSystemTag>::Scalar a) const. Division of a vector with a real number. Scalar x() const; Methods providing limited backward name compatibil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html:24992,perform,perform,24992,root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,https://root.cern,https://root.cern/root/html534/ROOT__Math__DisplacementVector3D_-p1Cartesian3D_double__-p1DefaultCoordinateSystemTag_.html,2,['perform'],['perform']
Performance,"srel, Double_t epsabs, Double_t& relerr, Int_t& nfnevl, Int_t& ifail). This function computes, to an attempted specified accuracy, the value of; the integral. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epsrel : Specified relative accuracy.; epsabs : Specified absolute accuracy.; The integration algorithm will attempt to reach either the relative or the absolute accuracy.; In case the maximum funcion called is reached the algorithm will stop earlier without having reached; the desired accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. The default method used is the Genz-Mallik adaptive multidimensional algorithm; using the class ROOT::Math::AdaptiveIntegratorMultiDim; (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); to different integrators.; Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; Possible methods are : Vegas, Miser or Plain; IN case of MC integration the accuracy is determined by the number of function calls, one should be; careful not to use a too large value of maxpts. Bool_t IsInside(const Double_t* x) const; Return kTRUE if the point is inside the function range. void Paint(Option_t* option = """"); Paint this function with its current attributes. void Print(O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TF1.html:60494,perform,performed,60494,root/html602/TF1.html,https://root.cern,https://root.cern/root/html602/TF1.html,2,['perform'],['performed']
Performance,"srel, Double_t epsabs, Double_t& relerr, Int_t& nfnevl, Int_t& ifail). This function computes, to an attempted specified accuracy, the value of; the integral. Input parameters:. n : Number of dimensions [2,15]; a,b : One-dimensional arrays of length >= N . On entry A[i], and B[i],; contain the lower and upper limits of integration, respectively.; maxpts: Maximum number of function evaluations to be allowed.; maxpts >= 2^n +2*n*(n+1) +1; if maxpts<minpts, maxpts is set to 10*minpts; epsrel : Specified relative accuracy.; epsabs : Specified absolute accuracy.; The integration algorithm will attempt to reach either the relative or the absolute accuracy.; In case the maximum funcion called is reached the algorithm will stop earlier without having reached; the desired accuracy. Output parameters:. relerr : Contains, on exit, an estimation of the relative accuracy of the result.; nfnevl : number of function evaluations performed.; ifail :; 0 Normal exit. . At least minpts and at most maxpts calls to the function were performed.; 1 maxpts is too small for the specified accuracy eps.; The result and relerr contain the values obtainable for the; specified value of maxpts.; 3 n<2 or n>15. Method:. The defult method used is the Genz-Mallik adaptive multidimensional algorithm; using the class ROOT::Math::AdaptiveIntegratorMultiDim; (see the reference documentation of the class); Other methods can be used by setting ROOT::Math::IntegratorMultiDimOptions::SetDefaultIntegrator(); to different integrators.; Other possible integrators are MC integrators based on the ROOT::Math::GSLMCIntegrator class; Possible methods are : Vegas, Miser or Plain; IN case of MC integration the accuracy is determined by the number of function calls, one should be; careful not to use a too large value of maxpts. Bool_t IsValid() const; Return kTRUE if the function is valid. void Print(Option_t* option = """") const. void Paint(Option_t* option = """"); Paint this function with its current attributes.; The fu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TF1.html:53277,perform,performed,53277,root/html604/TF1.html,https://root.cern,https://root.cern/root/html604/TF1.html,2,['perform'],['performed']
Performance,"ss * TTreeIndex::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TNamed.; Definition at line 73 of file TTreeIndex.h. ◆ IsValidFor(). bool TTreeIndex::IsValidFor ; (; const TTree * ; parent). overridevirtual . Return true if index can be applied to the TTree. ; Implements TVirtualIndex.; Definition at line 526 of file TTreeIndex.cxx. ◆ operator=(). TTreeIndex & TTreeIndex::operator= ; (; const TTreeIndex & ; ). privatedelete . ◆ Print(). void TTreeIndex::Print ; (; Option_t * ; option = """"); const. overridevirtual . Print the table with : serial number, majorname, minorname. . if option = ""10"" print only the first 10 entries; if option = ""100"" print only the first 100 entries; if option = ""1000"" print only the first 1000 entries . Reimplemented from TNamed.; Definition at line 542 of file TTreeIndex.cxx. ◆ SetTree(). void TTreeIndex::SetTree ; (; TTree * ; T). overridevirtual . this function is called by TChain::LoadTree and TTreePlayer::UpdateFormulaLeaves when a new Tree is loaded. ; Because Trees in a TChain may have a different list of leaves, one must update the leaves numbers in the TTreeFormula used by the TreeIndex. ; Implements TVirtualIndex.; Definition at line 638 of file TTreeIndex.cxx. ◆ Streamer(). void TTreeIndex::Streamer ; (; TBuffer & ; R__b). overridevirtual . Stream an object of class TTreeIndex. ; Note that this Streamer should be changed to an automatic Streamer once TStreamerInfo supports an index of type Long64_t ; Reimplemented from TNamed.; Definition at line 583 of file TTreeIndex.cxx. ◆ StreamerNVirtual(). void TTreeIndex::StreamerNVirtual ; (; TBuffer & ; ClassDef_StreamerNVirtual_b). inline . Definition at line 73 of file TTreeIndex.h. ◆ UpdateFormulaLeaves(). void TTreeIndex::UpdateFormulaLeaves ; (; const TTree * ; parent). overridevirtual . Called by TChain::LoadTree when the parent chain changes it's tree. ; Implements TVirtualIndex.; Definition at line 619 of file TTreeIndex.c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTTreeIndex.html:24781,load,loaded,24781,doc/master/classTTreeIndex.html,https://root.cern,https://root.cern/doc/master/classTTreeIndex.html,1,['load'],['loaded']
Performance,"ss ;  ;  Public Member Functions inherited from TStreamerElement;  TStreamerElement ();  Default ctor. ;  ;  TStreamerElement (const char *name, const char *title, Int_t offset, Int_t dtype, const char *typeName);  Create a TStreamerElement object. ;  ; virtual ~TStreamerElement ();  TStreamerElement dtor. ;  ; virtual Bool_t CannotSplit () const;  Returns true if the element cannot be split, false otherwise. ;  ; Int_t GetArrayDim () const;  ; Int_t GetArrayLength () const;  ; TClass * GetClass () const;  ; virtual Int_t GetExecID () const;  Returns the TExec id for the EXEC instruction in the comment field of a TRef data member. ;  ; Double_t GetFactor () const;  ; virtual const char * GetFullName () const;  Return element name including dimensions, if any Note that this function stores the name into a static array. ;  ; virtual const char * GetInclude () const;  ; Int_t GetMaxIndex (Int_t i) const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; TClass * IsA () const override;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeName instead of dm->GetFullTypename if this case is detected, the element type name is modified. ;  ; virtual Bool_t IsTransient () const;  Return kTRUE if the eleme",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBasicPointer.html:2940,cache,cached,2940,doc/master/classTStreamerBasicPointer.html,https://root.cern,https://root.cern/doc/master/classTStreamerBasicPointer.html,1,['cache'],['cached']
Performance,"ss ;  ;  Public Member Functions inherited from TStreamerElement;  TStreamerElement ();  Default ctor. ;  ;  TStreamerElement (const char *name, const char *title, Int_t offset, Int_t dtype, const char *typeName);  Create a TStreamerElement object. ;  ; virtual ~TStreamerElement ();  TStreamerElement dtor. ;  ; virtual Bool_t CannotSplit () const;  Returns true if the element cannot be split, false otherwise. ;  ; Int_t GetArrayDim () const;  ; Int_t GetArrayLength () const;  ; TClass * GetClass () const;  ; virtual Int_t GetExecID () const;  Returns the TExec id for the EXEC instruction in the comment field of a TRef data member. ;  ; Double_t GetFactor () const;  ; virtual const char * GetFullName () const;  Return element name including dimensions, if any Note that this function stores the name into a static array. ;  ; virtual const char * GetInclude () const;  ; Int_t GetMaxIndex (Int_t i) const;  ; TClass * GetNewClass () const;  ; Int_t GetNewType () const;  ; Int_t GetOffset () const;  ; void GetSequenceType (TString &type) const;  Fill type with the string representation of sequence information including 'cached','repeat','write' or 'nodelete'. ;  ; TMemberStreamer * GetStreamer () const;  Return the local streamer object. ;  ; Int_t GetTObjectOffset () const;  ; Int_t GetType () const;  ; const char * GetTypeName () const;  ; const char * GetTypeNameBasic () const;  Return type name of this element in case the type name is not a standard basic type, return the basic type name known to CINT. ;  ; Double_t GetXmax () const;  ; Double_t GetXmin () const;  ; virtual Bool_t HasCounter () const;  ; virtual void Init (TVirtualStreamerInfo *obj=nullptr);  Initliaze the element. ;  ; TClass * IsA () const override;  ; virtual Bool_t IsaPointer () const;  ; virtual Bool_t IsBase () const;  Return kTRUE if the element represent a base class. ;  ; virtual Bool_t IsOldFormat (const char *newTypeName);  The early 3.00/00 and 3.01/01 versions used to store dm->GetTypeNam",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTStreamerBasicType.html:2428,cache,cached,2428,doc/master/classTStreamerBasicType.html,https://root.cern,https://root.cern/doc/master/classTStreamerBasicType.html,1,['cache'],['cached']
Performance,"ss Reference. ; ROOT  ; . master. Reference Guide ; .  . Loading...; Searching...; No Matches. List of all members |; Public Member Functions |; Private Member Functions |; List of all members ; ROOT::Math::GSLMultiRootBaseSolver Class ReferenceabstractMath » MathCore | Math » MathMore » Numerical Algorithms » Multidimensional ROOT finding. ; GSLMultiRootBaseSolver, internal class for implementing GSL multi-root finders This is the base class for GSLMultiRootSolver (solver not using derivatives) and GSLMUltiRootDerivSolver (solver using derivatives) ; Definition at line 57 of file GSLMultiRootSolver.h. Public Member Functions; virtual ~GSLMultiRootBaseSolver ();  virtual Destructor ;  ; const double * Dx () const;  return function steps ;  ; const double * FVal () const;  return function values ;  ; bool InitSolver (const std::vector< ROOT::Math::IMultiGenFunction * > &funcVec, const double *x);  init the solver with function list and initial values ;  ; virtual int Iterate ()=0;  perform an iteration ;  ; virtual const std::string & Name () const =0;  return name ;  ; int TestDelta (double absTol, double relTol) const;  test using abs and relative tolerance |dx| < absTol + relTol*|x| for every component ;  ; int TestResidual (double absTol) const;  test using abs tolerance Sum |f|_i < absTol ;  ; const double * X () const;  solution values at the current iteration ;  . Private Member Functions; virtual gsl_vector * GetDx () const =0;  ; virtual gsl_vector * GetF () const =0;  ; virtual gsl_vector * GetRoot () const =0;  ; virtual int SetSolver (const std::vector< ROOT::Math::IMultiGenFunction * > &funcVec, const double *x)=0;  . #include </home/sftnight/build/workspace/root-makedoc-master/rootspi/rdoc/src/master/math/mathmore/src/GSLMultiRootSolver.h>. Inheritance diagram for ROOT::Math::GSLMultiRootBaseSolver:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ ~GSLMultiRootBaseS",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootBaseSolver.html:1042,perform,perform,1042,doc/master/classROOT_1_1Math_1_1GSLMultiRootBaseSolver.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Math_1_1GSLMultiRootBaseSolver.html,1,['perform'],['perform']
Performance,"ss T> Int_t SetBranchAddress(const char *bname, T *add, TBranch **ptr = nullptr) {; 638 TClass *cl = TClass::GetClass<T>();; 639 EDataType type = kOther_t;; 640 if (!cl) type = TDataType::GetType(typeid(T));; 641 return SetBranchAddress(bname,add,ptr,cl,type,false);; 642 }; 643#endif; 644 virtual void SetBranchStatus(const char* bname, bool status = true, UInt_t* found = nullptr);; 645 static void SetBranchStyle(Int_t style = 1); //style=0 for old branch, =1 for new branch style; 646 virtual Int_t SetCacheSize(Long64_t cachesize = -1);; 647 virtual Int_t SetCacheEntryRange(Long64_t first, Long64_t last);; 648 virtual void SetCacheLearnEntries(Int_t n=10);; 649 virtual void SetChainOffset(Long64_t offset = 0) { fChainOffset=offset; }; 650 virtual void SetCircular(Long64_t maxEntries);; 651 virtual void SetClusterPrefetch(bool enabled) { fCacheDoClusterPrefetch = enabled; }; 652 virtual void SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999); // *MENU*; 653 virtual void SetDefaultEntryOffsetLen(Int_t newdefault, bool updateExisting = false);; 654 virtual void SetDirectory(TDirectory* dir);; 655 virtual Long64_t SetEntries(Long64_t n = -1);; 656 virtual void SetEstimate(Long64_t nentries = 1000000);; 657 ROOT::TIOFeatures SetIOFeatures(const ROOT::TIOFeatures &);; 658 virtual void SetFileNumber(Int_t number = 0);; 659 virtual void SetEventList(TEventList* list);; 660 virtual void SetEntryList(TEntryList* list, Option_t *opt="""");; 661 virtual void SetImplicitMT(bool enabled) { fIMTEnabled = enabled; }; 662 virtual void SetMakeClass(Int_t make);; 663 virtual void SetMaxEntryLoop(Long64_t maxev = kMaxEntries) { fMaxEntryLoop = maxev; } // *MENU*; 664 static void SetMaxTreeSize(Long64_t maxsize = 100000000000LL);; 665 virtual void SetMaxVirtualSize(Long64_t size = 0) { fMaxVirtualSize = size; } // *MENU*; 666 void SetName(const char* name) override; // *MENU*; 667 ; 668 /**; 669 * @brief Sets the address of the object to be notified when the tree is loaded.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8h_source.html:37846,load,loaded,37846,doc/master/TTree_8h_source.html,https://root.cern,https://root.cern/doc/master/TTree_8h_source.html,1,['load'],['loaded']
Performance,"ss TTreeFormula: public ROOT::v5::TFormula. TTreeFormula now relies on a variety of TFormLeafInfo classes to handle the; reading of the information. Here is the list of theses classes:; TFormLeafInfo; TFormLeafInfoDirect; TFormLeafInfoNumerical; TFormLeafInfoClones; TFormLeafInfoCollection; TFormLeafInfoPointer; TFormLeafInfoMethod; TFormLeafInfoMultiVarDim; TFormLeafInfoMultiVarDimDirect; TFormLeafInfoCast. The following method are available from the TFormLeafInfo interface:. AddOffset(Int_t offset, TStreamerElement* element); GetCounterValue(TLeaf* leaf) : return the size of the array pointed to.; GetObjectAddress(TLeafElement* leaf) : Returns the the location of the object pointed to.; GetMultiplicity() : Returns info on the variability of the number of elements; GetNdata(TLeaf* leaf) : Returns the number of elements; GetNdata() : Used by GetNdata(TLeaf* leaf); GetValue(TLeaf *leaf, Int_t instance = 0) : Return the value; GetValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value; GetLocalValuePointer(TLeaf *leaf, Int_t instance = 0) : Returns the address of the value of 'this' LeafInfo; IsString(); ReadValue(char *where, Int_t instance = 0) : Internal function to interpret the location 'where'; Update() : react to the possible loading of a shared library. Function Members (Methods); public:. virtual~TTreeFormula(); voidTObject::AbstractMethod(const char* method) const; virtual voidROOT::v5::TFormula::Analyze(const char* schain, Int_t& err, Int_t offset = 0); virtual Bool_tROOT::v5::TFormula::AnalyzeFunction(TString& chaine, Int_t& err, Int_t offset = 0); virtual voidTObject::AppendPad(Option_t* option = """"); virtual voidTObject::Browse(TBrowser* b); static TClass*Class(); virtual const char*TObject::ClassName() const; virtual voidROOT::v5::TFormula::Clear(Option_t* option = """"); virtual TObject*TNamed::Clone(const char* newname = """") const; virtual Int_tTNamed::Compare(const TObject* obj) const; virtual Int_tROOT::v5::TFormula::Compile(c",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TTreeFormula.html:1570,load,loading,1570,root/html604/TTreeFormula.html,https://root.cern,https://root.cern/root/html604/TTreeFormula.html,2,['load'],['loading']
Performance,ss code and instance factory; RooCmdArg Generic named argument container; RooCmdConfig Configurable parse of RooCmdArg objects; RooComplex a non-persistent bare-bones complex class; RooCompositeDataStore Composite Data Storage class; RooConstVar Constant RooAbsReal value object; RooConstraintSum sum of -log of set of RooAbsPdf representing parameter constraints; RooConvCoefVar Auxiliary class representing the coefficient of a RooAbsAnaConvPdf as a RooAbsReal; RooConvGenContext Context for generating a dataset from a PDF; RooConvIntegrandBinding RooAbsFunc representation of convolution integrands; RooCurve 1-dimensional smooth curve for use in RooPlots; RooCustomizer Editing tool for RooAbsArg composite object expressions; RooDLLSignificanceMCSModule MCStudy module to calculate Delta(-logL) significance w.r.t given null hypothesis; RooDataHist Binned data set; RooDataHistSliceIter Iterator over a one-dimensional slice of a RooDataHist; RooDataProjBinding RealFunc/Dataset binding for data projection of a real function; RooDataSet Unbinned data set; RooDataWeightedAverage Optimized calculator of data weighted average of a RooAbsReal; RooDecay General decay function p.d.f; RooDerivative Representation of derivative of any RooAbsReal; RooDirItem Base class for RooFit objects that are listed TDirectories; RooDouble Container class for Double_t; RooDstD0BG D*-D0 mass difference background PDF; RooEffGenContext Context for generating a dataset from a PDF; RooEffProd Product operator p.d.f of (PDF x efficiency) implementing optimized generator context; RooEfficiency Generic PDF defined by string expression and list of variables; RooEllipse 2-dimensional contour; RooErrorVar RooAbsRealLValue representation of an error of a RooRealVar; RooExpensiveObjectCache Singleton class that serves as session repository for expensive objects; RooExpensiveObjectCache::ExpensiveObject Cache element containing expensive object and parameter values for which object is valid; RooExponential Exp,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ClassIndex.html:31717,Optimiz,Optimized,31717,root/html602/ClassIndex.html,https://root.cern,https://root.cern/root/html602/ClassIndex.html,2,['Optimiz'],['Optimized']
Performance,"ss declaration ; Definition at line 112 of file RooMultiVarGaussian.h. ◆ decodeCode(). void RooMultiVarGaussian::decodeCode ; (; Int_t ; code, . std::vector< int > & ; map1, . std::vector< int > & ; map2 . ); const. protected . Decode analytical integration/generation code into index map of integrated/generated (map2) and non-integrated/generated observables (map1) ; Definition at line 600 of file RooMultiVarGaussian.cxx. ◆ evaluate(). double RooMultiVarGaussian::evaluate ; (; ); const. overrideprotectedvirtual . Do not persist. ; Represent observables as vector. ; Implements RooAbsReal.; Definition at line 175 of file RooMultiVarGaussian.cxx. ◆ genData(). RooMultiVarGaussian::GenData & RooMultiVarGaussian::genData ; (; Int_t ; code); const. protected . WVE – CHECK THAT GENDATA IS VALID GIVEN CURRENT VALUES OF _MU. ; Definition at line 501 of file RooMultiVarGaussian.cxx. ◆ generateEvent(). void RooMultiVarGaussian::generateEvent ; (; Int_t ; code). overridevirtual . Retrieve generator config from cache. ; Reimplemented from RooAbsPdf.; Definition at line 434 of file RooMultiVarGaussian.cxx. ◆ getAnalyticalIntegral(). Int_t RooMultiVarGaussian::getAnalyticalIntegral ; (; RooArgSet & ; allVars, . RooArgSet & ; analVars, . const char * ; rangeName = nullptr . ); const. overridevirtual . Interface function getAnalyticalIntergral advertises the analytical integrals that are supported. ; 'integSet' is the set of dependents for which integration is requested. The function should copy the subset of dependents it can analytically integrate to anaIntSet and return a unique identification code for this integration configuration. If no integration can be performed, zero should be returned. ; Reimplemented from RooAbsReal.; Definition at line 194 of file RooMultiVarGaussian.cxx. ◆ getGenerator(). Int_t RooMultiVarGaussian::getGenerator ; (; const RooArgSet & ; directVars, . RooArgSet & ; generateVars, . bool ; staticInitOK = true . ); const. overridevirtual . Special case: gene",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMultiVarGaussian.html:78973,cache,cache,78973,doc/master/classRooMultiVarGaussian.html,https://root.cern,https://root.cern/doc/master/classRooMultiVarGaussian.html,1,['cache'],['cache']
Performance,"ss description. RooAddPdf(const char* name, const char* title, const RooArgList& pdfList); Generic constructor from list of extended PDFs. There are no coefficients as the expected; number of events from each components determine the relative weight of the PDFs. All PDFs must inherit from RooAbsPdf. RooAddPdf(const RooAddPdf& other, const char* name); Copy constructor. ~RooAddPdf(); Destructor. void fixCoefNormalization(const RooArgSet& refCoefNorm); By default the interpretation of the fraction coefficients is; performed in the contextual choice of observables. This makes the; shape of the p.d.f explicitly dependent on the choice of; observables. This method instructs RooAddPdf to freeze the; interpretation of the coefficients to be done in the given set of; observables. If frozen, fractions are automatically transformed; from the reference normalization set to the contextual normalization; set by ratios of integrals. void fixCoefRange(const char* rangeName); By default the interpretation of the fraction coefficients is; performed in the default range. This make the shape of a RooAddPdf; explicitly dependent on the range of the observables. To allow; a range independent definition of the fraction this function; instructs RooAddPdf to freeze its interpretation in the given; named range. If the current normalization range is different; from the reference range, the appropriate fraction coefficients; are automically calculation from the reference fractions using; ratios if integrals. void updateCoefficients(RooAddPdf::CacheElem& cache, const RooArgSet* nset) const; Update the coefficient values in the given cache element: calculate new remainder; fraction, normalize fractions obtained from extended ML terms to unity and; multiply these the various range and dimensional corrections needed in the; current use context. Double_t evaluate() const; Calculate and return the current value. void resetErrorCounters(Int_t resetValue = 10); Reset error counter to given value, limi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAddPdf.html:43700,perform,performed,43700,root/html526/RooAddPdf.html,https://root.cern,https://root.cern/root/html526/RooAddPdf.html,1,['perform'],['performed']
Performance,"ss of the value at index 'idx'.Definition TGenCollectionProxy.cxx:243; TGenSetProxy::~TGenSetProxy~TGenSetProxy() overrideDefinition TGenCollectionProxy.cxx:239; TGenSetProxy::TGenSetProxyTGenSetProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:235; TGenVectorBoolProxyLocal optimization class.Definition TGenCollectionProxy.cxx:88; TGenVectorBoolProxy::fLastValueBool_t fLastValueDefinition TGenCollectionProxy.cxx:89; TGenVectorBoolProxy::Atvoid * At(UInt_t idx) overrideReturn the address of the value at index 'idx'.Definition TGenCollectionProxy.cxx:100; TGenVectorBoolProxy::TGenVectorBoolProxyTGenVectorBoolProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:92; TGenVectorBoolProxy::~TGenVectorBoolProxy~TGenVectorBoolProxy() overrideDefinition TGenCollectionProxy.cxx:96; TGenVectorBoolProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const overrideCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:115; TGenVectorProxyLocal optimization class.Definition TGenCollectionProxy.cxx:39; TGenVectorProxy::DeleteItemvoid DeleteItem(Bool_t force, void *ptr) const overrideCall to delete/destruct individual item.Definition TGenCollectionProxy.cxx:66; TGenVectorProxy::Atvoid * At(UInt_t idx) overrideReturn the address of the value at index 'idx'.Definition TGenCollectionProxy.cxx:50; TGenVectorProxy::~TGenVectorProxy~TGenVectorProxy() overrideDefinition TGenCollectionProxy.cxx:46; TGenVectorProxy::TGenVectorProxyTGenVectorProxy(const TGenCollectionProxy &c)Definition TGenCollectionProxy.cxx:42; THashTableTHashTable implements a hash table to store TObject's.Definition THashTable.h:35; TInterpreter::SuspendAutoParsingDefinition TInterpreter.h:111; TInterpreter::TypeInfo_Initvirtual void TypeInfo_Init(TypeInfo_t *, const char *) constDefinition TInterpreter.h:528; TInterpreter::TypeInfo_Deletevirtual void TypeInfo_Delete(TypeInfo_t *) constDefinition TInterpreter.h:524; TInterpreter::TypeInfo_Factoryvirtual TypeInf",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:88529,optimiz,optimization,88529,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['optimiz'],['optimization']
Performance,"ss or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3686 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3798 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3827 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populated with all the defined function and currently instantiated function template. ; Definition at line 3812 of file TClass.cxx. ◆ GetListOfRealData(). TList * TClass::GetListOfRealData ; (; ); const. inline . Definition at line 453 of file TClass.h. ◆ GetListOfUsingDataMembers(). TList * TClass::GetListOfUsingDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of using declarations of a class. ; Definition at line 3786 of file TClass.cxx. ◆ GetMenuItems(). void TClass::GetMenuItems ; (; TList * ; listitems). Returns list of methods accessible by context menu. ; Definition at line 3874 of file TClass.cxx. ◆ GetMenuList(). TList * TClass::GetMenuList ; (; ); const. Return the list of menu items associated with the class. ; Definition at line 4341 of file TClass.cxx. ◆ GetMerge(). ROOT::MergeFunc_t TClass::GetMerge ; (; ); const. Return the wrapper around Merge. ; Definition at line 7431 of file TClass.cxx. ◆ GetMethod(). TMethod * TClass::GetMethod ; (; const char * ; method, . con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:83660,load,load,83660,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,1,['load'],['load']
Performance,"ss or struct and requestListLoading is true, the list is immutable (and thus safe to access from multiple thread without taking the global lock at all).; In the case the TClass represents a class or struct and requestListLoading is false, the list is mutable and thus we return a TListOfEnumsWithLock which will implicit take the ROOT global lock upon any access. ; Definition at line 3753 of file TClass.cxx. ◆ GetListOfFunctionTemplates(). TList * TClass::GetListOfFunctionTemplates ; (; Bool_t ; load = kTRUE). Return TListOfFunctionTemplates for a class. ; Definition at line 3865 of file TClass.cxx. ◆ GetListOfMethodOverloads(). TCollection * TClass::GetListOfMethodOverloads ; (; const char * ; name); const. Return the collection of functions named ""name"". ; Definition at line 3894 of file TClass.cxx. ◆ GetListOfMethods(). TList * TClass::GetListOfMethods ; (; Bool_t ; load = kTRUE). Return list containing the TMethods of a class. ; If load is true, the list is populated with all the defined function and currently instantiated function template. ; Definition at line 3879 of file TClass.cxx. ◆ GetListOfRealData(). TList * TClass::GetListOfRealData ; (; ); const. inline . Definition at line 453 of file TClass.h. ◆ GetListOfUsingDataMembers(). TList * TClass::GetListOfUsingDataMembers ; (; Bool_t ; load = kTRUE). Return list containing the TDataMembers of using declarations of a class. ; Definition at line 3853 of file TClass.cxx. ◆ GetMenuItems(). void TClass::GetMenuItems ; (; TList * ; listitems). Returns list of methods accessible by context menu. ; Definition at line 3941 of file TClass.cxx. ◆ GetMenuList(). TList * TClass::GetMenuList ; (; ); const. Return the list of menu items associated with the class. ; Definition at line 4408 of file TClass.cxx. ◆ GetMerge(). ROOT::MergeFunc_t TClass::GetMerge ; (; ); const. Return the wrapper around Merge. ; Definition at line 7498 of file TClass.cxx. ◆ GetMethod(). TMethod * TClass::GetMethod ; (; const char * ; method, . con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTClass.html:83661,load,load,83661,doc/master/classTClass.html,https://root.cern,https://root.cern/doc/master/classTClass.html,1,['load'],['load']
Performance,"ss to Python objects from Cling is not completely fleshed out. Currently, ROOT objects and built-in types can cross the boundary between the two interpreters, but other objects are much more restricted. For example, for a Python object to cross, it has to be a class instance, and its class has to be known to Cling first (i.e. the class has to cross first, before the instance can). All other cross-coding is based on strings that are run on the Python interpreter and vise-versa.; With the ROOT v4.00/06 and later, the TPython class will be loaded automatically on use, for older editions, the libPyROOT.so needs to be loaded first before use. It is possible to switch between interpreters by calling TPython::Prompt() on the ROOT side, while returning with ^D (EOF). State is preserved between successive switches, and string based cross calls can nest as long as shared resources are properly handled.; // Example: accessing the Python interpreter from ROOT; // either load PyROOT explicitly or rely on auto-loading; root[] gSystem->Load( ""libPyROOT"" );; root[] TPython::Exec(""print1+1"");; 2. // create a TBrowser on the Python side, and transfer it back and forth; root[] TBrowser* b = (void*)TPython::Eval(""ROOT.TBrowser()"");; (class TObject*)0x8d1daa0; root[] TPython::Bind(b,""b"");. // builtin variables can cross-over (after the call i==2); root[] int i = TPython::Eval( ""1+1"" );; root[] i; (int)2; 19.1.4 Installation; There are several ways of obtaining PyROOT, and which is best depends on your specific situation. If you work at CERN, you can use the installation available on afs. Otherwise, you will want to build from source, as PyROOT is not build by default in the binaries distributed from the ROOT project site. If you download the ROOT binaries, take care to download and install the Python distribution from http://www.python.org/ against which they were built.; 19.1.4.1 Environment Settings; ROOT installations with the build of PyROOT enabled are available from the CERN afs ce",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:1045991,load,load,1045991,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,5,"['Load', 'load']","['Load', 'load', 'loading']"
Performance,"ss&operator=(const TBaseClass&). Data Members; public:. enum TDictionary::ESTLType { kNone; kVector; kList; kDeque; kMap; kMultimap; kSet; kMultiset; kBitset; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. private:. TClass*fClasspointer to parent class; TClassReffClassPtrpointer to the base class TClass; BaseClassInfo_t*fInfopointer to CINT base class info; Long_tfOffset!Cache offset of the baseClassInfo.; Long_tfProperty!Cache property of the baseClassInfo. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TBaseClass(BaseClassInfo_t* info = 0, TClass* cl = 0); Default TBaseClass ctor. TBaseClasses are constructed in TClass; via a call to TCint::CreateListOfBaseClasses(). ~TBaseClass(); TBaseClass dtor deletes adopted CINT BaseClassInfo object. void Browse(TBrowser* b); Called by the browser, to browse a baseclass. TClass * GetClassPointer(Bool_t load = kTRUE); Get pointer to the base class TClass. Int_t GetDelta() const; Get offset from ""this"" to part of base class. const char * GetTitle() const; Get base class description (comment). int IsSTLContainer(); Return which type (if any) of STL container the data member is. Long_t Property() const; Get property description word. For meaning of bits see EProperty. TBaseClass(const TBaseClass& ). TBaseClass& operator=(const TBaseClass& ). Bool_t IsFolder() const; {return kTRUE;}. » Author: Fons Rademakers 08/02/95 » Copyright (C) 1995-2000, Rene Brun and Fons Rademakers. *; » Last changed: root/meta:$Id$ » Last generated: 2015-03-12 16:37; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TBaseClass.html:6861,load,load,6861,root/html534/TBaseClass.html,https://root.cern,https://root.cern/root/html534/TBaseClass.html,2,['load'],['load']
Performance,"ss()->IsSyntheticPair()) {; 3706 printf(""ReadStreamerInfo, class:%s, illegal uid=%d\n"",info->GetName(),uid);; 3707 }; 3708 if (gDebug > 0) printf("" -class: %s version: %d info read at slot %d\n"",info->GetName(), info->GetClassVersion(),uid);; 3709 }; 3710 lnk = lnk->Next();; 3711 }; 3712 }; 3713 fClassIndex->fArray[0] = 0;; 3714 list->Clear(); //this will delete all TStreamerInfo objects with kCanDelete bit set; 3715 delete list;; 3716 ; 3717 // We are done processing the record, let future calls and other threads that it; 3718 // has been done.; 3719 fgTsSIHashes.Insert(listRetcode.fHash, std::move(si_uids));; 3720}; 3721 ; 3722////////////////////////////////////////////////////////////////////////////////; 3723/// Specify if the streamerinfos must be read at file opening.; 3724///; 3725/// If fgReadInfo is true (default) TFile::ReadStreamerInfo is called; 3726/// when opening the file.; 3727/// It may be interesting to set fgReadInfo to false to speedup the file; 3728/// opening time or in case libraries containing classes referenced; 3729/// by the file have not yet been loaded.; 3730/// if fgReadInfo is false, one can still read the StreamerInfo with; 3731/// myfile.ReadStreamerInfo();; 3732 ; 3733void TFile::SetReadStreamerInfo(Bool_t readinfo); 3734{; 3735 fgReadInfo = readinfo;; 3736}; 3737 ; 3738////////////////////////////////////////////////////////////////////////////////; 3739/// If the streamerinfos are to be read at file opening.; 3740///; 3741/// See TFile::SetReadStreamerInfo for more documentation.; 3742 ; 3743Bool_t TFile::GetReadStreamerInfo(); 3744{; 3745 return fgReadInfo;; 3746}; 3747 ; 3748////////////////////////////////////////////////////////////////////////////////; 3749/// Show the StreamerInfo of all classes written to this file.; 3750 ; 3751void TFile::ShowStreamerInfo(); 3752{; 3753 TList *list = GetStreamerInfoList();; 3754 if (!list) return;; 3755 ; 3756 list->ls();; 3757 delete list;; 3758}; 3759 ; 3760/////////////////////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:135776,load,loaded,135776,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['load'],['loaded']
Performance,"ss(). static TClass * TDirectory::Class ; (; ). static . ReturnsTClass describing this class . ◆ Class_Name(). static const char * TDirectory::Class_Name ; (; ). static . ReturnsName of this class . ◆ Class_Version(). static constexpr Version_t TDirectory::Class_Version ; (; ). inlinestaticconstexpr . ReturnsVersion of this class ; Definition at line 308 of file TDirectory.h. ◆ CleanTargets(). void TDirectory::CleanTargets ; (; ). protected . Clean the pointers to this object (gDirectory, TContext, etc.). ; Definition at line 264 of file TDirectory.cxx. ◆ Clear(). void TDirectory::Clear ; (; Option_t * ; option = """"). overridevirtual . Delete all objects from a Directory list. ; Reimplemented from TObject.; Definition at line 634 of file TDirectory.cxx. ◆ CloneObject(). TObject * TDirectory::CloneObject ; (; const TObject * ; obj, . Bool_t ; autoadd = kTRUE . ). virtual . Clone an object. ; This function is called when the directory is not a TDirectoryFile. This version has to load the I/O package, hence via Cling.; If autoadd is true and if the object class has a DirectoryAutoAdd function, it will be called at the end of the function with the parameter gDirector. This usually means that the object will be appended to the current ROOT directory. ; Reimplemented in TDirectoryFile.; Definition at line 364 of file TDirectory.cxx. ◆ Close(). void TDirectory::Close ; (; Option_t * ; option = """"). virtual . Delete all objects from memory and directory structure itself. ; if option is ""slow"", iterate through the containers in a way to can handle 'external' modification (induced by recursions) if option is ""nodelete"", write the TDirectory but do not delete the contained objects. ; Reimplemented in TSQLFile, TXMLFile, TDirectoryFile, TFile, TNetFile, TParallelMergingFile, and TWebFile.; Definition at line 645 of file TDirectory.cxx. ◆ Copy(). void TDirectory::Copy ; (; TObject & ; object); const. inlineoverridevirtual . Copy this to obj. ; Reimplemented from TObject.; Reimple",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTDirectory.html:27944,load,load,27944,doc/v632/classTDirectory.html,https://root.cern,https://root.cern/doc/v632/classTDirectory.html,2,['load'],['load']
Performance,"ss(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidTGLLogicalShape::DirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tTGLLogicalShape::DLOffset(Short_t) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static TClass*GetGLRenderer(TClass* isa); static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tKeepDuringSmartRefresh() const; virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tTGLLogicalShape::QuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; virtual voidSetBBox(); Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tSetModel(TObject* obj, Option_t* opt = 0); virtual Bool_tShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesTGLLogicalShape::SupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidUpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TGLObject.html:2390,cache,cached,2390,root/html534/TGLObject.html,https://root.cern,https://root.cern/root/html534/TGLObject.html,2,['cache'],['cached']
Performance,"ss();; 627}; 628 ; 629template <typename T>; 630struct TClassGetClassHelper {; 631 static TClass *GetClass(Bool_t load, Bool_t silent) {; 632 return TClass::GetClass(typeid(T), load, silent);; 633 }; 634};; 635 ; 636template <typename F, typename S>; 637struct TClassGetClassHelper<std::pair<F, S> > {; 638 static TClass *GetClass(Bool_t load, Bool_t silent) {; 639 using pair_t = std::pair<F,S>;; 640 size_t hint_offset = offsetof(pair_t, second);; 641 return TClass::GetClass(typeid(std::pair<F, S>), load, silent, hint_offset, sizeof(std::pair<F,S>));; 642 }; 643};; 644 ; 645template <typename T>; 646TClass *GetClassHelper(Bool_t load, Bool_t silent, std::false_type); 647{; 648 return TClassGetClassHelper<T>::GetClass(load, silent);; 649}; 650 ; 651} // namespace Internal; 652} // namespace ROOT; 653 ; 654template <typename T>; 655TClass *TClass::GetClass(Bool_t load, Bool_t silent); 656{; 657 typename std::is_base_of<TObject, T>::type tag;; 658 return ROOT::Internal::GetClassHelper<T>(load, silent, tag);; 659}; 660 ; 661namespace ROOT {; 662 ; 663template <typename T> TClass *GetClass(T * /* dummy */) { return TClass::GetClass<T>(); }; 664template <typename T> TClass *GetClass(const T * /* dummy */) { return TClass::GetClass<T>(); }; 665 ; 666#ifndef R__NO_CLASS_TEMPLATE_SPECIALIZATION; 667 // This can only be used when the template overload resolution can distinguish between T* and T**; 668 template <typename T> TClass* GetClass( T** /* dummy */) { return TClass::GetClass<T>(); }; 669 template <typename T> TClass* GetClass(const T** /* dummy */) { return TClass::GetClass<T>(); }; 670 template <typename T> TClass* GetClass( T* const* /* dummy */) { return TClass::GetClass<T>(); }; 671 template <typename T> TClass* GetClass(const T* const* /* dummy */) { return TClass::GetClass<T>(); }; 672#endif; 673 ; 674 extern TClass *CreateClass(const char *cname, Version_t id,; 675 const char *dfil, const char *ifil,; 676 Int_t dl, Int_t il);; 677}; 678 ; 679#endif // ROOT_TClass;",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8h_source.html:33250,load,load,33250,doc/master/TClass_8h_source.html,https://root.cern,https://root.cern/doc/master/TClass_8h_source.html,2,['load'],['load']
Performance,"ss(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidTProofServ::DeletePlayer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tTProofServ::Fork(); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; Int_tTProofServ::GetSessionStatus(); virtual voidTProofServ::HandleArchive(TMessage* mess, TString* slb = 0); virtual Int_tTProofServ::HandleCache(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleCheckFile(TMessage* mess, TString* slb = 0); virtual Int_tTProofServ::HandleDataSets(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleLibIncPath(TMessage* mess); virtual voidTProofServ::HandleProcess(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleQueryList(TMessage* mess); virtual voidTProofServ::HandleRemove(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleRetrieve(TMessage* mess, TString* slb = 0); virtual voidTProofServ::HandleSubmerger(TMessage* mess); virtual Int_tTProofServ::HandleWorkerLists(TMessage* mess); virtual voidTApplication::Help(const char* line); Bool_tTProofServ::IsIdle(); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); virtual voidTProofServ::MakePlayer(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual voidTProofServ::ProcessNext(TString* slb = 0); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh); Int_tTProofServ::SetupCommon(); Bool_tTProofServ::UnlinkDataDir(const char* path).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TProofServLite.html:15048,Load,LoadGraphicsLibs,15048,root/html532/TProofServLite.html,https://root.cern,https://root.cern/root/html532/TProofServLite.html,2,['Load'],['LoadGraphicsLibs']
Performance,"ss) for one-dimensional functions providing a gradient calculation ;  CIGradientMultiDimTemplGradient interface (abstract class) defining the signature for calculating the gradient of a multi-dimensional function ;  CIGradientOneDimSpecialized Gradient interface(abstract class) for one dimensional functions It provides a method to evaluate the derivative of the function, Derivative and a method to evaluate at the same time the function and the derivative FdF ;  CIMinimizer1DInterface class for numerical methods for one-dimensional minimization ;  CIntegrandTransformAuxiliary inner class for mapping infinite and semi-infinite integrals ;  CIntegratorMultiDimUser class for performing multidimensional integration ;  CIntegratorMultiDimOptionsNumerical multi dimensional integration options ;  CIntegratorOneDimUser Class for performing numerical integration of a function in one dimension ;  CIntegratorOneDimOptionsNumerical one dimensional integration options ;  CInterpolatorClass for performing function interpolation of points ;  CInverterMatrix Inverter class Class to specialize calls to Dinv ;  CInverter< 0 >Inverter<0> ;  CInverter< 1 >1x1 matrix inversion \(a_{11} \to 1/a_{11}\) ;  CInverter< 2 >2x2 matrix inversion using Cramers rule ;  CIOptionsGeneric interface for defining configuration options of a numerical algorithm ;  CIParametricFunctionMultiDimTemplIParamFunction interface (abstract class) describing multi-dimensional parameteric functions It is a derived class from ROOT::Math::IBaseFunctionMultiDim and ROOT::Math::IBaseParam ;  CIParametricFunctionOneDimSpecialized IParamFunction interface (abstract class) for one-dimensional parametric functions It is a derived class from ROOT::Math::IBaseFunctionOneDim and ROOT::Math::IBaseParam ;  CIParametricGradFunctionMultiDimTemplInterface (abstract class) for parametric gradient multi-dimensional functions providing in addition to function evaluation with respect to the coordinates also the gradient with respect to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v612/annotated.html:44958,perform,performing,44958,doc/v612/annotated.html,https://root.cern,https://root.cern/doc/v612/annotated.html,4,['perform'],['performing']
Performance,"ss* cl); Check whether cl is a namespace. void LoadAllLibs(); Load all libraries known to ROOT via the rootmap system. void MakeAll(Bool_t force = kFALSE, const char* filter = ""*"", int numthreads = 1); Produce documentation for all the classes specified in the filter (by default ""*""); To process all classes having a name starting with XX, do:; html.MakeAll(kFALSE,""XX*"");; If force=kFALSE (default), only the classes that have been modified since; the previous call to this function will be generated.; If force=kTRUE, all classes passing the filter will be processed.; If numthreads is != -1, use numthreads threads, else decide automatically; based on the number of CPUs. void MakeClass(const char* className, Bool_t force = kFALSE); Make HTML files for a single class. Input: className - name of the class to process. void MakeClass(void* cdi, Bool_t force = kFALSE); Make HTML files for a single class. Input: cdi - doc info for class to process. void* MakeClassThreaded(void* info); Entry point of worker threads for multi-threaded MakeAll().; info points to an (internal) THtmlThreadInfo object containing the current; THtml object, and whether ""force"" was passed to MakeAll().; The thread will poll GetNextClass() until no further class is available. void MakeIndex(const char* filter = ""*""); Create the index files for the product, modules, all types, etc.; By default all classes are indexed (if filter=""*"");; to generate an index for all classes starting with ""XX"", do; html.MakeIndex(""XX*"");. void MakeTree(const char* className, Bool_t force = kFALSE); Make an inheritance tree. Input: className - name of the class to process. void SetFoundDot(Bool_t found = kTRUE); Set whether ""dot"" (a GraphViz utility) is available. void SetLocalFiles() const; Fill the files available in the file system below fPathInfo.fInputPath. void SetModuleDefinition(const THtml::TModuleDefinition& md); Set the module defining object to be used; can also be a user derived; object (a la traits). void SetFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/THtml.html:32816,multi-thread,multi-threaded,32816,root/html534/THtml.html,https://root.cern,https://root.cern/root/html534/THtml.html,6,['multi-thread'],['multi-threaded']
Performance,"ss* cl); Check whether cl is a namespace. void LoadAllLibs(); Load all libraries known to ROOT via the rootmap system. void MakeAll(Bool_t force = kFALSE, const char* filter = ""*"", int numthreads = 1); Produce documentation for all the classes specified in the filter (by default ""*""); To process all classes having a name starting with XX, do:; html.MakeAll(kFALSE,""XX*"");; If force=kFALSE (default), only the classes that have been modified since; the previous call to this function will be generated.; If force=kTRUE, all classes passing the filter will be processed.; If numthreads is != -1, use numthreads threads, else decide automatically; based on the number of CPUs. void MakeClass(const char* className, Bool_t force = kFALSE); Make HTML files for a single class. Input: className - name of the class to process. void MakeClass(void* cdi, Bool_t force = kFALSE); Make HTML files for a single class. Input: cdi - doc info for class to process. void* MakeClassThreaded(void* info); Entry point of worker threads for multi-threaded MakeAll().; info points to an (internal) THtmlThreadInfo object containing the current; THtml object, and whether ""force"" was passed to MakeAll().; The thread will poll GetNextClass() until no further class is available. void MakeIndex(const char* filter = ""*""); Create the index files for the product, modules, all types, etc.; By default all classes are indexed (if filter=""*"");; to generate an index for all classes starting with ""XX"", do; html.MakeIndex(""XX*"");. void MakeTree(const char* className, Bool_t force = kFALSE); Make an inheritance tree. Input: className - name of the class to process. void SetFoundDot(Bool_t found = kTRUE); Set whether ""dot"" (a GraphViz utility) is avaliable. void SetLocalFiles() const; Fill the files available in the file system below fPathInfo.fInputPath. void SetModuleDefinition(const THtml::TModuleDefinition& md); Set the module defining object to be used; can also be a user derived; object (a la traits). void SetFil",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/THtml.html:32915,multi-thread,multi-threaded,32915,root/html528/THtml.html,https://root.cern,https://root.cern/root/html528/THtml.html,4,['multi-thread'],['multi-threaded']
Performance,"ss*Class(); voidTGLLogicalShape::DestroyPhysicals(); virtual voidDirectDraw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DLCacheClear(); virtual voidTGLLogicalShape::DLCacheDrop(); virtual voidTGLLogicalShape::DLCachePurge(); virtual UInt_tDLOffset(Short_t lod) const; virtual voidTGLLogicalShape::Draw(TGLRnrCtx& rnrCtx) const; virtual voidTGLLogicalShape::DrawHighlight(TGLRnrCtx& rnrCtx, const TGLPhysicalShape* pshp, Int_t lvl = -1) const; TObject*TGLLogicalShape::GetExternal() const; const TGLPhysicalShape*TGLLogicalShape::GetFirstPhysical() const; static Bool_tTGLLogicalShape::GetIgnoreSizeForCameraInterest(); TGLScene*TGLLogicalShape::GetScene() const; TObject*TGLLogicalShape::ID() const; virtual Bool_tTGLLogicalShape::IgnoreSizeForOfInterest() const; voidTGLLogicalShape::InvokeContextMenu(TContextMenu& menu, UInt_t x, UInt_t y) const; virtual TClass*IsA() const; virtual Bool_tTGLLogicalShape::KeepDuringSmartRefresh() const; TGLCylinder&operator=(const TGLCylinder&); virtual voidTGLLogicalShape::ProcessSelection(TGLRnrCtx& rnrCtx, TGLSelectRecord& rec); virtual Short_tQuantizeShapeLOD(Short_t shapeLOD, Short_t combiLOD) const; UInt_tTGLLogicalShape::Ref() const; Bool_tTGLLogicalShape::SetDLCache(Bool_t cached); static voidTGLLogicalShape::SetIgnoreSizeForCameraInterest(Bool_t isfci); virtual Bool_tTGLLogicalShape::ShouldDLCache(const TGLRnrCtx& rnrCtx) const; virtual voidShowMembers(TMemberInspector& insp) const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); voidTGLLogicalShape::StrongRef(Bool_t strong) const; voidTGLLogicalShape::SubRef(TGLPhysicalShape* phys) const; virtual TGLLogicalShape::ELODAxesSupportedLODAxes() const; virtual Bool_tTGLLogicalShape::SupportsSecondarySelect() const; TGLCylinder(const TBuffer3DTube& buffer); TGLCylinder(const TGLCylinder&); UInt_tTGLLogicalShape::UnrefFirstPhysical(); virtual voidTGLLogicalShape::UpdateBoundingBox(); voidTGLLogicalShape::UpdateBoundingBoxesOfPhysicals().",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TGLCylinder.html:1878,cache,cached,1878,root/html602/TGLCylinder.html,https://root.cern,https://root.cern/root/html602/TGLCylinder.html,4,['cache'],['cached']
Performance,"ss*IsA() const; RooAbsCacheElement&operator=(const RooAbsCacheElement&); virtual voidoperModeHook(RooAbsArg::OperMode); virtual voidoptimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); virtual voidprintCompactTreeHook(ostream&, const char*, Int_t curElem, Int_t totElem); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidsetOwner(RooAbsArg* owner); virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). Data Members; public:. enum Action { OperModeChange; OptimizeCaching; FindConstantNodes; };. protected:. RooAbsArg*_owner! Pointer to owning RooAbsArg. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; Bool_t redirectServersHook(const RooAbsCollection& , Bool_t , Bool_t , Bool_t ); Interface for server redirect calls. void printCompactTreeHook(ostream& , const char* , Int_t curElem, Int_t totElem); Hook function to print cache guts in tree printing mode of RooAbsArgs. void operModeHook(RooAbsArg::OperMode ); Interface for operation mode change calls. void optimizeCacheMode(const RooArgSet& obs, RooArgSet& optNodes, RooLinkedList& processedNodes); Interface for cache optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). void findConstantNodes(const RooArgSet& obs, RooArgSet& cacheList, RooLinkedList& processedNodes); Interface for constant term optimization calls. The default implementation is to forward all these; calls to all contained RooAbsArg objects as publicized through containedArg(). virtual ~RooAbsCacheElement(); Destructor. RooArgList containedArgs(RooAbsCacheElement::Action ). void setOwner(RooAbsArg* owner); Store pointer to owner. » Last changed: Tue Mar 10 17:13:51 2015 » Last generated: 2015-03-10 17:13; This page has been automatically generated. For comments or ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCacheElement.html:2008,cache,cache,2008,root/html534/RooAbsCacheElement.html,https://root.cern,https://root.cern/root/html534/RooAbsCacheElement.html,2,['cache'],['cache']
Performance,"ss. TClass * Load(TBuffer& b); Load class description from I/O buffer and return class object. TClass * LoadClass(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; either from the TClassTable or from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassDefault(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname' from; the TClassTable or the autoloader.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. TClass * LoadClassCustom(const char* requestedname, Bool_t silent); Helper function used by TClass::GetClass().; This function attempts to load the dictionary for 'classname'; from the list of generator.; If silent is 'true', do not warn about missing dictionary for the class.; (typically used for class that are used only for transient members). The 'requestedname' is expected to be already normalized. void LoadClassInfo() const; Try to load the classInfo (it may require parsing the header file; and/or loading data from the clang pcm). void Store(TBuffer& b) const; Store class description on I/O buffer. Bool_t IsLoaded() const; Return true if the shared library of this class is currently in the a; process's memory. Return false, after the shared library has been; unloaded or if this is an 'emulated' class created from a file's StreamerInfo. Bool_t IsStartingWithTObject() const; Returns true if this class inherits from TObject and if the start of; the TObject parts is at the very beginning of the objects.; Concretly this means that the foll",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TClass.html:52581,Load,LoadClassCustom,52581,root/html602/TClass.html,https://root.cern,https://root.cern/root/html602/TClass.html,2,['Load'],['LoadClassCustom']
Performance,"ss. The first data member is fChain. Once this class is instantiated, fChain will point to the original tree or chain this class was made from. In our case, this is “T” in “Event.root”. If the class is instantiated with a tree as a parameter to the constructor, fChain will point to the tree named in the parameter. Next is fCurrent, which is also a pointer to the current tree/chain. Its role is only relevant when we have multiple trees chained together in a TChain. The class definition shows us that this tree has one branch and one leaf per data member. The methods of MyClass are:. MyClass(TTree *tree=0) - this constructor has an optional tree for a parameter. If you pass a tree, MyClass will use it rather than the tree from which it was created.; void Init(TTree *tree) - it is called by the constructor to initialize the tree for reading. It associates each branch with the corresponding leaf data member.; ~MyClass() -the destructor, nothing special.; Int_t GetEntry(Int_t entry) - it loads the class with the entry specified. Once you have executed GetEntry, the leaf data members in MyClass are set to the values of the entry. For example, GetEntry(12) loads the 13th event into the event data member of MyClass (note that the first entry is 0). GetEntry returns the number of bytes read from the file. In case the same entry is read twice, ROOT does not have to do any I/O. In this case GetEntry returns 1. It does not return 0, because many people assume a return of 0 means an error has occurred while reading.; Int_t LoadTree(Int_t entry) and void Notify() - these two methods are related to chains. LoadTree will load the tree containing the specified entry from a chain of trees. Notify is called by LoadTree to adjust the branch addresses.; void Loop() - it is the skeleton method that loops through each entry of the tree. This is interesting to us, because we will need to customize it for our analysis. 12.21.3 MyClass.C; MyClass::Loop consists of a for-loop calling GetEntry ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html:639500,load,loads,639500,root/htmldoc/guides/users-guide/ROOTUsersGuide.html,https://root.cern,https://root.cern/root/htmldoc/guides/users-guide/ROOTUsersGuide.html,2,['load'],['loads']
Performance,"ss. When miss optimization is enabled (see the SetOptimizeMisses method), it tracks all branches utilized after the learning phase which caused a cache miss. When one cache miss occurs, all the utilized branches are be prefetched for that event. This optimization utilizes the observation that infrequently accessed branches are often accessed together. An example scenario where such behavior is desirable, is an analysis where a set of collections are read only for a few events in which a certain condition is respected, e.g. a trigger fired. Additional memory and CPU usage when optimizing for cache misses; When this mode is enabled, the memory dedicated to the cache can increase by at most a factor two in the case of cache miss. Additionally, on the first miss of an event, we must iterate through all the ""active branches"" for the miss cache and find the correct basket. This can be potentially a CPU-expensive operation compared to, e.g., the latency of a SSD. This is why the miss cache is currently disabled by default. Example usages of TTreeCache; A few use cases are discussed below. A cache may be created with automatic sizing when a TTree is used:; In some applications, e.g. central processing workflows of experiments, the list of branches to read is known a priori. For these cases, the TTreeCache can be instructed about the branches which will be read via explicit calls to the TTree or TTreeCache interfaces. In less streamlined applications such as analysis, predicting the branches which will be read can be difficult. In such cases, ROOT I/O flags used branches automatically when a branch buffer is read during the learning phase.; In the examples below, portions of analysis code are shown. The few statements involving the TreeCache are marked with //<<<. ROOT::RDataFrame and TTreeReader Examples; If you use RDataFrame or TTreeReader, the system will automatically cache the best set of branches: no action is required by the user. TTree::Draw Example; The TreeCache is",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:5446,cache,cache,5446,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"ss. void fillCacheObject(RooAbsCachedReal::FuncCacheElem& cacheFunc) const; Update contents of cache histogram by resampling the input function. RooArgSet* actualObservables(const RooArgSet& nset) const; If this pdf is operated with a fixed set of observables, return; the subset of the fixed observables that are actual dependents; of the external input p.d.f. If this p.d.f is operated without; a fixed set of cache observables, return the actual observables; of the external input p.d.f given the choice of observables defined; in nset. RooArgSet* actualParameters(const RooArgSet& nset) const; If this p.d.f is operated with a fixed set of observables, return; all variables of the external input p.d.f that are not one of; the cache observables. If this p.d.f is operated in automatic mode,; return the parameters of the external input p.d.f. void operModeHook(). RooCachedReal(); coverity[UNINIT_CTOR]. TObject* clone(const char* newname) const; { return new RooCachedReal(*this,newname); }. void setCdfBoundaries(Bool_t flag); If flag is true the RooHistFunc that represent the cache histogram; will use special boundary conditions for use with cumulative distribution; functions: at the lower bound the function is forced to converge at zero and the upper; bound is the function is forced to converge at 1.0. Bool_t getCdfBoundaries() const; If true the c.d.f boundary mode is active. Bool_t cacheSource() const; { return _cacheSource ; }. void setCacheSource(Bool_t flag); { _cacheSource = flag ; }. const char* inputBaseName() const; Return base name for caches, i.e. the name of the cached function. Double_t evaluate() const; Dummy evaluate, it is never called. const char* payloadUniqueSuffix() const; { return func.arg().aggregateCacheUniqueSuffix() ; }. » Last changed: Sat Sep 5 16:40:23 2015 » Last generated: 2015-09-05 16:40; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ROOT support. ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooCachedReal.html:39900,cache,cache,39900,root/html534/RooCachedReal.html,https://root.cern,https://root.cern/root/html534/RooCachedReal.html,8,['cache'],"['cache', 'cacheSource', 'cached', 'caches']"
Performance,"ss.Definition TCanvas.h:23; RooFitThe namespace RooFit contains mostly switches that change the behaviour of functions of PDFs (or othe...Definition JSONIO.h:26; rf201_compositeDefinition rf201_composite.py:1; ; [#0] WARNING:InputArguments -- The parameter 'sigma1' with range [-inf, inf] of the RooGaussian 'sig1' exceeds the safe range of (0, inf). Advise to limit its range.; [#0] WARNING:InputArguments -- The parameter 'sigma2' with range [-inf, inf] of the RooGaussian 'sig2' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model_modelData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) directly selected PDF components: (bkg,sig2); [#1] INFO:Plotting -- RooAbsPdf::plotOn(model) indirectly selected PDF components: (sig); 0x7fff963ebea0 RooAddPdf::model = 0.898624/1 [Auto,Clean] ; 0x7fff963eb588/V- RooChebychev::bkg = 0.79893 [Auto,Dirty] ; 0x7fff963ebab8/V- RooRealVar::x = 5; 0x7fff963e9588/V- RooRealVar::a0 = 0.441621 +/- 0.0731875; 0x7fff963e9970/V- RooRealVar::a1 = 0.20107 +/- 0.117637; 0x7fff963eac48/V- RooRealVar::bkgfrac = 0.504184 +/- 0.0359091; 0x7fff963e9d58/V- RooAddPdf::sig = 1/1 [Auto,Clean] ; 0x7fff963e8860/V- RooGaussian::sig1 = 1 [Auto,Dirty] ; 0x7fff963ebab8/V- RooRealVar::x = 5; 0x7fff963ea478/V- RooRealVar::mean = 5; 0x7fff963e8db8/V- RooRealVar::sigma1 = 0.5; 0x7fff963ea8",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf201__composite_8C.html:6844,optimiz,optimization,6844,doc/master/rf201__composite_8C.html,https://root.cern,https://root.cern/doc/master/rf201__composite_8C.html,2,['optimiz'],['optimization']
Performance,"ss; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_defShapeServer; Bool_t_defValueServer; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsProxy::_nset! Normalization set to be used for evaluation of RooAbsPdf contents; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; RooAbsArg*_owner; static char*RooArgSet::_poolBegin! Start of memory pool; static char*RooArgSet::_poolCur! Next free slot in memory pool; static char*RooArgSet::_poolEnd! End of memory pool . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void* operator new(size_t bytes); Overload new operator must be implemented because it is overloaded; in the RooArgSet base class. Perform standard memory allocation; here instead of memory pool management performed in RooArgSet. void operator delete(void* ptr). RooSetProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t defValueServer = kTRUE, Bool_t defShapeServer = kFALSE); Construct proxy with given name and description, with given owner; The default value and shape dirty propagation of the set contents; to the set owner is controlled by flags defValueServer and defShapeServer. RooSetProxy(const char* name, RooAbsArg* owner, const RooSetProxy& other); Copy constructor. ~RooSetProxy(); Destructor. Bool_t add(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); Overloaded RooArgSet::add() method insert object into set; and registers object as server to owner with given value; and shape dirty flag propagation requests. Bool_t addOwned(RooAbsArg& var, Bool_t silent = kFALSE); Overloaded RooArgSet::addOwned() method insert object into owning set; and registers object as server to owner with default value; and shape dirty flag",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooSetProxy.html:12871,perform,performed,12871,root/html528/RooSetProxy.html,https://root.cern,https://root.cern/root/html528/RooSetProxy.html,2,['perform'],['performed']
Performance,"ss; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. Bool_t_defShapeServer; Bool_t_defValueServer; TIterator*_iter! do not persist; RooLinkedListRooAbsCollection::_listActual object store; TStringRooAbsCollection::_nameOur name.; static Int_tRooPrintable::_nameLength; RooArgSet*RooAbsProxy::_nset! Normalization set to be used for evaluation of RooAbsPdf contents; Bool_tRooAbsCollection::_ownContFlag to identify a list that owns its contents.; RooAbsArg*_owner; static char*RooArgSet::_poolBegin! Start of memory pool; static char*RooArgSet::_poolCur! Next free slot in memory pool; static char*RooArgSet::_poolEnd! End of memory pool . Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void* operator new(size_t bytes); Overload new operator must be implemented because it is overloaded; in the RooArgSet base class. Perform standard memory allocation; here instead of memory pool management performed in RooArgSet. void operator delete(void* ptr). RooSetProxy(const char* name, const char* desc, RooAbsArg* owner, Bool_t defValueServer = kTRUE, Bool_t defShapeServer = kFALSE); Construct proxy with given name and description, with given owner; The default value and shape dirty propagation of the set contents; to the set owner is controlled by flags defValueServer and defShapeServer. RooSetProxy(const char* name, RooAbsArg* owner, const RooSetProxy& other); Copy constructor. ~RooSetProxy(); Destructor. Bool_t add(const RooAbsArg& var, Bool_t valueServer, Bool_t shapeServer, Bool_t silent); Overloaded RooArgSet::add() method insert object into set; and registers object as server to owner with given value; and shape dirty flag propagation requests. Bool_t addOwned(RooAbsArg& var, Bool_t silent); Overloaded RooArgSet::addOwned() method insert object into owning set; and registers object as server to owner with default value; and shape dirty flag propagat",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooSetProxy.html:12834,perform,performed,12834,root/html526/RooSetProxy.html,https://root.cern,https://root.cern/root/html526/RooSetProxy.html,1,['perform'],['performed']
Performance,"ssInfo_t *cl = gCling->ClassInfo_Factory(localname);; 198 bool ok = false;; 199 bool nameFound = false;; 200 if (cl && gCling->ClassInfo_IsValid(cl)) {; 201 if (localname == gCling->ClassInfo_FullName(cl)) {; 202 nameFound = true;; 203 if (gCling->ClassInfo_IsBase(cl,""TSelector"")) ok = true;; 204 }; 205 }; 206 if (!ok) {; 207 if (fromFile) {; 208 if (nameFound) {; 209 ::Error(""TSelector::GetSelector"",; 210 ""The class %s in file %s does not derive from TSelector."", localname.Data(), filename);; 211 } else {; 212 ::Error(""TSelector::GetSelector"",; 213 ""The file %s does not define a class named %s."", filename, localname.Data());; 214 }; 215 } else {; 216 if (autoloaderr); 217 ::Error(""TSelector::GetSelector"", ""class %s could not be loaded"", filename);; 218 else; 219 ::Error(""TSelector::GetSelector"",; 220 ""class %s does not exist or does not derive from TSelector"", filename);; 221 }; 222 gCling->ClassInfo_Delete(cl);; 223 return nullptr;; 224 }; 225 ; 226 // we can now create an instance of the class; 227 TSelector *selector = (TSelector*)gCling->ClassInfo_New(cl);; 228 gCling->ClassInfo_Delete(cl);; 229 return selector;; 230 }; 231}; 232 ; 233////////////////////////////////////////////////////////////////////////////////; 234/// Find out if this is a standard selection used for Draw actions; 235/// (either TSelectorDraw, TProofDraw or deriving from them).; 236 ; 237bool TSelector::IsStandardDraw(const char *selec); 238{; 239 // Make sure we have a name; 240 if (!selec) {; 241 ::Info(""TSelector::IsStandardDraw"",; 242 ""selector name undefined - do nothing"");; 243 return false;; 244 }; 245 ; 246 bool stdselec = false;; 247 if (!strchr(selec, '.')) {; 248 if (strstr(selec, ""TSelectorDraw"")) {; 249 stdselec = true;; 250 } else {; 251 TClass *cl = TClass::GetClass(selec);; 252 if (cl && (cl->InheritsFrom(""TProofDraw"") ||; 253 cl->InheritsFrom(""TSelectorDraw""))); 254 stdselec = true;; 255 }; 256 }; 257 ; 258 // We are done; 259 return stdselec;; 260}; 261 ; 262//////////////",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TSelector_8cxx_source.html:8930,load,loaded,8930,doc/master/TSelector_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TSelector_8cxx_source.html,1,['load'],['loaded']
Performance,ss_Version ();  ; static const char * DeclFileName ();  ; static Longptr_t GetDtorOnly ();  Return destructor only flag. ;  ; static Bool_t GetObjectStat ();  Get status of object stat flag. ;  ; static void SetDtorOnly (void *obj);  Set destructor only flag. ;  ; static void SetObjectStat (Bool_t stat);  Turn on/off tracking of objects in the TObjectTable. ;  ;  Static Public Member Functions inherited from RooPrintable; static TClass * Class ();  ; static const char * Class_Name ();  ; static constexpr Version_t Class_Version ();  ; static const char * DeclFileName ();  ; static std::ostream & defaultPrintStream (std::ostream *os=nullptr);  Return a reference to the current default stream to use in Print(). ;  ; static void nameFieldLength (Int_t newLen);  Set length of field reserved from printing name of RooAbsArgs in multi-line collection printing to given amount. ;  . Protected Member Functions; RooFit::OwningPtr< RooArgSet > actualObservables (const RooArgSet &nset) const override;  Return observable in nset to be cached by RooAbsCachedPdf this is always the x observable that is integrated. ;  ; RooFit::OwningPtr< RooArgSet > actualParameters (const RooArgSet &nset) const override;  Return the parameters of the cache created by RooAbsCachedPdf. ;  ; const char * binningName () const override;  ; FuncCacheElem * createCache (const RooArgSet *nset) const override;  Create custom cache element for running integral calculations. ;  ; double evaluate () const override;  Dummy function that is never called. ;  ; void fillCacheObject (FuncCacheElem &cacheFunc) const override;  Fill the cache object by calling its calculate() method. ;  ; const char * inputBaseName () const override;  Return unique name for RooAbsCachedPdf cache components constructed from input function name. ;  ; const char * payloadUniqueSuffix () const override;  ;  Protected Member Functions inherited from RooAbsCachedReal; TString cacheNameSuffix (const RooArgSet &nset) const;  Construct unique,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooNumRunningInt.html:49294,cache,cached,49294,doc/master/classRooNumRunningInt.html,https://root.cern,https://root.cern/doc/master/classRooNumRunningInt.html,1,['cache'],['cached']
Performance,"ssed entry, passing in the aggregator variable and the value of the column columnName. If the signature is U(U,T) the aggregator variable is then copy-assigned the result of the execution of the callable. Otherwise the signature of aggregator must be void(U&,T).; The merger callable is used to merge the partial accumulation results of each processing thread. It is only called in multi-thread executions. If its signature is U(U,U) the aggregator variables of each thread are merged two by two. If its signature is void(std::vector<U>& a) it is assumed that it merges all aggregators in a[0].; This action is lazy: upon invocation of this method the calculation is booked but not executed. Also see RResultPtr.; Example usage: auto aggregator = [](double acc, double x) { return acc * x; };; ROOT::EnableImplicitMT();; // If multithread is enabled, the aggregator function will be called by more threads; // and will produce a vector of partial accumulators.; // The merger function performs the final aggregation of these partial results.; auto merger = [](std::vector<double> &accumulators) {; for (auto i : ROOT::TSeqU(1u, accumulators.size())) {; accumulators[0] *= accumulators[i];; }; };; ; // The accumulator is initialized at this value by every thread.; double initValue = 1.;; ; // Multiplies all elements of the column ""x""; auto result = d.Aggregate(aggregator, merger, ""x"", initValue);; d#define d(i)Definition RSha256.hxx:102; sizesize_t size(const MatrixT &matrix)retrieve the size of a square matrix; resultOption_t Option_t TPoint TPoint const char GetTextMagnitude GetFillStyle GetLineColor GetLineWidth GetMarkerStyle GetTextAlign GetTextColor GetTextSize void char Point_t Rectangle_t WindowAttributes_t Float_t Float_t Float_t Int_t Int_t UInt_t UInt_t Rectangle_t resultDefinition TGWin32VirtualXProxy.cxx:174; ROOT::TSeqA pseudo container class which is a generator of indices.Definition TSeq.hxx:67; xDouble_t x[n]Definition legend1.C:17; ROOTtbb::task_arena is an alias of tb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:33361,perform,performs,33361,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['perform'],['performs']
Performance,"sses and create branches for each one.; 6095 TObjArray* blist = this->GetListOfBranches();; 6096 TIter next(sinfo->GetElements());; 6097 TStreamerElement* element = nullptr;; 6098 TString bname;; 6099 for (Int_t id = 0; (element = (TStreamerElement*) next()); ++id) {; 6100 if (element->IsA() == TStreamerArtificial::Class()) {; 6101 continue;; 6102 }; 6103 if (element->TestBit(TStreamerElement::kRepeat)) {; 6104 continue;; 6105 }; 6106 if (element->TestBit(TStreamerElement::kCache) && !element->TestBit(TStreamerElement::kWrite)) {; 6107 continue;; 6108 }; 6109 char* pointer = (char*) (objptr + element->GetOffset());; 6110 // FIXME: This is not good enough, an STL container can be; 6111 // a base, and the test will fail.; 6112 // See TBranchElement::InitializeOffsets() for the; 6113 // correct test.; 6114 bool isBase = (element->IsA() == TStreamerBase::Class());; 6115 if (isBase) {; 6116 TClass* clbase = element->GetClassPointer();; 6117 if ((clbase == TObject::Class()) && cl->CanIgnoreTObjectStreamer()) {; 6118 // Note: TStreamerInfo::Compile() leaves this element; 6119 // out of the optimized info, although it does; 6120 // exists in the non-compiled and non-optimized info.; 6121 // FIXME: The test that TStreamerInfo::Compile() uses; 6122 // is element->GetType() < 0, so that is what; 6123 // we should do as well.; 6124 continue;; 6125 }; 6126 if (clbase->GetListOfRealData()->GetSize() == 0) {; 6127 // Do not create a branch for empty bases.; 6128 continue;; 6129 }; 6130 }; 6131 if (dot) {; 6132 if (dotlast) {; 6133 bname.Form(""%s%s"", name, element->GetFullName());; 6134 } else {; 6135 // FIXME: We are in the case where we have a top-level; 6136 // branch name that was created by the branch; 6137 // constructor which takes a folder as input.; 6138 // The internal dots in the name are in place of; 6139 // of the original slashes and represent the; 6140 // folder hierarchy.; 6141 if (isBase) {; 6142 // FIXME: This is very strange, this is the only case where; 6143 // ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TBranchElement_8cxx_source.html:228981,optimiz,optimized,228981,doc/master/TBranchElement_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TBranchElement_8cxx_source.html,2,['optimiz'],['optimized']
Performance,"ssification example; /// @param nevts : number of signal/background events. Use by default a low value (1000); /// but increase to at least 5000 to get a good result; /// @param opt : vector of bool with method used (default all on if available). The order is:; /// - TMVA CNN; /// - Keras CNN; /// - TMVA DNN; /// - TMVA BDT; /// - PyTorch CNN; void TMVA_CNN_Classification(int nevts = 1000, std::vector<bool> opt = {1, 1, 1, 1, 1}); {; ; int imgSize = 16 * 16;; TString inputFileName = ""images_data_16x16.root"";; ; bool fileExist = !gSystem->AccessPathName(inputFileName);; ; // if file does not exists create it; if (!fileExist) {; MakeImagesTree(nevts, 16, 16);; }; ; bool useTMVACNN = (opt.size() > 0) ? opt[0] : false;; bool useKerasCNN = (opt.size() > 1) ? opt[1] : false;; bool useTMVADNN = (opt.size() > 2) ? opt[2] : false;; bool useTMVABDT = (opt.size() > 3) ? opt[3] : false;; bool usePyTorchCNN = (opt.size() > 4) ? opt[4] : false;; #ifndef R__HAS_TMVACPU; #ifndef R__HAS_TMVAGPU; Warning(""TMVA_CNN_Classification"",; ""TMVA is not build with GPU or CPU multi-thread support. Cannot use TMVA Deep Learning for CNN"");; useTMVACNN = false;; #endif; #endif; ; bool writeOutputFile = true;; ; #ifdef R__USE_IMT; int num_threads = 4; // use by default 4 threads if value is not set before; // switch off MT in OpenBLAS to avoid conflict with tbb; gSystem->Setenv(""OMP_NUM_THREADS"", ""1"");; ; // do enable MT running; if (num_threads >= 0) {; ROOT::EnableImplicitMT(num_threads);; }; #endif; ; TMVA::Tools::Instance();; ; ; std::cout << ""Running with nthreads = "" << ROOT::GetThreadPoolSize() << std::endl;; ; #ifdef R__HAS_PYMVA; gSystem->Setenv(""KERAS_BACKEND"", ""tensorflow"");; // for using Keras; TMVA::PyMethodBase::PyInitialize();; #else; useKerasCNN = false;; usePyTorchCNN = false;; #endif; ; TFile *outputFile = nullptr;; if (writeOutputFile); outputFile = TFile::Open(""TMVA_CNN_ClassificationOutput.root"", ""RECREATE"");; ; /***; ## Create TMVA Factory; ; Create the Factory class. Later yo",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html:48381,multi-thread,multi-thread,48381,doc/master/TMVA__CNN__Classification_8C.html,https://root.cern,https://root.cern/doc/master/TMVA__CNN__Classification_8C.html,1,['multi-thread'],['multi-thread']
Performance,"ssing();; 73 void DisableParBranchProcessing();; 74 Bool_t IsParBranchProcessingEnabled();; 75 class TParBranchProcessingRAII {; 76 public:; 77 TParBranchProcessingRAII() { EnableParBranchProcessing(); }; 78 ~TParBranchProcessingRAII() { DisableParBranchProcessing(); }; 79 };; 80} } // End ROOT::Internal; 81 ; 82namespace ROOT {; 83 /// \brief Enable support for multi-threading within the ROOT code; 84 /// in particular, enables the global mutex to make ROOT thread safe/aware.; 85 void EnableThreadSafety();; 86 /// \brief Enable ROOT's implicit multi-threading for all objects and methods that provide an internal; 87 /// parallelisation mechanism.; 88 void EnableImplicitMT(UInt_t numthreads = 0);; 89 void DisableImplicitMT();; 90 Bool_t IsImplicitMTEnabled();; 91 UInt_t GetThreadPoolSize();; 92}; 93 ; 94class TROOT : public TDirectory {; 95 ; 96friend class TCling;; 97friend TROOT *ROOT::Internal::GetROOT2();; 98 ; 99private:; 100 Int_t fLineIsProcessing; ///< To synchronize multi-threads; 101 ; 102 static Int_t fgDirLevel; ///< Indentation level for ls(); 103 static Bool_t fgRootInit; ///< Singleton initialization flag; 104 ; 105 TROOT(const TROOT&) = delete;; 106 TROOT& operator=(const TROOT&) = delete;; 107 ; 108protected:; 109 typedef std::atomic<TListOfEnums*> AListOfEnums_t;; 110 ; 111 TString fConfigOptions; ///< ROOT ./configure set build options; 112 TString fConfigFeatures; ///< ROOT ./configure detected build features; 113 TString fVersion; ///< ROOT version (from CMZ VERSQQ) ex 0.05/01; 114 Int_t fVersionInt; ///< ROOT version in integer format (501); 115 Int_t fVersionCode; ///< ROOT version code as used in RVersion.h; 116 Int_t fVersionDate; ///< Date of ROOT version (ex 951226); 117 Int_t fVersionTime; ///< Time of ROOT version (ex 1152); 118 Int_t fBuiltDate; ///< Date of ROOT built; 119 Int_t fBuiltTime; ///< Time of ROOT built; 120 TString fGitCommit; ///< Git commit SHA1 of built; 121 TString fGitBranch; ///< Git branch; 122 TString fGitDate; ///< D",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TROOT_8h_source.html:3222,multi-thread,multi-threads,3222,doc/master/TROOT_8h_source.html,https://root.cern,https://root.cern/doc/master/TROOT_8h_source.html,2,['multi-thread'],['multi-threads']
Performance,"ssion level is not set yet. The enumeration ROOT::ECompressionAlgorithm associates each; algorithm with a number. There is a utility function to help; to set the value of the argument. For example,; ROOT::CompressionSettings(ROOT::kLZMA, 1); will build an integer which will set the compression to use; the LZMA algorithm and compression level 1. These are defined; in the header file Compression.h. Note that the compression settings may be changed at any time.; The new compression settings will only apply to branches created; or attached after the setting is changed and other objects written; after the setting is changed. void SetCacheRead(TFileCacheRead* cache); Set a pointer to the read cache.; NOTE: This relinquish ownership of the previous cache, so if you do not; already have a pointer to the previous cache (and there was a previous; cache), you ought to retrieve (and delete it if needed) using:; TFileCacheRead *older = myfile->GetCacheRead();. void SetCacheWrite(TFileCacheWrite* cache); Set a pointer to the write cache.; If file is null the existing write cache is deleted. Int_t Sizeof() const; Return the size in bytes of the file header. void Streamer(TBuffer& b); Stream a TFile object. void SumBuffer(Int_t bufsize); Increment statistics for buffer sizes of objects in this file. void UseCache(Int_t maxCacheSize = 10, Int_t pageSize = 0); Dummy function kept for backward compatibility.; The read cache is now managed by TFileCacheRead; The write cache is now managed by TFileCacheWrite; Both caches are created automatically by the system. Int_t Write(const char* name = 0, Int_t opt = 0, Int_t bufsiz = 0); Write memory objects to this file.; Loop on all objects in memory (including subdirectories).; A new key is created in the KEYS linked list for each object.; The list of keys is then saved on the file (via WriteKeys); as a single data record.; For values of opt see TObject::Write().; The directory header info is rewritten on the directory header record.; The link",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TFile.html:38986,cache,cache,38986,root/html530/TFile.html,https://root.cern,https://root.cern/root/html530/TFile.html,6,['cache'],['cache']
Performance,"ssion, functor class or any other callable object performing user defined calculations. ; [in]columnsNames of the columns/branches in input to the user function. The callable f is invoked once per entry. This is an instant action: upon invocation, an event loop as well as execution of all scheduled actions is triggered. Users are responsible for the thread-safety of this callable when executing with implicit multi-threading enabled (i.e. ROOT::EnableImplicitMT). Example usage:; myDf.Foreach([](int i){ std::cout << i << std::endl;}, {""myIntColumn""});. Definition at line 1611 of file RInterface.hxx. ◆ ForeachSlot(). template<typename Proxied , typename DataSource = void> . template<typename F > . void ROOT::RDF::RInterface< Proxied, DataSource >::ForeachSlot ; (; F ; f, . const ColumnNames_t & ; columns = {} . ). inline . Execute a user-defined function requiring a processing slot index on each entry (instant action). ; Parameters. [in]fFunction, lambda expression, functor class or any other callable object performing user defined calculations. ; [in]columnsNames of the columns/branches in input to the user function. Same as Foreach, but the user-defined function takes an extra unsigned int as its first parameter, the processing slot index. This slot index will be assigned a different value, 0 to poolSize - 1, for each thread of execution. This is meant as a helper in writing thread-safe Foreach actions when using RDataFrame after ROOT::EnableImplicitMT(). The user-defined processing callable is able to follow different streams of processing indexed by the first parameter. ForeachSlot works just as well with single-thread execution: in that case slot will always be 0. Example usage:; myDf.ForeachSlot([](unsigned int s, int i){ std::cout << ""Slot "" << s << "": ""<< i << std::endl;}, {""myIntColumn""});. Definition at line 1641 of file RInterface.hxx. ◆ GetFilterNames(). template<typename Proxied , typename DataSource = void> . std::vector< std::string > ROOT::RDF::RInterfac",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html:77200,perform,performing,77200,doc/master/classROOT_1_1RDF_1_1RInterface.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1RDF_1_1RInterface.html,1,['perform'],['performing']
Performance,"ssionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual const TUrl * GetEndpointUrl () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual TString GetNewUrl ();  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; virtual Long64_t GetSeekFree () const;  ; virtual Long64_t GetSeekInfo () const;  ; const TList * GetStreamerInfoCache ();  Returns the cached list of StreamerInfos used in this file. ;  ; virtual TList * GetStreamerInfoList () final;  Read the list of TStreamerInfo objects written to this file. ;  ; Int_t GetVersion () const;  ; virtual void IncrementProcessIDs ();  ; virtual Bool_t IsArchive () const;  ; Bool_t IsBinary () const;  ; Bool_t IsRaw () const;  ; void ls (Option_t *option="""") const override;  List file contents. ;  ; virtual void MakeFree (Long64_t first, Long64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRUE if 'url' matches the coordinates of this file. ;  ; virtual Bool_t MustFlush () const;  ; void Paint (O",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTS3WebFile.html:7465,cache,cached,7465,doc/master/classTS3WebFile.html,https://root.cern,https://root.cern/doc/master/classTS3WebFile.html,2,['cache'],['cached']
Performance,"ssionAlgorithm () const;  ; Float_t GetCompressionFactor ();  Return the file compression factor. ;  ; Int_t GetCompressionLevel () const;  ; Int_t GetCompressionSettings () const;  ; virtual Long64_t GetEND () const;  ; virtual const TUrl * GetEndpointUrl () const;  ; virtual Int_t GetErrno () const;  Method returning errno. ;  ; Int_t GetFd () const;  ; TList * GetListOfFree () const;  ; TObjArray * GetListOfProcessIDs () const;  ; virtual Int_t GetNbytesFree () const;  ; virtual Int_t GetNbytesInfo () const;  ; virtual TString GetNewUrl ();  ; virtual Int_t GetNfree () const;  ; virtual Int_t GetNProcessIDs () const;  ; Option_t * GetOption () const override;  ; virtual Int_t GetReadCalls () const;  ; Int_t GetRecordHeader (char *buf, Long64_t first, Int_t maxbytes, Int_t &nbytes, Int_t &objlen, Int_t &keylen);  Read the logical record header starting at a certain postion. ;  ; Long64_t GetRelOffset () const;  ; virtual Long64_t GetSeekFree () const;  ; virtual Long64_t GetSeekInfo () const;  ; const TList * GetStreamerInfoCache ();  Returns the cached list of StreamerInfos used in this file. ;  ; virtual TList * GetStreamerInfoList () final;  Read the list of TStreamerInfo objects written to this file. ;  ; Int_t GetVersion () const;  ; virtual void IncrementProcessIDs ();  ; virtual Bool_t IsArchive () const;  ; Bool_t IsBinary () const;  ; virtual Bool_t IsOpen () const;  Returns kTRUE in case file is open and kFALSE if file is not open. ;  ; Bool_t IsRaw () const;  ; void ls (Option_t *option="""") const override;  List file contents. ;  ; virtual void MakeFree (Long64_t first, Long64_t last);  Mark unused bytes on the file. ;  ; virtual void MakeProject (const char *dirname, const char *classes=""*"", Option_t *option=""new"");  Generate source code necessary to access the objects stored in the file. ;  ; virtual void Map ();  ; virtual void Map (Option_t *opt);  List the contents of a file sequentially. ;  ; virtual Bool_t Matches (const char *name);  Return kTRU",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html:6123,cache,cached,6123,doc/v632/classROOT_1_1TBufferMergerFile.html,https://root.cern,https://root.cern/doc/v632/classROOT_1_1TBufferMergerFile.html,5,['cache'],['cached']
Performance,"ssociative) && read); 1658 return TGenCollectionProxy__StagingCopyIterator;; 1659 else; 1660 return fFunctionCopyIterator = TGenCollectionProxy__SlowCopyIterator;; 1661}; 1662 ; 1663////////////////////////////////////////////////////////////////////////////////; 1664/// See typedef void* (*Next_t)(void *iter, void *end);; 1665/// iter and end should be pointer to respectively an iterator to be incremented and the result of colleciton.end(); 1666/// 'Next' will increment the iterator 'iter' and return 0 if the iterator reached the end.; 1667/// If the end is not reached, 'Next' will return the address of the content unless the collection contains pointers in; 1668/// which case 'Next' will return the value of the pointer.; 1669 ; 1670TVirtualCollectionProxy::Next_t TGenCollectionProxy::GetFunctionNext(Bool_t read); 1671{; 1672 if (read) {; 1673 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1674 if ( (fProperties & kIsAssociative) && read); 1675 return TGenCollectionProxy__StagingNext;; 1676 }; 1677 ; 1678 if ( fFunctionNextIterator ) return fFunctionNextIterator;; 1679 ; 1680 if ( !fValue.load(std::memory_order_relaxed) ) InitializeEx(kFALSE);; 1681 ; 1682 // TODO can we do better than the default for RVec?; 1683 if (fSTL_type==ROOT::kSTLvector || (fProperties & kIsEmulated)); 1684 return fFunctionNextIterator = TGenCollectionProxy__VectorNext;; 1685 else if ( (fProperties & kIsAssociative) && read); 1686 return TGenCollectionProxy__StagingNext;; 1687 else; 1688 return fFunctionNextIterator = TGenCollectionProxy__SlowNext;; 1689}; 1690 ; 1691////////////////////////////////////////////////////////////////////////////////; 1692/// See typedef void (*DeleteIterator_t)(void *iter);; 1693/// If the sizeof iterator is greater than fgIteratorArenaSize, call delete on the addresses,; 1694/// Otherwise just call the iterator's destructor.; 1695 ; 1696TVirtualCollectionProxy::DeleteIterator_t TGenCollectionProxy::GetFunctionDeleteIterator(Bool_t read)",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:55433,load,load,55433,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['load'],['load']
Performance,"st != """") {; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) it->second = 0;; ; std::vector<TString> mlist = TMVA::gTools().SplitString( myMethodList, ',' );; for (UInt_t i=0; i<mlist.size(); i++) {; std::string regMethod(mlist[i]);; ; if (Use.find(regMethod) == Use.end()) {; std::cout << ""Method \"""" << regMethod << ""\"" not known in TMVA under this name. Choose among the following:"" << std::endl;; for (std::map<std::string,int>::iterator it = Use.begin(); it != Use.end(); it++) std::cout << it->first << "" "";; std::cout << std::endl;; return 1;; }; Use[regMethod] = 1;; }; }; ; // --------------------------------------------------------------------------------------------------; ; // Here the preparation phase begins; ; // Read training and test data; // (it is also possible to use ASCII format as input -> see TMVA Users Guide); // Set the cache directory for the TFile to the current directory. The input; // data file will be downloaded here if not present yet, then it will be read; // from the cache path directly.; TFile::SetCacheFileDir(""."");; std::unique_ptr<TFile> input{TFile::Open(""http://root.cern/files/tmva_class_example.root"", ""CACHEREAD"")};; if (!input || input->IsZombie()) {; throw std::runtime_error(""ERROR: could not open data file"");; }; std::cout << ""--- TMVAClassification : Using input file: "" << input->GetName() << std::endl;; ; // Register the training and test trees; ; TTree *signalTree = (TTree*)input->Get(""TreeS"");; TTree *background = (TTree*)input->Get(""TreeB"");; ; // Create a ROOT output file where TMVA will store ntuples, histograms, etc.; TString outfileName(""TMVAC.root"");; std::unique_ptr<TFile> outputFile{TFile::Open(outfileName, ""RECREATE"")};; if (!outputFile || outputFile->IsZombie()) {; throw std::runtime_error(""ERROR: could not open output file"");; }; ; // Create the factory object. Later you can choose the methods; // whose performance you'd like to investigate. The factory is; // the only TMVA object you",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TMVAClassification_8C.html:85038,cache,cache,85038,doc/master/TMVAClassification_8C.html,https://root.cern,https://root.cern/doc/master/TMVAClassification_8C.html,1,['cache'],['cache']
Performance,"st * fListDefinition TDirectory.h:142; TEnv::GetValuevirtual Int_t GetValue(const char *name, Int_t dflt) constReturns the integer value for a resource.Definition TEnv.cxx:491; TFileCacheReadA cache when reading files over the network.Definition TFileCacheRead.h:22; TFileCacheRead::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Read buffer at position pos.Definition TFileCacheRead.cxx:364; TFileCacheRead::Closevirtual void Close(Option_t *option="""")Close out any threads or asynchronous fetches used by the underlying implementation.Definition TFileCacheRead.cxx:189; TFileCacheRead::GetBufferSizevirtual Int_t GetBufferSize() constDefinition TFileCacheRead.h:88; TFileCacheRead::GetFileTFile * GetFile() constDefinition TFileCacheRead.h:92; TFileCacheRead::SetFilevirtual void SetFile(TFile *file, TFile::ECacheAction action=TFile::kDisconnect)Set the file using this cache and reset the current blocks (if any).Definition TFileCacheRead.cxx:545; TFileCacheWriteA cache when writing files over the network.Definition TFileCacheWrite.h:19; TFileCacheWrite::Flushvirtual Bool_t Flush()Flush the current write buffer to the file.Definition TFileCacheWrite.cxx:79; TFileCacheWrite::ReadBuffervirtual Int_t ReadBuffer(char *buf, Long64_t pos, Int_t len)Called by the read cache to check if the requested data is not in the write cache buffer.Definition TFileCacheWrite.cxx:108; TFileCacheWrite::GetBytesInCachevirtual Int_t GetBytesInCache() constDefinition TFileCacheWrite.h:38; TFileCacheWrite::WriteBuffervirtual Int_t WriteBuffer(const char *buf, Long64_t pos, Int_t len)Write buffer at position pos in the write buffer.Definition TFileCacheWrite.cxx:121; TFileOpenHandleClass holding info about the file being opened.Definition TFile.h:354; TFileOpenHandle::fFileTFile * fFileTFile instance of the file being opened.Definition TFile.h:362; TFileOpenHandle::GetNetOptInt_t GetNetOpt() constDefinition TFile.h:381; TFileOpenHandle::GetFileTFile * GetFile() constDefinition T",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TFile_8cxx_source.html:208940,cache,cache,208940,doc/master/TFile_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TFile_8cxx_source.html,1,['cache'],['cache']
Performance,"st * h1analysisTreeReader::GetOutputList ; (; ); const. inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 73 of file h1analysisTreeReader.h. ◆ Init(). void h1analysisTreeReader::Init ; (; TTree * ; myTree). inlineoverridevirtual . Reimplemented from TSelector.; Definition at line 67 of file h1analysisTreeReader.h. ◆ IsA(). TClass * h1analysisTreeReader::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 77 of file h1analysisTreeReader.h. ◆ Notify(). Bool_t h1analysisTreeReader::Notify ; (; ). overridevirtual . This method must be overridden to handle object notification (the base implementation is no-op). ; Different objects in ROOT use the Notify method for different purposes, in coordination with other objects that call this method at the appropriate time.; For example, TLeaf uses it to load class information; TBranchRef to load contents of referenced branches TBranchRef; most notably, based on Notify, TChain implements a callback mechanism to inform interested parties when it switches to a new sub-tree. ; Reimplemented from TObject. ◆ Process(). Bool_t h1analysisTreeReader::Process ; (; Long64_t ; ). overridevirtual . The Process() function is called for each entry in the tree (or possibly keyed object in the case of PROOF) to be processed. ; The entry argument specifies which entry in the currently loaded tree is to be processed. It can be passed to either t01::GetEntry() or TBranch::GetEntry() to read either all or the required parts of the data. When processing keyed objects with PROOF, the object is already loaded and is available via the fObject pointer.; This function should contain the ""body"" of the analysis. It can contain simple or elaborate selection criteria, run algorithms on the data of the event and typically fill histograms.; The processing can be stopped by calling Abort().; Use fStatus to set the return value of TTree::Process().; The return v",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classh1analysisTreeReader.html:15667,load,load,15667,doc/master/classh1analysisTreeReader.html,https://root.cern,https://root.cern/doc/master/classh1analysisTreeReader.html,2,['load'],['load']
Performance,"st = nullptr;; 2807 return;; 2808 }; 2809 fEntryList = elist;; 2810 TList *elists = elist->GetLists();; 2811 bool shift = false;; 2812 TIter next(elists);; 2813 ; 2814 //check, if there are sub-lists in the entry list, that don't; 2815 //correspond to any trees in the chain; 2816 while((templist = (TEntryList*)next())){; 2817 if (templist->GetTreeNumber() < 0){; 2818 shift = true;; 2819 break;; 2820 }; 2821 }; 2822 fEntryList->SetShift(shift);; 2823 ; 2824}; 2825 ; 2826////////////////////////////////////////////////////////////////////////////////; 2827/// Set the input entry list (processing the entries of the chain will then be; 2828/// limited to the entries in the list). This function creates a special kind; 2829/// of entry list (TEntryListFromFile object) that loads lists, corresponding; 2830/// to the chain elements, one by one, so that only one list is in memory at a time.; 2831///; 2832/// If there is an error opening one of the files, this file is skipped and the; 2833/// next file is loaded; 2834///; 2835/// File naming convention:; 2836///; 2837/// - by default, filename_elist.root is used, where filename is the; 2838/// name of the chain element; 2839/// - xxx$xxx.root - $ sign is replaced by the name of the chain element; 2840///; 2841/// If the list name is not specified (by passing filename_elist.root/listname to; 2842/// the TChain::SetEntryList() function, the first object of class TEntryList; 2843/// in the file is taken.; 2844///; 2845/// It is assumed, that there are as many list files, as there are elements in; 2846/// the chain and they are in the same order; 2847 ; 2848void TChain::SetEntryListFile(const char *filename, Option_t * /*opt*/); 2849{; 2850 ; 2851 if (fEntryList){; 2852 //check, if the chain is the owner of the previous entry list; 2853 //(it happens, if the previous entry list was created from a user-defined; 2854 //TEventList in SetEventList() function); 2855 if (fEntryList->TestBit(kCanDelete)) {; 2856 TEntryList *tmp = fEntryL",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:102661,load,loaded,102661,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loaded']
Performance,"st > createEmptyResidHist (const RooCurve &curve, bool normalize=false) const;  ; void fillResidHist (RooHist &residHist, const RooCurve &curve, bool normalize=false, bool useAverage=false) const;  ; void initialize ();  Perform common initialization for all constructors. ;  ; Int_t roundBin (double y);  Return the nearest positive integer to the input value and print a warning if an adjustment is required. ;  ;  Protected Member Functions inherited from TGraphAsymmErrors; Double_t ** Allocate (Int_t size) override;  Allocate internal data structures for size points. ;  ; void CopyAndRelease (Double_t **newarrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy and release. ;  ; Bool_t CopyPoints (Double_t **arrays, Int_t ibegin, Int_t iend, Int_t obegin) override;  Copy errors from fE*** to arrays[***] or to f*** Copy points. ;  ; Bool_t CtorAllocate ();  Should be called from ctors after fNpoints has been set. ;  ; Bool_t DoMerge (const TGraph *g) override;  Protected function to perform the merge operation of a graph with asymmetric errors. ;  ; void FillZero (Int_t begin, Int_t end, Bool_t from_ctor=kTRUE) override;  Set zero values for point arrays in the range [begin, end] ;  ; void SwapPoints (Int_t pos1, Int_t pos2) override;  Swap points. ;  ; void UpdateArrays (const std::vector< Int_t > &sorting_indices, Int_t numSortedPoints, Int_t low) override;  Update the fX, fY, fEXlow, fEXhigh, fEYlow and fEYhigh arrays with the sorted values. ;  ;  Protected Member Functions inherited from TGraph; Double_t ** AllocateArrays (Int_t Narrays, Int_t arraySize);  Allocate arrays. ;  ; Bool_t CtorAllocate ();  In constructors set fNpoints than call this method. ;  ; Double_t ** ExpandAndCopy (Int_t size, Int_t iend);  if size > fMaxSize allocate new arrays of 2*size points and copy iend first points. ;  ; TString SaveArray (std::ostream &out, const char *suffix, Int_t frameNumber, Double_t *arr);  Save array as C++ code Returns name of created array. ;  ; void Sa",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooHist.html:37890,perform,perform,37890,doc/master/classRooHist.html,https://root.cern,https://root.cern/doc/master/classRooHist.html,1,['perform'],['perform']
Performance,"st RooAbsArg &other) const override;  Equality operator when comparing to another RooAbsArg. ;  ; bool operator== (double value) const;  Equality operator comparing to a double. ;  ; virtual RooPlot * plotSliceOn (RooPlot *frame, const RooArgSet &sliceSet, Option_t *drawOptions=""L"", double scaleFactor=1.0, ScaleType stype=Relative, const RooAbsData *projData=nullptr) const;  ; virtual void preferredObservableScanOrder (const RooArgSet &obs, RooArgSet &orderedObs) const;  Interface method for function objects to indicate their preferred order of observables for scanning their values into a (multi-dimensional) histogram or RooDataSet. ;  ; void printMultiline (std::ostream &os, Int_t contents, bool verbose=false, TString indent="""") const override;  Structure printing. ;  ; void printValue (std::ostream &os) const override;  Print object value. ;  ; bool readFromStream (std::istream &is, bool compact, bool verbose=false) override;  Read object contents from stream (dummy for now) ;  ; void selectComp (bool flag);  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; virtual bool setData (RooAbsData &, bool=true);  ; void setIntegratorConfig ();  Remove the specialized numeric integration configuration associated with this object. ;  ; void setIntegratorConfig (const RooNumIntConfig &config);  Set the given integrator configuration as default numeric integration configuration for this object. ;  ; void setParameterizeIntegral (const RooArgSet &paramVars);  ; void setPlotLabel (const char *label);  Set the label associated with this variable. ;  ; void setUnit (const char *unit);  ; RooAbsMoment * sigma (RooRealVar &obs);  ; RooAbsMoment * sigma (RooRealVar &obs, const RooArgSet &nset);  ; RooNumIntConfig * specialIntegratorConfig () const;  Returns the specialized integrator configuration for this RooAbsReal. ;  ; RooNumIntConfig * specialIntegratorConfig (bool createOnTheFly);  Returns the special",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classRooAddPdf.html:30468,cache,cache,30468,doc/v632/classRooAddPdf.html,https://root.cern,https://root.cern/doc/v632/classRooAddPdf.html,2,['cache'],['cache']
Performance,"st RooAbsArg *source);  Notify that a shape-like property (e.g. binning) has changed. ;  ; void setValueDirty (const RooAbsArg *source);  Force element to re-evaluate itself when a value is requested. ;  ; void unRegisterProxy (RooArgProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooListProxy &proxy);  Remove proxy from proxy list. ;  ; void unRegisterProxy (RooSetProxy &proxy);  Remove proxy from proxy list. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; value_type _defCat {NoCatIdx};  Default (unmapped) output type. ;  ; RooCategoryProxy _inputCat;  Input category. ;  ; std::map< std::string, RooMappedCategory::Entry > _mapArray;  List of mapping rules. ;  ; std::unique_ptr< RooMappedCategoryCache > _mapcache;  ! transient member: cache the mapping ;  ;  Protected Attributes inherited from RooAbsCategory; value_type _currentIndex {std::numeric_limits<int>::min()};  Current category state. ;  ; std::vector< std::string > _insertionOrder;  Keeps track in which order state numbers have been inserted. Make sure this is updated in recomputeShape(). ;  ; std::map< value_type, std::unique_ptr< RooCatType, std::function< void(RooCatType *)> > > _legacyStates;  ! Map holding pointers to RooCatType instances. Only for legacy interface. Don't use if possible. ;  ; std::map< std::string, value_type > _stateNames;  Map state names to index numbers. Make sure state names are updated in recomputeShape(). ;  ;  Protected Attributes inherited from RooAbsArg; std::set< std::string > _boolAttrib;  ; std::set< std::string > _boolAttribTransient;  ; std::vector< RooAbsCache * > _cacheList;  ; RefCountList_t _clientList;  ; RefCountList_t _clientListShape;  ; RefCountList_t _clientListValue;  ; std::size_t _dataToken = std::numeric_limits<std::size_t>::max();  In which wor",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooMappedCategory.html:40291,cache,cache,40291,doc/master/classRooMappedCategory.html,https://root.cern,https://root.cern/doc/master/classRooMappedCategory.html,1,['cache'],['cache']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooAbsReal&pdf() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Opt",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooNumConvolution.html:21787,optimiz,optimizeCacheMode,21787,root/html534/RooNumConvolution.html,https://root.cern,https://root.cern/root/html534/RooNumConvolution.html,2,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); RooArgSetparameters() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooChangeTracker.html:20042,optimiz,optimizeCacheMode,20042,root/html534/RooChangeTracker.html,https://root.cern,https://root.cern/root/html534/RooChangeTracker.html,2,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); const RooArgList&paramList() const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/ParamHistFunc.html:19969,optimiz,optimizeCacheMode,19969,root/html534/ParamHistFunc.html,https://root.cern,https://root.cern/root/html534/ParamHistFunc.html,6,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/Roo1DMomentMorphFunction.html:19573,optimiz,optimizeCacheMode,19573,root/html534/Roo1DMomentMorphFunction.html,https://root.cern,https://root.cern/root/html534/Roo1DMomentMorphFunction.html,100,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue& obs, Double_t xlo, Double_t xhi) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L""",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooHistFunc.html:19714,optimiz,optimizeCacheMode,19714,root/html534/RooHistFunc.html,https://root.cern,https://root.cern/root/html534/RooHistFunc.html,6,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_t* drawOptions = ""L"", Double_t s",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAddition.html:19790,optimiz,optimizeCacheMode,19790,root/html534/RooAddition.html,https://root.cern,https://root.cern/root/html534/RooAddition.html,4,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_tRooAbsMoment::order() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sli",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooFirstMoment.html:19700,optimiz,optimizeCacheMode,19700,root/html534/RooFirstMoment.html,https://root.cern,https://root.cern/root/html534/RooFirstMoment.html,6,['optimiz'],['optimizeCacheMode']
Performance,"st RooAbsData* dset, const RooAbsArg& testArg) const; Bool_tRooAbsArg::observableOverlaps(const RooArgSet* depList, const RooAbsArg& testArg) const; voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; virtual Double_tRooAbsReal::offset() const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TNamed&TNamed::operator=(const TNamed& rhs); Bool_tRooAbsReal::operator==(Double_t value) const; virtual Bool_tRooAbsReal::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Int_torder() const; Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, const RooCmdArg& arg1 = RooCmdArg(), const RooCmdArg& arg2 = RooCmdArg(), const RooCmdArg& arg3 = RooCmdArg(), const RooCmdArg& arg4 = RooCmdArg(), const RooCmdArg& arg5 = RooCmdArg(), const RooCmdArg& arg6 = RooCmdArg(), const RooCmdArg& arg7 = RooCmdArg(), const RooCmdArg& arg8 = RooCmdArg(), const RooCmdArg& arg9 = RooCmdArg(), const RooCmdArg& arg10 = RooCmdArg()) const; virtual list<Double_t>*RooAbsReal::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; virtual RooPlot*RooAbsReal::plotSliceOn(RooPlot* frame, const RooArgSet& sliceSet, Option_",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsMoment.html:19454,optimiz,optimizeCacheMode,19454,root/html534/RooAbsMoment.html,https://root.cern,https://root.cern/root/html534/RooAbsMoment.html,4,['optimiz'],['optimizeCacheMode']
Performance,"st RooArgSet& compSet, const RooArgSet& intSet, RooArgSet& saveSet, const char* isetRangeName); voidRooAbsReal::makeProjectionSet(const RooAbsArg* plotVar, const RooArgSet* allVars, RooArgSet& projectedVars, Bool_t silent) const; voidTObject::MakeZombie(); Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgSet& set) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c) const; Bool_tRooAbsReal::matchArgs(const RooArgSet& allDeps, RooArgSet& numDeps, const RooArgProxy& a, const RooArgProxy& b, const RooArgProxy& c, const RooArgProxy& d) const; Int_tRooAbsArg::numProxies() const; virtual voidoperModeHook(); virtual voidRooAbsArg::optimizeDirtyHook(const RooArgSet*); virtual RooPlot*RooAbsReal::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsReal::PlotOpt o) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooLinkedList& cmdList) const; virtual RooPlot*RooAbsReal::plotOn(RooPlot* frame, RooAbsReal::PlotOpt o) const; RooPlot*RooAbsReal::plotOnWithErrorBand(RooPlot* frame, const RooFitResult& fr, Double_t Z, const RooArgSet* params, const RooLinkedList& argList, Bool_t method1) const; Bool_tRooAbsReal::plotSanityChecks(RooPlot* frame) const; voidRooAbsArg::printAttribList(ostream& os) const; voidRooAbsArg::registerProxy(RooArgProxy& proxy); voidRooAbsArg::registerProxy(RooSetProxy& proxy); voidRooAbsArg::registerProxy(RooListProxy& proxy); voidRooAbsReal::selectComp(Bool_t flag); virtual voidRooAbsReal::selectNormalization(const RooArgSet* depSet = 0, Bool_t force = kFALSE); virtual voidRooAbsReal::selectNormalizationRange(const char* rangeName = 0, Bool_t force = kFALSE); voidRooAbsArg::setP",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooGenProdProj.html:27363,optimiz,optimizeDirtyHook,27363,root/html526/RooGenProdProj.html,https://root.cern,https://root.cern/root/html526/RooGenProdProj.html,1,['optimiz'],['optimizeDirtyHook']
Performance,"st RooArgSet&, RooArgSet&, RooLinkedList&); virtual voidprintCompactTreeHook(ostream&, const char*); virtual Bool_tredirectServersHook(const RooAbsCollection&, Bool_t, Bool_t, Bool_t); voidreset(); Int_tsetObj(const RooArgSet* nset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Int_tsetObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); virtual voidShowMembers(TMemberInspector& insp); voidsterilize(); virtual voidStreamer(TBuffer& b); voidStreamerNVirtual(TBuffer& b). Data Members; protected:. Int_t_lastIndexLast slot accessed; Int_t_maxSizeMaximum size; RooNormSetCache*_nsetCache! Normalization/Integration set manager; RooAbsCacheElement**_object! Payload; RooAbsArg*RooAbsCache::_ownerPointer to owning RooAbsArg; Int_t_sizeActual use. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; void RooCacheManager<T> reset(); Clear the cache. void RooCacheManager<T> sterilize(); Clear the cache payload but retain slot mapping w.r.t to; normalization and integration sets. Int_t RooCacheManager<T> setObj(const RooArgSet* nset, const RooArgSet* iset, RooAbsCacheElement* obj, const TNamed* isetRangeName = 0); Insert payload object 'obj' in cache indexed on nset,iset and isetRangeName. T* RooCacheManager<T> getObj(const RooArgSet* nset, const RooArgSet* iset, Int_t* sterileIdx = 0, const TNamed* isetRangeName = 0); Retrieve payload object indexed on nset,uset amd isetRangeName; If sterileIdx is not null, it is set to the index of the sterile; slot in cacse such a slot is recycled. T* RooCacheManager<T> getObjByIndex(Int_t index) const; Retrieve payload object by slot index. const RooNameSet* RooCacheManager<T> nameSet1ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. const RooNameSet* RooCacheManager<T> nameSet2ByIndex(Int_t index) const; Retrieve RooNameSet associated with slot at given index. T* getObj(const RooArgSet* nset, Int_t* st",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/RooCacheManager_RooAbsCacheElement_.html:3303,cache,cache,3303,root/html528/RooCacheManager_RooAbsCacheElement_.html,https://root.cern,https://root.cern/root/html528/RooCacheManager_RooAbsCacheElement_.html,1,['cache'],['cache']
Performance,"st RooArgSet* normSet = 0); virtual~RooDataProjBinding(); virtual list<Double_t>*RooRealBinding::binBoundaries(Int_t) const; static TClass*Class(); UInt_tRooAbsFunc::getDimension() const; virtual Double_tRooRealBinding::getMaxLimit(UInt_t dimension) const; virtual Double_tRooRealBinding::getMinLimit(UInt_t dimension) const; virtual const char*RooRealBinding::getName() const; virtual TClass*IsA() const; Bool_tRooAbsFunc::isValid() const; Int_tRooAbsFunc::numCall() const; virtual Double_toperator()(const Double_t* xvector) const; RooAbsFunc&RooAbsFunc::operator=(const RooAbsFunc&); virtual list<Double_t>*RooRealBinding::plotSamplingHint(RooAbsRealLValue&, Double_t, Double_t) const; voidRooAbsFunc::resetNumCall() const; virtual voidRooRealBinding::restoreXVec() const; virtual voidRooRealBinding::saveXVec() const; virtual voidShowMembers(TMemberInspector&); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b). protected:. voidRooRealBinding::loadValues(const Double_t* xvector) const. Data Members; protected:. Roo1DTable*_catTableSupercategory table generated from _data; Bool_tRooRealBinding::_clipInvalid; list<RooAbsReal*>RooRealBinding::_compList!; list<Double_t>RooRealBinding::_compSave!; const RooAbsData*_dataDataset used for projection; UInt_tRooAbsFunc::_dimensionNumber of observables; Bool_t_firstBit indicating if operator() has been called yet; const RooAbsReal*RooRealBinding::_func; Double_tRooRealBinding::_funcSave!; Int_tRooAbsFunc::_ncallFunction call counter; const RooArgSet*_nsetNormalization set for real function; const RooArgSet*RooRealBinding::_nset; const TNamed*RooRealBinding::_rangeName!; const RooAbsReal*_realReal function to be projected; RooSuperCategory*_superCatSupercategory constructed from _data's category variables; Bool_tRooAbsFunc::_validIs binding in valid state?; RooAbsRealLValue**RooRealBinding::_vars; Double_t*RooRealBinding::_xsave; Bool_tRooRealBinding::_xvecValid. Class Charts. Inheritance; Inherit",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooDataProjBinding.html:1929,load,loadValues,1929,root/html534/RooDataProjBinding.html,https://root.cern,https://root.cern/root/html534/RooDataProjBinding.html,2,['load'],['loadValues']
Performance,"st T *);  ; template<typename T > ; TClass * GetClass (const T **);  ; template<typename T > ; TClass * GetClass (const T *const *);  ; template<typename T > ; TClass * GetClass (T *);  ; template<typename T > ; TClass * GetClass (T **);  ; std::vector< std::unique_ptr< TClassRec > > & GetDelayedAddClass ();  ; std::vector< std::pair< const char *, const char * > > & GetDelayedAddClassAlternate ();  ; UInt_t GetImplicitMTPoolSize ();  Returns the size of the pool used for implicit multi-threading. More...;  ; TString & GetMacroPath ();  ; TROOT * GetROOT ();  ; void GetRuleIncludes (std::list< std::string > &result);  Get the list of includes specified in the shema rules. More...;  ; UInt_t GetThreadPoolSize ();  Returns the size of ROOT's thread pool. More...;  ; bool HasValidDataMembers (SchemaRuleMap_t &rule, MembersTypeMap_t &members, std::string &error_string);  Check if given rule contains references to valid data members. More...;  ; Bool_t IsImplicitMTEnabled ();  Returns true if the implicit multi-threading in ROOT is enabled. More...;  ; template<class T > ; TSeq< T > MakeSeq (T begin, T end, T step=1);  ; template<class T > ; TSeq< T > MakeSeq (T end);  ; bool ParseRule (std::string command, ROOT::Internal::MembersMap_t &result, std::string &error_string);  Parse the schema rule as specified in the LinkDef file. More...;  ; void ProcessReadPragma (const char *args, std::string &error_string);  I am being called when a read pragma is encountered. More...;  ; void ProcessReadRawPragma (const char *args, std::string &error_string);  I am being called then a readraw pragma is encountered. More...;  ; TNamed * RegisterClassTemplate (const char *name, const char *file, Int_t line);  Global function to register the implementation file and line of a class template (i.e. More...;  ; void RemoveClass (const char *cname);  Global function called by the dtor of a class's init class (see the ClassImp macro). More...;  ; void ResetClassVersion (TClass *, const char *, S",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v622/namespaceROOT.html:9281,multi-thread,multi-threading,9281,doc/v622/namespaceROOT.html,https://root.cern,https://root.cern/doc/v622/namespaceROOT.html,1,['multi-thread'],['multi-threading']
Performance,"st TGenCollectionProxy& c) : TGenVectorProxy(c); 236 {; 237 }; 238 // Standard Destructor; 239 ~TGenSetProxy() override; 240 {; 241 }; 242 // Return the address of the value at index 'idx'; 243 void* At(UInt_t idx) override; 244 {; 245 if ( fEnv && fEnv->fObject ) {; 246 if ( fEnv->fUseTemp ) {; 247 return (((char*)fEnv->fTemp)+idx*fValDiff);; 248 }; 249 switch( idx ) {; 250 case 0:; 251 fEnv->fIdx = idx;; 252 return fEnv->fStart = fFirst.invoke(fEnv);; 253 default: {; 254 fEnv->fIdx = idx - fEnv->fIdx;; 255 if (! fEnv->fStart ) fEnv->fStart = fFirst.invoke(fEnv);; 256 void* result = fNext.invoke(fEnv);; 257 fEnv->fIdx = idx;; 258 return result;; 259 }; 260 }; 261 }; 262 Fatal(""TGenSetProxy"",""At> Logic error - no proxy object set."");; 263 return nullptr;; 264 }; 265};; 266 ; 267/**; 268\class TGenMapProxy; 269\ingroup IO; 270Localoptimization class.; 271 ; 272Collection proxies get copied. On copy we switch the type of the; 273proxy to the concrete STL type. The concrete types are optimized; 274for element access.; 275*/; 276 ; 277class TGenMapProxy : public TGenSetProxy {; 278public:; 279 // Standard Destructor; 280 TGenMapProxy(const TGenCollectionProxy& c) : TGenSetProxy(c); 281 {; 282 }; 283 // Standard Destructor; 284 ~TGenMapProxy() override; 285 {; 286 }; 287 // Call to delete/destruct individual item; 288 void DeleteItem(Bool_t force, void* ptr) const override; 289 {; 290 if (force) {; 291 if ( fKey->fProperties&kNeedDelete) {; 292 TVirtualCollectionProxy *proxy = fKey->fType->GetCollectionProxy();; 293 TPushPop helper(proxy,fKey->fCase&kIsPointer ? *(void**)ptr : ptr);; 294 proxy->Clear(""force"");; 295 }; 296 if ( fVal->fProperties&kNeedDelete) {; 297 TVirtualCollectionProxy *proxy = fVal->fType->GetCollectionProxy();; 298 char *addr = ((char*)ptr)+fValOffset;; 299 TPushPop helper(proxy,fVal->fCase&kIsPointer ? *(void**)addr : addr);; 300 proxy->Clear(""force"");; 301 }; 302 }; 303 if ( fKey->fCase&kIsPointer ) {; 304 fKey->DeleteItem(*(void**)ptr);; 305 }; 306",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html:7684,optimiz,optimized,7684,doc/master/TGenCollectionProxy_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TGenCollectionProxy_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"st TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tTClass::GetCheckSum(Bool_t& isvalid) const; UInt_tTClass::GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tTClass::GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; TMethod*TClass::GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tTClass::GetClassSize() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; ROOT::ESTLTypeTClass::GetCollectionType() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tTClass::GetConvStreamerFunc() const; TVirtualStreamerInfo*TClass::GetCurrentStreamerInfo()",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TQClass.html:7609,load,load,7609,root/html604/TQClass.html,https://root.cern,https://root.cern/root/html604/TQClass.html,2,['load'],['load']
Performance,"st TObject* obj) const; TVirtualStreamerInfo*TClass::FindStreamerInfo(UInt_t checksum) const; TVirtualStreamerInfo*TClass::FindStreamerInfoAbstractEmulated(UInt_t checksum) const; TClass*TClass::GetActualClass(const void* object) const; TDictAttributeMap*TDictionary::GetAttributeMap() const; TClass*TClass::GetBaseClass(const char* classname); TClass*TClass::GetBaseClass(const TClass* base); Int_tTClass::GetBaseClassOffset(const TClass* toBase, void* address = 0, bool isDerivedObject = true); TClass*TClass::GetBaseDataMember(const char* datamember); UInt_tTClass::GetCheckSum(TClass::ECheckSum code = kCurrentCheckSum) const; UInt_tTClass::GetCheckSum(Bool_t& isvalid) const; UInt_tTClass::GetCheckSum(TClass::ECheckSum code, Bool_t& isvalid) const; static Bool_tTClass::GetClass(TDictionary::DeclId_t id, vector<TClass*>& classes); static TClass*TClass::GetClass(const char* name, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(const type_info& typeinfo, Bool_t load = kTRUE, Bool_t silent = kFALSE); static TClass*TClass::GetClass(ClassInfo_t* info, Bool_t load = kTRUE, Bool_t silent = kFALSE); ClassInfo_t*TClass::GetClassInfo() const; TMethod*TClass::GetClassMethod(const char* name, const char* params, Bool_t objectIsConst = kFALSE); TMethod*TClass::GetClassMethodWithPrototype(const char* name, const char* proto, Bool_t objectIsConst = kFALSE, ROOT::EFunctionMatchMode mode = ROOT::kConversionMatch); Int_tTClass::GetClassSize() const; Version_tTClass::GetClassVersion() const; TVirtualCollectionProxy*TClass::GetCollectionProxy() const; const char*TClass::GetContextMenuTitle() const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const char* onfile_classname, Int_t version) const; TVirtualStreamerInfo*TClass::GetConversionStreamerInfo(const TClass* onfile_cl, Int_t version) const; ClassConvStreamerFunc_tTClass::GetConvStreamerFunc() const; TVirtualStreamerInfo*TClass::GetCurrentStreamerInfo(); TDataMember*TClass::GetDataMember(const char* d",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TQClass.html:7609,load,load,7609,root/html602/TQClass.html,https://root.cern,https://root.cern/root/html602/TQClass.html,2,['load'],['load']
Performance,"st TString & THtml::GetMacroPath ; (; ); const. inline . Definition at line 302 of file THtml.h. ◆ GetMakeClassMutex(). TVirtualMutex * THtml::GetMakeClassMutex ; (; ); const. inline . Definition at line 343 of file THtml.h. ◆ GetModuleDefinition(). const THtml::TModuleDefinition & THtml::GetModuleDefinition ; (; ); const. Return the TModuleDefinition (or derived) object as set by SetModuleDefinition(); create and return a TModuleDefinition object if none was set. ; Definition at line 1311 of file THtml.cxx. ◆ GetModuleDocPath(). const TString & THtml::GetModuleDocPath ; (; ); const. inline . Definition at line 298 of file THtml.h. ◆ GetModuleMacroPath(). void THtml::GetModuleMacroPath ; (; const TString & ; module, . TString & ; out_path . ); const. inline . Definition at line 324 of file THtml.h. ◆ GetModuleNameForClass(). void THtml::GetModuleNameForClass ; (; TString & ; module, . TClass * ; cl . ); const. virtual . Return the module name for a given class. ; Use the cached information from fDocEntityInfo.fClasses. ; Definition at line 1540 of file THtml.cxx. ◆ GetNextClass(). TClassDocInfo * THtml::GetNextClass ; (; ). protected . Return the next class to be generated for MakeClassThreaded. ; Definition at line 1369 of file THtml.cxx. ◆ GetOutputDir(). const TString & THtml::GetOutputDir ; (; Bool_t ; createDir = kTRUE); const. Return the output directory as set by SetOutputDir(). ; Create it if it doesn't exist and if createDir is kTRUE. ; Definition at line 2177 of file THtml.cxx. ◆ GetPathDefinition(). const THtml::TPathDefinition & THtml::GetPathDefinition ; (; ); const. Return the TModuleDefinition (or derived) object as set by SetModuleDefinition(); create and return a TModuleDefinition object if none was set. ; Definition at line 1339 of file THtml.cxx. ◆ GetPathInfo(). const PathInfo_t & THtml::GetPathInfo ; (; ); const. inline . Definition at line 345 of file THtml.h. ◆ GetProductName(). const TString & THtml::GetProductName ; (; ); const. inline . Def",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTHtml.html:45840,cache,cached,45840,doc/v632/classTHtml.html,https://root.cern,https://root.cern/doc/v632/classTHtml.html,2,['cache'],['cached']
Performance,"st TString &containerName);  Constructor. ;  ; void AddDescriptor (TBranchProxyDescriptor *desc, bool isBase);  Add a descriptor to this proxy. ;  ; const char * GetBranchName () const;  Get the branch name. ;  ; TString GetContainerName () const;  Return the name of the container holding this class, if any. ;  ; TVirtualStreamerInfo * GetInfo () const;  ; ELocation GetIsClones () const;  Return whether the branch is inside, nested in or outside of a TClonesArray. ;  ; const char * GetRawSymbol () const;  Get the real symbol name. ;  ; UInt_t GetSplitLevel () const;  Return the split level of the branch. ;  ; const char * GetSubBranchPrefix () const;  Get the prefix from the branch name. ;  ; TClass * IsA () const override;  ; bool IsClones () const;  Return true if this proxy is for a TClonesArray. ;  ; virtual bool IsEquivalent (const TBranchProxyClassDescriptor *other);  Return true if this description is the 'same' as the other decription. ;  ; bool IsLoaded () const;  Return true if the class needed by the branch is loaded. ;  ; bool IsSTL () const;  Return true if this proxy is for a TClonesArray. ;  ; void OutputDecl (FILE *hf, int offset, UInt_t);  Output the declaration and implementation of this emulation class. ;  ; void Streamer (TBuffer &) override;  Stream an object of class TObject. ;  ; void StreamerNVirtual (TBuffer &ClassDef_StreamerNVirtual_b);  ;  Public Member Functions inherited from TNamed;  TNamed ();  ;  TNamed (const char *name, const char *title);  ;  TNamed (const TNamed &named);  TNamed copy ctor. ;  ;  TNamed (const TString &name, const TString &title);  ; virtual ~TNamed ();  TNamed destructor. ;  ; void Clear (Option_t *option="""") override;  Set name and title to empty strings (""""). ;  ; TObject * Clone (const char *newname="""") const override;  Make a clone of an object using the Streamer facility. ;  ; Int_t Compare (const TObject *obj) const override;  Compare two TNamed objects. ;  ; void Copy (TObject &named) const override;  Copy ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchProxyClassDescriptor.html:2724,load,loaded,2724,doc/master/classROOT_1_1Internal_1_1TBranchProxyClassDescriptor.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Internal_1_1TBranchProxyClassDescriptor.html,1,['load'],['loaded']
Performance,"st TVectorD& rho, TString options = ""a"", Double_t nSigma = 3, Bool_t rotate = kTRUE); Constructor. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooDataSet& data, RooNDKeysPdf::Mirror mirror = NoMirror, Double_t rho = 1, Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for (1-dim) RooKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const char* name, const char* title, RooAbsReal& x, RooAbsReal& y, RooDataSet& data, TString options = ""a"", Double_t rho = 1., Double_t nSigma = 3, Bool_t rotate = kTRUE); Backward compatibility constructor for Roo2DKeysPdf. If you are a new user,; please use the first constructor form. RooNDKeysPdf(const RooNDKeysPdf& other, const char* name = 0); Constructor. ~RooNDKeysPdf(). createPdf(Bool_t firstCall = kTRUE) const; evaluation order of constructor. setOptions() const; set the configuration. initialize() const; initialization. loadDataSet(Bool_t firstCall) const; copy the dataset and calculate some useful variables. mirrorDataSet() const; determine mirror dataset.; mirror points are added around the physical boundaries of the dataset; Two steps:; 1. For each entry, determine if it should be mirrored (the mirror configuration).; 2. For each mirror configuration, make the mirror points. loadWeightSet() const. calculateShell(RooNDKeysPdf::BoxInfo* bi) const; determine points in +/- nSigma shell around the box determined by the variable; ranges. These points are needed in the normalization, to determine probability; leakage in and out of the box. calculatePreNorm(RooNDKeysPdf::BoxInfo* bi) const; bi->nEventsBMSW=0.;; bi->nEventsBW=0.;. sortDataIndices(RooNDKeysPdf::BoxInfo* bi = 0) const; sort entries, as needed for loopRange(). calculateBandWidth() const. gauss(vector<Double_t>& x, vector<vector<Double_t> >& weights) const; loop over all closest point to x, as determined by loopRange(). loopRange(vector<Double_t>& x, map<Int_t,Bool_t>& ibMap) const; deter",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooNDKeysPdf.html:50853,load,loadDataSet,50853,root/html602/RooNDKeysPdf.html,https://root.cern,https://root.cern/root/html602/RooNDKeysPdf.html,4,['load'],['loadDataSet']
Performance,"st away, fCache should be mutable; 340 } else {; 341 Int_t idx;; 342 t = FindLink(obj, idx);; 343 if (t) ((TList*)this)->fCache = t->fNext;; 344 }; 345 ; 346 if (t && t->Next()); 347 return t->Next()->GetObject();; 348 else; 349 return nullptr;; 350}; 351 ; 352////////////////////////////////////////////////////////////////////////////////; 353/// Returns the object at position idx. Returns 0 if idx is out of range.; 354 ; 355TObject *TList::At(Int_t idx) const; 356{; 357 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 358 R__COLLECTION_WRITE_GUARD();; 359 ; 360 TObjLink *lnk = LinkAt(idx);; 361 if (lnk) return lnk->GetObject();; 362 return nullptr;; 363}; 364 ; 365////////////////////////////////////////////////////////////////////////////////; 366/// Returns the object before object obj. Obj is found using the; 367/// object's IsEqual() method. Returns 0 if obj is first in list.; 368 ; 369TObject *TList::Before(const TObject *obj) const; 370{; 371 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 372 R__COLLECTION_WRITE_GUARD();; 373 ; 374 TObjLink *t;; 375 ; 376 auto cached = fCache.lock();; 377 if (cached.get() && cached->GetObject() && cached->GetObject()->IsEqual(obj)) {; 378 t = cached.get();; 379 ((TList*)this)->fCache = cached->fPrev; //cast const away, fCache should be mutable; 380 } else {; 381 Int_t idx;; 382 t = FindLink(obj, idx);; 383 if (t) ((TList*)this)->fCache = t->fPrev;; 384 }; 385 ; 386 if (t && t->Prev()); 387 return t->Prev()->GetObject();; 388 else; 389 return nullptr;; 390}; 391 ; 392////////////////////////////////////////////////////////////////////////////////; 393/// Remove all objects from the list. Does not delete the objects; 394/// unless the TList is the owner (set via SetOwner()) and option; 395/// ""nodelete"" is not set.; 396/// If option=""nodelete"" then don't delete any heap objects that were; 397/// marked with the kCanDelete bit, otherwise these objects will be; 398/// deleted (this option is used by THashTable::Clear()).; 39",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:10952,cache,cached,10952,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['cache'],['cached']
Performance,"st char * GetSoExt() const; Get the shared library extension. const char * GetObjExt() const; Get the object file extension. void SetBuildDir(const char* build_dir, Bool_t isflat = kFALSE); Set the location where ACLiC will create libraries and use as; a scratch area.; If isflast is flase, then the libraries are actually stored in; sub-directories of 'build_dir' including the full pathname of the; script. If the script is location at /full/path/name/macro.C; the library will be located at 'build_dir+/full/path/name/macro_C.so'; If 'isflat' is true, then no subdirectory is created and the library; is created directly in the directory 'build_dir'. Note that in this; mode there is a risk than 2 script of the same in different source; directory will over-write each other. void SetFlagsDebug(const char* ); FlagsDebug should contain the options to pass to the C++ compiler; in order to compile the library in debug mode. void SetFlagsOpt(const char* ); FlagsOpt should contain the options to pass to the C++ compiler; in order to compile the library in optimized mode. void SetAclicMode(TSystem::EAclicMode mode); AclicMode indicates whether the library should be built in; debug mode or optimized. The values are:; TSystem::kDefault : compile the same as the current ROOT; TSystem::kDebug : compiled in debug mode; TSystem::kOpt : optimized the library. void SetMakeExe(const char* directives); Directives has the same syntax as the argument of SetMakeSharedLib but is; used to create an executable. This creation is used as a means to output; a list of unresolved symbols, when loading a shared library has failed.; The required variable is $ExeName rather than $SharedLib, e.g.:; gSystem->SetMakeExe(; ""g++ -Wall -fPIC $IncludePath $SourceFiles; -o $ExeName $LinkedLibs -L/usr/X11R6/lib -lX11 -lm -ldl -rdynamic"");. void SetMakeSharedLib(const char* directives); Directives should contain the description on how to compile and link a; shared lib. This description can be any valid shell comm",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TSystem.html:44582,optimiz,optimized,44582,root/html528/TSystem.html,https://root.cern,https://root.cern/root/html528/TSystem.html,10,['optimiz'],['optimized']
Performance,"st char *name, const char *title, const RooArgSet &obs);  Create an empty dataset to hold the events that will be generated. ;  ; void resampleData (double &ratio);  Rescale existing output buffer with given ratio. ;  ;  Protected Member Functions inherited from TObject; virtual void DoError (int level, const char *location, const char *fmt, va_list va) const;  Interface to ErrorHandler (protected). ;  ; void MakeZombie ();  . Protected Attributes; bool _expectedData;  Asimov? ;  ; std::unique_ptr< RooDataHist > _hist;  Histogram. ;  ; RooAbsPdf * _pdf;  Pointer to cloned p.d.f. ;  ; RooArgSet _pdfSet;  Set owned all nodes of internal clone of p.d.f. ;  ; std::unique_ptr< RooArgSet > _vars;  ;  Protected Attributes inherited from RooAbsGenContext; UInt_t _expectedEvents;  Number of expected events from extended p.d.f. ;  ; RooAbsPdf::ExtendMode _extendMode;  Extended mode capabilities of p.d.f. ;  ; RooDataSet * _genData = nullptr;  ! Data being generated ;  ; bool _isValid;  Is context in valid state? ;  ; Int_t _nextProtoIndex;  Next prototype event to load according to LUT. ;  ; TString _normRange;  Normalization range of pdf. ;  ; std::vector< Int_t > _protoOrder;  LUT with traversal order of prototype data. ;  ; const RooDataSet * _prototype;  Pointer to prototype dataset. ;  ; RooArgSet _protoVars;  Prototype observables. ;  ; RooArgSet _theEvent;  Pointer to observable event being generated. ;  ; bool _verbose;  Verbose messaging? ;  ;  Protected Attributes inherited from TNamed; TString fName;  ; TString fTitle;  . Additional Inherited Members;  Public Types inherited from TObject; enum  { ;   kIsOnHeap = 0x01000000; , kNotDeleted = 0x02000000; , kZombie = 0x04000000; , kInconsistent = 0x08000000; , ;   kBitMask = 0x00ffffff. };  ; enum  { kSingleKey = (1ULL << ( 0 )); , kOverwrite = (1ULL << ( 1 )); , kWriteDelete = (1ULL << ( 2 )); };  ; enum  EDeprecatedStatusBits { kObjInCanvas = (1ULL << ( 3 )); };  ; enum  EStatusBits { ;   kCanDelete = (1ULL << ( 0 ))",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooBinnedGenContext.html:15190,load,load,15190,doc/master/classRooBinnedGenContext.html,https://root.cern,https://root.cern/doc/master/classRooBinnedGenContext.html,1,['load'],['load']
Performance,"st char *option=nullptr, Int_t maxUnrolling=3)Generate a skeleton analysis class for this Tree using TBranchProxy.Definition TTree.cxx:6768; TTree::kSplitCollectionOfPointers@ kSplitCollectionOfPointersDefinition TTree.h:266; TTree::ReadStreamvirtual Long64_t ReadStream(std::istream &inputStream, const char *branchDescriptor="""", char delimiter=' ')Create or simply read branches from an input stream.Definition TTree.cxx:7615; TTree::SetDebugvirtual void SetDebug(Int_t level=1, Long64_t min=0, Long64_t max=9999999)Set the debug level and the debug range.Definition TTree.cxx:8928; TTree::fScanFieldInt_t fScanFieldNumber of runs before prompting in Scan.Definition TTree.h:92; TTree::Drawvoid Draw(Option_t *opt) overrideDefault Draw method for all objects.Definition TTree.h:431; TTree::GetFriendvirtual TTree * GetFriend(const char *) constReturn a pointer to the TTree friend whose name or alias is friendname.Definition TTree.cxx:5975; TTree::SetNotifyvirtual void SetNotify(TObject *obj)Sets the address of the object to be notified when the tree is loaded.Definition TTree.cxx:9231; TTree::GetMaximumvirtual Double_t GetMaximum(const char *columname)Return maximum of column with name columname.Definition TTree.cxx:6235; TTree::GetEntryNumberWithBestIndexvirtual Long64_t GetEntryNumberWithBestIndex(Long64_t major, Long64_t minor=0) constReturn entry number corresponding to major and minor number.Definition TTree.cxx:5890; TTree::SetMaxTreeSizestatic void SetMaxTreeSize(Long64_t maxsize=100000000000LL)Set the maximum size in bytes of a Tree file (static function).Definition TTree.cxx:9197; TTree::Printvoid Print(Option_t *option="""") const overridePrint a summary of the tree contents.Definition TTree.cxx:7219; TTree::UnbinnedFitvirtual Int_t UnbinnedFit(const char *funcname, const char *varexp, const char *selection="""", Option_t *option="""", Long64_t nentries=kMaxEntries, Long64_t firstentry=0)Unbinned fit of one or more variable(s) from a tree.Definition TTree.cxx:9702; TTree:",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TTree_8cxx_source.html:442348,load,loaded,442348,doc/master/TTree_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TTree_8cxx_source.html,1,['load'],['loaded']
Performance,"st char *signal, const char *receiver_class, void *receiver, const char *slot);  This method allows to make a connection from any object of the same class to a single slot. ;  ; static Bool_t Connect (TQObject *sender, const char *signal, const char *receiver_class, void *receiver, const char *slot);  Create connection between sender and receiver. ;  ; static const char * DeclFileName ();  ; static Bool_t Disconnect (const char *class_name, const char *signal, void *receiver=nullptr, const char *slot=nullptr);  Disconnects ""class signal"". ;  ; static Bool_t Disconnect (TQObject *sender, const char *signal=nullptr, void *receiver=nullptr, const char *slot=nullptr);  Disconnects signal in object sender from slot_method in object receiver. ;  . Protected Member Functions;  TProofLite ();  ; Int_t CopyMacroToCache (const char *macro, Int_t headerRequired=0, TSelector **selector=0, Int_t opt=0, TList *wrks=0);  Copy a macro, and its possible associated .h[h] file, to the cache directory, from where the workers can get the file. ;  ; Int_t Init (const char *masterurl, const char *conffile, const char *confdir, Int_t loglevel, const char *alias=0);  Start the PROOF environment. ;  ; TProofQueryResult * MakeQueryResult (Long64_t nent, const char *opt, Long64_t fst, TDSet *dset, const char *selec);  Create a TProofQueryResult instance for this query. ;  ; Int_t PollForNewWorkers () override;  Simulate dynamic addition, for test purposes. ;  ; void SetQueryRunning (TProofQueryResult *pq);  Set query in running state. ;  ; Int_t SetupWorkers (Int_t opt=0, TList *wrks=0);  Start up PROOF workers. ;  ;  Protected Member Functions inherited from TProof;  TProof ();  Protected constructor to be used by classes deriving from TProof (they have to call Init themselves and override StartSlaves appropriately). ;  ; Int_t AddWorkers (TList *wrks);  Works on the master node only. ;  ; Int_t AssertPath (const char *path, Bool_t writable);  Make sure that 'path' exists; if 'writable' is kTR",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTProofLite.html:35314,cache,cache,35314,doc/master/classTProofLite.html,https://root.cern,https://root.cern/doc/master/classTProofLite.html,1,['cache'],['cache']
Performance,"st char * ; title, . int ; imin1, . int ; imax1, . int ; imin2, . int ; imax2, . const TAxis * ; projAxis, . const TAxis * ; axis1, . const TAxis * ; axis2, . Option_t * ; option . ); const. protectedvirtual . internal method performing the projection to 1D histogram called from TH3::Project3D ; Definition at line 1829 of file TH3.cxx. ◆ DoProject1D() [3/3]. TH1D * TH3::DoProject1D ; (; const TH3 & ; h, . const char * ; name, . const char * ; title, . const TAxis * ; projX, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ). staticprotected . static methdod performing the projection to 1D histogram ; Definition at line 3504 of file TH3.cxx. ◆ DoProject2D() [1/2]. TH2D * TH3::DoProject2D ; (; const char * ; name, . const char * ; title, . const TAxis * ; projX, . const TAxis * ; projY, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ); const. protectedvirtual . internal method performing the projection to a 2D histogram called from TH3::Project3D ; Definition at line 2103 of file TH3.cxx. ◆ DoProject2D() [2/2]. TH2D * TH3::DoProject2D ; (; const TH3 & ; h, . const char * ; name, . const char * ; title, . const TAxis * ; projX, . const TAxis * ; projY, . bool ; computeErrors, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ). staticprotected . static methdod performing the projection to 2D histogram ; Definition at line 3513 of file TH3.cxx. ◆ DoProjectProfile2D(). TProfile2D * TH3::DoProjectProfile2D ; (; const char * ; name, . const char * ; title, . const TAxis * ; projX, . const TAxis * ; projY, . bool ; originalRange, . bool ; useUF, . bool ; useOF . ); const. protectedvirtual . internal method to project to a 2D Profile called from TH3::Project3DProfile ; Reimplemented in TProfile3D.; Definition at line 2576 of file TH3.cxx. ◆ Fill() [1/15]. Int_t TH3::Fill ; (; const char * ; , . const char * ; , . Double_t ;  . ). inlineprotected . Definition at line 63 of file TH3.h. ◆ Fill() [2/15]. In",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTH3.html:67778,perform,performing,67778,doc/master/classTH3.html,https://root.cern,https://root.cern/doc/master/classTH3.html,1,['perform'],['performing']
Performance,"st char * fDeclFileName;  ; ROOT::DelFunc_t fDelete;  ; ROOT::DelArrFunc_t fDeleteArray;  ; ROOT::DesFunc_t fDestructor;  ; ROOT::DirAutoAdd_t fDirAutoAdd;  ; std::atomic< TListOfEnums * > fEnums;  ; TListOfFunctionTemplates * fFuncTemplate;  ; IsAGlobalFunc_t fGlobalIsA;  pointer to the class's IsA proxy. ;  ; Bool_t fHasCustomStreamerMember: 1;  The class has a Streamer method and it is implemented by the user or an older (not StreamerInfo based) automatic streamer. ;  ; std::atomic< Bool_t > fHasRootPcmInfo;  C++ Property of the class (is abstract, has virtual table, etc.) ;  ; Short_t fImplFileLine;  ; const char * fImplFileName;  ; UInt_t fInstanceCount;  ; TVirtualIsAProxy * fIsA;  ; std::atomic< TMethodCall * > fIsAMethod;  ; std::atomic< Bool_t > fIsOffsetStreamerSet;  Indicates whether the ClassInfo is supposed to be available. ;  ; Bool_t fIsSyntheticPair: 1;  Indicates whether this class can be split or not. Values are -1, 0, 1, 2. ;  ; std::atomic< TVirtualStreamerInfo * > fLastReadInfo;  cached current streamer info. ;  ; ROOT::MergeFunc_t fMerge;  saved info to call a IsA member function ;  ; std::atomic< TListOfFunctions * > fMethod;  ; ROOT::NewFunc_t fNew;  ; ROOT::NewArrFunc_t fNewArray;  ; RepoCont_t fObjectVersionRepository;  ; Longptr_t fOffsetStreamer;  Properties that can only be evaluated at run-time. ;  ; UInt_t fOnHeap;  ; TVirtualMutex * fOVRMutex = nullptr;  ; std::atomic< TClass ** > fPersistentRef;  ; std::atomic< Long_t > fProperty;  ; TList * fRealData;  ; TVirtualRefProxy * fRefProxy;  cached streamer info used in the last read. ;  ; ROOT::ResetAfterMergeFunc_t fResetAfterMerge;  ; std::atomic< UChar_t > fRuntimeProperties;  ; ROOT::Detail::TSchemaRuleSet * fSchemaRules;  Pointer to reference proxy if this class represents a reference. ;  ; TString fSharedLibs;  ; ShowMembersFunc_t fShowMembers;  ; Int_t fSizeof;  ; EState fState;  cached of the streaming method to use ;  ; TClassStreamer * fStreamer;  ; ClassStreamerFunc_t fStreamerF",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTClass.html:45042,cache,cached,45042,doc/v632/classTClass.html,https://root.cern,https://root.cern/doc/v632/classTClass.html,2,['cache'],['cached']
Performance,"st char dpyName wid window const char font_name cursor keysym reg const char only_if_exist regb h Point_t winding char text const char depth char const char Int_t count const char ColorStruct_t color const char Pixmap_t Pixmap_t PictureAttributes_t attr const char char ret_data h unsigned char height h Atom_t Int_t ULong_t ULong_t unsigned char prop_list Atom_t Atom_t Atom_t Time_t formatDefinition TGWin32VirtualXProxy.cxx:249; [#0] WARNING:InputArguments -- The parameter 'sigG' with range [-10, 10] of the RooGaussian 'g' exceeds the safe range of (0, inf). Advise to limit its range.; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Fitting -- RooAbsPdf::fitTo(model0_over_model0_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_model0_over_model0_Int[x]_sumData) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; Minuit2Minimizer: Minimize with max-calls 1000 convergence for edm < 1 strategy 1; Minuit2Minimizer : Valid minimum - status = 0; FVAL = -2388.31039421315518; Edm = 3.25299757922590944e-06; Nfcn = 60; Abkg = 0.0614547 +/- 0.00211669 (limited); Asig = 0.833778 +/- 0.1898 (limited); [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; [#1] INFO:Minimization -- p.d.f. provides expected number of events, including extended term in likelihood.; [#1] INFO:Minimization -- Including the following constraint terms in minimization: (hc_sig,hc_bkg); [#1] INFO:Minimization -- The global observables are not defined , normalize constraints with respect to the parameters (Abkg,Asig,p_ph_bkg_gamma_bin_0,p_ph_bkg_gamma_bin_1,p_ph_bkg_gamma_bin_10,p_ph_bkg_gamma_bin_11,p_ph_bkg_gamma_bin_12,p_ph_bkg_gamma",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html:8888,optimiz,optimization,8888,doc/master/rf709__BarlowBeeston_8py.html,https://root.cern,https://root.cern/doc/master/rf709__BarlowBeeston_8py.html,1,['optimiz'],['optimization']
Performance,"st char* aliasName, const char* aliasFormula); virtual voidSetAutoDelete(Bool_t autodel = kTRUE); virtual voidTTree::SetAutoFlush(Long64_t autof = 30000000); virtual voidTTree::SetAutoSave(Long64_t autos = 300000000); virtual voidTTree::SetBasketSize(const char* bname, Int_t buffsize = 16000); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr = 0); virtual Int_tSetBranchAddress(const char* bname, void* add, TClass* realClass, EDataType datatype, Bool_t isptr); virtual Int_tSetBranchAddress(const char* bname, void* add, TBranch** ptr, TClass* realClass, EDataType datatype, Bool_t isptr); virtual voidSetBranchStatus(const char* bname, Bool_t status = 1, UInt_t* found = 0); static voidTTree::SetBranchStyle(Int_t style = 1); virtual voidTTree::SetCacheEntryRange(Long64_t first, Long64_t last); virtual voidTTree::SetCacheLearnEntries(Int_t n = 10); virtual voidTTree::SetCacheSize(Long64_t cachesize = -1); virtual voidTTree::SetChainOffset(Long64_t offset = 0); virtual voidTTree::SetCircular(Long64_t maxEntries); virtual voidTTree::SetDebug(Int_t level = 1, Long64_t min = 0, Long64_t max = 9999999)MENU ; virtual voidTTree::SetDefaultEntryOffsetLen(Int_t newdefault, Bool_t updateExisting = kFALSE); virtual voidSetDirectory(TDirectory* dir); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); virtual Long64_tTTree::SetEntries(Long64_t n = -1); virtual voidSetEntryList(TEntryList* elist, Option_t* opt = """"); virtual voidSetEntryListFile(const char* filename = """", Option_t* opt = """"); virtual voidTTree::SetEstimate(Long64_t nentries = 10000); virtual voidSetEventList(TEventList* evlist); virtual voidTTree::SetFileNumber(Int_t number = 0); virtual voidTAttFill::SetFillAttributes()MENU ; virtual voidTAttFill::SetFillColor(Color_t fcolor); virtual voidTAttFill::SetFillStyle(Style_t fstyle); virtual voidTAttLine::SetLineAttribut",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/TChain.html:15246,cache,cachesize,15246,root/html526/TChain.html,https://root.cern,https://root.cern/root/html526/TChain.html,5,['cache'],['cachesize']
Performance,"st char* fmt, va_list va) const; voidFillPerfStatPerfPlots(TTree* t, Int_t nactive); voidTObject::MakeZombie(); Int_tSetParameters(). private:. voidBuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TStringTProofBenchRun::fParListList of PARs to be loaded; TProof*TProofBenchRun::fProofProof; TStringTProofBenchRun::fSelNameName of the selector to be run. private:. TCanvas*fCanvascanvas for performance plots; Int_tfDebugdebug switch; TDirectory*fDirProofBenchdirectory for proof outputs; Int_tfDrawdraw switch; TPBHistType*fHistTypehistogram type; TH2*fHist_perfstat_event; TList*fListPerfPlotslist of performance plots; Long64_tfNEventsnumber of events to generate; Int_tfNHistsnumber of histograms; Int_tfNTriesnumber of tries ; TStringfNamename of CPU run; TProofNodes*fNodesnode information; TProfile*fNorm_queryresult_event; TProfile*fProfile_perfstat_event; TProfile*fProfile_queryresult_event; Int_tfStartstart number of workers to scan; Int_tfSteptest to be performed every fStep workers; Int_tfStopstop number of workers to scan. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TProofBenchRunCPU(TPBHistType* histtype = 0, Int_t nhists = 16, TDirectory* dirproofbench = 0, TProof* proof = 0, TProofNodes* nodes = 0, Long64_t nevents = 1000000, Int_t ntries = 2, Int_t start = 1, Int_t stop = -1, Int_t step = 1, Int_t draw = 0, Int_t debug = 0); Default constructor. ~TProofBenchRunCPU(); Destructor. void BuildHistos(Int_t start, Int_t stop, Int_t step, Bool_t nx); Build histograms, profiles and graphs needed for this run. void Run(Long64_t nevents, Int_t start, Int_t stop, Int_t step, Int_t ntries, Int_t debug, Int_t draw); Run benchmark; Inpu",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TProofBenchRunCPU.html:6935,perform,performance,6935,root/html530/TProofBenchRunCPU.html,https://root.cern,https://root.cern/root/html530/TProofBenchRunCPU.html,9,['perform'],"['performance', 'performed']"
Performance,"st char* fmt, va_list va) const; voidGetFileName(const char* filename, TString& fn, Bool_t* = 0); voidTObject::MakeZombie(). private:. TEntryList&operator=(const TEntryList&). Data Members; public:. enum { kBlockSize; };; enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. protected:. TObjArray*fBlocksblocks with indices of passing events (TEntryListBlocks); TEntryList*fCurrent! currently filled entry list; TDirectory*fDirectory! Pointer to directory holding this tree; Long64_tfEntriesToProcessused on proof to set the number of entries to process in a packet; TStringfFileNamename of the file, where the tree is; Long64_tfLastIndexQueried! used to optimize GetEntry() function from a loop ; Long64_tfLastIndexReturned! used to optimize GetEntry() function from a loop; TList*fListsa list of underlying entry lists for each tree of a chain; Long64_tfNnumber of entries in the list; Int_tfNBlocksnumber of TEntryListBlocks; TStringTNamed::fNameobject identifier; Bool_tfReapplyIf true, TTree::Draw will 'reapply' the original cut; Bool_tfShift! true when some sub-lists don't correspond to trees; ULong_tfStringHash! Hash value of a string of treename and filename; TStringTNamed::fTitleobject title; TStringfTreeNamename of the tree; Int_tfTreeNumber! the index of the tree in the chain (used when the entry. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEntryList(); default c-tor. TEntryList(const char* name, const char* title); c-tor with name and title. TEntryList(const char* name, const char* title, const TTree* tree); constructor with name and title, which also sets the tree. TEntryList(const char* name, const char* title, const char* treename, const char* filename); c-tor with name and title, which also sets the treename and the filen",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TEntryList.html:16787,optimiz,optimize,16787,root/html534/TEntryList.html,https://root.cern,https://root.cern/root/html534/TEntryList.html,4,['optimiz'],['optimize']
Performance,"st char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidsetUnit(const char* unit); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector& insp) const; RooAbsMoment*sigma(RooRealVar& obs); RooAbsMoment*sigma(RooRealVar& obs, const RooArgSet& nset); virtual Int_tTNamed::Sizeof() const; RooNumIntConfig*specialIntegratorConfig() const; RooNumIntConfig*specialIntegratorConfig(Bool_t createOnTheFly); virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<string,string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsReal.html:25501,cache,cache,25501,root/html602/RooAbsReal.html,https://root.cern,https://root.cern/root/html602/RooAbsReal.html,4,['cache'],['cache']
Performance,"st char* libname, Bool_t check = kFALSE); Check if class ""classname"" is known to the interpreter (in fact,; this check is not needed anymore, so classname is ignored). If; not it will load library ""libname"". If the library name does; not start with ""lib"", ""lib"" will be prepended and a search will; be made in the DynamicPath (see .rootrc). If not found a search; will be made on libname (without ""lib"" prepended) and if not found; a direct try of libname will be made (in case it contained an; absolute path).; If check is true it will only check if libname exists and is; readable.; Returns 0 on successful loading, -1 in case libname does not; exist or in case of error and -2 in case of version mismatch. void ls(Option_t* option = """") const; To list all objects of the application.; Loop on all objects created in the ROOT linked lists.; Objects may be files and windows or any other object directly; attached to the ROOT linked list. Int_t LoadMacro(const char* filename, Int_t* error = 0, Bool_t check = kFALSE); Load a macro in the interpreter's memory. Equivalent to the command line; command "".L filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]].; The possible error codes are defined by TInterpreter::EErrorCode.; If check is true it will only check if filename exists and is; readable.; Returns 0 on successful loading and -1 in case filename does not; exist or in case of error. Long_t Macro(const char* filename, Int_t* error = 0, Bool_t padUpdate = kTRUE); Execute a macro in the interpreter. Equivalent to the command line; command "".x filename"". If the filename has ""+"" or ""++"" appended; the macro will be compiled by ACLiC. The filename must have the format:; [path/]macro.C[+|++[g|O]][(args)].; The possible error codes are defined by TInterpreter::EErrorCode.; If padUpdate is true (default) update the current pad.; Returns the macro return value. void Message(Int_t id, const ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TROOT.html:28214,Load,LoadMacro,28214,root/html532/TROOT.html,https://root.cern,https://root.cern/root/html532/TROOT.html,4,['Load'],"['Load', 'LoadMacro']"
Performance,"st char* name = 0, Int_t option = 0, Int_t bufsize = 0) const. protected:. TGeoManager(const TGeoManager&); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidTObject::MakeZombie(); TGeoManager&operator=(const TGeoManager&). private:. voidInit(); Bool_tInitArrayPNE() const; Bool_tInsertPNEId(Int_t uid, Int_t ientry); Bool_tIsLoopingVolumes() const; voidSetLoopVolumes(Bool_t flag = kTRUE); voidUpdateElements(); voidVoxelize(Option_t* option = 0). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };. public:. vector<ThreadData_t*>fThreadData! Thread private data; Int_tfThreadSize! Length of thread data. protected:. TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title; static Bool_tfgLock! Lock preventing a second geometry to be loaded; static Int_tfgVerboseLevel! Verbosity level for Info messages (no IO). private:. Bool_tfActivity! switch ON/OFF volume activity (default OFF - all volumes active)); TObjArray*fArrayPNE! array of phisical node entries; UChar_t*fBits! bits used for voxelization; TGeoShape*fClippingShape! clipping shape for raytracing; Bool_tfClosed! flag that geometry is closed; TGeoNavigator*fCurrentNavigator! current navigator; TVirtualGeoTrack*fCurrentTrack! current track; TGeoVolume*fCurrentVolume! current volume; Bool_tfDrawExtra! flag that the list of physical nodes has to be drawn; TGeoElementTable*fElementTable! table of elements; Int_tfExplodedViewexploded view mode; TGeoHMatrix*fGLMatrixmatrix to be used for view transformations; TObjArray*fGShapes! list of runtime shapes; TObjArray*fGVolumes! list of runtime volumes; THashList*fHashGVolumes! hash list of group volumes providing fast search; THashList*fHashPNE-> hash list of phisical node entries; THashList*",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TGeoManager.html:32703,load,loaded,32703,root/html532/TGeoManager.html,https://root.cern,https://root.cern/root/html532/TGeoManager.html,2,['load'],['loaded']
Performance,"st char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TEnum* e); Mark enum 'e' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfEnums(const TListOfEnums& ). TListOfEnums& operator=(const TListOfEnums& ). void SetClass(TClass* cl); { fClass = cl; }. TClass * GetClass() const; {return fClass;}. TExMap * GetIds(); { return fIds;}. TEnum * FindUnloaded(const char* name); { return (TEnum*)fUnloaded->FindObject(name);}. Bool_t IsLoaded() const; { return fIsLoaded; }. » Author: Bianca-Cristina Cristescu February 2014 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-0",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TListOfEnums.html:14473,Load,Load,14473,root/html604/TListOfEnums.html,https://root.cern,https://root.cern/root/html604/TListOfEnums.html,2,['Load'],['Load']
Performance,"st char* name); Return (after creating it if necessary) the TEnum; describing the enum corresponding to the Decl 'id'. TEnum * GetObject(const char* ) const; Return an object from the list of enums *if and only if* is has already; been loaded in the list. This is an internal routine. void UnmapObject(TObject* obj); Remove a pair<id, object> from the map of functions and their ids. void RecursiveRemove(TObject* obj); Remove object from this collection and recursively remove the object; from all other objects (and collections).; This function overrides TCollection::RecursiveRemove that calls; the Remove function. THashList::Remove cannot be called because; it uses the hash value of the hash table. This hash value; is not available anymore when RecursiveRemove is called from; the TObject destructor. TObject * Remove(TObject* obj); Remove object from the list. TObject * Remove(TObjLink* lnk); Remove object via its objlink from the list. void Load(); Load all the DataMembers known to the intepreter for the scope 'fClass'; into this collection. void Unload(); Mark 'all func' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. void Unload(TEnum* e); Mark enum 'e' as being unloaded.; After the unload, the data member can no longer be found directly,; until the decl can be found again in the interpreter (in which; the func object will be reused. TListOfEnums(const TListOfEnums& ). TListOfEnums& operator=(const TListOfEnums& ). void SetClass(TClass* cl); { fClass = cl; }. TClass * GetClass() const; {return fClass;}. TExMap * GetIds(); { return fIds;}. TEnum * FindUnloaded(const char* name); { return (TEnum*)fUnloaded->FindObject(name);}. Bool_t IsLoaded() const; { return fIsLoaded; }. » Author: Bianca-Cristina Cristescu February 2014 » Copyright (C) 1995-2013, Rene Brun and Fons Rademakers. *; » Last changed: root/cont » Last generated: 2015-06-3",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/TListOfEnums.html:14302,Load,Load,14302,root/html602/TListOfEnums.html,https://root.cern,https://root.cern/root/html602/TListOfEnums.html,2,['Load'],['Load']
Performance,"st char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsArg::setValueDirty() const; TIterator*RooAbsArg::shapeClientIterator() const; RooFIterRooAbsArg::shapeClientMIterator() const; virtual voidShowMembers(TMemberInspector&); virtual Int_tTNamed::Sizeof() const; virtual voidStreamer(TBuffer&); voidStreamerNVirtual(TBuffer& ClassDef_StreamerNVirtual_b); const map<std::string,std::string>&RooAbsArg::stringAttributes() const; virtual voidTObject::SysError(const char* method, const char* msgfmt) const; Bool_tTObject::TestBit(UInt_t f) const; Int_tTObject::TestBits(UInt_t f) const; const set<std::string>&RooAbsArg::transientAttributes() const; voidRooAbsArg::treeNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t doBranch = kTRUE, Bool_t doLeaf = kTRUE, Bool_t valueOnly = kFALSE, Bool_t recurseNonDerived = kFALSE) const; TIterator*typeIterator() const; voidRooAbsArg::unRegisterCache(RooAbsCache& cache); virtual voidTObject::UseCurrentStyle(); TIterator*RooAbsArg::valueClientIterator() const; RooFIterRooAbsArg::valueClientMIterator() const; static voidRooAbsArg::verboseDirty(Bool_t flag); virtual voidTObject::Warning(const char* method, const char* msgfmt) const; voidRooAbsArg::wireAllCaches(); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0); virtual Int_tTObject::Write(const char* name = 0, Int_t option = 0, Int_t bufsize = 0) const; virtual voidwriteToStream(ostream& os, Bool_t compact) const.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsCategory.html:16316,cache,cache,16316,root/html534/RooAbsCategory.html,https://root.cern,https://root.cern/root/html534/RooAbsCategory.html,2,['cache'],['cache']
Performance,"st char* namecycle, const char* classname); virtual void*TDirectory::GetObjectChecked(const char* namecycle, const TClass* cl); virtual char*TObject::GetObjectInfo(Int_t px, Int_t py) const; static Bool_tTObject::GetObjectStat(); virtual void*TDirectory::GetObjectUnchecked(const char* namecycle); virtual Option_t*TObject::GetOption() const; virtual const char*TDirectory::GetPath() const; virtual const char*TDirectory::GetPathStatic() const; TPluginManager*GetPluginManager() const; TFolder*GetRootFolder() const; virtual Long64_tTDirectory::GetSeekDir() const; virtual Long64_tTDirectory::GetSeekKeys() const; virtual Long64_tTDirectory::GetSeekParent() const; TVirtualPad*GetSelectedPad() const; const TObject*GetSelectedPrimitive() const; TStyle*GetStyle(const char* name) const; const char*GetSvnBranch() const; const char*GetSvnDate(); Int_tGetSvnRevision() const; virtual const char*TNamed::GetTitle() const; static const char*GetTutorialsDir(); TDataType*GetType(const char* name, Bool_t load = kFALSE) const; virtual UInt_tTObject::GetUniqueID() const; TUUIDTDirectory::GetUUID() const; TProcessUUID*GetUUIDs() const; const char*GetVersion() const; Int_tGetVersionCode() const; Int_tGetVersionDate() const; Int_tGetVersionInt() const; Int_tGetVersionTime() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); virtual ULong_tTNamed::Hash() const; voidIdle(UInt_t idleTimeInSec, const char* command = 0); Int_tIgnoreInclude(const char* fname, const char* expandedfname); static Int_tIncreaseDirLevel(); static voidIndentLevel(); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tTObject::InheritsFrom(const char* classname) const; virtual Bool_tTObject::InheritsFrom(const TClass* cl) const; static Bool_tInitialized(); virtual voidTObject::Inspect() constMENU ; voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; Bool_tIsBatch() const; virtual Bool_tTObject::IsEqual(const TObject* obj) const; Bool_tIsEscaped() const; Bool_tIsExecutingM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TROOT.html:9041,load,load,9041,root/html534/TROOT.html,https://root.cern,https://root.cern/root/html534/TROOT.html,2,['load'],['load']
Performance,"st char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tEnablePackage(const char* package, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tEnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); Int_tEnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE, TList* workers = 0); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExec(const char* cmd, Bool_t plusMaster = kFALSE); Int_tExec(const char* cmd, const char* ord, Bool_t logtomacro = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tFinalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tFinalize(const char* queryref, Bool_t force = kFALSE); TList*FindDataSets(const char* searchString, const char* optStr = """"",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProof.html:5796,load,loadopts,5796,root/html534/TProof.html,https://root.cern,https://root.cern/root/html534/TProof.html,2,['load'],['loadopts']
Performance,"st char* rangeName = 0) const; virtual Double_tRooAbsReal::analyticalIntegralWN(Int_t code, const RooArgSet* normSet, const char* rangeName = 0) const; virtual voidTObject::AppendPad(Option_t* option = """"); TF1*RooAbsReal::asTF(const RooArgList& obs, const RooArgList& pars = RooArgList(), const RooArgSet& nset = RooArgSet()) const; voidRooAbsArg::attachDataSet(const RooAbsData& set); voidRooAbsArg::attachDataStore(const RooAbsDataStore& set); const set<std::string>&RooAbsArg::attributes() const; virtual list<Double_t>*RooAbsReal::binBoundaries(RooAbsRealLValue&, Double_t, Double_t) const; RooAbsFunc*RooAbsReal::bindVars(const RooArgSet& vars, const RooArgSet* nset = 0, Bool_t clipInvalid = kFALSE) const; const RooArgList&boundaries(); voidRooAbsArg::branchNodeServerList(RooAbsCollection* list, const RooAbsArg* arg = 0, Bool_t recurseNonDerived = kFALSE) const; virtual voidTObject::Browse(TBrowser* b); virtual const char*RooAbsArg::cacheUniqueSuffix() const; virtual RooAbsArg::CacheModeRooAbsArg::canNodeBeCached() const; voidRooAbsArg::changeServer(RooAbsArg& server, Bool_t valueProp, Bool_t shapeProp); Bool_tRooAbsArg::checkDependents(const RooArgSet* nset) const; virtual Bool_tRooAbsArg::checkObservables(const RooArgSet* nset) const; virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooLinkedList& cmdList); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataHist& data, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), const RooCmdArg& arg3 = RooCmdArg::none(), const RooCmdArg& arg4 = RooCmdArg::none(), const RooCmdArg& arg5 = RooCmdArg::none(), const RooCmdArg& arg6 = RooCmdArg::none(), const RooCmdArg& arg7 = RooCmdArg::none(), const RooCmdArg& arg8 = RooCmdArg::none()); virtual RooFitResult*RooAbsReal::chi2FitTo(RooDataSet& xydata, const RooCmdArg& arg1 = RooCmdArg::none(), const RooCmdArg& arg2 = RooCmdArg::none(), con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooStepFunction.html:2612,Cache,CacheModeRooAbsArg,2612,root/html534/RooStepFunction.html,https://root.cern,https://root.cern/root/html534/RooStepFunction.html,1,['Cache'],['CacheModeRooAbsArg']
Performance,"st char* removedFromVers) const; voidTObject::operator delete(void* ptr); voidTObject::operator delete(void* ptr, void* vp); voidTObject::operator delete[](void* ptr); voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); Bool_tRooAbsCategory::operator!=(Int_t index); Bool_tRooAbsCategory::operator!=(const char* label); Bool_tRooAbsCategory::operator!=(const RooAbsArg& other); RooAbsArg&operator=(int index); RooAbsArg&operator=(const char* label); RooAbsArg&operator=(const RooAbsCategory& other); RooAbsCategoryLValue&operator=(const RooAbsCategoryLValue&); Bool_tRooAbsCategory::operator==(Int_t index) const; Bool_tRooAbsCategory::operator==(const char* label) const; virtual Bool_tRooAbsCategory::operator==(const RooAbsArg& other); RooAbsArg::OperModeRooAbsArg::operMode() const; virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables); virtual voidRooAbsArg::optimizeCacheMode(const RooArgSet& observables, RooArgSet& optNodes, RooLinkedList& processedNodes); Bool_tRooAbsArg::overlaps(const RooAbsArg& testArg, Bool_t valueOnly = kFALSE) const; const RooArgSet*RooAbsArg::ownedComponents() const; virtual voidTObject::Paint(Option_t* option = """"); virtual voidTObject::Pop(); virtual voidRooAbsArg::Print(Option_t* options = 0) const; virtual voidRooAbsArg::printAddress(ostream& os) const; virtual voidRooAbsArg::printArgs(ostream& os) const; virtual voidRooAbsArg::printClassName(ostream& os) const; voidRooAbsArg::printCompactTree(const char* indent = """", const char* fileName = 0, const char* namePat = 0, RooAbsArg* client = 0); voidRooAbsArg::printCompactTree(ostream& os, const char* indent = """", const char* namePat = 0, RooAbsArg* client = 0); virtual voidRooAbsArg::printCompactTreeHook(ostream& os, const char* ind = """"); voidRooAbsArg::printComponentTree(const char* indent = """", con",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsCategoryLValue.html:12075,optimiz,optimizeCacheMode,12075,root/html602/RooAbsCategoryLValue.html,https://root.cern,https://root.cern/root/html602/RooAbsCategoryLValue.html,4,['optimiz'],['optimizeCacheMode']
Performance,"st char* signal, const char* params); voidTQObject::Emit(const char* signal, Double_t param); voidTQObject::Emit(const char* signal, Long_t param); voidTQObject::Emit(const char* signal, Long64_t param); voidTQObject::Emit(const char* signal, Bool_t param); voidTQObject::Emit(const char* signal, Char_t param); voidTQObject::Emit(const char* signal, UChar_t param); voidTQObject::Emit(const char* signal, Short_t param); voidTQObject::Emit(const char* signal, UShort_t param); voidTQObject::Emit(const char* signal, Int_t param); voidTQObject::Emit(const char* signal, UInt_t param); voidTQObject::Emit(const char* signal, ULong_t param); voidTQObject::Emit(const char* signal, ULong64_t param); voidTQObject::Emit(const char* signal, Float_t param); voidTQObject::EmitVA(const char* signal, Int_t nargs); voidTQObject::EmitVA(const char* signal, Int_t nargs, va_list va); Int_tEnablePackage(const char* package, Bool_t notOnClient = kFALSE); Int_tEnablePackage(const char* package, const char* loadopts, Bool_t notOnClient = kFALSE); Int_tEnablePackage(const char* package, TList* loadopts, Bool_t notOnClient = kFALSE); virtual voidTObject::Error(const char* method, const char* msgfmt) const; Int_tExec(const char* cmd, Bool_t plusMaster = kFALSE); virtual voidTObject::Execute(const char* method, const char* params, Int_t* error = 0); virtual voidTObject::Execute(TMethod* method, TObjArray* params, Int_t* error = 0); virtual voidTObject::ExecuteEvent(Int_t event, Int_t px, Int_t py); virtual Bool_tExistsDataSet(const char* dataset); virtual voidTObject::Fatal(const char* method, const char* msgfmt) const; voidFeedback(TList* objs)SIGNAL ; virtual voidTNamed::FillBuffer(char*& buffer); Long64_tFinalize(Int_t query = -1, Bool_t force = kFALSE); Long64_tFinalize(const char* queryref, Bool_t force = kFALSE); TList*FindDataSets(const char* searchString, const char* optStr = """"); virtual TObject*TObject::FindObject(const char* name) const; virtual TObject*TObject::FindObject(const TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TProof.html:5548,load,loadopts,5548,root/html528/TProof.html,https://root.cern,https://root.cern/root/html528/TProof.html,4,['load'],['loadopts']
Performance,"st char* slot); static voidTApplication::Close(TApplication* app); static TStringTQObject::CompressName(const char* method_name); static Bool_tTQObject::ConnectToClass(TQObject* sender, const char* signal, TClass* receiver_class, void* receiver, const char* slot); static Bool_tTQObject::ConnectToClass(const char* sender_class, const char* signal, TClass* receiver_class, void* receiver, const char* slot); virtual voidDeletePlayer(); virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; virtual Int_tFork(); virtual void*TQObject::GetSender(); virtual const char*TQObject::GetSenderClassName() const; Int_tGetSessionStatus(); virtual voidHandleArchive(TMessage* mess, TString* slb = 0); virtual Int_tHandleCache(TMessage* mess, TString* slb = 0); virtual voidHandleCheckFile(TMessage* mess, TString* slb = 0); virtual Int_tHandleDataSets(TMessage* mess, TString* slb = 0); virtual voidHandleFork(TMessage* mess); virtual Int_tHandleLibIncPath(TMessage* mess); virtual voidHandleProcess(TMessage* mess, TString* slb = 0); virtual voidHandleQueryList(TMessage* mess); virtual voidHandleRemove(TMessage* mess, TString* slb = 0); virtual voidHandleRetrieve(TMessage* mess, TString* slb = 0); virtual voidHandleSubmerger(TMessage* mess); virtual Int_tHandleWorkerLists(TMessage* mess); virtual voidTApplication::Help(const char* line); Bool_tIsIdle(); virtual voidTApplication::LoadGraphicsLibs(); virtual voidTApplication::MakeBatch(); virtual voidMakePlayer(); voidTObject::MakeZombie(); static TApplication*TApplication::Open(const char* url, Int_t debug, const char* script); static Int_tTApplication::ParseRemoteLine(const char* ln, TString& hostdir, TString& user, Int_t& dbg, TString& script); virtual voidProcessNext(TString* slb = 0); virtual Long_tTApplication::ProcessRemote(const char* line, Int_t* error = 0); voidTApplication::SetSignalHandler(TSignalHandler* sh); virtual Int_tSetup(); Int_tSetupCommon(); Bool_tUnlinkDataDir(const char* path).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/TProofServ.html:14380,Load,LoadGraphicsLibs,14380,root/html604/TProofServ.html,https://root.cern,https://root.cern/root/html604/TProofServ.html,1,['Load'],['LoadGraphicsLibs']
Performance,"st char* title, RooAbsPdf& _pdf); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidRooAbsArg::setCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooExtendedBinding.html:24054,cache,cache,24054,root/html602/RooExtendedBinding.html,https://root.cern,https://root.cern/root/html602/RooExtendedBinding.html,4,['cache'],['cache']
Performance,"st char* title, RooDataSet* ntuple, const RooArgSet& vars, const RooFormulaVar* cutVar, const char* cutRange, int nStart, int nStop, Bool_t copyCache, const char* wgtVarName = 0); RooArgSetaddWgtVar(const RooArgSet& origVars, const RooAbsArg* wgtVar); Bool_tRooAbsData::allClientsCached(RooAbsArg*, const RooArgSet&); voidRooDirItem::appendToDir(TObject* obj, Bool_t forceMemoryResident = kFALSE); virtual voidRooAbsData::attachCache(const RooAbsArg* newOwner, const RooArgSet& cachedVars); virtual voidRooAbsData::cacheArgs(const RooAbsArg* owner, RooArgSet& varSet, const RooArgSet* nset = 0); virtual RooAbsData*cacheClone(const RooAbsArg* newCacheOwner, const RooArgSet* newCacheVars, const char* newName = 0); Double_tRooAbsData::corrcov(RooRealVar& x, RooRealVar& y, const char* cutSpec, const char* cutRange, Bool_t corr) const; TMatrixDSym*RooAbsData::corrcovMatrix(const RooArgList& vars, const char* cutSpec, const char* cutRange, Bool_t corr) const; RooRealVar*RooAbsData::dataRealVar(const char* methodname, RooRealVar& extVar) const; virtual voidTObject::DoError(int level, const char* location, const char* fmt, va_list va) const; voidinitialize(const char* wgtVarName); voidTObject::MakeZombie(); virtual voidRooAbsData::optimizeReadingWithCaching(RooAbsArg& arg, const RooArgSet& cacheList, const RooArgSet& keepObsList); virtual RooPlot*RooAbsData::plotAsymOn(RooPlot* frame, const RooAbsCategoryLValue& asymCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotEffOn(RooPlot* frame, const RooAbsCategoryLValue& effCat, RooAbsData::PlotOpt o) const; virtual RooPlot*RooAbsData::plotOn(RooPlot* frame, RooAbsData::PlotOpt o) const; virtual RooAbsData*reduceEng(const RooArgSet& varSubset, const RooFormulaVar* cutVar, const char* cutRange = 0, Int_t nStart = 0, Int_t nStop = 2000000000, Bool_t copyCache = kTRUE); voidRooDirItem::removeFromDir(TObject* obj); virtual voidRooAbsData::resetCache(); virtual voidRooAbsData::setArgStatus(const RooArgSet& set, Bool_t active).",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooDataSet.html:14986,optimiz,optimizeReadingWithCaching,14986,root/html526/RooDataSet.html,https://root.cern,https://root.cern/root/html526/RooDataSet.html,4,"['cache', 'optimiz']","['cacheList', 'optimizeReadingWithCaching']"
Performance,"st char* title, const RooArgList& _prodSet); virtual voidTObject::SaveAs(const char* filename = """", Option_t* option = """") constMENU ; virtual voidTObject::SavePrimitive(ostream& out, Option_t* option = """"); TIterator*RooAbsArg::serverIterator() const; RooFIterRooAbsArg::serverMIterator() const; virtual voidRooAbsArg::serverNameChangeHook(const RooAbsArg*, const RooAbsArg*); voidRooAbsArg::setAttribute(const Text_t* name, Bool_t value = kTRUE); voidTObject::SetBit(UInt_t f); voidTObject::SetBit(UInt_t f, Bool_t set); virtual voidsetCacheAndTrackHints(RooArgSet&); static voidRooAbsReal::setCacheCheck(Bool_t flag); virtual Bool_tRooAbsReal::setData(RooAbsData&, Bool_t = kTRUE); static voidRooAbsArg::setDirtyInhibit(Bool_t flag); virtual voidTObject::SetDrawOption(Option_t* option = """")MENU ; static voidTObject::SetDtorOnly(void* obj); static voidRooAbsReal::setEvalErrorLoggingMode(RooAbsReal::ErrorLoggingMode m); virtual voidRooAbsArg::setExpensiveObjectCache(RooExpensiveObjectCache& cache); static voidRooAbsReal::setHideOffset(Bool_t flag); voidRooAbsReal::setIntegratorConfig(); voidRooAbsReal::setIntegratorConfig(const RooNumIntConfig& config); voidRooAbsArg::setLocalNoDirtyInhibit(Bool_t flag) const; virtual voidRooAbsArg::SetName(const char* name); virtual voidRooAbsArg::SetNameTitle(const char* name, const char* title); static voidTObject::SetObjectStat(Bool_t stat); voidRooAbsArg::setOperMode(RooAbsArg::OperMode mode, Bool_t recurseADirty = kTRUE); voidRooAbsReal::setParameterizeIntegral(const RooArgSet& paramVars); voidRooAbsReal::setPlotLabel(const char* label); voidRooAbsArg::setProhibitServerRedirect(Bool_t flag); voidRooAbsArg::setShapeDirty() const; voidRooAbsArg::setStringAttribute(const Text_t* key, const Text_t* value); virtual voidTNamed::SetTitle(const char* title = """")MENU ; voidRooAbsArg::setTransientAttribute(const Text_t* name, Bool_t value = kTRUE); virtual voidTObject::SetUniqueID(UInt_t uid); voidRooAbsReal::setUnit(const char* unit); voidRooAb",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooProduct.html:24028,cache,cache,24028,root/html602/RooProduct.html,https://root.cern,https://root.cern/root/html602/RooProduct.html,4,['cache'],['cache']
Performance,"st double * ; params = nullptr, . unsigned int ; dataSize = 0, . int ; fitType = 0 . ). Fit using the a generic FCN function as a C++ callable object implementing double () (const double *) Note that the function dimension (i.e. ; the number of parameter) is needed in this case For the options see documentation for following methods FitFCN(IMultiGenFunction & fcn,..) ; Definition at line 649 of file Fitter.h. ◆ GetDataFromFCN(). template<class ObjFuncType > . bool ROOT::Fit::Fitter::GetDataFromFCN. protected . internal functions to get data set and model function from FCN useful for fits done with customized FCN classes ; Definition at line 584 of file Fitter.h. ◆ GetFCN(). ROOT::Math::IMultiGenFunction * ROOT::Fit::Fitter::GetFCN ; (; ); const. inline . return pointer to last used objective function (is NULL in case fit is not yet done) This pointer will be valid as far as the fitter class has not been deleted. ; To be used after the fitting. The pointer should not be stored and will be invalided after performing a new fitting. In this case a new instance of the function pointer will be re-created and can be obtained calling again GetFCN() ; Definition at line 455 of file Fitter.h. ◆ GetMinimizer(). ROOT::Math::Minimizer * ROOT::Fit::Fitter::GetMinimizer ; (; ); const. inline . return pointer to last used minimizer (is NULL in case fit is not yet done) This pointer is guaranteed to be valid as far as the fitter class is valid and a new fit is not redone. ; To be used only after fitting. The pointer should not be stored and will be invalided after performing a new fitting. In this case a new instance of ROOT::Math::Minimizer will be re-created and can be obtained calling again GetMinimizer() ; Definition at line 444 of file Fitter.h. ◆ GetNCallsFromFCN(). int ROOT::Fit::Fitter::GetNCallsFromFCN ; (; ). protected . Definition at line 870 of file Fitter.cxx. ◆ IsBinFit(). bool ROOT::Fit::Fitter::IsBinFit ; (; ); const. inline . query if fit is binned. ; In cse of false",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html:26967,perform,performing,26967,doc/master/classROOT_1_1Fit_1_1Fitter.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Fit_1_1Fitter.html,1,['perform'],['performing']
Performance,"st entry to process for this element; Long64_tTEventIter::fElemNumnumber of entries to process for this element; TEntryList*TEventIter::fEntryList! entry list for processing; Long64_tTEventIter::fEntryListPos! current position in the entrylist; TEventList*TEventIter::fEventList! eventList for processing; Int_tTEventIter::fEventListPos! current position in the eventList; TFile*TEventIter::fFileCurrent file; TStringTEventIter::fFilenameName of the current file; Long64_tTEventIter::fFirstfirst entry to process; Long64_tTEventIter::fNumnumber of entries to process; Long64_tTEventIter::fOldBytesReadlast reported number of bytes read; TStringTEventIter::fPathPath to current TDirectory; TSelector*TEventIter::fSelselector to be used; Bool_tTEventIter::fStoptermination of run requested. private:. Long64_tfCacheSizeCache size; TList*fFileTreesFiles && Trees currently open; TTree*fTreetree we are iterating over; TTreeCache*fTreeCacheinstance of the tree cache for the tree; Bool_tfTreeCacheIsLearningWhether cache is in learning phase; TStringfTreeNamename of the tree object to iterate over; Bool_tfUseParallelUnzipControl usage of parallel unzip; Bool_tfUseTreeCacheControl usage of the tree cache. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; TEventIterTree(); Default ctor. TEventIterTree(TDSet* dset, TSelector* sel, Long64_t first, Long64_t num); Constructor. ~TEventIterTree(); Destructor. Long64_t GetCacheSize(); Return the size in bytes of the cache, if any; Return -1 if not used. Int_t GetLearnEntries(); Return the number of entries in the learning phase. TTree* GetTrees(TDSetElement* elem); Create a Tree for the main TDSetElement and for all the friends.; Returns the main tree or 0 in case of an error. TTree* Load(TDSetElement* elem, Bool_t& localfile); Load a tree from s TDSetElement. Long64_t GetNextEvent(); Get next event. TEventIterTree(). » Author: Maarten Ballintijn 07/01/02 » Copyright (C) 1995-2001, Rene Brun and Fons Rade",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html528/TEventIterTree.html:6859,cache,cache,6859,root/html528/TEventIterTree.html,https://root.cern,https://root.cern/root/html528/TEventIterTree.html,3,['cache'],['cache']
Performance,st of client objects; RooRefCountListRooAbsArg::_clientListShapesubset of clients that requested shape dirty flag propagation; RooRefCountListRooAbsArg::_clientListValuesubset of clients that requested value dirty flag propagation; TIterator*RooAbsArg::_clientShapeIter! Iterator over _clientListShape ; TIterator*RooAbsArg::_clientValueIter! Iterator over _clientListValue ; Bool_tRooAbsArg::_deleteWatch! Delete watch flag ; RooExpensiveObjectCache*RooAbsArg::_eocachePointer to global cache manager for any expensive components created by this object; Int_tRooAbsPdf::_errorCountNumber of errors remaining to print; static Bool_tRooAbsPdf::_evalError; static Bool_tRooAbsArg::_flipACleanStatic flag controlling flipping status of all AClean nodes to ADirty ;; Float_tRooAbsReal::_floatValue! Transient cache for floating point values from tree branches ; Bool_tRooAbsReal::_forceNumIntForce numerical integration if flag set; static Bool_tRooAbsReal::_globalSelectCompGlobal activation switch for component selection; static Bool_tRooAbsArg::_inhibitDirtyStatic flag controlling global inhibit of dirty state propagation; Int_tRooAbsReal::_intValue! Transient cache for integer values from tree branches ; Int_tRooAbsCachedPdf::_ipOrderInterpolation order for cache histograms ; TStringRooAbsReal::_labelPlot label for objects value; RooArgSet*RooAbsReal::_lastNSet!; Int_tRooAbsPdf::_minDimNormValueCacheMinimum number of numerically integrated dimensions to activate normalization value caching; static Int_tRooPrintable::_nameLength; Int_tRooAbsPdf::_negCountNumber of negative probablities remaining to print; RooAbsReal*RooAbsPdf::_norm! Normalization integral (owned by _normMgr); RooObjCacheManagerRooAbsPdf::_normMgrThe cache manager; RooArgSet*RooAbsPdf::_normSet! Normalization set with for above integral; RooAbsArg::OperModeRooAbsArg::_operModeDirty state propagation mode; RooArgSet*RooAbsArg::_ownedComponents! Set of owned component; RooSetProxy_paramsEffective parameters of this p.,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooFFTConvPdf.html:43693,cache,cache,43693,root/html526/RooFFTConvPdf.html,https://root.cern,https://root.cern/root/html526/RooFFTConvPdf.html,3,['cache'],['cache']
Performance,"st of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. Class Charts. Inh",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TUnixSystem.html:18812,Cache,Cache,18812,root/html532/TUnixSystem.html,https://root.cern,https://root.cern/root/html532/TUnixSystem.html,1,['Cache'],['Cache']
Performance,"st of helper classes for alternative file/directory access; TStringTSystem::fHostnameHostname; Bool_tTSystem::fInControlTrue if in eventloop; TStringTSystem::fIncludePathUsed to expand $IncludePath in the directives given to SetMakeSharedLib and SetMakeExe; Bool_tTSystem::fInsideNotifyUsed by DispatchTimers(); TStringTSystem::fLastErrorStringLast system error message; Int_tTSystem::fLevelLevel of nested eventloops; TStringTSystem::fLinkdefSuffixDefault suffix for linkdef files to be used by ACLiC (see EACLiCProperties); TStringTSystem::fLinkedLibsUsed to expand $LinkedLibs in the directives given to SetMakeSharedLib and SetMakeExe; TStringTSystem::fListLibsList shared libraries, cache used by GetLibraries; TStringTSystem::fListPathsList of all include (fIncludePath + interpreter include path). Cache used by GetIncludePath; TStringTSystem::fMakeExeDirective used to build an executable; TStringTSystem::fMakeSharedLibDirective used to build a shared library; Int_tTSystem::fMaxrfdLargest fd in read mask; Int_tTSystem::fMaxwfdLargest fd in write mask; TStringTNamed::fNameobject identifier; Int_tTSystem::fNfdNumber of fd's in masks; TStringTSystem::fObjExtExtension of object files (.o, .obj, etc.); TSeqCollection*TSystem::fOnExitListList of items to be cleaned-up on exit; TFdSet*TSystem::fReadmask!Files that should be checked for read events; TFdSet*TSystem::fReadready!Files with reads waiting; Int_tTSystem::fSigcntNumber of pending signals; TSeqCollection*TSystem::fSignalHandlerList of signal handlers; TFdSet*TSystem::fSignals!Signals that were trapped; TStringTSystem::fSoExtExtension of shared library (.so, .sl, .a, .dll, etc.); TSeqCollection*TSystem::fStdExceptionHandlerList of std::exception handlers; TSeqCollection*TSystem::fTimersList of timers; TStringTNamed::fTitleobject title; TStringTSystem::fWdpathWorking directory; TFdSet*TSystem::fWritemask!Files that should be checked for write events; TFdSet*TSystem::fWriteready!Files with writes waiting. private:. void*fD",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TDCacheSystem.html:17639,Cache,Cache,17639,root/html532/TDCacheSystem.html,https://root.cern,https://root.cern/root/html532/TDCacheSystem.html,3,['Cache'],['Cache']
Performance,"st of physical nodes, so that we can start over with a new list. ; If MUSTDELETE is true, delete previous nodes. ; Definition at line 3542 of file TGeoManager.cxx. ◆ ClearShape(). void TGeoManager::ClearShape ; (; const TGeoShape * ; shape). Remove a shape from the list of shapes. ; Definition at line 1617 of file TGeoManager.cxx. ◆ ClearThreadData(). void TGeoManager::ClearThreadData ; (; ); const. Definition at line 953 of file TGeoManager.cxx. ◆ ClearThreadsMap(). void TGeoManager::ClearThreadsMap ; (; ). static . Clear the current map of threads. ; This will be filled again by the calling threads via ThreadId calls. ; Definition at line 984 of file TGeoManager.cxx. ◆ ClearTracks(). void TGeoManager::ClearTracks ; (; ). inline . Definition at line 415 of file TGeoManager.h. ◆ CloseGeometry(). void TGeoManager::CloseGeometry ; (; Option_t * ; option = ""d""). Closing geometry implies checking the geometry validity, fixing shapes with negative parameters (run-time shapes)building the cache manager, voxelizing all volumes, counting the total number of physical nodes and registering the manager class to the browser. ; Definition at line 1480 of file TGeoManager.cxx. ◆ ConvertReflections(). void TGeoManager::ConvertReflections ; (; ). Convert all reflections in geometry to normal rotations + reflected shapes. ; Definition at line 1723 of file TGeoManager.cxx. ◆ CountLevels(). void TGeoManager::CountLevels ; (; ). Count maximum number of nodes per volume, maximum depth and maximum number of xtru vertices. ; Definition at line 1759 of file TGeoManager.cxx. ◆ CountNodes(). Int_t TGeoManager::CountNodes ; (; const TGeoVolume * ; vol = nullptr, . Int_t ; nlevels = 10000, . Int_t ; option = 0 . ). Count the total number of nodes starting from a volume, nlevels down. ; Definition at line 1803 of file TGeoManager.cxx. ◆ CreateParallelWorld(). TGeoParallelWorld * TGeoManager::CreateParallelWorld ; (; const char * ; name). Create a parallel world for prioritised navigation. ; This",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTGeoManager.html:79208,cache,cache,79208,doc/master/classTGeoManager.html,https://root.cern,https://root.cern/doc/master/classTGeoManager.html,1,['cache'],['cache']
Performance,"st of proxies. Avoids type casting. ;  ;  Static Protected Attributes inherited from RooPrintable; static Int_t _nameLength;  . #include <RooWrapperPdf.h>. Inheritance diagram for RooWrapperPdf:. This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.; [legend]; Constructor & Destructor Documentation. ◆ RooWrapperPdf() [1/3]. RooWrapperPdf::RooWrapperPdf ; (; ). inline . Definition at line 27 of file RooWrapperPdf.h. ◆ RooWrapperPdf() [2/3]. RooWrapperPdf::RooWrapperPdf ; (; const char * ; name, . const char * ; title, . RooAbsReal & ; inputFunction, . bool ; selfNormalized = false . ). inline . Construct a new RooWrapperPdf. ; Parameters. [in]nameA name to identify this object. ; [in]titleTitle (for e.g. plotting) ; [in]inputFunctionAny RooAbsReal that should be converted into a PDF. Although it's possible ; [in]selfNormalizedThe return value the RooAbsPdf::selfNormalized() function for the wrapped PDF object. If it is true, then no automatic normalization will be performed when evaluating the function. In this case, the effect RooWrapperPdf is not to change the evaluated values, but only to wrap the function in something that is of type RooAbsPdf, which can be useful if some interface reqiures it. to pass a PDF, it only makes sense for non-PDF functions. . Definition at line 39 of file RooWrapperPdf.h. ◆ RooWrapperPdf() [3/3]. RooWrapperPdf::RooWrapperPdf ; (; const RooWrapperPdf & ; other, . const char * ; name = nullptr . ). inline . Definition at line 44 of file RooWrapperPdf.h. Member Function Documentation. ◆ analyticalIntegral(). double RooWrapperPdf::analyticalIntegral ; (; Int_t ; code, . const char * ; rangeName = nullptr . ); const. inlineoverridevirtual . Implements the actual analytical integral(s) advertised by getAnalyticalIntegral. ; This functions will only be called with codes returned by getAnalyticalIntegral, except code zero. ; Reimplemented from RooAbsReal.; Definition at line 70 of file RooWrapperPdf.h. ◆ analytica",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooWrapperPdf.html:74513,perform,performed,74513,doc/master/classRooWrapperPdf.html,https://root.cern,https://root.cern/doc/master/classRooWrapperPdf.html,1,['perform'],['performed']
Performance,"st of the streamer infos in this file; Bool_tTFile::fInitDone!True if the file has been initialized; Bool_tTFile::fIsArchive!True if this is a pure archive file; Bool_tTFile::fIsRootFile!True is this is a ROOT file, raw file otherwise; TList*TDirectoryFile::fKeysPointer to keys list in memory; TList*TDirectory::fListList of objects in memory; Bool_tTDirectoryFile::fModifiedtrue if directory has been modified; TObject*TDirectory::fMotherpointer to mother of the directory; TStringfMsgGetHeadcache GetHead() msg; TStringfMsgReadBuffercache ReadBuffer() msg; TStringfMsgReadBuffer10cache ReadBuffer10() msg; Bool_tTFile::fMustFlush!True if the file buffers must be flushed; Int_tTFile::fNProcessIDsNumber of TProcessID written to this file; TStringTNamed::fNameobject identifier; Int_tTFile::fNbytesFreeNumber of bytes for free segments structure; Int_tTFile::fNbytesInfoNumber of bytes for StreamerInfo record; Int_tTDirectoryFile::fNbytesKeysNumber of bytes for the keys; Int_tTDirectoryFile::fNbytesNameNumber of bytes in TNamed at creation time; Bool_tTFile::fNoAnchorInName!True if we don't want to force the anchor to be appended to the file name; Bool_tfNoProxydon't use proxy; Long64_tTFile::fOffset!Seek offset cache; TList*TFile::fOpenPhases!Time info about open phases; TStringTFile::fOptionFile options; TStringTDirectory::fPathBuffer!Buffer for GetPath() function; TObjArray*TFile::fProcessIDs!Array of pointers to TProcessIDs; TUrlfProxyproxy URL; Int_tTFile::fReadCallsNumber of read calls ( not counting the cache calls ); TStringTFile::fRealNameEffective real file name (not original url); Long64_tTDirectoryFile::fSeekDirLocation of directory on file; Long64_tTFile::fSeekFreeLocation on disk of free segments structure; Long64_tTFile::fSeekInfoLocation on disk of StreamerInfo record; Long64_tTDirectoryFile::fSeekKeysLocation of Keys record on file; Long64_tTDirectoryFile::fSeekParentLocation of parent directory on file; Long64_tfSizefile size; TSocket*fSocketsocket for HTTP/1.",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TWebFile.html:21021,cache,cache,21021,root/html532/TWebFile.html,https://root.cern,https://root.cern/root/html532/TWebFile.html,8,['cache'],['cache']
Performance,"st override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; virtual void recomputeShape ()=0;  If a category depends on the shape of others, i.e. its state numbers or names depend on the states of other categories, this function has to be implemented to recompute _stateNames and _insertionOrder. ;  ; RooCatType * retrieveLegacyState (value_type index) const;  Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ;  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)activate associate tree branch ;  ; std::map< std::string, value_type > & stateNames ();  Access the map of state names to index numbers. ;  ; const std::map< std::string, value_type > & stateNames () const;  Access the map of state names to index numbers. ;  ; void syncCache (const RooArgSet *set=nullptr) override;  Explicitly synchronize RooAbsCategory internal cache. ;  ; virtual bool isValid (const RooCatType &value) const;  Check if given state is defined for this object. ;  ; const RooCatType * defineType (const char *label);  ; const RooCatType * defineType (const char *label, int index);  ; const RooCatType * defineTypeUnchecked (const char *label, value_type index);  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategoryLValue.html:39268,cache,cache,39268,doc/master/classRooAbsCategoryLValue.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategoryLValue.html,1,['cache'],['cache']
Performance,"st override;  WVE (08/21/01) Probably obsolete now. ;  ; value_type nextAvailableStateIndex () const;  ; virtual void recomputeShape ()=0;  If a category depends on the shape of others, i.e. its state numbers or names depend on the states of other categories, this function has to be implemented to recompute _stateNames and _insertionOrder. ;  ; RooCatType * retrieveLegacyState (value_type index) const;  Return the legacy RooCatType corresponding to index. If it doesn't exist, create one. ;  ; void setCachedValue (double value, bool notifyClients=true) final;  Overwrite the value stored in this object's cache. ;  ; void setTreeBranchStatus (TTree &t, bool active) override;  (De)activate associate tree branch ;  ; std::map< std::string, value_type > & stateNames ();  Access the map of state names to index numbers. ;  ; const std::map< std::string, value_type > & stateNames () const;  Access the map of state names to index numbers. ;  ; void syncCache (const RooArgSet *set=nullptr) override;  Explicitly synchronize RooAbsCategory internal cache. ;  ;  Protected Member Functions inherited from RooAbsArg; void attachToStore (RooAbsDataStore &store);  Attach this argument to the data store such that it reads data from there. ;  ; TString cleanBranchName () const;  Construct a mangled name from the actual name that is free of any math symbols that might be interpreted by TTree. ;  ; void clearShapeDirty () const;  ; void clearValueAndShapeDirty () const;  ; void clearValueDirty () const;  ; virtual void getObservablesHook (const RooArgSet *, RooArgSet *) const;  ; virtual void getParametersHook (const RooArgSet *, RooArgSet *, bool) const;  ; void graphVizAddConnections (std::set< std::pair< RooAbsArg *, RooAbsArg * > > &);  Utility function that inserts all point-to-point client-server connections between any two RooAbsArgs in the expression tree headed by this object in the linkSet argument. ;  ; bool inhibitDirty () const;  Delete watch flag. ;  ; virtual void ioStreame",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooAbsCategory.html:38253,cache,cache,38253,doc/master/classRooAbsCategory.html,https://root.cern,https://root.cern/doc/master/classRooAbsCategory.html,1,['cache'],['cache']
Performance,"st the histogram; # counts and the list of variables. The binning is optional: the default; # binning of the RooRealVars is used if not explicitly specified.; datahist_new_1 = ROOT.RooDataHist.from_numpy(counts, [x]); ; print(""RooDataHist imported with default binning and exported back to numpy:""); print_histogram_output(datahist_new_1.to_numpy()); ; ; # It's also possible to pass custom bin edges to `RooDataHist.from_numpy`, just; # like you pass them to `numpy.histogramdd` when you get the counts to fill the; # RooDataHist with:; bins = [np.linspace(-10, 10, 21)]; counts, _ = np.histogramdd([x_arr], bins=bins); datahist_new_2 = ROOT.RooDataHist.from_numpy(counts, [x], bins=bins); ; print(""RooDataHist imported with linspace binning and exported back to numpy:""); print_histogram_output(datahist_new_2.to_numpy()); ; # Alternatively, you can specify only the number of bins and the range if your; # binning is uniform. This is preferred over passing the full list of bin; # edges, because RooFit will know that the binning is uniform and do some; # optimizations.; bins = [20]; ranges = [(-10, 10)]; counts, _ = np.histogramdd([x_arr], bins=bins, range=ranges); datahist_new_3 = ROOT.RooDataHist.from_numpy(counts, [x], bins=bins, ranges=ranges); ; print(""RooDataHist imported with uniform binning and exported back to numpy:""); print_histogram_output(datahist_new_3.to_numpy()); [#1] INFO:Fitting -- RooAbsPdf::fitTo(gauss_over_gauss_Int[x]) fixing normalization set for coefficient determination to observables in data; [#1] INFO:Fitting -- using CPU computation library compiled with -mavx2; [#1] INFO:Fitting -- RooAddition::defaultErrorLevel(nll_gauss_over_gauss_Int[x]_) Summation contains a RooNLLVar, using its error level; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: activating const optimization; [#1] INFO:Minimization -- RooAbsMinimizerFcn::setOptimizeConst: deactivating const optimization; ; RooFitResult: minimized FCN value: 14250.1, estimated distance to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/rf409__NumPyPandasToRooFit_8py.html:5602,optimiz,optimizations,5602,doc/master/rf409__NumPyPandasToRooFit_8py.html,https://root.cern,https://root.cern/doc/master/rf409__NumPyPandasToRooFit_8py.html,1,['optimiz'],['optimizations']
Performance,"st unsigned char *p = (const unsigned char*)Data();; 667 while (i--) {; 668 Mash(hv, toupper(*p));; 669 ++p;; 670 }; 671 return hv;; 672}; 673 ; 674////////////////////////////////////////////////////////////////////////////////; 675/// Return hash value.; 676 ; 677UInt_t TString::Hash(ECaseCompare cmp) const; 678{; 679 return (cmp == kExact) ? HashCase() : HashFoldCase();; 680}; 681 ; 682 // MurmurHash3 - a blazingly fast public domain hash!; 683 // See http://code.google.com/p/smhasher/; 684 // There are two versions, one optimized for 32 bit and one for 64 bit.; 685 // They give different hash results!; 686 // We use only the 64 bit version which also works on 32 bit.; 687 ; 688 //-----------------------------------------------------------------------------; 689 // MurmurHash3 was written by Austin Appleby, and is placed in the public; 690 // domain. The author hereby disclaims copyright to this source code.; 691 ; 692 // Note - The x86 and x64 versions do _not_ produce the same results, as the; 693 // algorithms are optimized for their respective platforms. You can still; 694 // compile and run any of them on any platform, but your performance with the; 695 // non-native version will be less than optimal.; 696 ; 697 //-----------------------------------------------------------------------------; 698 // Platform-specific functions and macros; 699 ; 700 // From MurmurHash.h:; 701 ; 702#if defined(_MSC_VER) && (_MSC_VER < 1800); 703 // Microsoft Visual Studio; 704 typedef unsigned char uint8_t;; 705 typedef unsigned long uint32_t;; 706 typedef unsigned __int64 uint64_t;; 707#else // defined(_MSC_VER); 708 // Other compilers; 709#include <stdint.h>; 710#endif // !defined(_MSC_VER); 711 ; 712 // From MurmurHash.cpp:; 713#if defined(_MSC_VER); 714 // Microsoft Visual Studio; 715#include <stdlib.h>; 716#define ROTL64(x,y) _rotl64(x,y); 717#define BIG_CONSTANT(x) (x); 718#else // defined(_MSC_VER); 719 // Other compilers; 720 inline uint64_t rotl64 ( uint64_t x, int8_t r",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TString_8cxx_source.html:20597,optimiz,optimized,20597,doc/master/TString_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TString_8cxx_source.html,1,['optimiz'],['optimized']
Performance,"st va) const; voidTObject::MakeZombie(); voidresampleData(Double_t& ratio). Data Members; public:. enum TObject::EStatusBits { kCanDelete; kMustCleanup; kObjInCanvas; kIsReferenced; kHasUUID; kCannotPick; kNoContextMenu; kInvalidObject; };; enum TObject::[unnamed] { kIsOnHeap; kNotDeleted; kZombie; kBitMask; kSingleKey; kOverwrite; kWriteDelete; };; enum RooPrintable::ContentsOption { kName; kClassName; kValue; kArgs; kExtras; kAddress; kTitle; kCollectionHeader; };; enum RooPrintable::StyleOption { kInline; kSingleLine; kStandard; kVerbose; kTreeStructure; };. protected:. UInt_t_expectedEventsNumber of expected events from extended p.d.f; RooAbsPdf::ExtendMode_extendModeExtended mode capabilities of p.d.f.; RooDataSet*_genData! Data being generated; Bool_t_isValidIs context in valid state?; static Int_tRooPrintable::_nameLength; Int_t_nextProtoIndexNext prototype event to load according to LUT; TString_normRangeNormalization range of pdf; Int_t*_protoOrderLUT with traversal order of prototype data; RooArgSet_protoVarsPrototype observables; const RooDataSet*_prototypePointer to prototype dataset; RooArgSet*_theEventPointer to observable event being generated; Bool_t_verboseVerbose messaging?; TStringTNamed::fNameobject identifier; TStringTNamed::fTitleobject title. Class Charts. Inheritance; Inherited Members; Includes; Libraries. Function documentation; ~RooAbsGenContext(); Destructor. void attach(const RooArgSet& params); Interface to attach given parameters to object in this context. RooDataSet* createDataSet(const char* name, const char* title, const RooArgSet& obs); Create an empty dataset to hold the events that will be generated. RooDataSet * generate(Double_t nEvents = 0, Bool_t skipInit = kFALSE, Bool_t extendedMode = kFALSE); Generate the specified number of events with nEvents>0 and; and return a dataset containing the generated events. With nEvents<=0,; generate the number of events in the prototype dataset, if available,; or else the expected number of e",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsGenContext.html:7864,load,load,7864,root/html534/RooAbsGenContext.html,https://root.cern,https://root.cern/root/html534/RooAbsGenContext.html,2,['load'],['load']
Performance,"st() function); 2855 if (fEntryList->TestBit(kCanDelete)) {; 2856 TEntryList *tmp = fEntryList;; 2857 fEntryList = nullptr; // Avoid problem with RecursiveRemove.; 2858 delete tmp;; 2859 } else {; 2860 fEntryList = nullptr;; 2861 }; 2862 }; 2863 ; 2864 fEventList = nullptr;; 2865 ; 2866 TString basename(filename);; 2867 ; 2868 Int_t dotslashpos = basename.Index("".root/"");; 2869 TString behind_dot_root = """";; 2870 if (dotslashpos>=0) {; 2871 // Copy the list name specification; 2872 behind_dot_root = basename(dotslashpos+6,basename.Length()-dotslashpos+6);; 2873 // and remove it from basename; 2874 basename.Remove(dotslashpos+5);; 2875 }; 2876 fEntryList = new TEntryListFromFile(basename.Data(), behind_dot_root.Data(), fNtrees);; 2877 fEntryList->SetBit(kCanDelete, true);; 2878 fEntryList->SetDirectory(nullptr);; 2879 ((TEntryListFromFile*)fEntryList)->SetFileNames(fFiles);; 2880}; 2881 ; 2882////////////////////////////////////////////////////////////////////////////////; 2883/// This function transfroms the given TEventList into a TEntryList; 2884///; 2885/// NOTE, that this function loads all tree headers, because the entry numbers; 2886/// in the TEventList are global and have to be recomputed, taking into account; 2887/// the number of entries in each tree.; 2888///; 2889/// The new TEntryList is owned by the TChain and gets deleted when the chain; 2890/// is deleted. This TEntryList is returned by GetEntryList() function, and after; 2891/// GetEntryList() function is called, the TEntryList is not owned by the chain; 2892/// any more and will not be deleted with it.; 2893 ; 2894void TChain::SetEventList(TEventList *evlist); 2895{; 2896 fEventList = evlist;; 2897 if (fEntryList) {; 2898 if (fEntryList->TestBit(kCanDelete)) {; 2899 TEntryList *tmp = fEntryList;; 2900 fEntryList = nullptr; // Avoid problem with RecursiveRemove.; 2901 delete tmp;; 2902 } else {; 2903 fEntryList = nullptr;; 2904 }; 2905 }; 2906 ; 2907 if (!evlist) {; 2908 fEntryList = nullptr;; 2909 f",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TChain_8cxx_source.html:104662,load,loads,104662,doc/master/TChain_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TChain_8cxx_source.html,1,['load'],['loads']
Performance,"st(TMessage* mess); Handle request for list of queries. void HandleRemove(TMessage* mess, TString* slb = 0); Handle remove request. void HandleRetrieve(TMessage* mess, TString* slb = 0); Handle retrieve request. Int_t HandleLibIncPath(TMessage* mess); Handle lib, inc search paths modification request. void HandleCheckFile(TMessage* mess, TString* slb = 0); Handle file checking request. Int_t HandleCache(TMessage* mess, TString* slb = 0); Handle here all cache and package requests. Int_t HandleWorkerLists(TMessage* mess); Handle here all requests to modify worker lists. FILE * SetErrorHandlerFile(FILE* ferr); Set the file stream where to log (default stderr).; If ferr == 0 the default is restored.; Returns current setting. void ErrorHandler(Int_t level, Bool_t abort, const char* location, const char* msg); The PROOF error handler function. It prints the message on fgErrorHandlerFile and; if abort is set it aborts the application. Int_t CopyFromCache(const char* name, Bool_t cpbin); Retrieve any files related to 'macro' from the cache directory.; If 'cpbin' is true, the associated binaries are retrieved as well.; Returns 0 on success, -1 otherwise. Int_t CopyToCache(const char* name, Int_t opt = 0); Copy files related to 'macro' to the cache directory.; Action depends on 'opt':. opt = 0 copy 'macro' to cache and delete from cache any binary; related to name; e.g. if macro = bla.C, the binaries are; bla_C.so, bla_C.rootmap, ...; opt = 1 copy the binaries related to macro to the cache. Returns 0 on success, -1 otherwise. void MakePlayer(); Make player instance. void DeletePlayer(); Delete player instance. Int_t GetPriority(); Get the processing priority for the group the user belongs too. This; priority is a number (0 - 100) determined by a scheduler (third; party process) based on some basic priority the group has, e.g.; we might want to give users in a specific group (e.g. promptana); a higher priority than users in other groups, and on the analysis; of historical logg",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TProofServ.html:28100,cache,cache,28100,root/html534/TProofServ.html,https://root.cern,https://root.cern/root/html534/TProofServ.html,4,['cache'],['cache']
Performance,"st); 3875{; 3876 if (!HasInterpreterInfo()) return;; 3877 ; 3878 // get the base class; 3879 TIter nextBase(GetListOfBases(), kIterBackward);; 3880 TBaseClass *baseClass;; 3881 while ((baseClass = (TBaseClass *) nextBase())) {; 3882 TClass *base = baseClass->GetClassPointer();; 3883 if (base) base->GetMenuItems(list);; 3884 }; 3885 ; 3886 // remove methods redefined in this class with no menu; 3887 TMethod *method, *m;; 3888 TIter next(GetListOfMethods(), kIterBackward);; 3889 while ((method = (TMethod*)next())) {; 3890 m = (TMethod*)list->FindObject(method->GetName());; 3891 if (method->IsMenuItem() != kMenuNoMenu) {; 3892 if (!m); 3893 list->AddFirst(method);; 3894 } else {; 3895 if (m && m->GetNargs() == method->GetNargs()); 3896 list->Remove(m);; 3897 }; 3898 }; 3899}; 3900 ; 3901////////////////////////////////////////////////////////////////////////////////; 3902/// Check whether a class has a dictionary or not.; 3903/// This is equivalent to ask if a class is coming from a bootstrapping; 3904/// procedure initiated during the loading of a library.; 3905 ; 3906Bool_t TClass::HasDictionary() const; 3907{; 3908 return IsLoaded();; 3909}; 3910 ; 3911////////////////////////////////////////////////////////////////////////////////; 3912/// Check whether a class has a dictionary or ROOT can load one.; 3913/// This is equivalent to ask HasDictionary() or whether a library is known; 3914/// where it can be loaded from, or whether a Dictionary function is; 3915/// available because the class's dictionary library was already loaded.; 3916 ; 3917Bool_t TClass::HasDictionarySelection(const char* clname); 3918{; 3919 if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname)); 3920 return cl->IsLoaded();; 3921 return gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);; 3922}; 3923 ; 3924////////////////////////////////////////////////////////////////////////////////; 3925/// Verify the base classes always.; 3926 ; 3927void TClass::GetMissi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/TClass_8cxx_source.html:147855,load,loading,147855,doc/v632/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/v632/TClass_8cxx_source.html,1,['load'],['loading']
Performance,"st); 3942{; 3943 if (!HasInterpreterInfo()) return;; 3944 ; 3945 // get the base class; 3946 TIter nextBase(GetListOfBases(), kIterBackward);; 3947 TBaseClass *baseClass;; 3948 while ((baseClass = (TBaseClass *) nextBase())) {; 3949 TClass *base = baseClass->GetClassPointer();; 3950 if (base) base->GetMenuItems(list);; 3951 }; 3952 ; 3953 // remove methods redefined in this class with no menu; 3954 TMethod *method, *m;; 3955 TIter next(GetListOfMethods(), kIterBackward);; 3956 while ((method = (TMethod*)next())) {; 3957 m = (TMethod*)list->FindObject(method->GetName());; 3958 if (method->IsMenuItem() != kMenuNoMenu) {; 3959 if (!m); 3960 list->AddFirst(method);; 3961 } else {; 3962 if (m && m->GetNargs() == method->GetNargs()); 3963 list->Remove(m);; 3964 }; 3965 }; 3966}; 3967 ; 3968////////////////////////////////////////////////////////////////////////////////; 3969/// Check whether a class has a dictionary or not.; 3970/// This is equivalent to ask if a class is coming from a bootstrapping; 3971/// procedure initiated during the loading of a library.; 3972 ; 3973Bool_t TClass::HasDictionary() const; 3974{; 3975 return IsLoaded();; 3976}; 3977 ; 3978////////////////////////////////////////////////////////////////////////////////; 3979/// Check whether a class has a dictionary or ROOT can load one.; 3980/// This is equivalent to ask HasDictionary() or whether a library is known; 3981/// where it can be loaded from, or whether a Dictionary function is; 3982/// available because the class's dictionary library was already loaded.; 3983 ; 3984Bool_t TClass::HasDictionarySelection(const char* clname); 3985{; 3986 if (TClass* cl = (TClass*)gROOT->GetListOfClasses()->FindObject(clname)); 3987 return cl->IsLoaded();; 3988 return gClassTable->GetDict(clname) || gInterpreter->GetClassSharedLibs(clname);; 3989}; 3990 ; 3991////////////////////////////////////////////////////////////////////////////////; 3992/// Verify the base classes always.; 3993 ; 3994void TClass::GetMissi",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TClass_8cxx_source.html:150606,load,loading,150606,doc/master/TClass_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TClass_8cxx_source.html,1,['load'],['loading']
Performance,"st* GetUserInfo(); Return a pointer to the list containing user objects associated to this tree. The list is automatically created if it does not exist. WARNING: By default the TTree destructor will delete all objects added; to this list. If you do not want these objects to be deleted,; call:. mytree->GetUserInfo()->Clear();. before deleting the tree. void ImportClusterRanges(TTree* fromtree); Appends the cluster range information stored in 'fromtree' to this tree,; including the value of fAutoFlush. This is used when doing a fast cloning (by TTreeCloner).; See also fAutoFlush and fAutoSave if needed. void KeepCircular(); Keep a maximum of fMaxEntries in memory. Int_t LoadBaskets(Long64_t maxmemory = 2000000000); Read in memory all baskets from all branches up to the limit of maxmemory bytes. If maxmemory is non null and positive SetMaxVirtualSize is called; with this value. Default for maxmemory is 2000000000 (2 Gigabytes).; The function returns the total number of baskets read into memory; if negative an error occured while loading the branches.; This method may be called to force branch baskets in memory; when random access to branch entries is required.; If random access to only a few branches is required, you should; call directly TBranch::LoadBaskets. Long64_t LoadTree(Long64_t entry); Set current entry. Returns -2 if entry does not exist (just as TChain::LoadTree()). Note: This function is overloaded in TChain. Long64_t LoadTreeFriend(Long64_t entry, TTree* T); Load entry on behalf of our master tree, we may use an index. Called by LoadTree() when the masterTree looks for the entry; number in a friend tree (us) corresponding to the passed entry; number in the masterTree. If we have no index, our entry number and the masterTree entry; number are the same. If we *do* have an index, we must find the (major, minor) value pair; in masterTree to locate our corresponding entry. Int_t MakeClass(const char* classname = 0, Option_t* option = """"); Generate a skeleton ana",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html530/TTree.html:98437,load,loading,98437,root/html530/TTree.html,https://root.cern,https://root.cern/root/html530/TTree.html,1,['load'],['loading']
Performance,st* TTreeCache::fBrNames {nullptr}. protected . ! list of branch names in the cache ; Definition at line 52 of file TTreeCache.h. ◆ fCurrentClusterStart. Long64_t TTreeCache::fCurrentClusterStart {-1}. protected . ! Start of the cluster(s) where the current content was picked out ; Definition at line 42 of file TTreeCache.h. ◆ fEnabled. bool TTreeCache::fEnabled {true}. protected . ! cache enabled for cached reading ; Definition at line 63 of file TTreeCache.h. ◆ fEntryCurrent. Long64_t TTreeCache::fEntryCurrent {-1}. protected . ! current lowest entry number in the cache ; Definition at line 40 of file TTreeCache.h. ◆ fEntryMax. Long64_t TTreeCache::fEntryMax {1}. protected . ! last entry in the cache ; Definition at line 39 of file TTreeCache.h. ◆ fEntryMin. Long64_t TTreeCache::fEntryMin {0}. protected . ! first entry in the cache ; Definition at line 38 of file TTreeCache.h. ◆ fEntryNext. Long64_t TTreeCache::fEntryNext {-1}. protected . ! next entry number where cache must be filled ; Definition at line 41 of file TTreeCache.h. ◆ fFillTimes. Int_t TTreeCache::fFillTimes {0}. protected . ! how many times we can fill the current buffer ; Definition at line 59 of file TTreeCache.h. ◆ fFirstBuffer. bool TTreeCache::fFirstBuffer {true}. protected . ! true if first buffer is used for prefetching ; Definition at line 56 of file TTreeCache.h. ◆ fFirstEntry. Long64_t TTreeCache::fFirstEntry {-1}. protected . ! save the value of the first entry ; Definition at line 61 of file TTreeCache.h. ◆ fFirstMiss. Long64_t TTreeCache::fFirstMiss {-1}. protected . ! set to the event # of the first miss. ; Definition at line 73 of file TTreeCache.h. ◆ fFirstTime. bool TTreeCache::fFirstTime {true}. protected . ! save the fact that we processes the first entry ; Definition at line 60 of file TTreeCache.h. ◆ fgLearnEntries. Int_t TTreeCache::fgLearnEntries = 100. staticprotected . number of entries used for learning mode ; Definition at line 65 of file TTreeCache.h. ◆ fIsLearning. bool ,MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/v632/classTTreeCache.html:53142,cache,cache,53142,doc/v632/classTTreeCache.html,https://root.cern,https://root.cern/doc/v632/classTTreeCache.html,2,['cache'],['cache']
Performance,"st+len). ; This implementation will fill a vector with every event retrieved one by one (even if the weight is constant). Then, it returns a span. ; Implements RooAbsDataStore.; Definition at line 473 of file RooCompositeDataStore.cxx. ◆ hasFilledCache(). bool RooCompositeDataStore::hasFilledCache ; (; ); const. overridevirtual . Reimplemented from RooAbsDataStore.; Definition at line 159 of file RooCompositeDataStore.cxx. ◆ index(). RooCategory * RooCompositeDataStore::index ; (; ). inline . Definition at line 79 of file RooCompositeDataStore.h. ◆ IsA(). TClass * RooCompositeDataStore::IsA ; (; ); const. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from RooAbsDataStore.; Definition at line 127 of file RooCompositeDataStore.h. ◆ isWeighted(). bool RooCompositeDataStore::isWeighted ; (; ); const. overridevirtual . Implements RooAbsDataStore.; Definition at line 269 of file RooCompositeDataStore.cxx. ◆ loadValues(). void RooCompositeDataStore::loadValues ; (; const RooAbsDataStore * ; tds, . const RooFormulaVar * ; select = nullptr, . const char * ; rangeName = nullptr, . std::size_t ; nStart = 0, . std::size_t ; nStop = std::numeric_limits<std::size_t>::max() . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 280 of file RooCompositeDataStore.cxx. ◆ merge(). RooAbsDataStore * RooCompositeDataStore::merge ; (; const RooArgSet & ; allvars, . std::list< RooAbsDataStore * > ; dstoreList . ). overridevirtual . Implements RooAbsDataStore.; Definition at line 335 of file RooCompositeDataStore.cxx. ◆ numEntries(). Int_t RooCompositeDataStore::numEntries ; (; ); const. overridevirtual . Implements RooAbsDataStore.; Definition at line 359 of file RooCompositeDataStore.cxx. ◆ recalculateCache(). void RooCompositeDataStore::recalculateCache ; (; const RooArgSet * ; proj, . Int_t ; firstEvent, . Int_t ; lastEvent, . Int_t ; stepSize, . bool ; skipZeroWeights . ). overridevirtual . Forward recalculate request to all subsets. ; ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classRooCompositeDataStore.html:26946,load,loadValues,26946,doc/master/classRooCompositeDataStore.html,https://root.cern,https://root.cern/doc/master/classRooCompositeDataStore.html,1,['load'],['loadValues']
Performance,"st-read callback. ; Definition at line 175 of file RFieldBase.hxx. ◆ fName. std::string ROOT::Experimental::RFieldBase::fName. private . The field name relative to its parent field. ; Definition at line 167 of file RFieldBase.hxx. ◆ fNRepetitions. std::size_t ROOT::Experimental::RFieldBase::fNRepetitions. private . For fixed sized arrays, the array length. ; Definition at line 173 of file RFieldBase.hxx. ◆ fOnDiskId. DescriptorId_t ROOT::Experimental::RFieldBase::fOnDiskId = kInvalidDescriptorId. private . When the columns are connected to a page source or page sink, the field represents a field id in the corresponding RNTuple descriptor. ; This on-disk ID is set in RPageSink::Create() for writing and by RFieldDescriptor::CreateField() when recreating a field / model from the stored descriptor. ; Definition at line 179 of file RFieldBase.hxx. ◆ fOnDiskTypeChecksum. std::uint32_t ROOT::Experimental::RFieldBase::fOnDiskTypeChecksum = 0. protected . TClass checksum cached from the descriptor after a call to ConnectPageSource(). ; Only set for classes with dictionaries. ; Definition at line 246 of file RFieldBase.hxx. ◆ fOnDiskTypeVersion. std::uint32_t ROOT::Experimental::RFieldBase::fOnDiskTypeVersion = kInvalidTypeVersion. protected . C++ type version cached from the descriptor after a call to ConnectPageSource() ; Definition at line 243 of file RFieldBase.hxx. ◆ fParent. RFieldBase* ROOT::Experimental::RFieldBase::fParent. protected . Sub fields point to their mother field. ; Definition at line 222 of file RFieldBase.hxx. ◆ fPrincipalColumn. Internal::RColumn* ROOT::Experimental::RFieldBase::fPrincipalColumn = nullptr. protected . All fields that have columns have a distinct main column. ; E.g., for simple fields (float, int, ...), the principal column corresponds to the field type. For collection fields except fixed-sized arrays, the main column is the offset field. Class fields have no column of their own. When reading, points to any column of the column team of t",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html:55525,cache,cached,55525,doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,https://root.cern,https://root.cern/doc/master/classROOT_1_1Experimental_1_1RFieldBase.html,1,['cache'],['cached']
Performance,"st. inlineoverridevirtual . ReturnsTClass describing current object ; Reimplemented from TObject.; Definition at line 98 of file TDataMember.h. ◆ IsaPointer(). Bool_t TDataMember::IsaPointer ; (; ); const. Return true if data member is a pointer. ; Definition at line 542 of file TDataMember.cxx. ◆ IsBasic(). Bool_t TDataMember::IsBasic ; (; ); const. Return true if data member is a basic type, e.g. char, int, long... ; Definition at line 524 of file TDataMember.cxx. ◆ IsEnum(). Bool_t TDataMember::IsEnum ; (; ); const. Return true if data member is an enum. ; Definition at line 533 of file TDataMember.cxx. ◆ IsPersistent(). Bool_t TDataMember::IsPersistent ; (; ); const. inline . Definition at line 91 of file TDataMember.h. ◆ IsSTLContainer(). int TDataMember::IsSTLContainer ; (; ). The return type is defined in TDictionary (kVector, kList, etc.) ; Definition at line 551 of file TDataMember.cxx. ◆ IsValid(). Bool_t TDataMember::IsValid ; (; ). Return true if this data member object is pointing to a currently loaded data member. ; If a function is unloaded after the TDataMember is created, the TDataMember will be set to be invalid. ; Definition at line 564 of file TDataMember.cxx. ◆ operator=(). TDataMember & TDataMember::operator= ; (; const TDataMember & ; dm). protected . assignment operator ; Definition at line 298 of file TDataMember.cxx. ◆ Property(). Long_t TDataMember::Property ; (; ); const. overridevirtual . Get property description word. For meaning of bits see EProperty. ; Implements TDictionary.; Definition at line 588 of file TDataMember.cxx. ◆ SetClass(). void TDataMember::SetClass ; (; TClass * ; cl). inline . Definition at line 95 of file TDataMember.h. ◆ SetterMethod(). TMethodCall * TDataMember::SetterMethod ; (; TClass * ; cl). Return a TMethodCall method responsible for setting the value of data member. ; The cl argument specifies the class of the object which will be used to call this method (in case of multiple inheritance TMethodCall needs to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/classTDataMember.html:29253,load,loaded,29253,doc/master/classTDataMember.html,https://root.cern,https://root.cern/doc/master/classTDataMember.html,1,['load'],['loaded']
Performance,"st::TObjLinkPtr_t TList::NewOptLink(TObject *obj, Option_t *opt, const TObjLinkPtr_t &prev); 747{; 748 R__COLLECTION_WRITE_LOCKGUARD(ROOT::gCoreMutex);; 749 R__COLLECTION_WRITE_GUARD();; 750 ; 751 auto newlink = std::make_shared<TObjOptLink>(obj, opt);; 752 if (prev) {; 753 InsertAfter(newlink, prev);; 754 }; 755 return newlink;; 756}; 757 ; 758////////////////////////////////////////////////////////////////////////////////; 759/// Remove object from this collection and recursively remove the object; 760/// from all other objects (and collections).; 761 ; 762void TList::RecursiveRemove(TObject *obj); 763{; 764 // Note, we can assume that the Collection Read lock is held, see; 765 // THashList::RecursiveRemove for a more complete discussion.; 766 if (!obj || (fSize == 0 && fCache.expired())); 767 return;; 768 ; 769 R__COLLECTION_WRITE_GUARD();; 770 ; 771 // When fCache is set and has no previous and next node, it represents; 772 // the node being cleared and/or deleted.; 773 {; 774 auto cached = fCache.lock();; 775 if (cached && cached->fNext.get() == nullptr && cached->fPrev.lock().get() == nullptr) {; 776 TObject *ob = cached->GetObject();; 777 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 778 ob->RecursiveRemove(obj);; 779 }; 780 }; 781 }; 782 ; 783 auto lnk = fFirst;; 784 decltype(lnk) next;; 785 while (lnk.get()) {; 786 next = lnk->fNext;; 787 TObject *ob = lnk->GetObject();; 788 if (ob && !ROOT::Detail::HasBeenDeleted(ob)) {; 789 if (ob->IsEqual(obj)) {; 790 lnk->SetObject(nullptr);; 791 if (lnk == fFirst) {; 792 fFirst = next;; 793 if (lnk == fLast); 794 fLast = fFirst;; 795 else; 796 fFirst->fPrev.reset();; 797 // DeleteLink(lnk);; 798 } else if (lnk == fLast) {; 799 fLast = lnk->fPrev.lock();; 800 fLast->fNext.reset();; 801 // DeleteLink(lnk);; 802 } else {; 803 lnk->Prev()->fNext = next;; 804 lnk->Next()->fPrev = lnk->fPrev;; 805 // DeleteLink(lnk);; 806 }; 807 fSize--;; 808 fCache.reset();; 809 Changed();; 810 } else; 811 ob->RecursiveRemove(obj);; 812 }",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/doc/master/TList_8cxx_source.html:23828,cache,cached,23828,doc/master/TList_8cxx_source.html,https://root.cern,https://root.cern/doc/master/TList_8cxx_source.html,1,['cache'],['cached']
Performance,"st; (Re)Initialize numerical integration engine if necessary. Return kTRUE if; successful, or otherwise kFALSE. RooRealIntegral(const RooRealIntegral& other, const char* name = 0); Copy constructor. ~RooRealIntegral(); Destructor. RooAbsReal* createIntegral(const RooArgSet& iset, const RooArgSet* nset = 0, const RooNumIntConfig* cfg = 0, const char* rangeName = 0) const; Special handling of integral of integral, return RooRealIntegral that represents integral over all dimensions in one pass. Double_t getValV(const RooArgSet* set = 0) const; Return value of object. If the cache is clean, return the; cached value, otherwise recalculate on the fly and refill; the cache. Double_t evaluate() const; Perform the integration and return the result. Double_t jacobianProduct() const; Return product of jacobian terms originating from analytical integration. Double_t sum() const; Perform summation of list of category dependents to be integrated. Double_t integrate() const; Perform hybrid numerical/analytical integration over all real-valued dependents. Bool_t redirectServersHook(const RooAbsCollection& newServerList, Bool_t mustReplaceAll, Bool_t nameChange, Bool_t isRecursive); Intercept server redirects and reconfigure internal object accordingly. const RooArgSet& parameters() const. void operModeHook(); Dummy. Bool_t isValidReal(Double_t value, Bool_t printError = kFALSE) const; Check if current value is valid. void printMetaArgs(ostream& os) const; Customized printing of arguments of a RooRealIntegral to more intuitively reflect the contents of the; integration operation. void printMultiline(ostream& os, Int_t contents, Bool_t verbose = kFALSE, TString indent = """") const; Print the state of this object to the specified output stream. void setCacheAllNumeric(Int_t ndim); Global switch to cache all integral values that integrate at least ndim dimensions numerically. Int_t getCacheAllNumeric(); Return minimum dimensions of numeric integration for which values are cached. TObject",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/RooRealIntegral.html:37460,Perform,Perform,37460,root/html532/RooRealIntegral.html,https://root.cern,https://root.cern/root/html532/RooRealIntegral.html,1,['Perform'],['Perform']
Performance,"st; Analytical integral with normalization (see RooAbsReal::analyticalIntegralWN() for further information). This function applies the normalization specified by 'normSet' to the integral returned; by RooAbsReal::analyticalIntegral(). The passthrough scenario (code=0) is also changed; to return a normalized answer. Bool_t traceEvalPdf(Double_t value) const; Check that passed value is positive and not 'not-a-number'. If; not, print an error, until the error counter reaches its set; maximum. Double_t getNorm(const RooArgSet* nset); Return the integral of this PDF over all observables listed in 'nset'. const RooAbsReal* getNormObj(const RooArgSet* set, const RooArgSet* iset, const TNamed* rangeName = 0) const; Return pointer to RooAbsReal object that implements calculation of integral over observables iset in range; rangeName, optionally taking the integrand normalized over observables nset. Bool_t syncNormalization(const RooArgSet* dset, Bool_t adjustProxies = kTRUE) const; Verify that the normalization integral cached with this PDF; is valid for given set of normalization observables. If not, the cached normalization integral (if any) is deleted; and a new integral is constructed for use with 'nset'; Elements in 'nset' can be discrete and real, but must be lvalues. For functions that declare to be self-normalized by overloading the; selfNormalized() function, a unit normalization is always constructed. void setNormValueCaching(Int_t minNumIntDim, Int_t ipOrder = 2); Activate caching of normalization integral values in a interpolated histogram; for integrals that exceed the specified minimum number of numerically integrated; dimensions, _and_ of which the integral has at most 2 parameters. The cache is scanned with a granularity defined by a binning named ""cache"" in the; scanned integral parameters and is interpolated to given order.; The cache values are kept for the livetime of the ROOT session/application; and are persisted along with the object in case the p.d.f. i",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html526/RooAbsPdf.html:43891,cache,cached,43891,root/html526/RooAbsPdf.html,https://root.cern,https://root.cern/root/html526/RooAbsPdf.html,1,['cache'],['cached']
Performance,"st; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; virtual voidPrintNetwork() const; voidTMVA::Configurable::PrintOptions() const; virtual voidProcessOptions(); voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTM",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodANNBase.html:8906,Optimiz,OptimizeTuningParameters,8906,root/html532/TMVA__MethodANNBase.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodANNBase.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"st; Bool_tTObject::IsZombie() const; virtual voidTObject::ls(Option_t* option = """") const; virtual voidTMVA::MethodBase::MakeClass(const TString& classFileName = TString("""")) const; voidTObject::MayNotUse(const char* method) const; TDirectory*TMVA::MethodBase::MethodBaseDir() const; virtual Bool_tTMVA::MethodBase::MonitorBoost(TMVA::MethodBoost*); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& istr); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandler(TMVA::Transformatio",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TMVA__MethodCompositeBase.html:9198,Optimiz,OptimizeTuningParameters,9198,root/html532/TMVA__MethodCompositeBase.html,https://root.cern,https://root.cern/root/html532/TMVA__MethodCompositeBase.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"st; Return the label color number in the axis. Style_t GetLabelFont(Option_t* axis = ""X"") const; Return label font. Float_t GetLabelOffset(Option_t* axis = ""X"") const; Return label offset. Float_t GetLabelSize(Option_t* axis = ""X"") const; Return label size. const char * GetLineStyleString(Int_t i = 1) const; Return line style string (used by PostScript).; See SetLineStyleString for more explanations. Int_t GetNumberOfColors() const; Return number of colors in the color palette. void GetPaperSize(Float_t& xsize, Float_t& ysize) const; Set paper size for PostScript output. Float_t GetTickLength(Option_t* axis = ""X"") const; Return tick length. Color_t GetTitleColor(Option_t* axis = ""X"") const; Return title color. Style_t GetTitleFont(Option_t* axis = ""X"") const; Return title font. Float_t GetTitleOffset(Option_t* axis = ""X"") const; Return title offset. Float_t GetTitleSize(Option_t* axis = ""X"") const; Return title size. void Paint(Option_t* option = """"); Show the options from the current style; if (TClass::GetClass(""TStyleManager"")) gSystem->Load(""libGed"");. void SetColorModelPS(Int_t c = 0); Define the color model used by TPostScript and TPDF (RGB or CMYK).; CMY and CMYK models are subtractive color models unlike RGB which is; additive. They are mainly used for printing purposes. CMY means Cyan Magenta; Yellow. To convert RGB to CMY it is enough to do: C=1-R, M=1-G and Y=1-B.; CMYK has one more component K (black). The conversion from RGB to CMYK is:. Double_t Black = TMath::Min(TMath::Min(1-Red,1-Green),1-Blue);; Double_t Cyan = (1-Red-Black)/(1-Black);; Double_t Magenta = (1-Green-Black)/(1-Black);; Double_t Yellow = (1-Blue-Black)/(1-Black);. CMYK adds the black component which allows better quality for black; printing. PostScript and PDF support the CMYK model. c = 0 means TPostScript and TPDF will use RGB color model (default); c = 1 means TPostScript and TPDF will use CMYK color model. void SetHistMinimumZero(Bool_t zero = kTRUE); If the argument zero=kTRUE the m",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TStyle.html:25561,Load,Load,25561,root/html532/TStyle.html,https://root.cern,https://root.cern/root/html532/TStyle.html,4,['Load'],['Load']
Performance,"st; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. void attachToVStore(RooVectorDataStore& ); {}. » Last changed: Tue Jun 2 15:27:32 2015 » Last generated: 2015-06-02 15:27; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to ",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html604/RooAbsString.html:23596,cache,cache,23596,root/html604/RooAbsString.html,https://root.cern,https://root.cern/root/html604/RooAbsString.html,2,['cache'],['cache']
Performance,"st; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. void attachToVStore(RooVectorDataStore& ); {}. » Last changed: Tue Jun 30 14:30:34 2015 » Last generated: 2015-06-30 14:30; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/RooAbsString.html:23596,cache,cache,23596,root/html602/RooAbsString.html,https://root.cern,https://root.cern/root/html602/RooAbsString.html,2,['cache'],['cache']
Performance,"st; Return value of object. Calculated if dirty, otherwise cached value is returned. Bool_t operator==(const char* ) const; Equality operator comparing with a TString. Bool_t isIdentical(const RooAbsArg& other, Bool_t assumeSameType = kFALSE). Bool_t operator==(const RooAbsArg& other); Equality operator comparing to another RooAbsArg. Bool_t readFromStream(istream& is, Bool_t compact, Bool_t verbose = kFALSE); Read object contents from stream (dummy for now). void writeToStream(ostream& os, Bool_t compact) const; Write object contents to stream (dummy for now). void printValue(ostream& os) const; Print value. Bool_t isValid() const; Check if current value is valid. Bool_t isValidString(const char* , Bool_t printError = kFALSE) const; Check if given string value is valid. Bool_t traceEvalHook(const char* value) const; Hook function for trace evaluation. const char* traceEval() const; Calculate current value of object, with error tracing wrapper. void syncCache(const RooArgSet* nset = 0); Forcibly bring internal cache up-to-date. void copyCache(const RooAbsArg* source, Bool_t valueOnly = kFALSE, Bool_t setValDiry = kTRUE); Copy cache of another RooAbsArg to our cache. Warning: This function copies the cached values of source,; it is the callers responsibility to make sure the cache is clean. void attachToTree(TTree& t, Int_t bufSize = 32000); Attach object to a branch of given TTree. void fillTreeBranch(TTree& t); Fill tree branch associated with this object. void setTreeBranchStatus(TTree& t, Bool_t active); (De)Activate associated tree branch. RooAbsArg * createFundamental(const char* newname = 0) const; Create a RooStringVar fundamental object with our properties. TString evaluate() const; { return """" ; }. void attachToVStore(RooVectorDataStore& ); {}. » Last changed: Tue Mar 10 17:14:14 2015 » Last generated: 2015-03-10 17:14; This page has been automatically generated. For comments or suggestions regarding the documentation or ROOT in general please send a mail to",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/RooAbsString.html:22014,cache,cache,22014,root/html534/RooAbsString.html,https://root.cern,https://root.cern/root/html534/RooAbsString.html,2,['cache'],['cache']
Performance,"st; TDirectory*TMVA::MethodBase::MethodBaseDir() const; TMVA::MethodFisherMethodFisher(TMVA::DataSetInfo& dsi, const TString& theWeightFile, TDirectory* theTargetDir = NULL); TMVA::MethodFisherMethodFisher(const TString& jobName, const TString& methodTitle, TMVA::DataSetInfo& dsi, const TString& theOption = ""Fisher"", TDirectory* theTargetDir = 0); virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator new[](size_t sz, void* vp); TMVA::IMethod&TMVA::IMethod::operator=(const TMVA::IMethod&); virtual map<TString,Double_t>TMVA::MethodBase::OptimizeTuningParameters(TString fomType = ""ROCIntegral"", TString fitType = ""FitGA""); virtual voidTObject::Paint(Option_t* option = """"); virtual voidTMVA::Configurable::ParseOptions(); virtual voidTObject::Pop(); virtual voidTObject::Print(Option_t* option = """") const; voidPrintCoefficients(); virtual voidTMVA::MethodBase::PrintHelpMessage() const; voidTMVA::Configurable::PrintOptions() const; voidTMVA::MethodBase::ProcessSetup(); virtual Int_tTObject::Read(const char* name); voidTMVA::Configurable::ReadOptionsFromStream(istream& istr); voidTMVA::Configurable::ReadOptionsFromXML(void* node); voidTMVA::MethodBase::ReadStateFromFile(); voidTMVA::MethodBase::ReadStateFromStream(istream& tf); voidTMVA::MethodBase::ReadStateFromStream(TFile& rf); voidTMVA::MethodBase::ReadStateFromXMLString(const char* xmlstr); virtual voidReadWeightsFromStream(istream& i); virtual voidReadWeightsFromXML(void* wghtnode); virtual voidTObject::RecursiveRemove(TObject* obj); voidTMVA::MethodBase::RerouteTransformationHandl",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html534/TMVA__MethodFisher.html:11399,Optimiz,OptimizeTuningParameters,11399,root/html534/TMVA__MethodFisher.html,https://root.cern,https://root.cern/root/html534/TMVA__MethodFisher.html,1,['Optimiz'],['OptimizeTuningParameters']
Performance,"st; const type_info*GetTypeInfo() const; virtual UInt_tTObject::GetUniqueID() const; virtual Bool_tTObject::HandleTimer(TTimer* timer); Bool_tHasDefaultConstructor() const; virtual ULong_tTNamed::Hash() const; voidIgnoreTObjectStreamer(Bool_t ignore = kTRUE); virtual voidTObject::Info(const char* method, const char* msgfmt) const; virtual Bool_tInheritsFrom(const char* cl) const; virtual Bool_tInheritsFrom(const TClass* cl) const; virtual voidTObject::Inspect() constMENU ; voidInterpretedShowMembers(void* obj, TMemberInspector& insp); voidTObject::InvertBit(UInt_t f); virtual TClass*IsA() const; static TClass::ENewTypeIsCallingNew(); virtual Bool_tTObject::IsEqual(const TObject* obj) const; virtual Bool_tIsFolder() const; Bool_tIsFolder(void* obj) const; Bool_tIsForeign() const; Bool_tIsLoaded() const; Bool_tTObject::IsOnHeap() const; virtual Bool_tTNamed::IsSortable() const; Bool_tIsStartingWithTObject() const; Bool_tIsTObject() const; Bool_tTObject::IsZombie() const; static TClass*Load(TBuffer& b); virtual voidls(Option_t* opt = """") const; voidMakeCustomMenuList(); voidTObject::MayNotUse(const char* method) const; voidMove(void* arenaFrom, void* arenaTo) const; void*New(TClass::ENewType defConstructor = kClassNew) const; void*New(void* arena, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, TClass::ENewType defConstructor = kClassNew) const; void*NewArray(Long_t nElements, void* arena, TClass::ENewType defConstructor = kClassNew) const; virtual Bool_tTObject::Notify(); voidTObject::Obsolete(const char* method, const char* asOfVers, const char* removedFromVers) const; static voidTObject::operator delete(void* ptr); static voidTObject::operator delete(void* ptr, void* vp); static voidTObject::operator delete[](void* ptr); static voidTObject::operator delete[](void* ptr, void* vp); void*TObject::operator new(size_t sz); void*TObject::operator new(size_t sz, void* vp); void*TObject::operator new[](size_t sz); void*TObject::operator ne",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html532/TClass.html:8003,Load,Load,8003,root/html532/TClass.html,https://root.cern,https://root.cern/root/html532/TClass.html,1,['Load'],['Load']
Performance,"st; evaluate the derivative of the function with respect to the parameters. double DoDerivative(double x) const; return the function derivatives w.r.t. x. double DoParameterDerivative(double x, const double* p, unsigned int ipar) const; evaluate the derivative of the function with respect to the parameters; IMPORTANT NOTE: TF1::GradientPar returns 0 for fixed parameters to avoid computing useless derivatives; BUT the TLinearFitter wants to have the derivatives also for fixed parameters.; so in case of fLinear (or fPolynomial) a non-zero value will be returned for fixed parameters. void SetDerivPrecision(double eps); { fgEps = eps; }. double GetDerivPrecision(); { return fgEps; }. virtual ~WrappedTF1(). Destructor (no operations). TF1 Function pointer is not owned. {}. ROOT::Math::IGenFunction * Clone() const; @name interface inherited from IFunction . Clone the wrapper but not the original function. const double * Parameters() const; @name interface inherited from IParamFunction ; get the parameter values (return values cachen inside, those inside TF1 might be different). void SetParameters(const double* p); set parameter values (only the cached one in this class,leave unchanges those of TF1). unsigned int NPar() const; return number of parameters. std::string ParameterName(unsigned int i) const; return parameter name (this is stored in TF1). void FdF(double x, double& f, double& deriv) const; calculate function and derivative at same time (required by IGradient interface). double DoEvalPar(double x, const double* p) const; evaluate function passing coordinates x and vector of parameters. double DoEval(double x) const; evaluate function using the cached parameter values of this class (not of TF1); re-implement for better efficiency. » Author: L. Moneta Wed Sep 6 09:52:26 2006 » Copyright (c) 2006 LCG ROOT Math Team, CERN/PH-SFT *; » Last changed: root/mathmore:$Id$ » Last generated: 2015-06-30 14:27; This page has been automatically generated. For comments or sugges",MatchSource.WIKI,root-project,root,v6-32-06,https://root.cern/root/html602/ROOT__Math__WrappedTF1.html:5056,cache,cachen,5056,root/html602/ROOT__Math__WrappedTF1.html,https://root.cern,https://root.cern/root/html602/ROOT__Math__WrappedTF1.html,2,['cache'],['cachen']
